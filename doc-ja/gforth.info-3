This is gforth.info, produced by makeinfo version 6.8 from gforth.texi.

このマニュアルは、 標準 Forth 言語の高速で移植可能な実装である Gforth (バ
ージョン 0.7.9_20240418, April 18, 2024)用です。 これはリファレンス・マ
ニュアルとして機能しますが、 Forth の概要と Forth チュートリアルも含まれ
ています。

   Authors: Bernd Paysan, Anton Ertl, Gerald Wodni Copyright © 1995,
1996, 1997, 1998, 2000, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
2011, 2012, 2013, 2014,2015,2016,2017,2018,2019,2020,2021,2022,2023 Free
Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover texts
     being “A GNU Manual,” and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by the
     Free Software Foundation raise funds for GNU development.”
INFO-DIR-SECTION Software development
START-INFO-DIR-ENTRY
* Gforth: (gforth).          forth言語のための高速インタプリタ
END-INFO-DIR-ENTRY


File: gforth.info,  Node: Formatted numeric output,  Next: Floating-point output,  Prev: Simple numeric output,  Up: Other I/O

6.20.2 Formatted numeric output
-------------------------------

Forth は伝統的に、 整数の書式設定された出力に「表示数値出力」(“pictured
numeric Output”) と呼ばれる手法を使用しています。 この手法では、 数値か
ら数字桁(digits)が抽出され(‘base’ で定義された現在の出力基数を使用 *note
Number Conversion::)、 ASCII コードに変換され、 メモリのスクラッチパッド
領域(*note Implementation-defined options: core-idef.)に構築される文字列
の先頭に付加されます。 抽出プロセス中に、 文字列の先頭に任意の文字を追加
できます。 完成した文字列はアドレスと長さによって指定され、 プログラム制
御の下で操作(‘TYPE’ や、 コピーや、 変更)できます。

   前のセクションで説明したすべての整数出力ワード (*note Simple numeric
output::) は、 Gforth では表示数値出力(pictured numeric output)を使用し
て実装されています。

   表示数値出力(pictured numeric output)について覚えておくべき 3 つの重
要な点:

   • 常に2倍長数を処理します。 1倍長数を表示するには、 まず最初に2倍長に
     変換します (これを行う方法は *note Double precision::)。
   • 倍精度数は常に符号無しであるかのように扱われます。 下記の例は、 符
     号付き数値を出力する方法を示しています。
   • 文字列は右から左に構築されます。 最下位桁が最初です。

   標準 Forth は、 ‘<#’ で空にして初期化し、 ‘#>’ で結果文字列を取得する
単一の出力バッファー(別名ホールド領域;hold area)をサポートします。

   Gforth はさらに、 このバッファーの入れ子になった使用をサポートしてお
り、 たとえば、 ホールド領域を処理するコード内でデバッグ・トレーサー
‘~~’ からの出力を入れ子にすることができます。 ‘<<#’ は新しい入れ子を開始
し、 ‘#>’ は結果文字列を生成し、 ‘#>>’ は入れ子を解除します。 入れ子の保
ホールド領域が再利用され、‘#>’ は次に外側の入れ子の文字列を生成します。
Gforth の高レベルの数値出力ワードはすべて ‘<<#’ ...  ‘#>’ ...  ‘#>>’ を
使用し、 ホールド領域の他のユーザー内に入れ子にできます。

‘<#’ ( –  ) core “less-number-sign”
   表示数値出力文字列を 初期化/クリア します。

‘<<#’ ( –  ) gforth-0.5 “less-less-number-sign”
   ‘#>>’ で終わるホールド領域を開始します。 相互に入れ子にすることも、
‘<#’ で入れ子にすることもできます。 注: ‘<<#’ と ‘#>>’ を一致させないと
、 最終的にホールド領域が不足します。 ‘<#’ を使用してホールド領域を空に
リセットできます。

‘#’ ( ud1 – ud2  ) core “number-sign”
   ‘<<#’ と ‘#>’ の間で使用されます。 UD1 の最下位桁(‘base’ による)を、
表示数値出力文字列の先頭に追加します。 UD2 は UD1/BASE、 つまり残りの桁
を表す数値です。

‘#s’ ( ud – 0 0  ) core “number-sign-s”
   ‘<<#’ と ‘#>’ の間で使用されます。 UD のすべての数字を表示数値出力文
字列の先頭に追加します。 ‘#s’ は少なくとも 1 つの数字を変換します。 した
がって、 UD が 0 の場合、 ‘#s’ は表示数値出力文字列の先頭に ‘0‘ を追加し
ます。

‘hold’ ( char –  ) core “hold”
   ‘<<#’ と ‘#>’ の間で使用されます。 表示数値出力文字列の前に文字 CHAR
を追加します。

‘holds’ ( addr u –  ) core-ext “holds”
   ‘<<#’ と ‘#>’ の間で使用されます。 表示数値出力文字列の前に文字列
‘addr u’ を追加します。

‘sign’ ( n –  ) core “sign”
   ‘<<#’ と ‘#>’ の間で使用されます。 N (1倍長数) が負の場合、 表示数値
出力文字列の先頭に ‘-’ を追加します。

‘#>’ ( xd – addr u  ) core “number-sign-greater”
   XD を破棄し、 フォーマットされた文字列のアドレスと長さを示す ADDR U を
返すことで、 表示数値出力文字列を完成させます。 標準のプログラムでは、 文
字列内の文字を変更する場合があります。 ホールド領域は解放されません。
‘#>>’ を使用して ‘<<#’ で始まるホールド領域を解放するか、 ‘<#’ を使用し
てすべてのホールド領域を解放します。

‘#>>’ ( –  ) gforth-0.5 “number-sign-greater-greater”
   ‘<<#’ で始まるホールド領域を解放します。

以下に、 表示数値出力の使用例をいくつか示します:

     : my-u. ( u -- )
       \ PNS(Pictured Number String)の最も単純な使用法。標準の u. のように振る舞います。
       0              \ 上記 u を 2倍長にする
       <<#            \ 変換開始
       #s             \ 全桁を変換
       #>             \ 変換終了
       TYPE SPACE     \ 表示、続けて空白1つ
       #>> ;          \ ホールド領域を開放

     : cents-only ( u -- )
       0              \ 上記 u を 2倍長数に変換
       <<#            \ 変換開始
       # #            \ 最下位と最下位からの次の 2 桁のみ変換
       #>             \ 変換完了。他の桁は破棄
       TYPE SPACE     \ 表示、続けて空白1つ
       #>> ;          \ ホールド領域を開放

     : dollars-and-cents ( u -- )
       0              \ 上記 u を符号無し2倍長数に変換
       <<#            \ 変換開始
       # #            \ 下位2桁を変換
       '.' hold       \ 小数点を打つ
       #s             \ 残りの桁を変換
       '$' hold       \ 通貨記号を打つ
       #>             \ 変換完了
       TYPE SPACE     \ 表示、続けて空白1つ
       #>> ;          \ ホールド領域を開放

     : my-. ( n -- )
       \ 負数も処理する標準の . のように振る舞う
       s>d            \ 符号付き2倍長数に変換
       swap over dabs \ 符号バイトを別途保存して数値は符号無し2倍長に
       <<#            \ 変換開始
       #s             \ 全桁を変換
       rot sign       \ 符号チェック。必要なら "-" 付加
       #>             \ 変換完了
       TYPE SPACE     \ 表示、続けて空白1つ
       #>> ;          \ ホールド領域を開放

     : account. ( n -- )
       \ (会計風出力)会計士はマイナス記号が嫌いで、
       \ 負の数には括弧を使用します
       s>d            \ 符号付き2倍長数に変換
       swap over dabs \ 符号バイトを別途保存して数値は符号無し2倍長に
       <<#            \ 変換開始
       2 pick         \ 符号バイトのコピーを得る
       0< IF ')' hold THEN \ これが(あれば)出力の右端の文字
       #s             \ 全桁を変換
       rot            \ 符号バイトを得る
       0< IF '(' hold THEN
       #>             \ 変換完了
       TYPE SPACE     \ 表示、続けて空白1つ
       #>> ;          \ ホールド領域を開放


   これらのワードの利用例をいくつか示します:

     1 my-u. 1  ok
     hex -1 my-u. decimal FFFFFFFFFFFFFFFF  ok
     1 cents-only 01  ok
     1234 cents-only 34  ok
     2 dollars-and-cents  $0.02  ok
     1234 dollars-and-cents  $12.34  ok
     123 my-. 123  ok
     -123 my-. -123  ok
     123 account. 123  ok
     -456 account. (456)  ok



File: gforth.info,  Node: Floating-point output,  Next: Miscellaneous output,  Prev: Formatted numeric output,  Up: Other I/O

6.20.3 Floating-point output
----------------------------

浮動小数点数出力は常に基数 10 を使用して表示されます。

‘f.’ ( r –  ) floating-ext “f-dot”
   (浮動小数点数) r を指数なしで表示し、 その後に空白1つ続けます。

‘fe.’ ( r –  ) floating-ext “f-e-dot”
   r を工学表記(3 で割り切れる指数) で表示し、 その後に空白1つ続けます。

‘fs.’ ( r –  ) floating-ext “f-s-dot”
   r を科学表記(指数付き)で表示し、 その後に空白1つ続けます。

‘fp.’ ( r –  ) floating-ext “f-p-dot”
   r を SI 接頭辞表記(3 で割れる指数を使用し、 可能な場合は SI 接頭辞に
変換)で表示し、 その後に空白1つ続けます。

   数値 1234.5678E23 をさまざまな浮動小数点数出力形式で出力する例を以下
に示します。

     1234.5678E23 f. 123456780000000000000000000.  ok
     1234.5678E23 fe. 123.456780000000E24  ok
     1234.5678E23 fs. 1.23456780000000E26  ok
     1234.5678E23 fp. 123.456780000000Y  ok

   出力桁幅は以下の影響を受けます:

‘precision’ ( – u  ) floating-ext “precision”
   u は、 ‘f.’ や ‘fe.’ や ‘fs.’ や ‘fp.’ で現在使用されている有効桁数で
す。

‘set-precision’ ( u –  ) floating-ext “set-precision”
   ‘f.’ や ‘fe.’ や ‘fs.’ や ‘fp.’ で現在使用されている有効桁数を u に設
定します。

   以下のコマンドを使用して、 出力をより詳細に制御できます:

‘f.rdp’ ( rf +nr +nd +np –  ) gforth-0.6 “f.rdp”
   浮動小数点数 rf を書式化して表示します。 出力の合計幅は nr です。 固
定小数点表記の場合、 小数点以下の桁数は +nd、 有効桁数の最小値は np です
。 ‘Set-precision’ は ‘f.rdp’ には影響しません。 固定小数点表記は、 有効
桁数が少なくとも np の場合で、 かつ、 小数点以下の桁数が収まる場合に、 使
用されます。 固定小数点表記が使用されない場合は指数表記が使用され、 それ
でも適合しない場合はアスタリスクが出力されます。 数値がまったく適合しな
いリスクを避けるために、 nr>=7 を使用することをお勧めします。 ‘f.rdp’ が
指数表記に切り替わるケースを避けるために、 nr>=np+5 をお勧めします。 ど
うしてかというと、 固定小数点表記でも有効桁数が少なすぎるのに、 指数表記
では有効桁数が更に少なくなるためです。 一部の数値を固定小数点表記しなけ
ればならない場合は、 nr>=nd+2 をお勧めします。 np の値が小さいほど、 よ
り多くの場合で固定小数点表記で表示されます (固定小数点表記に有効数字がほ
とんどまたはまったく残っていない場合)。 すべての数値を指数表記したい場合
は、np>nr をお勧めします。

   出力にどのような影響を与えるかをより直感的に理解できるように、 パラメ
ーターの組み合わせの例をいくつか示します。 各行内は同じ数値が出力されて
いて、 各列には同じパラメータの組み合わせが出力に使用されています:

         12 13 0    7 3 4   7 3 0   7 3 1   7 5 1   7 7 1   7 0 2  4 2 1
     |-1.234568E-6|-1.2E-6| -0.000|-1.2E-6|-1.2E-6|-1.2E-6|-1.2E-6|****|
     |-1.234568E-5|-1.2E-5| -0.000|-1.2E-5|-.00001|-1.2E-5|-1.2E-5|****|
     |-1.234568E-4|-1.2E-4| -0.000|-1.2E-4|-.00012|-1.2E-4|-1.2E-4|****|
     |-1.234568E-3|-1.2E-3| -0.001| -0.001|-.00123|-1.2E-3|-1.2E-3|****|
     |-1.234568E-2|-1.2E-2| -0.012| -0.012|-.01235|-1.2E-2|-1.2E-2|-.01|
     |-1.234568E-1|-1.2E-1| -0.123| -0.123|-.12346|-1.2E-1|-1.2E-1|-.12|
     |-1.2345679E0| -1.235| -1.235| -1.235|-1.23E0|-1.23E0|-1.23E0|-1E0|
     |-1.2345679E1|-12.346|-12.346|-12.346|-1.23E1|-1.23E1|   -12.|-1E1|
     |-1.2345679E2|-1.23E2|-1.23E2|-1.23E2|-1.23E2|-1.23E2|  -123.|-1E2|
     |-1.2345679E3|-1.23E3|-1.23E3|-1.23E3|-1.23E3|-1.23E3| -1235.|-1E3|
     |-1.2345679E4|-1.23E4|-1.23E4|-1.23E4|-1.23E4|-1.23E4|-12346.|-1E4|
     |-1.2345679E5|-1.23E5|-1.23E5|-1.23E5|-1.23E5|-1.23E5|-1.23E5|-1E5|

   以下を使用して、 数値を表示する代わりに文字列を生成できます:

‘f>str-rdp’ ( rf +nr +nd +np – c-addr nr  ) gforth-0.6 “f>str-rdp”
   rf を c-addr nr の文字列に変換します。 nr +nd np の変換規則と意味は
‘f.rdp’ と同じです。 結果は表示数値出力(pictured numeric output)バッファ
ーに格納され、 そのバッファを破壊するものによって破壊されます(訳注: この
バッファーは、 他の 表示数値出力(pictured numeric output) と共用であると
いうこと)。

‘f>buf-rdp’ ( rf c-addr +nr +nd +np –  ) gforth-0.6 “f>buf-rdp”
   rf を c-addr nr の文字列に変換します。 nr nd np の変換規則と意味は
‘f.rdp’ と同じです(

   以下のような、 高レベルの FP-to-string ワードを実装するために使用され
るプリミティブもあります:

‘represent’ ( r c-addr u – n f1 f2 ) floating “represent”
   r の 10 進仮数部(別名 mantissa)をバッファ c-addr u 内の文字列に変換し
ます。 n は指数で、r が負の場合は f1 が true、 r が有効(Gforth の有限数
)の場合は f2 が true です(訳注: 仮数部が u の桁数になるようそれ以下を四
捨五入するっぽい)。


File: gforth.info,  Node: Miscellaneous output,  Next: Displaying characters and strings,  Prev: Floating-point output,  Up: Other I/O

6.20.4 Miscellaneous output
---------------------------

‘cr’ ( –  ) core “c-r”
   (ホスト OS の好みの種類の)改行(newline)を出力します。 注意: Forth コ
マンド・ライン・インタプリタの改行(newline)挿入のクセのため、 ‘cr’ をテ
キストの先頭で使用することをお勧めします。 例: ‘cr ." hello, world"’.

‘space’ ( –  ) core “space”
   空白を1つ表示する。

‘spaces’ ( u –  ) core “spaces”
   U 個の空白を表示します。

‘out’ ( – addr  ) gforth-1.0 “out”
   ‘addr’ には、 ユーザー出力デバイス上の現在行内のカーソルの位置を指定
しようと試みる数値が含まれています。 ‘cr’ で 0 にリセットされ、 ‘type’ に
よって文字数ずつ増加、 ‘emit’ で増加、 ‘backspaces’ で減少します。 残念
ながら、 タブ文字や、マルチバイト文字や、 幅 0 と 幅2 のユニコード文字の
存在は考慮されていないため、 単純な場合にのみ機能します。

‘.\"’ ( compilation ’ccc"’ – ; run-time –  ) gforth-0.6 “dot-backslash-quote”
   ‘."’ と似ていますが、 C言語のようなバックスラッシュによるエスケープ・
シーケンス(\-escape-sequences)を認識します(詳しくは ‘S\"’ 参照)。

‘."’ ( compilation ’ccc"’ – ; run-time –  ) core “dot-quote”
   コンパイル時: ‘"‘ (二重引用符)で区切られた文字列 ccc を解析します。 実
行時、 その文字列を表示します。 このワードのインタプリタ機能
(interpretation semantics)は、 標準 Forth では定義されていません。
Gforth でのインタプリタ機能(interpretation semantics)は、 その文字列を表
示することです。

‘.(’ ( compilation&interpretation "ccc<paren>" –  ) core-ext “dot-paren”
   コンパイル時(compilation semantics)とインタプリタ時(interpretation
semantics): ‘)’(右括弧)で区切られた文字列 ccc を解析します。 その文字列
を表示します。 これは、 コンパイル中に進行状況情報を表示するためによく使
用されます。 下記の例を参照してください。

   あなたが ‘.( hello)’ を使用するべきか ‘." hello"’ を使用するべきかを
気に掛けたくない場合は、 ‘"hello" type’ と書くことができます。 これによ
り、 通常必要なものが得られます(ただし、他の Forth システムへの移植性は
低くなります)。

例として、 ファイル ‘test.fs’ に保存されている以下のテキストについて考え
てみましょう:

     .( text-1)
     : my-word
       ." text-2" cr
       .( text-3)
       "text-4" type
     ;

     ." text-5"
     "text-6" type

   このコードを Gforth にロードすると、 以下の出力が生成されます:

     include test.fs <RET> text-1text-3text-5text-6 ok

   • ‘.(’ は即実行ワードであるため、 メッセージ ‘text-1’ と ‘text-3’ が
     表示されます。 コロン定義の内側でも外側でも、 全く同じに振る舞いま
     す。
   • ‘."’ に対する Gforth の追加インタプリタ機能(interpretation
     semantics)により、 メッセージ ‘text-5’ が表示されます。
   • ‘"text-6" type’ が通訳(interpret)され、 メッセージ ‘text-6’ が表示
     されます。
   • テキスト・インタプリタが ‘my-word’ の定義内で ‘."’ のコンパイル機能
     (compilation semantics)を実行するため、 メッセージ ‘text-2’ は「表
     示されません」。
   • ‘"text-4" type’ は ‘my-word’ 内にコンパイルされるため、 メッセージ
     ‘text-4’ は「表示されません」。


File: gforth.info,  Node: Displaying characters and strings,  Next: Terminal output,  Prev: Miscellaneous output,  Up: Other I/O

6.20.5 Displaying characters and strings
----------------------------------------

‘type’ ( c-addr u –  ) core “type”
   U>0 なら、 C-ADDR からに格納されている文字列から U 文字を表示します
(訳注: 日本語(UTF-8)の出力も対応)。

‘xemit’ ( xc –  ) xchar “x-emit”
   端末に xchar を出力します。

‘emit’ ( c –  ) core “emit”
   バイト値 c を現在の出力に送信します。 ASCII 文字の場合、 ‘emit’ は
‘xemit’ と同等です。

‘typewhite’ ( addr n –  ) gforth-0.2 “typewhite”
   type と似ていますが、 文字の代わりに空白が表示されます(訳注: 指定の文
字数 n だけ空白出すだけなので日本語(UTF-8)だと表示幅がズレる)。


File: gforth.info,  Node: Terminal output,  Next: Single-key input,  Prev: Displaying characters and strings,  Up: Other I/O

6.20.6 Terminal output
----------------------

端末に出力している場合、 カーソル位置を制御することができます:

‘at-xy’ ( x y –  ) facility “at-x-y”
   カーソルを位置 x y に置きます。 ディスプレイの左上角は 0 0 です。

‘at-deltaxy’ ( dx dy –  ) gforth-0.7 “at-deltaxy”
   現在の位置を x y として、 カーソルを x+dx y+dy に置きます。

   カーソルをどこに置くかを知るには、 以下のように、 画面(screen)のサイ
ズを知っておくと役立つことがよくあります:

‘form’ ( – nlines ncols  ) gforth-0.2 “form”
\ 訳注:画面のサイズを得る

   また、 以下のようなものを使用したい場合もあります:

‘page’ ( –  ) facility “page”
   画面(screen)をクリアする

   注意: ターミナル以外では、フォーム・フィード(form feed;FF)を取得する
には ‘page’ ではなく ‘12 Emit’ を使用する必要があることに注意してくださ
い。

6.20.6.1 Color output
.....................

以下のワード群は、 意味・理由ごとに色を変えるために使用されます。 更に細
かい設定は、 ワードによって指定された色とスタイルで生成されます。 実際の
色とスタイルはテーマによって異なります(下記を参照)。

‘default-color’ ( –  ) gforth-1.0 “default-color”
   システムのデフォルト用の色

‘error-color’ ( –  ) gforth-1.0 “error-color”
   エラー用の色: (通常は)赤

‘error-hl-inv’ ( –  ) gforth-1.0 “error-hl-inv”
   エラー用にハイライトとして反転表示するカラーモード

‘error-hl-ul’ ( –  ) gforth-1.0 “error-hl-ul”
   エラー用にアンダーラインでハイライトする色変更モード

‘warning-color’ ( –  ) gforth-1.0 “warning-color”
   警告(warning)の色: 背景が黒の端末では 青/黄

‘info-color’ ( –  ) gforth-1.0 “info-color”
   情報(info)用の色: 黒色の背景の端末では 緑/シアン

‘success-color’ ( –  ) gforth-1.0 “success-color”
   成功(success)の色: 緑

‘input-color’ ( –  ) gforth-1.0 “input-color”
   ユーザー入力の色: 黒/白 (両方ともボールド)

‘status-color’ ( –  ) gforth-1.0 “status-color”
   エラー用にハイライトとして反転表示するカラーモード

6.20.6.2 Color themes
.....................

あなたが、 明るい背景を好むか暗い背景を好むかに応じて、 前景の色テーマ
(foreground colors-theme)を以下のように変更できます:

‘light-mode’ ( –  ) gforth-1.0 “light-mode”
   白背景用の色テーマ

‘dark-mode’ ( –  ) gforth-1.0 “dark-mode”
   黒背景用の色テーマ

‘uncolored-mode’ ( –  ) gforth-1.0 “uncolored-mode”
   このモードでは色は設定されませんが、 デフォルトの色が使用されます。

‘magenta-input’ ( –  ) gforth-1.0 “magenta-input”
   入力色(input color)を認識しやすくします(プレゼンテーションに役立ちま
す)


File: gforth.info,  Node: Single-key input,  Next: Line input and conversion,  Prev: Terminal output,  Up: Other I/O

6.20.7 Single-key input
-----------------------

単一の印刷可能な文字を取得したい場合は、 ‘key’ を使用できます。 文字が
‘key’ に使用できるかどうかを確認するには、 ‘key?’ を使用できます。

‘key’ ( – char  ) core “key”
   1 文字 CHAR を受け取ります(ただし表示はされません)。

‘key-ior’ ( – char|ior  ) gforth-1.0 “key-ior”
   1 文字 CHAR を受け取ります (ただし表示はされません)。 エラーまたは割
り込みの場合は、 代わりに、 負数の IOR を返します。

‘key?’ ( – flag  ) facility “key-question”
   文字が ‘key’ で使用可能かどうかを判断します。 文字が使用可能な場合、
FLAG は true です。 次に ‘key’ を呼び出すと、 文字が生成されます。 一度
‘key?’ が true を返すと、 その後に ‘key’ または ‘ekey’ を呼び出す前に
‘key?’ を呼び出した場合も true が返されます。

‘xkey?’ ( – flag  ) xchar “x-key-query”
\ 訳注: UTF-8 な環境では key? は xkey? のエイリアスです。
\ xchar 文字が xkey で使用可能かどうかを判断します(たぶん)

   印刷可能な文字と印刷不可能な文字を組み合わせて処理したい場合は、
‘ekey’ とそのファミリーを使用して実行できます。 ‘ekey’ は、 ‘ekey>char’
で文字に変換するか、 ‘ekey>fkey’ でキー識別子に変換する必要があるキーボ
ード・イベントを生成します。

   ekey を使用するための一般的なコードは以下のようになります:

     ekey ekey>xchar if ( xc )
       ... \ do something with the character
     else ekey>fkey if ( key-id )
       case
         k-up                                  of ... endof
         k-f1                                  of ... endof
         k-left k-shift-mask or k-ctrl-mask or of ... endof
         ...
       endcase
     else ( keyboard-event )
       drop \ just ignore an unknown keyboard event type
     then then

‘ekey’ ( – u  ) facility-ext “e-key”
   キーボード・イベント U を受信します(実装定義のエンコーディングです) 。

‘ekey>xchar’ ( u – u false | xc true  ) xchar-ext “e-key-to-x-char”
   可能であれば、 キーボード・イベント U を xchar ‘xc’ に変換します。

‘ekey>char’ ( u – u false | c true  ) facility-ext “e-key-to-char”
   可能であれば、 キーボード・イベント U を文字 ‘c’ に変換します。 注意:
非 ASCII 文字は、 ‘ekey>char’ と ‘ekey>fkey’ の両方から ‘false’ が返るこ
とに注意してください。 利用可能な場合は、 ‘ekey>char’ の代わりに
‘ekey>xchar’ を使用します。

‘ekey>fkey’ ( u1 – u2 f  ) facility-ext “e-key-to-f-key”
   u1 が特殊キー(special key)セット内のキーボード・イベントの場合、 キー
ボード・イベント U1 をキー ID U2 に変換し、 true を返します。それ以外の
場合は、 U1 と false を返します。

‘ekey?’ ( – flag  ) facility-ext “e-key-question”
   キーボード・イベントが利用可能な場合は True。

   カーソル・キーのキー識別子は以下のとおりです:

‘k-left’ ( – u  ) facility-ext “k-left”

‘k-right’ ( – u  ) facility-ext “k-right”

‘k-up’ ( – u  ) facility-ext “k-up”

‘k-down’ ( – u  ) facility-ext “k-down”

‘k-home’ ( – u  ) facility-ext “k-home”
   別名 Pos1

‘k-end’ ( – u  ) facility-ext “k-end”

‘k-prior’ ( – u  ) facility-ext “k-prior”
   別名 PgUp

‘k-next’ ( – u  ) facility-ext “k-next”
   別名 PgDn

‘k-insert’ ( – u  ) facility-ext “k-insert”

‘k-delete’ ( – u  ) facility-ext “k-delete”
   著者の xterm 上では<DEL> キーで、 Backspace ではありません

   ファンクション・キー(別名キーパッド・キー)のキー識別子は以下のとおり
です:

‘k-f1’ ( – u  ) facility-ext “k-f-1”

‘k-f2’ ( – u  ) facility-ext “k-f-2”

‘k-f3’ ( – u  ) facility-ext “k-f-3”

‘k-f4’ ( – u  ) facility-ext “k-f-4”

‘k-f5’ ( – u  ) facility-ext “k-f-5”

‘k-f6’ ( – u  ) facility-ext “k-f-6”

‘k-f7’ ( – u  ) facility-ext “k-f-7”

‘k-f8’ ( – u  ) facility-ext “k-f-8”

‘k-f9’ ( – u  ) facility-ext “k-f-9”

‘k-f10’ ( – u  ) facility-ext “k-f-10”

‘k-f11’ ( – u  ) facility-ext “k-f-11”

‘k-f12’ ( – u  ) facility-ext “k-f-12”

   ‘k-f11’ と ‘k-f12’ はそれほど広くには利用可能ではないことに注意してく
ださい。

   これらのキー識別子をさまざまなシフト・キーのマスクと組み合わせること
ができます:

‘k-shift-mask’ ( – u  ) facility-ext “k-shift-mask”

‘k-ctrl-mask’ ( – u  ) facility-ext “k-ctrl-mask”

‘k-alt-mask’ ( – u  ) facility-ext “k-alt-mask”

   ASCII 値を持つキーが多数あるため、 特殊キーとして報告される可能性は低
いですが、 以下のキーとシフト・キーの組み合わせは特殊キーとして報告され
る可能性があります:

‘k-enter’ ( – u  ) gforth-1.0 “k-enter”

‘k-backspace’ ( – u  ) gforth-1.0 “k-backspace”

‘k-tab’ ( – u  ) gforth-1.0 “k-tab”

   さらに、 キーおよびその他のイベントには以下のキー・コードがあります:

‘k-winch’ ( – u  ) gforth-1.0 “k-winch”
   ユーザーがウィンドウ・サイズを変更したときに生成される可能性のあるキ
ー・コード。

‘k-pause’ ( – u  ) gforth-1.0 “k-pause”

‘k-mute’ ( – u  ) gforth-1.0 “k-mute”

‘k-volup’ ( – u  ) gforth-1.0 “k-volup”

‘k-voldown’ ( – u  ) gforth-1.0 “k-voldown”

‘k-sel’ ( – u  ) gforth-1.0 “k-sel”
   Androidでの選択(selections)のキー・コード

‘k-eof’ ( – u  ) gforth-1.0 “k-eof”

   注意: Forth システムに ‘ekey>fkey’ とキー識別子のワードがある場合でも
、 そのキーが必ずしも利用可能であるとは限らず、 すべてのキーとシフト・マ
スクとの可能なすべての組み合わせを報告できるとは限らないことに注意してく
ださい。 したがって、キーやキーの組み合わせが押せない場合や認識されない
場合でも、プログラムが使えるようにプログラムを作成してください。

   例: 古いキーボードには F11 キーと F12 キーがないことがよくあります。
xterm で Gforth を実行すると、xterm は多数の組み合わせ(例: <Shift-Up>)を
捕捉しますが、それを Gforth に渡すことはありません。 最後に、Gforth は現
在、 複数の Shift キーの組み合わせを認識して報告しません(そのため、上記
の例の <shift-ctrl-left> のケースは決して入力されません)。

   Gforth は、ANSI 端末で利用可能なさまざまなキーを認識します(MS-DOS で
は、 その動作を実現するには ANSI.SYS ドライバーが必要です)。 これは、 そ
のようなキーが押されたときに ANSI 端末が送信するエスケープ・シーケンスを
認識することによって機能します。 他のエスケープ・シーケンスを送信する端
末を使用している場合、 Gforth では有益な結果は得られません。 他の Forth
システムは異なる方法で動作する可能性があります。

   Gforth には、 ファンクション・キーの名前を出力するためのいくつかのワ
ードも用意されています:

‘fkey.’ ( u –  ) gforth-1.0 “fkey-dot”
   ファンクション・キー u の文字列表現を出力します。 U はファンクション
・キー(おそらく修飾子マスク付き)でなければなりません。 そうでない場合は
例外が発生する可能性があります。

‘simple-fkey-string’ ( u1 – c-addr u  ) gforth-1.0 “simple-fkey-string”
   c-addr u は、ファンクション・キー u1 の文字列名です。 修飾子マスクの
ない単純なファンクション・キーに対してのみ機能します。 現在、 単純なファ
ンクション・キーでない u1 では例外を生成します。


File: gforth.info,  Node: Line input and conversion,  Next: Pipes,  Prev: Single-key input,  Up: Other I/O

6.20.8 Line input and conversion
--------------------------------

For ways of storing character strings in memory see *note String
representations::.

   Words for inputting one line from the keyboard:

‘accept’ ( c-addr +n1 – +n2  ) core “accept”
   Get a string of up to N1 characters from the user input device and
store it at C-ADDR.  N2 is the length of the received string.  The user
indicates the end by pressing <RET>.  Gforth supports all the editing
functions available on the Forth command line (including history and
word completion) in ‘accept’.

‘edit-line’ ( c-addr n1 n2 – n3  ) gforth-0.6 “edit-line”
   edit the string with length N2 in the buffer C-ADDR N1, like
‘accept’.

   Conversion words:

‘s>number?’ ( addr u – d f  ) gforth-0.5 “s>number?”
   converts string addr u into d, flag indicates success

‘s>unumber?’ ( c-addr u – ud flag  ) gforth-0.5 “s>unumber?”
   converts string c-addr u into ud, flag indicates success

‘>number’ ( ud1 c-addr1 u1 – ud2 c-addr2 u2  ) core “to-number”
   Attempt to convert the character string C-ADDR1 U1 to an unsigned
number in the current number base.  The double UD1 accumulates the
result of the conversion to form UD2.  Conversion continues,
left-to-right, until the whole string is converted or a character that
is not convertable in the current number base is encountered (including
+ or -).  For each convertable character, UD1 is first multiplied by the
value in ‘BASE’ and then incremented by the value represented by the
character.  C-ADDR2 is the location of the first unconverted character
(past the end of the string if the whole string was converted).  U2 is
the number of unconverted characters in the string.  Overflow is not
detected.

‘>float’ ( c-addr u – f:... flag ) floating “to-float”
   Actual stack effect: ( c_addr u – r t | f ).  Attempt to convert the
character string c-addr u to internal floating-point representation.  If
the string represents a valid floating-point number, r is placed on the
floating-point stack and flag is true.  Otherwise, flag is false.  A
string of blanks is a special case and represents the floating-point
number 0.

‘>float1’ ( c-addr u c – f:... flag ) gforth-1.0 “to-float1”
   Actual stack effect: ( c_addr u c – r t | f ).  Attempt to convert
the character string c-addr u to internal floating-point representation,
with c being the decimal separator.  If the string represents a valid
floating-point number, r is placed on the floating-point stack and flag
is true.  Otherwise, flag is false.  A string of blanks is a special
case and represents the floating-point number 0.

   Obsolescent input and conversion words:

‘convert’ ( ud1 c-addr1 – ud2 c-addr2  ) core-ext-obsolescent “convert”
   Obsolescent: superseded by ‘>number’.

‘expect’ ( c-addr +n –  ) core-ext-obsolescent “expect”
   Receive a string of at most +n characters, and store it in memory
starting at c-addr.  The string is displayed.  Input terminates when the
<return> key is pressed or +n characters have been received.  The normal
Gforth line editing capabilites are available.  The length of the string
is stored in ‘span’; it does not include the <return> character.
OBSOLESCENT: superceeded by ‘accept’.

‘span’ ( – c-addr  ) core-ext-obsolescent “span”
   ‘Variable’ – c-addr is the address of a cell that stores the length
of the last string received by ‘expect’.  OBSOLESCENT.


File: gforth.info,  Node: Pipes,  Next: Xchars and Unicode,  Prev: Line input and conversion,  Up: Other I/O

6.20.9 Pipes
------------

In addition to using Gforth in pipes created by other processes (*note
Gforth in pipes::), you can create your own pipe with ‘open-pipe’, and
read from or write to it.

‘open-pipe’ ( c-addr u wfam – wfileid wior ) gforth-0.2 “open-pipe”

‘close-pipe’ ( wfileid – wretval wior ) gforth-0.2 “close-pipe”

   If you write to a pipe, Gforth can throw a ‘broken-pipe-error’; if
you don’t catch this exception, Gforth will catch it and exit, usually
silently (*note Gforth in pipes::).  Since you probably do not want
this, you should wrap a ‘catch’ or ‘try’ block around the code from
‘open-pipe’ to ‘close-pipe’, so you can deal with the problem yourself,
and then return to regular processing.

‘broken-pipe-error’ ( – n  ) gforth-0.6 “broken-pipe-error”
   the error number for a broken pipe


File: gforth.info,  Node: Xchars and Unicode,  Next: i18n and l10n,  Prev: Pipes,  Up: Other I/O

6.20.10 Xchars and Unicode
--------------------------

ASCII is only appropriate for the English language.  Most western
languages however fit somewhat into the Forth frame, since a byte is
sufficient to encode the few special characters in each (though not
always the same encoding can be used; latin-1 is most widely used,
though).  For other languages, different char-sets have to be used,
several of them variable-width.  To deal with this problem, characters
are often represented as Unicode codepoints on the stack, and as UTF-8
byte strings in memory.  An Unicode codepoint often represents one
application-level character, but Unicode also supports decomposed
characters that consist of several code points, e.g., a base letter and
a combining diacritical mark.

   An Unicode codepoint can consume more than one byte in memory, so we
adjust our terminology: A char is a raw byte in memory or a value in the
range 0-255 on the stack.  An xchar (for extended char) stands for one
codepoint; it is represented by one or more bytes in memory and may have
larger values on the stack.  ASCII characters are the same as chars and
as xchars: values in the range 0-127, and a single byte with that value
in memory.

   When using UTF-8 encoding, all other codepoints take more than one
byte/char.  In most cases, you can just treat such characters as strings
in memory and don’t need to use the following words, but if you want to
deal with individual codepoints, the following words are useful.  We
currently have no words for dealing with decomposed characters.

   The xchar words add a few data types:

   • XC is an extended char (xchar) on the stack.  It occupies one cell,
     and is a subset of unsigned cell.  On 16 bit systems, only the BMP
     subset of the Unicode character set (i.e., codepoints <65536) can
     be represented on the stack.  If you represent your application
     characters as strings at all times, you can avoid this limitation.

   • XC-ADDR is the address of an xchar in memory.  Alignment
     requirements are the same as C-ADDR.  The memory representation of
     an xchar differs from the stack representation, and depends on the
     encoding used.  An xchar may use a variable number of chars in
     memory.

   • XC-ADDR U is a buffer of xchars in memory, starting at XC-ADDR, U
     chars (i.e., bytes, not xchars) long.

‘xc-size’ ( xc – u  ) xchar “x-c-size”
   Computes the memory size of the xchar XC in chars.

‘x-size’ ( xc-addr u1 – u2  ) xchar “x-size”
   Computes the memory size of the first xchar stored at XC-ADDR in
chars.

‘xc@’ ( xc-addr – xc  ) xchar-ext “xc-fetch”
   Fetchs the xchar XC at XC-ADDR1.

‘xc@+’ ( xc-addr1 – xc-addr2 xc  ) xchar “x-c-fetch-plus”
   Fetchs the xchar XC at XC-ADDR1.  XC-ADDR2 points to the first memory
location after XC.

‘xc@+?’ ( xc-addr1 u1 – xc-addr2 u2 xc  ) gforth-experimental “x-c-fetch-plus-query”
   Fetchs the first xchar XC of the string XC-ADDR1 U1.  XC-ADDR2 U2 is
the remaining string after XC.

‘xc!+?’ ( xc xc-addr1 u1 – xc-addr2 u2 f  ) xchar “x-c-store-plus-query”
   Stores the xchar XC into the buffer starting at address XC-ADDR1, U1
chars large.  XC-ADDR2 points to the first memory location after XC, U2
is the remaining size of the buffer.  If the xchar XC did fit into the
buffer, F is true, otherwise F is false, and XC-ADDR2 U2 equal XC-ADDR1
U1.  XC!+?  is safe for buffer overflows, and therefore preferred over
XC!+.

‘xc!+’ ( xc xc-addr1 – xc-addr2  ) xchar “x-c-store”
   Stores the xchar XC at XC-ADDR1.  XC-ADDR2 is the next unused address
in the buffer.  Note that this writes up to 4 bytes, so you need at
least 3 bytes of padding after the end of the buffer to avoid
overwriting useful data if you only check the address against the end of
the buffer.

‘xchar+’ ( xc-addr1 – xc-addr2  ) xchar “x-char-plus”
   Adds the size of the xchar stored at XC-ADDR1 to this address, giving
XC-ADDR2.

‘xchar-’ ( xc-addr1 – xc-addr2  ) xchar-ext “x-char-minus”
   Goes backward from XC_ADDR1 until it finds an xchar so that the size
of this xchar added to XC_ADDR2 gives XC_ADDR1.

‘+x/string’ ( xc-addr1 u1 – xc-addr2 u2  ) xchar-ext “plus-x-slash-string”
   Step forward by one xchar in the buffer defined by address XC-ADDR1,
size U1 chars.  XC-ADDR2 is the address and u2 the size in chars of the
remaining buffer after stepping over the first xchar in the buffer.

‘x\string-’ ( xc-addr u1 – xc-addr u2  ) xchar-ext “x-backslash-string-minus”
   Step backward by one xchar in the buffer defined by address XC-ADDR
and size U1 in chars, starting at the end of the buffer.  XC-ADDR is the
address and U2 the size in chars of the remaining buffer after stepping
backward over the last xchar in the buffer.

‘-trailing-garbage’ ( xc-addr u1 – xc-addr u2  ) xchar-ext “minus-trailing-garbage”
   Examine the last XCHAR in the buffer XC-ADDR U1—if the encoding is
correct and it repesents a full char, U2 equals U1, otherwise, U2
represents the string without the last (garbled) xchar.

‘x-width’ ( xc-addr u – n  ) xchar-ext “x-width”
   N is the number of monospace ASCII chars that take the same space to
display as the the xchar string starting at XC-ADDR, using U chars;
assuming a monospaced display font, i.e.  char width is always an
integer multiple of the width of an ASCII char.

‘xkey’ ( – xc  ) xchar “x-key”
   Reads an xchar from the terminal.  This will discard all input events
up to the completion of the xchar.

‘xc-width’ ( xc – n  ) xchar-ext “x-c-width”
   XC has a width of N times the width of a normal fixed-width glyph.

‘xhold’ ( xc –  ) xchar-ext “x-hold”
   Used between ‘<<#’ and ‘#>’.  Prepend XC to the pictured numeric
output string.  Alternatively, use ‘holds’.

‘xc,’ ( xchar –  ) xchar “x-c-comma”


File: gforth.info,  Node: i18n and l10n,  Next: Substitute,  Prev: Xchars and Unicode,  Up: Other I/O

6.20.11 国際化(I18n)とローカライズ
----------------------------------

Programs for end users require to address those in their native
language.  There is a decades old proposal for such a facility that has
been split from other proposals for international character sets like
Xchars (*note Xchars and Unicode::) and Substitute (*note Substitute::).
Messages displayed on the screen need to be translated from the native
language of the developers to the local languages of the user.

   Strings subject to translation are declared with ‘L" ’STRING‘"’.
This returns a locale string identifier (LSID). LSIDs are opaque types,
taking a cell on the stack.  LSIDs can be translated into a locale;
locales are languages and country-specific variants of that language.

‘L"’ ( "lsid<">" – lsid  ) gforth-experimental “l-quote”
   Parse a string and define a new lsid, if the string is uniquely new.
Identical strings result in identical lsids, which allows to refer to
the same lsid from multiple locations using the same string.

‘LU"’ ( "lsid<">" – lsid  ) gforth-experimental “l-unique-quote”
   Parse a string and always define a new lsid, even if the string is
not unique.

‘native@’ ( lsid – addr u  ) gforth-experimental “native-fetch”
   fetch native string from an LSID

‘locale@’ ( lsid – addr u  ) gforth-experimental “locale-fetch”
   fetch the localized string in the current language and country

‘locale!’ ( addr u lsid –  ) gforth-experimental “locale-store”
   Store localized string ADDR U for the current locale and country in
LSID.

‘Language’ ( "name" –  ) gforth-experimental “Language”
   define a locale.  Executing that locale makes it the current locale.

‘Country’ ( <lang> "name" –  ) gforth-experimental “Country”
   define a variant (typical: country) for the current locale.
Executing that locale makes it the current locale.  You can create
variants of variants (a country may have variants within, e.g.  think of
how many words for rolls/buns there are in many languages).

‘locale-file’ ( fid –  ) gforth-experimental “locale-file”
   read lines from FID into the current locale.

‘included-locale’ ( addr u –  ) gforth-experimental “included-locale”
   read lines from the file ADDR U into the current locale.

‘include-locale’ ( "name" –  ) gforth-experimental “include-locale”
   read lines from the file "NAME" into the current locale.

‘locale-csv’ ( "name" –  ) gforth-experimental “locale-csv”
   import comma-separated value table into locales.  first line contains
locale names, “program” and “default” are special entries; generic
languages must preceed translations for specific countries.  Entries
under “program” (must be leftmost) are used to search for the lsid; if
empty, the line number-1 is the lsid index.

‘.locale-csv’ ( –  ) gforth-experimental “dot-locale-csv”
   write the locale database in CSV format to the terminal output.

‘locale-csv-out’ ( "name" –  ) gforth-experimental “locale-csv”
   Create file "NAME" and write the locale database out to the file
"NAME" in CSV format.


File: gforth.info,  Node: Substitute,  Next: CSV Reader,  Prev: i18n and l10n,  Up: Other I/O

6.20.12 Substitute
------------------

This is a simple text macro replacement facility.  Texts in the form
‘"text %macro% text"’ are processed, and the macro variables enclosed in
‘'%'’ are replaced with their associated strings.  Two consecutive ‘%’
are replaced by one ‘%’.  Macros are defined in a specific wordlist, and
return a string upon execution; the standard defines only one way to
declare macros, ‘replaces’, which creates a macro that just returns a
string.

‘macros-wordlist’ ( – wid  ) gforth-experimental “macros-wordlist”
   wordlist for string replacement macros

‘replaces’ ( addr1 len1 addr2 len2 –  ) string-ext “replaces”
   create a macro with name ADDR2 LEN2 and content ADDR1 LEN1.  If the
macro already exists, just change the content.

‘.substitute’ ( addr1 len1 – n / ior  ) gforth-experimental “dot-substitute”
   substitute all macros in text ADDR1 LEN1 and print the result.  N is
the number of substitutions or, if negative, a throwable IOR.

‘$substitute’ ( addr1 len1 – addr2 len2 n/ior  ) gforth-experimental “string-substitute”
   substitute all macros in text ADDR1 LEN1.  N is the number of
substitutions, if negative, it’s a throwable IOR, ADDR2 LEN2 the result.

‘substitute’ ( addr1 len1 addr2 len2 – addr2 len3 n/ior  ) string-ext “substitute”
   substitute all macros in text ADDR1 LEN1, and copy the result to
ADDR2 LEN2.  N is the number of substitutions or, if negative, a
throwable IOR, ADDR2 LEN3 the result.

‘unescape’ ( addr1 u1 dest – dest u2  ) string-ext “unescape”
   double all delimiters in ADDR1 U1, so that substitute will result in
the original text.  Note that the buffer DEST does not have a size, as
in worst case, it will need just twice as many characters as U1.  DEST
U2 is the resulting string.

‘$unescape’ ( addr1 u1 – addr2 u2  ) gforth-experimental “string-unescape”
   same as ‘unescape’, but creates a temporary destination string with
‘$tmp’.


File: gforth.info,  Node: CSV Reader,  Prev: Substitute,  Up: Other I/O

6.20.13 CSV Reader
------------------

Comma-separated values (CSV) are a popular text format to interchange
data.  Gforth provides an reader in ‘csv.fs’.

‘read-csv’ ( addr u xt –  ) gforth-experimental “read-csv”
   read CVS file ADDR U and execute XT for every item found.  XT takes
‘( addr u col line -- )’, i.e.  the string, the current column (starting
with 0), and the current line (starting with 1).


File: gforth.info,  Node: OS command line arguments,  Next: Locals,  Prev: Other I/O,  Up: Words

6.21 OS command line arguments
==============================

The usual way to pass arguments to Gforth programs on the command line
is via the ‘-e’ option, e.g.

     gforth -e "123 456" foo.fs -e bye

   However, you may want to interpret the command-line arguments
directly.  In that case, you can access the (image-specific)
command-line arguments through ‘next-arg’:

‘next-arg’ ( – addr u  ) gforth-0.7 “next-arg”
   get the next argument from the OS command line, consuming it; if
there is no argument left, return ‘0 0’.

   Here’s an example program ‘echo.fs’ for ‘next-arg’:

     : echo ( -- )
         begin
     	next-arg 2dup 0 0 d<> while
     	    type space
         repeat
         2drop ;

     echo cr bye

   This can be invoked with

     gforth echo.fs hello world

   and it will print

     hello world

   The next lower level of dealing with the OS command line are the
following words:

‘arg’ ( u – addr count  ) gforth-0.2 “arg”
   Return the string for the uth command-line argument; returns ‘0 0’ if
the access is beyond the last argument.  ‘0 arg’ is the program name
with which you started Gforth.  The next unprocessed argument is always
‘1 arg’, the one after that is ‘2 arg’ etc.  All arguments already
processed by the system are deleted.  After you have processed an
argument, you can delete it with ‘shift-args’.

‘shift-args’ ( –  ) gforth-0.7 “shift-args”
   ‘1 arg’ is deleted, shifting all following OS command line parameters
to the left by 1, and reducing ‘argc @’.  This word can change ‘argv @’.

   Finally, at the lowest level Gforth provides the following words:

‘argc’ ( – addr  ) gforth-0.2 “argc”
   ‘Variable’ – the number of command-line arguments (including the
command name).  Changed by ‘next-arg’ and ‘shift-args’.

‘argv’ ( – addr  ) gforth-0.2 “argv”
   ‘Variable’ – a pointer to a vector of pointers to the command-line
arguments (including the command-name).  Each argument is represented as
a C-style zero-terminated string.  Changed by ‘next-arg’ and
‘shift-args’.


File: gforth.info,  Node: Locals,  Next: Structures,  Prev: OS command line arguments,  Up: Words

6.22 Locals
===========

ローカル変数を使用すると、 Forth プログラミングがより楽しくなり、 Forth
プログラムが読みやすくなります。 残念ながら、 標準 Forth の ローカル変数
には制限がたくさんあります。 したがって、 標準 Forth のローカル変数ワー
ドセットだけでなく、 Gforth 独自のより強力なローカル変数ワードセットも提
供します(標準Forthのローカル変数ワードセットは、 Gforth のローカル変数ワ
ードセットで実装しました)。

   このセクションのアイデアは、 M. Anton Ertl, ‘Automatic Scoping of
Local Variables
(https://www.complang.tuwien.ac.at/papers/ertl94l.ps.gz)’, EuroForth ’94
でも公開されています。

* Menu:

* Gforth locals::
* Standard Forth locals::


File: gforth.info,  Node: Gforth locals,  Next: Standard Forth locals,  Prev: Locals,  Up: Locals

6.22.1 Gforth locals
--------------------

ローカル変数は以下のように定義できます

     {: local1 local2 ... -- comment :}
   or
     {: local1 local2 ... :}
   or
     {: local1 local2 ... | ulocal0 ulocal1 -- comment :}

   例えば、 以下のように使います
     : max {: n1 n2 -- n3 :}
      n1 n2 > if
        n1
      else
        n2
      endif ;

   The similarity of locals definitions with stack comments is intended.
A locals definition often replaces the stack comment of a word.  The
order of the locals corresponds to the order in a stack comment and
everything after the ‘--’ is really a comment.

   This similarity has one disadvantage: It is too easy to confuse
locals declarations with stack comments, causing bugs and making them
hard to find.  However, this problem can be avoided by appropriate
coding conventions: Do not use both notations in the same program.  If
you do, they should be distinguished using additional means, e.g.  by
position.

   The name of the local may be preceded by a type specifier, e.g., ‘F:’
for a floating point value:

     : CX* {: F: Ar F: Ai F: Br F: Bi -- Cr Ci :}
     \ 複素数の掛け算
      Ar Br f* Ai Bi f* f-
      Ar Bi f* Ai Br f* f+ ;

   Gforth currently supports cells (‘W:’, ‘WA:’, ‘W^’), doubles (‘D:’,
‘DA:’, ‘D^’), floats (‘F:’, ‘FA:’, ‘F^’), characters (‘C:’, ‘CA:’,
‘C^’), and xts (‘xt:’, ‘xta:’) in several flavours:

“valueフレーバー(value-flavoured)”
     (*note Values::) A value-flavoured local (defined with ‘W:’, ‘D:’
     etc.)  produces its value and can be changed with ‘TO’.

“varue-flavoured”
     (*note Varues::) A varue-flavoured local l (defined with ‘WA:’
     etc.)  behaves exactly like a value-flavoured local, except that
     you can use ‘addr l’ to get its address (which becomes invalid when
     the variable’s scope is left).  Currently there is no performance
     difference, but in the long run value-flavoured locals will be
     significantly faster, because they can reside in registers.

“variable-flavoured”
     (*note Variables::) A variable-flavoured local (defined with ‘W^’
     etc.)  produces its address (which becomes invalid when the
     variable’s scope is left).  E.g., the standard word ‘emit’ can be
     defined in terms of ‘type’ like this:

          : emit {: C^ char* -- :}
              char* 1 type ;

“deferフレーバー(defer-flavoured)”
     (*note Deferred Words::) (‘XT:’ または ‘XTA:’ と指定した) defer フ
     レーバーのローカル変数 xt を ‘execute’ します。 ‘action-of’ を使用
     すると、 defer フレーバーのローカル変数から xt を取得できます。 ロ
     ーカル変数が ‘xta:’ で定義されている場合、 ‘addr’ を使用して、 xt が
     保存されているアドレス(ローカル変数のスコープの終わりまで有効)を取
     得できます。 たとえば、 標準のワード ‘execute’ は、 以下のように
     defer フレーバーのローカル変数で定義できます:

          : execute {: xt: x -- :}
            x ;

   A local without type specifier is a ‘W:’ local.  You can allow or
disallow the use of ‘addr’ with:

‘default-wa:’ ( –  ) gforth-experimental “default-wa:”
   Allow ‘addr’ on locals defined without a type specifyer.  On other
words, define locals without a type specifyer using ‘wa:’.

‘default-w:’ ( –  ) gforth-experimental “default-w:”
   Forbid ‘addr’ on locals defined without a type specifyer.  On other
words, define locals without a type specifyer using ‘w:’.

   All flavours of locals are initialized with values from the data or
(for FP locals) FP stack, with the exception being locals defined behind
‘|’: Gforth initializes them to 0; some Forth systems leave them
uninitialized.

   Gforth supports the square bracket notation for local buffers and
data structures.  These locals are similar to variable-flavored locals,
the size is specified as a constant expression.  A declaration looks
‘name[ size ]’.  The Forth expression ‘size’ is evaluated during
declaration, it must have the stack effect ‘( -- +n )’, giving the size
in bytes.  The square bracket ‘[’ is part of the defined name.

   Local data structures are initialized by copying size bytes from an
address passed on the stack; uninitialized local data structures (after
‘|’ in the declaration) are not erased, they just contain whatever data
there was on the locals stack before.

   Example:

     begin-structure test-struct
       field: a1
       field: a2
     end-structure

     : test-local {: foo[ test-struct ] :}
         foo[ a1 !  foo[ a2 !
         foo[ test-struct dump ;

   Gforth allows defining locals everywhere in a colon definition.  This
poses the following questions:

* Menu:

* Locals definition words::
* Where are locals visible by name?::
* How long do locals live?::
* Locals programming style::
* Locals implementation::
* Closures::


File: gforth.info,  Node: Locals definition words,  Next: Where are locals visible by name?,  Prev: Gforth locals,  Up: Gforth locals

6.22.1.1 Locals definitions words
.................................

This section documents the words used for defining locals.  Note that
the run-times for the words (like ‘W:’) that define a local are
performed from the rightmost defined local to the leftmost defined
local, such that the rightmost local gets the top of stack.

‘{:’ ( – hmaddr u latest latestnt wid 0  ) local-ext “open-brace-colon”
   Start locals definitions.

‘--’ ( hmaddr u latest latestnt wid 0 ... –  ) gforth-0.2 “dash-dash”
   During locals definitions everything from ‘--’ to ‘:}’ is ignored.
This is typically used when you want to make a locals definition serve
double duty as a stack effect description.

‘|’ ( –  ) gforth-1.0 “bar”
   Locals defined behind ‘|’ are not initialized from the stack; so the
run-time of words like ‘W:’ changes to ‘( -- )’.

‘:}’ ( hmaddr u latest latestnt wid 0 xt1 ... xtn –  ) gforth-1.0 “colon-close-brace”
   Ends locals definitions.

‘{’ ( – hmaddr u latest latestnt wid 0  ) gforth-0.2 “open-brace”
   Start locals definitions.  The Forth-2012 standard name for this word
is ‘{:’.

‘}’ ( hmaddr u latest latestnt wid 0 xt1 ... xtn –  ) gforth-0.2 “close-brace”
   Ends locals definitions.  The Forth-2012 standard name for this word
is ‘:}’.

‘W:’ ( compilation "name" – a-addr xt; run-time x –  ) gforth-0.2 “w-colon”
   Define value-flavoured cell local name ‘( -- x1 )’

‘WA:’ ( compilation "name" – a-addr xt; run-time x –  ) gforth-1.0 “w-a-colon”
   Define varue-flavoured cell local name ‘( -- x1 )’

‘W^’ ( compilation "name" – a-addr xt; run-time x –  ) gforth-0.2 “w-caret”
   Define variable-flavoured cell local name ‘( -- a-addr )’

‘D:’ ( compilation "name" – a-addr xt; run-time x1 x2 –  ) gforth-0.2 “d-colon”
   Define value-flavoured double local name ‘( -- x3 x4 )’

‘DA:’ ( compilation "name" – a-addr xt; run-time x1 x2 –  ) gforth-1.0 “w-a-colon”
   Define varue-flavoured double local name ‘( -- x3 x4 )’

‘D^’ ( compilation "name" – a-addr xt; run-time x1 x2 –  ) gforth-0.2 “d-caret”
   Define variable-flavoured double local name ‘( -- a-addr )’

‘C:’ ( compilation "name" – a-addr xt; run-time c –  ) gforth-0.2 “c-colon”
   Define value-flavoured char local name ‘( -- c1 )’

‘CA:’ ( compilation "name" – a-addr xt; run-time c –  ) gforth-1.0 “c-a-colon”
   Define varue-flavoured char local name ‘( -- c1 )’

‘C^’ ( compilation "name" – a-addr xt; run-time c –  ) gforth-0.2 “c-caret”
   Define variable-flavoured char local name ‘( -- c-addr )’

‘F:’ ( compilation "name" – a-addr xt; run-time r –  ) gforth-0.2 “f-colon”
   Define value-flavoured float local name ‘( -- r1 )’

‘FA:’ ( compilation "name" – a-addr xt; run-time f –  ) gforth-1.0 “f-a-colon”
   Define varue-flavoured float local name ‘( -- r1 )’

‘F^’ ( compilation "name" – a-addr xt; run-time r –  ) gforth-0.2 “f-caret”
   Define variable-flavoured float local name ‘( -- f-addr )’

‘XT:’ ( compilation "name" – a-addr xt; run-time xt1 –  ) gforth-1.0 “x-t-colon”
   Define defer-flavoured cell local name ‘( ... -- ... )’

‘XTA:’ ( compilation "name" – a-addr xt; run-time ... – ...  ) gforth-1.0 “x-t-a-colon”
   Define a defer-flavoured local name on which ‘addr’ can be used.

   Note that ‘|’, ‘--’, ‘:}’ and ‘}’ are not normally in the search
order (they are in the vocabulary ‘locals-types’), and they are not
necessarily words in all Forth systems; therefore they are documented as
Gforth words.


File: gforth.info,  Node: Where are locals visible by name?,  Next: How long do locals live?,  Prev: Locals definition words,  Up: Gforth locals

6.22.1.2 Where are locals visible by name?
..........................................

Basically, the answer is that locals are visible where you would expect
it in block-structured languages, and sometimes a little longer.  If you
want to restrict the scope of a local, enclose its definition in
‘SCOPE’...‘ENDSCOPE’.

‘scope’ ( compilation  – scope ; run-time  –  ) gforth-0.2 “scope”

‘endscope’ ( compilation scope – ; run-time  –  ) gforth-0.2 “endscope”

   These words behave like control structure words, so you can use them
with ‘CS-PICK’ and ‘CS-ROLL’ to restrict the scope in arbitrary ways.

   If you want a more exact answer to the visibility question, here’s
the basic principle: A local is visible in all places that can only be
reached through the definition of the local(1).  In other words, it is
not visible in places that can be reached without going through the
definition of the local.  E.g., locals defined in ‘IF’...‘ENDIF’ are
visible until the ‘ENDIF’, locals defined in ‘BEGIN’...‘UNTIL’ are
visible after the ‘UNTIL’ (until, e.g., a subsequent ‘ENDSCOPE’).

   The reasoning behind this solution is: We want to have the locals
visible as long as it is meaningful.  The user can always make the
visibility shorter by using explicit scoping.  In a place that can only
be reached through the definition of a local, the meaning of a local
name is clear.  In other places it is not: How is the local initialized
at the control flow path that does not contain the definition?  Which
local is meant, if the same name is defined twice in two independent
control flow paths?

   This should be enough detail for nearly all users, so you can skip
the rest of this section.  If you really must know all the gory details
and options, read on.

   In order to implement this rule, the compiler has to know which
places are unreachable.  It knows this automatically after ‘AHEAD’,
‘AGAIN’, ‘EXIT’ and ‘LEAVE’; in other cases (e.g., after most ‘THROW’s),
you can use the word ‘UNREACHABLE’ to tell the compiler that the control
flow never reaches that place.  If ‘UNREACHABLE’ is not used where it
could, the only consequence is that the visibility of some locals is
more limited than the rule above says.  If ‘UNREACHABLE’ is used where
it should not (i.e., if you lie to the compiler), buggy code will be
produced.

‘UNREACHABLE’ ( –  ) gforth-0.2 “UNREACHABLE”

   Another problem with this rule is that at ‘BEGIN’, the compiler does
not know which locals will be visible on the incoming back-edge.  All
problems discussed in the following are due to this ignorance of the
compiler (we discuss the problems using ‘BEGIN’ loops as examples; the
discussion also applies to ‘?DO’ and other loops).  Perhaps the most
insidious example is:
     AHEAD
     BEGIN
       x
     [ 1 CS-ROLL ] THEN
       {: x :}
       ...
     UNTIL

   This should be legal according to the visibility rule.  The use of
‘x’ can only be reached through the definition; but that appears
textually below the use.

   From this example it is clear that the visibility rules cannot be
fully implemented without major headaches.  Our implementation treats
common cases as advertised and the exceptions are treated in a safe way:
The compiler makes a reasonable guess about the locals visible after a
‘BEGIN’; if it is too pessimistic, the user will get a spurious error
about the local not being defined; if the compiler is too optimistic, it
will notice this later and issue a warning.  In the case above the
compiler would complain about ‘x’ being undefined at its use.  You can
see from the obscure examples in this section that it takes quite
unusual control structures to get the compiler into trouble, and even
then it will often do fine.

   If the ‘BEGIN’ is reachable from above, the most optimistic guess is
that all locals visible before the ‘BEGIN’ will also be visible after
the ‘BEGIN’.  This guess is valid for all loops that are entered only
through the ‘BEGIN’, in particular, for normal
‘BEGIN’...‘WHILE’...‘REPEAT’ and ‘BEGIN’...‘UNTIL’ loops and it is
implemented in our compiler.  When the branch to the ‘BEGIN’ is finally
generated by ‘AGAIN’ or ‘UNTIL’, the compiler checks the guess and warns
the user if it was too optimistic:
     IF
       {: x :}
     BEGIN
       \ x ?
     [ 1 cs-roll ] THEN
       ...
     UNTIL

   Here, ‘x’ lives only until the ‘BEGIN’, but the compiler
optimistically assumes that it lives until the ‘THEN’.  It notices this
difference when it compiles the ‘UNTIL’ and issues a warning.  The user
can avoid the warning, and make sure that ‘x’ is not used in the wrong
area by using explicit scoping:
     IF
       SCOPE
       {: x :}
       ENDSCOPE
     BEGIN
     [ 1 cs-roll ] THEN
       ...
     UNTIL

   Since the guess is optimistic, there will be no spurious error
messages about undefined locals.

   If the ‘BEGIN’ is not reachable from above (e.g., after ‘AHEAD’ or
‘EXIT’), the compiler cannot even make an optimistic guess, as the
locals visible after the ‘BEGIN’ may be defined later.

   It pessimistically assumes that all locals are visible that were
visible at the latest place outside any control structure (i.e., where
nothing is on the control-flow stack).  This means that in:

     : foo
       IF {: z :} THEN
       {: x :}
       AHEAD
         BEGIN
           ( * )
         [ 1 CS-ROLL ] THEN
         {: y :}
         ...
       UNTIL ;

   At the place marked with ‘( * )’, ‘x’ is visible, but ‘y’ is not
(although, according to the reachability rule it should); ‘z’ is not and
should not be visible there.

   However, you can use ‘ASSUME-LIVE’ to make the compiler assume that
the same locals are visible at the BEGIN as at the point where the top
control-flow stack item was created.

‘ASSUME-LIVE’ ( orig – orig  ) gforth-0.2 “ASSUME-LIVE”

例えば、 以下のように使います
     IF
       {: x :}
       AHEAD
         ASSUME-LIVE
         BEGIN
           x
         [ 1 CS-ROLL ] THEN
         ...
       UNTIL
     THEN

   Here ‘x’ would not be visible at the use of ‘x’, because its
definition is inside a control structure, but by using ASSUME-LIVE the
programmer tells the compiler that the locals visible at the ‘AHEAD’
should be visible at the ‘BEGIN’.

   Other cases where the locals are defined before the ‘BEGIN’ can be
handled by inserting an appropriate ‘CS-ROLL’ before the ‘ASSUME-LIVE’
(and changing the control-flow stack manipulation behind the
‘ASSUME-LIVE’).

   Cases where locals are defined after the ‘BEGIN’ (but should be
visible immediately after the ‘BEGIN’) can only be handled by
rearranging the loop.  E.g., the “most insidious” example above can be
arranged into:
     BEGIN
       {: x :}
       ... 0=
     WHILE
       x
     REPEAT

   ---------- Footnotes ----------

   (1) In compiler construction terminology, all places dominated by the
definition of the local.


File: gforth.info,  Node: How long do locals live?,  Next: Locals programming style,  Prev: Where are locals visible by name?,  Up: Gforth locals

6.22.1.3 How long do locals live?
.................................

The right answer for the lifetime question would be: A local lives at
least as long as it can be accessed.  For a value-flavoured local this
means: until the end of its visibility.  However, a variable-flavoured
local could be accessed through its address far beyond its visibility
scope.  Ultimately, this would mean that such locals would have to be
garbage collected.  Since this entails un-Forth-like implementation
complexities, I adopted the same cowardly solution as some other
languages (e.g., C): The local lives only as long as it is visible;
afterwards its address is invalid (and programs that access it
afterwards are erroneous).


File: gforth.info,  Node: Locals programming style,  Next: Locals implementation,  Prev: How long do locals live?,  Up: Gforth locals

6.22.1.4 Locals programming style
.................................

The freedom to define locals anywhere has the potential to change
programming styles dramatically.  In particular, the need to use the
return stack for intermediate storage vanishes.  Moreover, all stack
manipulations (except ‘PICK’s and ‘ROLL’s with run-time determined
arguments) can be eliminated: If the stack items are in the wrong order,
just write a locals definition for all of them; then write the items in
the order you want.

   This seems a little far-fetched and eliminating stack manipulations
is unlikely to become a conscious programming objective.  Still, the
number of stack manipulations will be reduced dramatically if local
variables are used liberally (e.g., compare ‘max’ (*note Gforth
locals::) with a traditional implementation of ‘max’).

   This shows one potential benefit of locals: making Forth programs
more readable.  Of course, this benefit will only be realized if the
programmers continue to honour the principle of factoring instead of
using the added latitude to make the words longer.

   Using ‘TO’ can and should be avoided.  Without ‘TO’, every
value-flavoured local has only a single assignment and many advantages
of functional languages apply to Forth.  I.e., programs are easier to
analyse, to optimize and to read: It is clear from the definition what
the local stands for, it does not turn into something different later.

   E.g., a definition using ‘TO’ might look like this:
     : strcmp {: addr1 u1 addr2 u2 -- n :}
      u1 u2 min 0
      ?do
        addr1 c@ addr2 c@ -
        ?dup-if
          unloop exit
        then
        addr1 char+ TO addr1
        addr2 char+ TO addr2
      loop
      u1 u2 - ;
   Here, ‘TO’ is used to update ‘addr1’ and ‘addr2’ at every loop
iteration.  ‘strcmp’ is a typical example of the readability problems of
using ‘TO’.  When you start reading ‘strcmp’, you think that ‘addr1’
refers to the start of the string.  Only near the end of the loop you
realize that it is something else.

   This can be avoided by defining two locals at the start of the loop
that are initialized with the right value for the current iteration.
     : strcmp {: addr1 u1 addr2 u2 -- n :}
      addr1 addr2
      u1 u2 min 0
      ?do {: s1 s2 :}
        s1 c@ s2 c@ -
        ?dup-if
          unloop exit
        then
        s1 char+ s2 char+
      loop
      2drop
      u1 u2 - ;
   Here it is clear from the start that ‘s1’ has a different value in
every loop iteration.


File: gforth.info,  Node: Locals implementation,  Next: Closures,  Prev: Locals programming style,  Up: Gforth locals

6.22.1.5 Locals implementation
..............................

Gforth は追加のローカル変数・スタックを使用します。 この最も説得力のある
理由は、 リターン・スタックが浮動小数点数に整列されていないことです。 こ
の追加のスタックを使用すると、 リターン・スタックをローカル変数・スタッ
クとして使用する場合の問題や制限も解消されます。 他のスタックと同様に、
ローカル変数スタックは下位アドレスに向かって成長します。 いくつかのプリ
ミティブにより効率的な実装になっています。 あなたは、 これらを直接使用す
るべきではありませんが、 ‘see’ の出力には表示されるため、 以下に文書化し
ておきます:

‘@localn’ ( noffset – w ) gforth-internal “fetch-local-n”

‘f@localn’ ( noffset – r ) gforth-1.0 “f-fetch-local-n”

‘lp@’ ( – c-addr ) gforth-0.2 “lp-fetch”
   C_addr は、 ローカル・スタック・ポインタの現在の値です。

   doc-lp+!#(訳注: まだ説明書いて無いっぽい)
‘lp!’ ( c-addr – ) gforth-internal “lp-store”

‘>l’ ( w – ) gforth-0.2 “to-l”
\ 訳注: w をローカル変数スタックにプッシュ

‘f>l’ ( r – ) gforth-0.2 “f-to-l”

   これらのプリミティブに加えて、 一般的に発生するインライン引数に対する
これらのプリミティブのいくつかの特殊化が、 効率上の理由から提供されてい
ます(例: ‘0 @localn’ の特殊化として ‘@local0’ )。 以下のコンパイル・ワー
ド(compiling words)は、 適切な特殊バージョン、 または一般バージョンを適
切にコンパイルします(訳注: ‘@local0’ シリーズは、 ‘@local0’ ローカル変数
スタックのTOS(のコピー)をスタックに積む、 ‘@local1’ ローカル変数スタック
の2nd(のコピー)をスタックに積む、 〜 ‘@local4’ まである):

‘compile-lp+!’ ( n –  ) gforth-0.2 “compile-l-p-plus-store”

   Combinations of conditional branches and ‘lp+!#’ like ‘?branch-lp+!#’
(the locals pointer is only changed if the branch is taken) are provided
for efficiency and correctness in loops.

   A special area in the dictionary space is reserved for keeping the
local variable names.  ‘{:’ switches the dictionary pointer to this area
and ‘:}’ switches it back and generates the locals initializing code.
‘W:’ etc. are normal defining words.  This special area is cleared at
the start of every colon definition.

   A special feature of Gforth’s dictionary is used to implement the
definition of locals without type specifiers: every word list (aka
vocabulary) has its own methods for searching etc.  (*note Word
Lists::).  For the present purpose we defined a word list with a special
search method: When it is searched for a word, it actually creates that
word using ‘W:’.  ‘{:’ changes the search order to first search the word
list containing ‘:}’, ‘W:’ etc., and then the word list for defining
locals without type specifiers.

   The lifetime rules support a stack discipline within a colon
definition: The lifetime of a local is either nested with other locals
lifetimes or it does not overlap them.

   At ‘BEGIN’, ‘IF’, and ‘AHEAD’ no code for locals stack pointer
manipulation is generated.  Between control structure words locals
definitions can push locals onto the locals stack.  ‘AGAIN’ is the
simplest of the other three control flow words.  It has to restore the
locals stack depth of the corresponding ‘BEGIN’ before branching.  The
code looks like this:
‘lp+!#’ current-locals-size − dest-locals-size
‘branch’ <begin>

   ‘UNTIL’ is a little more complicated: If it branches back, it must
adjust the stack just like ‘AGAIN’.  But if it falls through, the locals
stack must not be changed.  The compiler generates the following code:
‘?branch-lp+!#’ <begin> current-locals-size − dest-locals-size
   The locals stack pointer is only adjusted if the branch is taken.

   ‘THEN’ can produce somewhat inefficient code:
‘lp+!#’ current-locals-size − orig-locals-size
<orig target>:
‘lp+!#’ orig-locals-size − new-locals-size
   The second ‘lp+!#’ adjusts the locals stack pointer from the level at
the orig point to the level after the ‘THEN’.  The first ‘lp+!#’ adjusts
the locals stack pointer from the current level to the level at the orig
point, so the complete effect is an adjustment from the current level to
the right level after the ‘THEN’.

   In a conventional Forth implementation a dest control-flow stack
entry is just the target address and an orig entry is just the address
to be patched.  Our locals implementation adds a word list to every orig
or dest item.  It is the list of locals visible (or assumed visible) at
the point described by the entry.  Our implementation also adds a tag to
identify the kind of entry, in particular to differentiate between live
and dead (reachable and unreachable) orig entries.

   A few unusual operations have to be performed on locals word lists:

‘common-list’ ( list1 list2 – list3  ) gforth-internal “common-list”

‘sub-list?’ ( list1 list2 – f  ) gforth-internal “sub-list?”

‘list-size’ ( list – u  ) gforth-internal “list-size”

   Several features of our locals word list implementation make these
operations easy to implement: The locals word lists are organised as
linked lists; the tails of these lists are shared, if the lists contain
some of the same locals; and the address of a name is greater than the
address of the names behind it in the list.

   Another important implementation detail is the variable ‘dead-code’.
It is used by ‘BEGIN’ and ‘THEN’ to determine if they can be reached
directly or only through the branch that they resolve.  ‘dead-code’ is
set by ‘UNREACHABLE’, ‘AHEAD’, ‘EXIT’ etc., and cleared at the start of
a colon definition, by ‘BEGIN’ and usually by ‘THEN’.

   Counted loops are similar to other loops in most respects, but
‘LEAVE’ requires special attention: It performs basically the same
service as ‘AHEAD’, but it does not create a control-flow stack entry.
Therefore the information has to be stored elsewhere; traditionally, the
information was stored in the target fields of the branches created by
the ‘LEAVE’s, by organizing these fields into a linked list.
Unfortunately, this clever trick does not provide enough space for
storing our extended control flow information.  Therefore, we introduce
another stack, the leave stack.  It contains the control-flow stack
entries for all unresolved ‘LEAVE’s.

   Local names are kept until the end of the colon definition, even if
they are no longer visible in any control-flow path.  In a few cases
this may lead to increased space needs for the locals name area, but
usually less than reclaiming this space would cost in code size.


File: gforth.info,  Node: Closures,  Prev: Locals implementation,  Up: Gforth locals

6.22.1.6 Closures
.................

Gforth also provides basic closures.  A closure is a combination of a
quotation (*note Quotations::) and locals.  Gforth’s closures have
locals which are filled with values at the closure’s run-time, producing
a trampoline xt.  When executing that trampoline xt, the closure’s code
is executed, with access to the closure’s locals on the locals stack.
Modifications of the closure’s locals aren’t persistent, i.e.  when the
closure ‘EXIT’s, the modified values are lost.

‘[{:’ ( – hmaddr u latest latestnt wid 0  ) gforth-experimental “start-closure”
   starts a closure.  Closures first declare the locals frame they are
going to use, and then the code that is executed with those locals.
Closures end like quotations with a ‘;]’.  The locals declaration ends
depending where the closure’s locals are created.  At run-time, the
closure is created as trampolin xt, and fills the values of its local
frame from the stack.  At execution time of the xt, the local frame is
copied to the locals stack, and used inside the closure’s code.  After
return, those values are removed from the locals stack, and not updated
in the closure itself.

‘:}l’ ( hmaddr u latest latestnt wid 0 a-addr1 u1 ... –  ) gforth-1.0 “close-brace-locals”
   end a closure’s locals declaration.  The closure will be allocated on
the local’s stack.

‘:}d’ ( hmaddr u latest latestnt wid 0 a-addr1 u1 ... –  ) gforth-1.0 “colon-close-brace-d”
   end a closure’s locals declaration.  The closure will be allocated in
the dictionary.

‘:}h’ ( hmaddr u latest latestnt wid 0 a-addr1 u1 ... –  ) gforth-1.0 “colon-close-brace-h”
   end a closure’s locals declaration.  The closure will be allocated on
the heap.

‘:}h1’ ( hmaddr u latest latestnt wid 0 a-addr1 u1 ... –  ) gforth-1.0 “colon-close-brace-h”
   end a closure’s locals declaration.  The closure will be allocated on
the heap.

‘:}xt’ ( hmaddr u latest latestnt wid 0 a-addr1 u1 ... –  ) gforth-1.0 “colon-close-brace-x-t”
   end a closure’s locals declaration.  The closure will be allocated by
the xt on the stack, so the closure’s run-time stack effect is ‘(
xt-alloc -- xt-closure )’.

‘>addr’ ( xt – addr  ) gforth-experimental “to-addr”
   convert the xt of a closure on the heap to the ADDR with can be
passed to ‘free’ to get rid of the closure

‘free-closure’ ( xt –  ) gforth-internal “free-closure”
   free a heap-allocated closure

     : foo [{: a f: b d: c xt: d :}d a . b f. c d. d ;] ;
     5 3.3e #1234. ' cr foo execute

   ‘foo’ creates a closure in the dictionary with a single cell, a
floating point, a double, and an xt, and prints the first three values
before executing the xt on invocation.

   This allows to implement Donald Knuth’s “Man or boy test” proposed in
1964 to test Algol compilers.

     : A {: w^ k x1 x2 x3 xt: x4 xt: x5 | w^ B :} recursive
         k  0<= IF  x4 x5 f+  ELSE
             B k x1 x2 x3 action-of x4 [{: B k x1 x2 x3 x4 :}L
                 -1 k +!
                 k  B  x1 x2 x3 x4 A ;] dup B !
             execute  THEN ;
     : man-or-boy? ( n -- ) [: 1e ;] [: -1e ;] 2dup swap [: 0e ;] A f. ;

   Sometimes, closures need a permanent storage to be modified; it is
even possible that more than one closure shares that permanent storage.
In the example above, local variables of the outer procedure are used
for this, but in some cases, the closure lives longer than the outer
procedure; especially closures allocated in the dictionary or on the
heap are designed to outlive their parent procedure.

   For those, we have home locations, which are allocated like closures,
but their code is directly executed at creation and should provide us
with the addresses of the home locations.

     : bar ( a b c -- aaddr baddr caddr hl-addr )
         <{: w^ a w^ b w^ c :}h a b c ;> ;

   This example creates a home location with three cells on the heap,
and returns the addresses of the three locations and the address of the
home location.  This address can be used to ‘free’ the home location
when it is no longer needed.

‘<{:’ ( – hmaddr u latest latestnt wid 0  ) gforth-experimental “start-homelocation”
   starts a home location

‘;>’ ( –  ) gforth-experimental “end-homelocation”
   end using a home location


File: gforth.info,  Node: Standard Forth locals,  Prev: Gforth locals,  Up: Locals

6.22.2 Standard Forth locals
----------------------------

The Forth-2012 standard defines a syntax for locals is restricted
version of Gforth’s locals:

   • Locals can only be cell-sized values (no type specifiers are
     allowed).
   • Locals can be defined only outside control structures.
   • Only one locals definition per definition is allowed.
   • Locals can interfere with explicit usage of the return stack.  For
     the exact (and long) rules, see the standard.  If you don’t use
     return stack accessing words in a definition using locals, you will
     be all right.  The purpose of this rule is to make locals
     implementation on the return stack easier.
   • The whole locals definition must be in one line.

   The Standard Forth locals wordset itself consists of two words: ‘{:’
and:

‘(local)’ ( addr u –  ) local “paren-local-paren”

   The ANS Forth locals extension wordset defines a syntax using
‘locals|’, but it is so awful that we strongly recommend not to use it.
We have implemented this syntax to make porting to Gforth easy, but do
not document it here.  The problem with this syntax is that the locals
are defined in an order reversed with respect to the standard stack
comment notation, making programs harder to read, and easier to misread
and miswrite.  The only merit of this syntax is that it is easy to
implement using the ANS Forth locals wordset, but then, so is the ‘{:’
syntax.


File: gforth.info,  Node: Structures,  Next: Object-oriented Forth,  Prev: Locals,  Up: Words

6.23 Structures
===============

This section presents the structure package that comes with Gforth.  A
version of the package implemented in Standard Forth is available in
‘compat/struct.fs’.  This package was inspired by a posting on
comp.lang.forth in 1989 (unfortunately I don’t remember, by whom;
possibly John Hayes).  A version of this section has been published in
M. Anton Ertl, Yet Another Forth Structures Package
(https://www.complang.tuwien.ac.at/forth/objects/structs.html), Forth
Dimensions 19(3), pages 13–16.  Marcel Hendrix provided helpful
comments.

* Menu:

* Why explicit structure support?::
* Structure Usage::
* Structure Naming Convention::
* Structure Implementation::
* Structure Glossary::
* Forth200x Structures::


File: gforth.info,  Node: Why explicit structure support?,  Next: Structure Usage,  Prev: Structures,  Up: Structures

6.23.1 Why explicit structure support?
--------------------------------------

If we want to use a structure containing several fields, we could simply
reserve memory for it, and access the fields using address arithmetic
(*note Address arithmetic::).  As an example, consider a structure with
the following fields

‘a’
     is a float
‘b’
     is a cell
‘c’
     is a float

   Given the (float-aligned) base address of the structure we get the
address of the field

‘a’
     without doing anything further.
‘b’
     with ‘float+’
‘c’
     with ‘float+ cell+ faligned’

   It is easy to see that this can become quite tiring.

   Moreover, it is not very readable, because seeing a ‘cell+’ tells us
neither which kind of structure is accessed nor what field is accessed;
we have to somehow infer the kind of structure, and then look up in the
documentation, which field of that structure corresponds to that offset.

   Finally, this kind of address arithmetic also causes maintenance
troubles: If you add or delete a field somewhere in the middle of the
structure, you have to find and change all computations for the fields
afterwards.

   So, instead of using ‘cell+’ and friends directly, how about storing
the offsets in constants:

     0 constant a-offset
     0 float+ constant b-offset
     0 float+ cell+ faligned c-offset

   Now we can get the address of field ‘x’ with ‘x-offset +’.  This is
much better in all respects.  Of course, you still have to change all
later offset definitions if you add a field.  You can fix this by
declaring the offsets in the following way:

     0 constant a-offset
     a-offset float+ constant b-offset
     b-offset cell+ faligned constant c-offset

   Since we always use the offsets with ‘+’, we could use a defining
word ‘cfield’ that includes the ‘+’ in the action of the defined word:

     : cfield ( n "name" -- )
         create ,
     does> ( name execution: addr1 -- addr2 )
         @ + ;

     0 cfield a
     0 a float+ cfield b
     0 b cell+ faligned cfield c

   Instead of ‘x-offset +’, we now simply write ‘x’.

   The structure field words now can be used quite nicely.  However,
their definition is still a bit cumbersome: We have to repeat the name,
the information about size and alignment is distributed before and after
the field definitions etc.  The structure package presented here
addresses these problems.


File: gforth.info,  Node: Structure Usage,  Next: Structure Naming Convention,  Prev: Why explicit structure support?,  Up: Structures

6.23.2 Structure Usage
----------------------

You can define a structure for a (data-less) linked list with:
     struct
         cell% field list-next
     end-struct list%

   With the address of the list node on the stack, you can compute the
address of the field that contains the address of the next node with
‘list-next’.  E.g., you can determine the length of a list with:

     : list-length ( list -- n )
     \ "list" is a pointer to the first element of a linked list
     \ "n" is the length of the list
         0 BEGIN ( list1 n1 )
             over
         WHILE ( list1 n1 )
             1+ swap list-next @ swap
         REPEAT
         nip ;

   You can reserve memory for a list node in the dictionary with ‘list%
%allot’, which leaves the address of the list node on the stack.  For
the equivalent allocation on the heap you can use ‘list% %alloc’ (or,
for an ‘allocate’-like stack effect (i.e., with ior), use ‘list%
%allocate’).  You can get the the size of a list node with ‘list% %size’
and its alignment with ‘list% %alignment’.

   Note that in Standard Forth the body of a ‘create’d word is ‘aligned’
but not necessarily ‘faligned’; therefore, if you do a:

     create _name_ foo% %allot drop

then the memory alloted for ‘foo%’ is guaranteed to start at the body of
‘_name_’ only if ‘foo%’ contains only character, cell and double fields.
Therefore, if your structure contains floats, better use

     foo% %allot constant _name_

   You can include a structure ‘foo%’ as a field of another structure,
like this:
     struct
     ...
         foo% field ...
     ...
     end-struct ...

   Instead of starting with an empty structure, you can extend an
existing structure.  E.g., a plain linked list without data, as defined
above, is hardly useful; You can extend it to a linked list of integers,
like this:(1)

     list%
         cell% field intlist-int
     end-struct intlist%

   ‘intlist%’ is a structure with two fields: ‘list-next’ and
‘intlist-int’.

   You can specify an array type containing _n_ elements of type ‘foo%’
like this:

     foo% _n_ *

   You can use this array type in any place where you can use a normal
type, e.g., when defining a ‘field’, or with ‘%allot’.

   The first field is at the base address of a structure and the word
for this field (e.g., ‘list-next’) actually does not change the address
on the stack.  You may be tempted to leave it away in the interest of
run-time and space efficiency.  This is not necessary, because the
structure package optimizes this case: If you compile a first-field
words, no code is generated.  So, in the interest of readability and
maintainability you should include the word for the field when accessing
the field.

   ---------- Footnotes ----------

   (1) This feature is also known as _extended records_.  It is the main
innovation in the Oberon language; in other words, adding this feature
to Modula-2 led Wirth to create a new language, write a new compiler
etc.  Adding this feature to Forth just required a few lines of code.


File: gforth.info,  Node: Structure Naming Convention,  Next: Structure Implementation,  Prev: Structure Usage,  Up: Structures

6.23.3 Structure Naming Convention
----------------------------------

The field names that come to (my) mind are often quite generic, and, if
used, would cause frequent name clashes.  E.g., many structures probably
contain a ‘counter’ field.  The structure names that come to (my) mind
are often also the logical choice for the names of words that create
such a structure.

   Therefore, I have adopted the following naming conventions:

   • The names of fields are of the form ‘_struct_-_field_’, where
     ‘_struct_’ is the basic name of the structure, and ‘_field_’ is the
     basic name of the field.  You can think of field words as
     converting the (address of the) structure into the (address of the)
     field.

   • The names of structures are of the form ‘_struct_%’, where
     ‘_struct_’ is the basic name of the structure.

   This naming convention does not work that well for fields of extended
structures; e.g., the integer list structure has a field ‘intlist-int’,
but has ‘list-next’, not ‘intlist-next’.


File: gforth.info,  Node: Structure Implementation,  Next: Structure Glossary,  Prev: Structure Naming Convention,  Up: Structures

6.23.4 Structure Implementation
-------------------------------

The central idea in the implementation is to pass the data about the
structure being built on the stack, not in some global variable.
Everything else falls into place naturally once this design decision is
made.

   The type description on the stack is of the form _align size_.
Keeping the size on the top-of-stack makes dealing with arrays very
simple.

   ‘field’ is a defining word that uses ‘Create’ and ‘DOES>’.  The body
of the field contains the offset of the field, and the normal ‘DOES>’
action is simply:

     @ +

i.e., add the offset to the address, giving the stack effect addr1 –
addr2 for a field.

   This simple structure is slightly complicated by the optimization for
fields with offset 0, which requires a different ‘DOES>’-part (because
we cannot rely on there being something on the stack if such a field is
invoked during compilation).  Therefore, we put the different
‘DOES>’-parts in separate words, and decide which one to invoke based on
the offset.  For a zero offset, the field is basically a noop; it is
immediate, and therefore no code is generated when it is compiled.


File: gforth.info,  Node: Structure Glossary,  Next: Forth200x Structures,  Prev: Structure Implementation,  Up: Structures

6.23.5 Structure Glossary
-------------------------

‘%align’ ( align size –  ) gforth-0.4 “%align”
   Align the data space pointer to the alignment ALIGN.

‘%alignment’ ( align size – align  ) gforth-0.4 “%alignment”
   The alignment of the structure.

‘%alloc’ ( align size – addr  ) gforth-0.4 “%alloc”
   Allocate SIZE address units with alignment ALIGN, giving a data block
at ADDR; ‘throw’ an ior code if not successful.

‘%allocate’ ( align size – addr ior  ) gforth-0.4 “%allocate”
   Allocate SIZE address units with alignment ALIGN, similar to
‘allocate’.

‘%allot’ ( align size – addr  ) gforth-0.4 “%allot”
   Allot SIZE address units of data space with alignment ALIGN; the
resulting block of data is found at ADDR.

‘cell%’ ( – align size  ) gforth-0.4 “cell%”

‘char%’ ( – align size  ) gforth-0.4 “char%”

‘dfloat%’ ( – align size  ) gforth-0.4 “dfloat%”

‘double%’ ( – align size  ) gforth-0.4 “double%”

‘end-struct’ ( align size "name" –  ) gforth-0.2 “end-struct”
   Define a structure/type descriptor NAME with alignment ALIGN and size
SIZE1 (SIZE rounded up to be a multiple of ALIGN).
‘name’ execution: – ALIGN SIZE1

‘field’ ( align1 offset1 align size "name" –  align2 offset2  ) gforth-0.2 “field”
   Create a field NAME with offset OFFSET1, and the type given by ALIGN
SIZE.  OFFSET2 is the offset of the next field, and ALIGN2 is the
alignment of all fields.
‘name’ execution: ADDR1 – ADDR2.
ADDR2=ADDR1+OFFSET1

‘float%’ ( – align size  ) gforth-0.4 “float%”

‘sfloat%’ ( – align size  ) gforth-0.4 “sfloat%”

‘%size’ ( align size – size  ) gforth-0.4 “%size”
   The size of the structure.

‘struct’ ( – align size  ) gforth-0.2 “struct”
   An empty structure, used to start a structure definition.


File: gforth.info,  Node: Forth200x Structures,  Prev: Structure Glossary,  Up: Structures

6.23.6 Forth200x Structures
---------------------------

The Forth 2012 standard defines a slightly less convenient form of
structures.  In general (when using ‘field+’, you have to perform the
alignment yourself, but there are a number of convenience words (e.g.,
‘field:’) that include alignment.

   A typical usage example is:

     0
       field:                   s-a
       faligned 2 floats +field s-b
     constant s-struct

   An alternative way of writing this structure is:

     begin-structure s-struct
       field:                   s-a
       faligned 2 floats +field s-b
     end-structure

   You can define a structure that has the same fields and additional
fields as follows:

     s-struct
       cfield: t-c
       cfield: t-d
     constant t-struct

   or alternatively

     s-struct extend-structure t-struct
       cfield: t-c
       cfield: t-d
     end-structure

‘begin-structure’ ( "name" – struct-sys 0  ) facility-ext “begin-structure”

‘extend-structure’ ( n "name" – struct-sys n  ) gforth-1.0 “extend-structure”
   Start a new structure name as extension of an existing structure with
size n.

‘end-structure’ ( struct-sys +n –  ) facility-ext “end-structure”
   end a structure started wioth ‘begin-structure’

‘+field’ ( noffset1 nsize "name" – noffset2  ) facility-ext “plus-field”
   Defining word; defines name ‘( addr1 -- addr2 )’, where addr2 is
addr1+noffset1.  noffset2 is noffset1+nsize.

‘cfield:’ ( u1 "name" – u2  ) facility-ext “c-field-colon”
   Define a char-sized field

‘field:’ ( u1 "name" – u2  ) facility-ext “field-colon”
   Define an aligned cell-sized field

‘2field:’ ( u1 "name" – u2  ) gforth-0.7 “two-field-colon”
   Define an aligned double-cell-sized field

‘ffield:’ ( u1 "name" – u2  ) floating-ext “f-field-colon”
   Define a faligned float-sized field

‘sffield:’ ( u1 "name" – u2  ) floating-ext “s-f-field-colon”
   Define a sfaligned sfloat-sized field

‘dffield:’ ( u1 "name" – u2  ) floating-ext “d-f-field-colon”
   Define a dfaligned dfloat-sized field

‘wfield:’ ( u1 "name" – u2  ) gforth-1.0 “w-field-colon”
   Define a naturally aligned field for a 16-bit value.

‘lfield:’ ( u1 "name" – u2  ) gforth-1.0 “l-field-colon”
   Define a naturally aligned field for a 32-bit value.

‘xfield:’ ( u1 "name" – u2  ) gforth-1.0 “x-field-colon”
   Define a naturally aligned field for a 64-bit-value.


File: gforth.info,  Node: Object-oriented Forth,  Next: Regular Expressions,  Prev: Structures,  Up: Words

6.24 Object-oriented Forth
==========================

Gforth comes with three packages for object-oriented programming:
‘objects.fs’, ‘oof.fs’, and ‘mini-oof.fs’; none of them is preloaded, so
you have to ‘include’ them before use.  The most important differences
between these packages (and others) are discussed in *note Comparison
with other object models::.  All packages are written in Standard Forth
and can be used with any other Standard Forth.

* Menu:

* Why object-oriented programming?::
* Object-Oriented Terminology::
* Objects::
* OOF::
* Mini-OOF::
* Mini-OOF2::
* Comparison with other object models::


File: gforth.info,  Node: Why object-oriented programming?,  Next: Object-Oriented Terminology,  Prev: Object-oriented Forth,  Up: Object-oriented Forth

6.24.1 Why object-oriented programming?
---------------------------------------

Often we have to deal with several data structures (_objects_), that
have to be treated similarly in some respects, but differently in
others.  Graphical objects are the textbook example: circles, triangles,
dinosaurs, icons, and others, and we may want to add more during program
development.  We want to apply some operations to any graphical object,
e.g., ‘draw’ for displaying it on the screen.  However, ‘draw’ has to do
something different for every kind of object.

   We could implement ‘draw’ as a big ‘CASE’ control structure that
executes the appropriate code depending on the kind of object to be
drawn.  This would be not be very elegant, and, moreover, we would have
to change ‘draw’ every time we add a new kind of graphical object (say,
a spaceship).

   What we would rather do is: When defining spaceships, we would tell
the system: “Here’s how you ‘draw’ a spaceship; you figure out the
rest”.

   This is the problem that all systems solve that (rightfully) call
themselves object-oriented; the object-oriented packages presented here
solve this problem (and not much else).


File: gforth.info,  Node: Object-Oriented Terminology,  Next: Objects,  Prev: Why object-oriented programming?,  Up: Object-oriented Forth

6.24.2 Object-Oriented Terminology
----------------------------------

This section is mainly for reference, so you don’t have to understand
all of it right away.  The terminology is mainly Smalltalk-inspired.  In
short:

_class_
     a data structure definition with some extras.

_object_
     an instance of the data structure described by the class
     definition.

_instance variables_
     fields of the data structure.

_selector_
     (or _method selector_) a word (e.g., ‘draw’) that performs an
     operation on a variety of data structures (classes).  A selector
     describes _what_ operation to perform.  In C++ terminology: a
     (pure) virtual function.

_method_
     the concrete definition that performs the operation described by
     the selector for a specific class.  A method specifies _how_ the
     operation is performed for a specific class.

_selector invocation_
     a call of a selector.  One argument of the call (the TOS
     (top-of-stack)) is used for determining which method is used.  In
     Smalltalk terminology: a message (consisting of the selector and
     the other arguments) is sent to the object.

_receiving object_
     the object used for determining the method executed by a selector
     invocation.  In the ‘objects.fs’ model, it is the object that is on
     the TOS when the selector is invoked.  (_Receiving_ comes from the
     Smalltalk _message_ terminology.)

_child class_
     a class that has (_inherits_) all properties (instance variables,
     selectors, methods) from a _parent class_.  In Smalltalk
     terminology: The subclass inherits from the superclass.  In C++
     terminology: The derived class inherits from the base class.


File: gforth.info,  Node: Objects,  Next: OOF,  Prev: Object-Oriented Terminology,  Up: Object-oriented Forth

6.24.3 The ‘objects.fs’ model
-----------------------------

This section describes the ‘objects.fs’ package.  This material also has
been published in M. Anton Ertl, ‘Yet Another Forth Objects Package
(https://www.complang.tuwien.ac.at/forth/objects/objects.html)’, Forth
Dimensions 19(2), pages 37–43.

   This section assumes that you have read *note Structures::.

   The techniques on which this model is based have been used to
implement the parser generator, Gray, and have also been used in Gforth
for implementing the various flavours of word lists (hashed or not,
case-sensitive or not, special-purpose word lists for locals etc.).

* Menu:

* Properties of the Objects model::
* Basic Objects Usage::
* The Objects base class::
* Creating objects::
* Object-Oriented Programming Style::
* Class Binding::
* Method conveniences::
* Classes and Scoping::
* Dividing classes::
* Object Interfaces::
* Objects Implementation::
* Objects Glossary::

   Marcel Hendrix provided helpful comments on this section.


File: gforth.info,  Node: Properties of the Objects model,  Next: Basic Objects Usage,  Prev: Objects,  Up: Objects

6.24.3.1 Properties of the ‘objects.fs’ model
.............................................

   • It is straightforward to pass objects on the stack.  Passing
     selectors on the stack is a little less convenient, but possible.

   • Objects are just data structures in memory, and are referenced by
     their address.  You can create words for objects with normal
     defining words like ‘constant’.  Likewise, there is no difference
     between instance variables that contain objects and those that
     contain other data.

   • Late binding is efficient and easy to use.

   • It avoids parsing, and thus avoids problems with state-smartness
     and reduced extensibility; for convenience there are a few parsing
     words, but they have non-parsing counterparts.  There are also a
     few defining words that parse.  This is hard to avoid, because all
     standard defining words parse (except ‘:noname’); however, such
     words are not as bad as many other parsing words, because they are
     not state-smart.

   • It does not try to incorporate everything.  It does a few things
     and does them well (IMO). In particular, this model was not
     designed to support information hiding (although it has features
     that may help); you can use a separate package for achieving this.

   • It is layered; you don’t have to learn and use all features to use
     this model.  Only a few features are necessary (*note Basic Objects
     Usage::, *note The Objects base class::, *note Creating
     objects::.), the others are optional and independent of each other.

   • An implementation in Standard Forth is available.


File: gforth.info,  Node: Basic Objects Usage,  Next: The Objects base class,  Prev: Properties of the Objects model,  Up: Objects

6.24.3.2 Basic ‘objects.fs’ Usage
.................................

You can define a class for graphical objects like this:

     object class \ "object" is the parent class
       selector draw ( x y graphical -- )
     end-class graphical

   This code defines a class ‘graphical’ with an operation ‘draw’.  We
can perform the operation ‘draw’ on any ‘graphical’ object, e.g.:

     100 100 t-rex draw

where ‘t-rex’ is a word (say, a constant) that produces a graphical
object.

   How do we create a graphical object?  With the present definitions,
we cannot create a useful graphical object.  The class ‘graphical’
describes graphical objects in general, but not any concrete graphical
object type (C++ users would call it an _abstract class_); e.g., there
is no method for the selector ‘draw’ in the class ‘graphical’.

   For concrete graphical objects, we define child classes of the class
‘graphical’, e.g.:

     graphical class \ "graphical" is the parent class
       cell% field circle-radius

     :noname ( x y circle -- )
       circle-radius @ draw-circle ;
     overrides draw

     :noname ( n-radius circle -- )
       circle-radius ! ;
     overrides construct

     end-class circle

   Here we define a class ‘circle’ as a child of ‘graphical’, with field
‘circle-radius’ (which behaves just like a field (*note Structures::);
it defines (using ‘overrides’) new methods for the selectors ‘draw’ and
‘construct’ (‘construct’ is defined in ‘object’, the parent class of
‘graphical’).

   Now we can create a circle on the heap (i.e., ‘allocate’d memory)
with:

     50 circle heap-new constant my-circle

‘heap-new’ invokes ‘construct’, thus initializing the field
‘circle-radius’ with 50.  We can draw this new circle at (100,100) with:

     100 100 my-circle draw

   Note: You can only invoke a selector if the object on the TOS (the
receiving object) belongs to the class where the selector was defined or
one of its descendents; e.g., you can invoke ‘draw’ only for objects
belonging to ‘graphical’ or its descendents (e.g., ‘circle’).
Immediately before ‘end-class’, the search order has to be the same as
immediately after ‘class’.


File: gforth.info,  Node: The Objects base class,  Next: Creating objects,  Prev: Basic Objects Usage,  Up: Objects

6.24.3.3 The ‘object.fs’ base class
...................................

When you define a class, you have to specify a parent class.  So how do
you start defining classes?  There is one class available from the
start: ‘object’.  It is ancestor for all classes and so is the only
class that has no parent.  It has two selectors: ‘construct’ and
‘print’.


File: gforth.info,  Node: Creating objects,  Next: Object-Oriented Programming Style,  Prev: The Objects base class,  Up: Objects

6.24.3.4 Creating objects
.........................

You can create and initialize an object of a class on the heap with
‘heap-new’ ( ...  class – object ) and in the dictionary (allocation
with ‘allot’) with ‘dict-new’ ( ...  class – object ).  Both words
invoke ‘construct’, which consumes the stack items indicated by "..."
above.

   If you want to allocate memory for an object yourself, you can get
its alignment and size with ‘class-inst-size 2@’ ( class – align size ).
Once you have memory for an object, you can initialize it with
‘init-object’ ( ...  class object – ); ‘construct’ does only a part of
the necessary work.


File: gforth.info,  Node: Object-Oriented Programming Style,  Next: Class Binding,  Prev: Creating objects,  Up: Objects

6.24.3.5 Object-Oriented Programming Style
..........................................

This section is not exhaustive.

   In general, it is a good idea to ensure that all methods for the same
selector have the same stack effect: when you invoke a selector, you
often have no idea which method will be invoked, so, unless all methods
have the same stack effect, you will not know the stack effect of the
selector invocation.

   One exception to this rule is methods for the selector ‘construct’.
We know which method is invoked, because we specify the class to be
constructed at the same place.  Actually, I defined ‘construct’ as a
selector only to give the users a convenient way to specify
initialization.  The way it is used, a mechanism different from selector
invocation would be more natural (but probably would take more code and
more space to explain).


File: gforth.info,  Node: Class Binding,  Next: Method conveniences,  Prev: Object-Oriented Programming Style,  Up: Objects

6.24.3.6 Class Binding
......................

Normal selector invocations determine the method at run-time depending
on the class of the receiving object.  This run-time selection is called
late binding.

   Sometimes it’s preferable to invoke a different method.  For example,
you might want to use the simple method for ‘print’ing ‘object’s instead
of the possibly long-winded ‘print’ method of the receiver class.  You
can achieve this by replacing the invocation of ‘print’ with:

     [bind] object print

in compiled code or:

     bind object print

in interpreted code.  Alternatively, you can define the method with a
name (e.g., ‘print-object’), and then invoke it through the name.  Class
binding is just a (often more convenient) way to achieve the same
effect; it avoids name clutter and allows you to invoke methods directly
without naming them first.

   A frequent use of class binding is this: When we define a method for
a selector, we often want the method to do what the selector does in the
parent class, and a little more.  There is a special word for this
purpose: ‘[parent]’; ‘[parent] _selector_’ is equivalent to ‘[bind]
_parent selector_’, where ‘_parent_’ is the parent class of the current
class.  E.g., a method definition might look like:

     :noname
       dup [parent] foo \ do parent's foo on the receiving object
       ... \ do some more
     ; overrides foo

   In ‘Object-oriented programming in ANS Forth’ (Forth Dimensions,
March 1997), Andrew McKewan presents class binding as an optimization
technique.  I recommend not using it for this purpose unless you are in
an emergency.  Late binding is pretty fast with this model anyway, so
the benefit of using class binding is small; the cost of using class
binding where it is not appropriate is reduced maintainability.

   While we are at programming style questions: You should bind
selectors only to ancestor classes of the receiving object.  E.g., say,
you know that the receiving object is of class ‘foo’ or its descendents;
then you should bind only to ‘foo’ and its ancestors.


File: gforth.info,  Node: Method conveniences,  Next: Classes and Scoping,  Prev: Class Binding,  Up: Objects

6.24.3.7 Method conveniences
............................

In a method you usually access the receiving object pretty often.  If
you define the method as a plain colon definition (e.g., with
‘:noname’), you may have to do a lot of stack gymnastics.  To avoid
this, you can define the method with ‘m: ... ;m’.  E.g., you could
define the method for ‘draw’ing a ‘circle’ with

     m: ( x y circle -- )
       ( x y ) this circle-radius @ draw-circle ;m

   When this method is executed, the receiver object is removed from the
stack; you can access it with ‘this’ (admittedly, in this example the
use of ‘m: ... ;m’ offers no advantage).  Note that I specify the stack
effect for the whole method (i.e.  including the receiver object), not
just for the code between ‘m:’ and ‘;m’.  You cannot use ‘exit’ in
‘m:...;m’; instead, use ‘exitm’.(1)

   You will frequently use sequences of the form ‘this _field_’ (in the
example above: ‘this circle-radius’).  If you use the field only in this
way, you can define it with ‘inst-var’ and eliminate the ‘this’ before
the field name.  E.g., the ‘circle’ class above could also be defined
with:

     graphical class
       cell% inst-var radius

     m: ( x y circle -- )
       radius @ draw-circle ;m
     overrides draw

     m: ( n-radius circle -- )
       radius ! ;m
     overrides construct

     end-class circle

   ‘radius’ can only be used in ‘circle’ and its descendent classes and
inside ‘m:...;m’.

   You can also define fields with ‘inst-value’, which is to ‘inst-var’
what ‘value’ is to ‘variable’.  You can change the value of such a field
with ‘[to-inst]’.  E.g., we could also define the class ‘circle’ like
this:

     graphical class
       inst-value radius

     m: ( x y circle -- )
       radius draw-circle ;m
     overrides draw

     m: ( n-radius circle -- )
       [to-inst] radius ;m
     overrides construct

     end-class circle

   ---------- Footnotes ----------

   (1) Moreover, for any word that calls ‘catch’ and was defined before
loading ‘objects.fs’, you have to redefine it like I redefined ‘catch’:
‘: catch this >r catch r> to-this ;’


File: gforth.info,  Node: Classes and Scoping,  Next: Dividing classes,  Prev: Method conveniences,  Up: Objects

6.24.3.8 Classes and Scoping
............................

Inheritance is frequent, unlike structure extension.  This exacerbates
the problem with the field name convention (*note Structure Naming
Convention::): One always has to remember in which class the field was
originally defined; changing a part of the class structure would require
changes for renaming in otherwise unaffected code.

   To solve this problem, I added a scoping mechanism (which was not in
my original charter): A field defined with ‘inst-var’ (or ‘inst-value’)
is visible only in the class where it is defined and in the descendent
classes of this class.  Using such fields only makes sense in
‘m:’-defined methods in these classes anyway.

   This scoping mechanism allows us to use the unadorned field name,
because name clashes with unrelated words become much less likely.

   Once we have this mechanism, we can also use it for controlling the
visibility of other words: All words defined after ‘protected’ are
visible only in the current class and its descendents.  ‘public’
restores the compilation (i.e.  ‘current’) word list that was in effect
before.  If you have several ‘protected’s without an intervening
‘public’ or ‘set-current’, ‘public’ will restore the compilation word
list in effect before the first of these ‘protected’s.


File: gforth.info,  Node: Dividing classes,  Next: Object Interfaces,  Prev: Classes and Scoping,  Up: Objects

6.24.3.9 Dividing classes
.........................

You may want to do the definition of methods separate from the
definition of the class, its selectors, fields, and instance variables,
i.e., separate the implementation from the definition.  You can do this
in the following way:

     graphical class
       inst-value radius
     end-class circle

     ... \ do some other stuff

     circle methods \ now we are ready

     m: ( x y circle -- )
       radius draw-circle ;m
     overrides draw

     m: ( n-radius circle -- )
       [to-inst] radius ;m
     overrides construct

     end-methods

   You can use several ‘methods’...‘end-methods’ sections.  The only
things you can do to the class in these sections are: defining methods,
and overriding the class’s selectors.  You must not define new selectors
or fields.

   Note that you often have to override a selector before using it.  In
particular, you usually have to override ‘construct’ with a new method
before you can invoke ‘heap-new’ and friends.  E.g., you must not create
a circle before the ‘overrides construct’ sequence in the example above.


File: gforth.info,  Node: Object Interfaces,  Next: Objects Implementation,  Prev: Dividing classes,  Up: Objects

6.24.3.10 Object Interfaces
...........................

In this model you can only call selectors defined in the class of the
receiving objects or in one of its ancestors.  If you call a selector
with a receiving object that is not in one of these classes, the result
is undefined; if you are lucky, the program crashes immediately.

   Now consider the case when you want to have a selector (or several)
available in two classes: You would have to add the selector to a common
ancestor class, in the worst case to ‘object’.  You may not want to do
this, e.g., because someone else is responsible for this ancestor class.

   The solution for this problem is interfaces.  An interface is a
collection of selectors.  If a class implements an interface, the
selectors become available to the class and its descendents.  A class
can implement an unlimited number of interfaces.  For the problem
discussed above, we would define an interface for the selector(s), and
both classes would implement the interface.

   As an example, consider an interface ‘storage’ for writing objects to
disk and getting them back, and a class ‘foo’ that implements it.  The
code would look like this:

     interface
       selector write ( file object -- )
       selector read1 ( file object -- )
     end-interface storage

     bar class
       storage implementation

     ... overrides write
     ... overrides read1
     ...
     end-class foo

(I would add a word ‘read’ ( file – object ) that uses ‘read1’
internally, but that’s beyond the point illustrated here.)

   Note that you cannot use ‘protected’ in an interface; and of course
you cannot define fields.

   In the Neon model, all selectors are available for all classes;
therefore it does not need interfaces.  The price you pay in this model
is slower late binding, and therefore, added complexity to avoid late
binding.


File: gforth.info,  Node: Objects Implementation,  Next: Objects Glossary,  Prev: Object Interfaces,  Up: Objects

6.24.3.11 ‘objects.fs’ Implementation
.....................................

An object is a piece of memory, like one of the data structures
described with ‘struct...end-struct’.  It has a field ‘object-map’ that
points to the method map for the object’s class.

   The _method map_(1) is an array that contains the execution tokens
(xts) of the methods for the object’s class.  Each selector contains an
offset into a method map.

   ‘selector’ is a defining word that uses ‘CREATE’ and ‘DOES>’.  The
body of the selector contains the offset; the ‘DOES>’ action for a class
selector is, basically:

     ( object addr ) @ over object-map @ + @ execute

   Since ‘object-map’ is the first field of the object, it does not
generate any code.  As you can see, calling a selector has a small,
constant cost.

   A class is basically a ‘struct’ combined with a method map.  During
the class definition the alignment and size of the class are passed on
the stack, just as with ‘struct’s, so ‘field’ can also be used for
defining class fields.  However, passing more items on the stack would
be inconvenient, so ‘class’ builds a data structure in memory, which is
accessed through the variable ‘current-interface’.  After its definition
is complete, the class is represented on the stack by a pointer (e.g.,
as parameter for a child class definition).

   A new class starts off with the alignment and size of its parent, and
a copy of the parent’s method map.  Defining new fields extends the size
and alignment; likewise, defining new selectors extends the method map.
‘overrides’ just stores a new xt in the method map at the offset given
by the selector.

   Class binding just gets the xt at the offset given by the selector
from the class’s method map and ‘compile,’s (in the case of ‘[bind]’)
it.

   I implemented ‘this’ as a ‘value’.  At the start of an ‘m:...;m’
method the old ‘this’ is stored to the return stack and restored at the
end; and the object on the TOS is stored ‘TO this’.  This technique has
one disadvantage: If the user does not leave the method via ‘;m’, but
via ‘throw’ or ‘exit’, ‘this’ is not restored (and ‘exit’ may crash).
To deal with the ‘throw’ problem, I have redefined ‘catch’ to save and
restore ‘this’; the same should be done with any word that can catch an
exception.  As for ‘exit’, I simply forbid it (as a replacement, there
is ‘exitm’).

   ‘inst-var’ is just the same as ‘field’, with a different ‘DOES>’
action:
     @ this +
   Similar for ‘inst-value’.

   Each class also has a word list that contains the words defined with
‘inst-var’ and ‘inst-value’, and its protected words.  It also has a
pointer to its parent.  ‘class’ pushes the word lists of the class and
all its ancestors onto the search order stack, and ‘end-class’ drops
them.

   An interface is like a class without fields, parent and protected
words; i.e., it just has a method map.  If a class implements an
interface, its method map contains a pointer to the method map of the
interface.  The positive offsets in the map are reserved for class
methods, therefore interface map pointers have negative offsets.
Interfaces have offsets that are unique throughout the system, unlike
class selectors, whose offsets are only unique for the classes where the
selector is available (invokable).

   This structure means that interface selectors have to perform one
indirection more than class selectors to find their method.  Their body
contains the interface map pointer offset in the class method map, and
the method offset in the interface method map.  The ‘does>’ action for
an interface selector is, basically:

     ( object selector-body )
     2dup selector-interface @ ( object selector-body object interface-offset )
     swap object-map @ + @ ( object selector-body map )
     swap selector-offset @ + @ execute

   where ‘object-map’ and ‘selector-offset’ are first fields and
generate no code.

   As a concrete example, consider the following code:

     interface
       selector if1sel1
       selector if1sel2
     end-interface if1

     object class
       if1 implementation
       selector cl1sel1
       cell% inst-var cl1iv1

     ' m1 overrides construct
     ' m2 overrides if1sel1
     ' m3 overrides if1sel2
     ' m4 overrides cl1sel2
     end-class cl1

     create obj1 object dict-new drop
     create obj2 cl1    dict-new drop

   The data structure created by this code (including the data structure
for ‘object’) is shown in the figure (objects-implementation.eps),
assuming a cell size of 4.

   ---------- Footnotes ----------

   (1) This is Self terminology; in C++ terminology: virtual function
table.


File: gforth.info,  Node: Objects Glossary,  Prev: Objects Implementation,  Up: Objects

6.24.3.12 ‘objects.fs’ Glossary
...............................

‘bind’ ( ... "class" "selector" – ...  ) objects “bind”
   Execute the method for SELECTOR in CLASS.

‘<bind>’ ( class selector-xt – xt  ) objects “<bind>”
   XT is the method for the selector SELECTOR-XT in CLASS.

‘bind'’ ( "class" "selector" – xt  ) objects “bind”’
   XT is the method for SELECTOR in CLASS.

‘[bind]’ ( compile-time: "class" "selector" – ; run-time: ... object – ...  ) objects “[bind]”
   Compile the method for SELECTOR in CLASS.

‘class’ ( parent-class – align offset  ) objects “class”
   Start a new class definition as a child of PARENT-CLASS.  ALIGN
OFFSET are for use by FIELD etc.

‘class->map’ ( class – map  ) objects “class->map”
   MAP is the pointer to CLASS’s method map; it points to the place in
the map to which the selector offsets refer (i.e., where OBJECT-MAPs
point to).

‘class-inst-size’ ( class – addr  ) objects “class-inst-size”
   Give the size specification for an instance (i.e.  an object) of
CLASS; used as ‘class-inst-size 2 ( class -- align size )’.

‘class-override!’ ( xt sel-xt class-map –  ) objects “class-override!”
   XT is the new method for the selector SEL-XT in CLASS-MAP.

‘class-previous’ ( class –  ) objects “class-previous”
   Drop CLASS’s wordlists from the search order.  No checking is made
whether CLASS’s wordlists are actually on the search order.

‘class>order’ ( class –  ) objects “class>order”
   Add CLASS’s wordlists to the head of the search-order.

‘construct’ ( ... object –  ) objects “construct”
   Initialize the data fields of OBJECT.  The method for the class
OBJECT just does nothing: ‘( object -- )’.

‘current'’ ( "selector" – xt  ) objects “current”’
   XT is the method for SELECTOR in the current class.

‘[current]’ ( compile-time: "selector" – ; run-time: ... object – ...  ) objects “[current]”
   Compile the method for SELECTOR in the current class.

‘current-interface’ ( – addr  ) objects “current-interface”
   Variable: contains the class or interface currently being defined.

‘dict-new’ ( ... class – object  ) objects “dict-new”
   ‘allot’ and initialize an object of class CLASS in the dictionary.

‘end-class’ ( align offset "name" –  ) objects “end-class”
   NAME execution: ‘-- class’
End a class definition.  The resulting class is CLASS.

‘end-class-noname’ ( align offset – class  ) objects “end-class-noname”
   End a class definition.  The resulting class is CLASS.

‘end-interface’ ( "name" –  ) objects “end-interface”
   ‘name’ execution: ‘-- interface’
End an interface definition.  The resulting interface is INTERFACE.

‘end-interface-noname’ ( – interface  ) objects “end-interface-noname”
   End an interface definition.  The resulting interface is INTERFACE.

‘end-methods’ ( –  ) objects “end-methods”
   Switch back from defining methods of a class to normal mode
(currently this just restores the old search order).

‘exitm’ ( –  ) objects “exitm”
   ‘exit’ from a method; restore old ‘this’.

‘heap-new’ ( ... class – object  ) objects “heap-new”
   ‘allocate’ and initialize an object of class CLASS.

‘implementation’ ( interface –  ) objects “implementation”
   The current class implements INTERFACE.  I.e., you can use all
selectors of the interface in the current class and its descendents.

‘init-object’ ( ... class object –  ) objects “init-object”
   Initialize a chunk of memory (OBJECT) to an object of class CLASS;
then performs ‘construct’.

‘inst-value’ ( align1 offset1 "name" – align2 offset2  ) objects “inst-value”
   NAME execution: ‘-- w’
W is the value of the field NAME in ‘this’ object.

‘inst-var’ ( align1 offset1 align size "name" – align2 offset2  ) objects “inst-var”
   NAME execution: ‘-- addr’
ADDR is the address of the field NAME in ‘this’ object.

‘interface’ ( –  ) objects “interface”
   Start an interface definition.

‘m:’ ( – xt colon-sys; run-time: object –  ) objects “m:”
   Start a method definition; OBJECT becomes new ‘this’.

‘:m’ ( "name" – xt; run-time: object –  ) objects “:m”
   Start a named method definition; OBJECT becomes new ‘this’.  Has to
be ended with ‘;m’.

‘;m’ ( colon-sys –; run-time: –  ) objects “;m”
   End a method definition; restore old ‘this’.

‘method’ ( xt "name" –  ) objects “method”
   ‘name’ execution: ‘... object -- ...’
Create selector NAME and makes XT its method in the current class.

‘methods’ ( class –  ) objects “methods”
   Makes CLASS the current class.  This is intended to be used for
defining methods to override selectors; you cannot define new fields or
selectors.

‘object’ ( – class  ) objects “object”
   the ancestor of all classes.

‘overrides’ ( xt "selector" –  ) objects “overrides”
   replace default method for SELECTOR in the current class with XT.
‘overrides’ must not be used during an interface definition.

‘[parent]’ ( compile-time: "selector" – ; run-time: ... object – ...  ) objects “[parent]”
   Compile the method for SELECTOR in the parent of the current class.

‘print’ ( object –  ) objects “print”
   Print the object.  The method for the class OBJECT prints the address
of the object and the address of its class.

‘protected’ ( –  ) objects “protected”
   Set the compilation wordlist to the current class’s wordlist

‘public’ ( –  ) objects “public”
   Restore the compilation wordlist that was in effect before the last
‘protected’ that actually changed the compilation wordlist.

‘selector’ ( "name" –  ) objects “selector”
   NAME execution: ‘... object -- ...’
Create selector NAME for the current class and its descendents; you can
set a method for the selector in the current class with ‘overrides’.

‘this’ ( – object  ) objects “this”
   the receiving object of the current method (aka active object).

‘<to-inst>’ ( w xt –  ) objects “<to-inst>”
   store W into the field XT in ‘this’ object.

‘[to-inst]’ ( compile-time: "name" – ; run-time: w –  ) objects “[to-inst]”
   store W into field NAME in ‘this’ object.

‘to-this’ ( object –  ) objects “to-this”
   Set ‘this’ (used internally, but useful when debugging).

‘xt-new’ ( ... class xt – object  ) objects “xt-new”
   Make a new object, using ‘xt ( align size -- addr )’ to get memory.


File: gforth.info,  Node: OOF,  Next: Mini-OOF,  Prev: Objects,  Up: Object-oriented Forth

6.24.4 The ‘oof.fs’ model
-------------------------

This section describes the ‘oof.fs’ package.

   The package described in this section has been used in bigFORTH since
1991, and used for two large applications: a chromatographic system used
to create new medicaments, and a graphic user interface library (MINOS).

   You can find a description (in German) of ‘oof.fs’ in ‘Object
oriented bigFORTH’ by Bernd Paysan, published in ‘Vierte Dimension’
10(2), 1994.

* Menu:

* Properties of the OOF model::
* Basic OOF Usage::
* The OOF base class::
* Class Declaration::
* Class Implementation::


File: gforth.info,  Node: Properties of the OOF model,  Next: Basic OOF Usage,  Prev: OOF,  Up: OOF

6.24.4.1 Properties of the ‘oof.fs’ model
.........................................

   • This model combines object oriented programming with information
     hiding.  It helps you writing large application, where scoping is
     necessary, because it provides class-oriented scoping.

   • Named objects, object pointers, and object arrays can be created,
     selector invocation uses the “object selector” syntax.  Selector
     invocation to objects and/or selectors on the stack is a bit less
     convenient, but possible.

   • Selector invocation and instance variable usage of the active
     object is straightforward, since both make use of the active
     object.

   • Late binding is efficient and easy to use.

   • State-smart objects parse selectors.  However, extensibility is
     provided using a (parsing) selector ‘postpone’ and a selector ‘'’.

   • An implementation in Standard Forth is available.


File: gforth.info,  Node: Basic OOF Usage,  Next: The OOF base class,  Prev: Properties of the OOF model,  Up: OOF

6.24.4.2 Basic ‘oof.fs’ Usage
.............................

This section uses the same example as for ‘objects’ (*note Basic Objects
Usage::).

   You can define a class for graphical objects like this:

     object class graphical \ "object" is the parent class
       method draw ( x y -- )
     class;

   This code defines a class ‘graphical’ with an operation ‘draw’.  We
can perform the operation ‘draw’ on any ‘graphical’ object, e.g.:

     100 100 t-rex draw

where ‘t-rex’ is an object or object pointer, created with e.g.
‘graphical : t-rex’.

   How do we create a graphical object?  With the present definitions,
we cannot create a useful graphical object.  The class ‘graphical’
describes graphical objects in general, but not any concrete graphical
object type (C++ users would call it an _abstract class_); e.g., there
is no method for the selector ‘draw’ in the class ‘graphical’.

   For concrete graphical objects, we define child classes of the class
‘graphical’, e.g.:

     graphical class circle \ "graphical" is the parent class
       cell var circle-radius
     how:
       : draw ( x y -- )
         circle-radius @ draw-circle ;

       : init ( n-radius -- )
         circle-radius ! ;
     class;

   Here we define a class ‘circle’ as a child of ‘graphical’, with a
field ‘circle-radius’; it defines new methods for the selectors ‘draw’
and ‘init’ (‘init’ is defined in ‘object’, the parent class of
‘graphical’).

   Now we can create a circle in the dictionary with:

     50 circle : my-circle

‘:’ invokes ‘init’, thus initializing the field ‘circle-radius’ with 50.
We can draw this new circle at (100,100) with:

     100 100 my-circle draw

   Note: You can only invoke a selector if the receiving object belongs
to the class where the selector was defined or one of its descendents;
e.g., you can invoke ‘draw’ only for objects belonging to ‘graphical’ or
its descendents (e.g., ‘circle’).  The scoping mechanism will check if
you try to invoke a selector that is not defined in this class
hierarchy, so you’ll get an error at compilation time.


File: gforth.info,  Node: The OOF base class,  Next: Class Declaration,  Prev: Basic OOF Usage,  Up: OOF

6.24.4.3 The ‘oof.fs’ base class
................................

When you define a class, you have to specify a parent class.  So how do
you start defining classes?  There is one class available from the
start: ‘object’.  You have to use it as ancestor for all classes.  It is
the only class that has no parent.  Classes are also objects, except
that they don’t have instance variables; class manipulation such as
inheritance or changing definitions of a class is handled through
selectors of the class ‘object’.

   ‘object’ provides a number of selectors:

   • ‘class’ for subclassing, ‘definitions’ to add definitions later on,
     and ‘class?’ to get type informations (is the class a subclass of
     the class passed on the stack?).

     ‘object-class’ ( "name" –  ) oof “object-class”

     ‘object-definitions’ ( –  ) oof “object-definitions”

     ‘object-class?’ ( o – flag  ) oof “class-query”

   • ‘init’ and ‘dispose’ as constructor and destructor of the object.
     ‘init’ is invocated after the object’s memory is allocated, while
     ‘dispose’ also handles deallocation.  Thus if you redefine
     ‘dispose’, you have to call the parent’s dispose with ‘super
     dispose’, too.

     ‘object-init’ ( ... –  ) oof “object-init”

     ‘object-dispose’ ( –  ) oof “object-dispose”

   • ‘new’, ‘new[]’, ‘:’, ‘ptr’, ‘asptr’, and ‘[]’ to create named and
     unnamed objects and object arrays or object pointers.

     ‘object-new’ ( – o  ) oof “object-new”

     ‘object-new[]’ ( n – o  ) oof “new-array”

     ‘object-:’ ( "name" –  ) oof “define”

     ‘object-ptr’ ( "name" –  ) oof “object-ptr”

     ‘object-asptr’ ( o "name" –  ) oof “object-asptr”

     ‘object-[]’ ( n "name" –  ) oof “array”

   • ‘::’ and ‘super’ for explicit scoping.  You should use explicit
     scoping only for super classes or classes with the same set of
     instance variables.  Explicitly-scoped selectors use early binding.

     ‘object-::’ ( "name" –  ) oof “scope”

     ‘object-super’ ( "name" –  ) oof “object-super”

   • ‘self’ to get the address of the object

     ‘object-self’ ( – o  ) oof “object-self”

   • ‘bind’, ‘bound’, ‘link’, and ‘is’ to assign object pointers and
     instance defers.

     ‘object-bind’ ( o "name" –  ) oof “object-bind”

     ‘object-bound’ ( class addr "name" –  ) oof “object-bound”

     ‘object-link’ ( "name" – class addr  ) oof “object-link”

     ‘object-is’ ( xt "name" –  ) oof “object-is”

   • ‘'’ to obtain selector tokens, ‘send’ to invocate selectors form
     the stack, and ‘postpone’ to generate selector invocation code.

     ‘object-'’ ( "name" – xt  ) oof “tick”

     ‘object-postpone’ ( "name" –  ) oof “object-postpone”

   • ‘with’ and ‘endwith’ to select the active object from the stack,
     and enable its scope.  Using ‘with’ and ‘endwith’ also allows you
     to create code using selector ‘postpone’ without being trapped by
     the state-smart objects.

     ‘object-with’ ( o –  ) oof “object-with”

     ‘object-endwith’ ( –  ) oof “object-endwith”


File: gforth.info,  Node: Class Declaration,  Next: Class Implementation,  Prev: The OOF base class,  Up: OOF

6.24.4.4 Class Declaration
..........................

   • Instance variables

     ‘var’ ( size –  ) oof “var”
     Create an instance variable

   • Object pointers

     ‘ptr’ ( –  ) oof “ptr”
     Create an instance pointer

     ‘asptr’ ( class –  ) oof “asptr”
     Create an alias to an instance pointer, cast to another class.

   • Instance defers

     ‘defer’ ( –  ) oof “defer”
     Create an instance defer

   • Method selectors

     ‘early’ ( –  ) oof “early”
     Create a method selector for early binding.

     ‘method’ ( –  ) oof “method”
     Create a method selector.

   • Class-wide variables

     ‘static’ ( –  ) oof “static”
     Create a class-wide cell-sized variable.

   • End declaration

     ‘how:’ ( –  ) oof “how-to”
     End declaration, start implementation

     ‘class;’ ( –  ) oof “end-class”
     End class declaration or implementation


File: gforth.info,  Node: Class Implementation,  Prev: Class Declaration,  Up: OOF

6.24.4.5 Class Implementation
.............................


File: gforth.info,  Node: Mini-OOF,  Next: Mini-OOF2,  Prev: OOF,  Up: Object-oriented Forth

6.24.5 The ‘mini-oof.fs’ model
------------------------------

Gforth’s third object oriented Forth package is a 12-liner.  It uses a
mixture of the ‘objects.fs’ and the ‘oof.fs’ syntax, and reduces to the
bare minimum of features.  This is based on a posting of Bernd Paysan in
comp.lang.forth.

* Menu:

* Basic Mini-OOF Usage::
* Mini-OOF Example::
* Mini-OOF Implementation::


File: gforth.info,  Node: Basic Mini-OOF Usage,  Next: Mini-OOF Example,  Prev: Mini-OOF,  Up: Mini-OOF

6.24.5.1 Basic ‘mini-oof.fs’ Usage
..................................

There is a base class (‘class’, which allocates one cell for the object
pointer) plus seven other words: to define a method, a variable, a
class; to end a class, to resolve binding, to allocate an object and to
compile a class method.

‘object’ ( – a-addr  ) mini-oof “object”
   OBJECT is the base class of all objects.

‘method’ ( m v "name" – m’ v  ) mini-oof “method”
   Define a selector.

‘var’ ( m v size "name" – m v’  ) mini-oof “var”
   Define a variable with SIZE bytes.

‘class’ ( class – class selectors vars  ) mini-oof “class”
   Start the definition of a class.

‘end-class’ ( class selectors vars "name" –  ) mini-oof “end-class”
   End the definition of a class.

‘defines’ ( xt class "name" –  ) mini-oof “defines”
   Bind XT to the selector NAME in class CLASS.

‘new’ ( class – o  ) mini-oof “new”
   Create a new incarnation of the class CLASS.

‘::’ ( class "name" –  ) mini-oof “colon-colon”
   Compile the method for the selector NAME of the class CLASS (not
immediate!).


File: gforth.info,  Node: Mini-OOF Example,  Next: Mini-OOF Implementation,  Prev: Basic Mini-OOF Usage,  Up: Mini-OOF

6.24.5.2 Mini-OOF Example
.........................

A short example shows how to use this package.  This example, in
slightly extended form, is supplied as ‘moof-exm.fs’

     object class
       method init
       method draw
     end-class graphical

   This code defines a class ‘graphical’ with an operation ‘draw’.  We
can perform the operation ‘draw’ on any ‘graphical’ object, e.g.:

     100 100 t-rex draw

   where ‘t-rex’ is an object or object pointer, created with e.g.
‘graphical new Constant t-rex’.

   For concrete graphical objects, we define child classes of the class
‘graphical’, e.g.:

     graphical class
       cell var circle-radius
     end-class circle \ "graphical" is the parent class

     :noname ( x y -- )
       circle-radius @ draw-circle ; circle defines draw
     :noname ( r -- )
       circle-radius ! ; circle defines init

   There is no implicit init method, so we have to define one.  The
creation code of the object now has to call init explicitely.

     circle new Constant my-circle
     50 my-circle init

   It is also possible to add a function to create named objects with
automatic call of ‘init’, given that all objects have ‘init’ on the same
place:

     : new: ( .. o "name" -- )
         new dup Constant init ;
     80 circle new: large-circle

   We can draw this new circle at (100,100) with:

     100 100 my-circle draw


File: gforth.info,  Node: Mini-OOF Implementation,  Prev: Mini-OOF Example,  Up: Mini-OOF

6.24.5.3 ‘mini-oof.fs’ Implementation
.....................................

Object-oriented systems with late binding typically use a
“vtable”-approach: the first variable in each object is a pointer to a
table, which contains the methods as function pointers.  The vtable may
also contain other information.

   So first, let’s declare selectors:

     : method ( m v "name" -- m' v ) Create  over , swap cell+ swap
       DOES> ( ... o -- ... ) @ over @ + @ execute ;

   During selector declaration, the number of selectors and instance
variables is on the stack (in address units).  ‘method’ creates one
selector and increments the selector number.  To execute a selector, it
takes the object, fetches the vtable pointer, adds the offset, and
executes the method xt stored there.  Each selector takes the object it
is invoked with as top of stack parameter; it passes the parameters
(including the object) unchanged to the appropriate method which should
consume that object.

   Now, we also have to declare instance variables

     : var ( m v size "name" -- m v' ) Create  over , +
       DOES> ( o -- addr ) @ + ;

   As before, a word is created with the current offset.  Instance
variables can have different sizes (cells, floats, doubles, chars), so
all we do is take the size and add it to the offset.  If your machine
has alignment restrictions, put the proper ‘aligned’ or ‘faligned’
before the variable, to adjust the variable offset.  That’s why it is on
the top of stack.

   We need a starting point (the base object) and some syntactic sugar:

     Create object  1 cells , 2 cells ,
     : class ( class -- class selectors vars ) dup 2@ ;

   For inheritance, the vtable of the parent object has to be copied
when a new, derived class is declared.  This gives all the methods of
the parent class, which can be overridden, though.

     : end-class  ( class selectors vars "name" -- )
       Create  here >r , dup , 2 cells ?DO ['] noop , 1 cells +LOOP
       cell+ dup cell+ r> rot @ 2 cells /string move ;

   The first line creates the vtable, initialized with ‘noop’s.  The
second line is the inheritance mechanism, it copies the xts from the
parent vtable.

   We still have no way to define new methods, let’s do that now:

     : defines ( xt class "name" -- ) ' >body @ + ! ;

   To allocate a new object, we need a word, too:

     : new ( class -- o )  here over @ allot swap over ! ;

   Sometimes derived classes want to access the method of the parent
object.  There are two ways to achieve this with Mini-OOF: first, you
could use named words, and second, you could look up the vtable of the
parent object.

     : :: ( class "name" -- ) ' >body @ + @ compile, ;

   Nothing can be more confusing than a good example, so here is one.
First let’s declare a text object (called ‘button’), that stores text
and position:

     object class
       cell var text
       cell var len
       cell var x
       cell var y
       method init
       method draw
     end-class button

Now, implement the two methods, ‘draw’ and ‘init’:

     :noname ( o -- )
      >r r@ x @ r@ y @ at-xy  r@ text @ r> len @ type ;
      button defines draw
     :noname ( addr u o -- )
      >r 0 r@ x ! 0 r@ y ! r@ len ! r> text ! ;
      button defines init

To demonstrate inheritance, we define a class ‘bold-button’, with no new
data and no new selectors:

     button class
     end-class bold-button

     : bold   27 emit ." [1m" ;
     : normal 27 emit ." [0m" ;

The class ‘bold-button’ has a different draw method to ‘button’, but the
new method is defined in terms of the draw method for ‘button’:

     :noname bold [ button :: draw ] normal ; bold-button defines draw

Finally, create two objects and apply selectors:

     button new Constant foo
     s" thin foo" foo init
     page
     foo draw
     bold-button new Constant bar
     s" fat bar" bar init
     1 bar y !
     bar draw


File: gforth.info,  Node: Mini-OOF2,  Next: Comparison with other object models,  Prev: Mini-OOF,  Up: Object-oriented Forth

6.24.6 Mini-OOF2
----------------

Mini-OOF2 is very similar to Mini-OOF in many respects, but differs
significantly in a few aspects.  In particular, Mini-OOF2 has a current
object variable, and uses the primitives ‘>o’ and ‘o>’ to manipulate
that object stack.  All method invocations and instance variable
accesses refer to the current object.

‘>o’ ( c-addr – r:c-old ) new “to-o”
   Set the current object to C_ADDR, the previous current object is
pushed to the return stack

‘o>’ ( r:c-addr – ) new “o-restore”
   Restore the previous current object from the return stack

   To ease passing an object pointer to method invocation or instance
variable accesses, the additional recognizer ‘rec-moof2’ is activated.

‘rec-moof2’ ( addr u – xt translate-moof2 | notfound  ) mini-oof2 “rec-moof2”
   Very simplistic dot-parser, transforms ‘.’SELECTOR/IVAR to ‘>o’
SELECTOR/IVAR ‘o>’.

   To assign methods to selectors, use XT CLASS ‘is’ SELECTOR, so no
‘defines’ necessary.  For early binding of methods, ‘[’ CLASS ‘] defers’
SELECTOR is used, no need for ‘::’.


File: gforth.info,  Node: Comparison with other object models,  Prev: Mini-OOF2,  Up: Object-oriented Forth

6.24.7 Comparison with other object models
------------------------------------------

Many object-oriented Forth extensions have been proposed (‘A survey of
object-oriented Forths’ (SIGPLAN Notices, April 1996) by Bradford J.
Rodriguez and W. F. S. Poehlman lists 17).  This section discusses the
relation of the object models described here to two well-known and two
closely-related (by the use of method maps) models.  Andras Zsoter
helped us with this section.

   The most popular model currently seems to be the Neon model (see
‘Object-oriented programming in ANS Forth’ (Forth Dimensions, March
1997) by Andrew McKewan) but this model has a number of limitations (1):

   • It uses a ‘_selector object_’ syntax, which makes it unnatural to
     pass objects on the stack.

   • It requires that the selector parses the input stream (at compile
     time); this leads to reduced extensibility and to bugs that are
     hard to find.

   • It allows using every selector on every object; this eliminates the
     need for interfaces, but makes it harder to create efficient
     implementations.

   Another well-known publication is ‘Object-Oriented Forth’ (Academic
Press, London, 1987) by Dick Pountain.  However, it is not really about
object-oriented programming, because it hardly deals with late binding.
Instead, it focuses on features like information hiding and overloading
that are characteristic of modular languages like Ada (83).

   In Does late binding have to be slow?
(http://www.forth.org/oopf.html) (Forth Dimensions 18(1) 1996, pages
31-35) Andras Zsoter describes a model that makes heavy use of an active
object (like ‘this’ in ‘objects.fs’): The active object is not only used
for accessing all fields, but also specifies the receiving object of
every selector invocation; you have to change the active object
explicitly with ‘{ ... }’, whereas in ‘objects.fs’ it changes more or
less implicitly at ‘m: ... ;m’.  Such a change at the method entry point
is unnecessary with Zsoter’s model, because the receiving object is the
active object already.  On the other hand, the explicit change is
absolutely necessary in that model, because otherwise no one could ever
change the active object.  An Standard Forth implementation of this
model is available through <http://www.forth.org/oopf.html>.

   The ‘oof.fs’ model combines information hiding and overloading
resolution (by keeping names in various word lists) with object-oriented
programming.  It sets the active object implicitly on method entry, but
also allows explicit changing (with ‘>o...o>’ or with ‘with...endwith’).
It uses parsing and state-smart objects and classes for resolving
overloading and for early binding: the object or class parses the
selector and determines the method from this.  If the selector is not
parsed by an object or class, it performs a call to the selector for the
active object (late binding), like Zsoter’s model.  Fields are always
accessed through the active object.  The big disadvantage of this model
is the parsing and the state-smartness, which reduces extensibility and
increases the opportunities for subtle bugs; essentially, you are only
safe if you never tick or ‘postpone’ an object or class (Bernd
disagrees, but I (Anton) am not convinced).

   The ‘mini-oof.fs’ model is quite similar to a very stripped-down
version of the ‘objects.fs’ model, but syntactically it is a mixture of
the ‘objects.fs’ and ‘oof.fs’ models.

   ---------- Footnotes ----------

   (1) A longer version of this critique can be found in ‘On
Standardizing Object-Oriented Forth Extensions’ (Forth Dimensions, May
1997) by Anton Ertl.


File: gforth.info,  Node: Regular Expressions,  Next: Programming Tools,  Prev: Object-oriented Forth,  Up: Words

6.25 Regular Expressions
========================

Regular expressions are pattern matching algorithms for strings found in
many contemporary languages.  You can add regular expression
functionality to Gforth with ‘require regexp.fs’.

   The classical implementation for this pattern matching is a
backtracking algorithm, which is also necessary if you want to have
features like backreferencing.  Gforth implements regular expressions by
providing a language to define backtracking programs for pattern
matching.  Basic element is the control structure ‘FORK’ ... ‘JOIN’,
which is a forward call within a word, and therefore allows to code a
lightweight try and fail control structure.

‘FORK’ ( compilation – orig ; run-time f –  ) gforth-0.7 “FORK”
   AHEAD-like control structure: calls the code after JOIN.

‘JOIN’ ( orig –  ) gforth-0.7 “JOIN”
   THEN-like control structure for FORK

   You can program any sort of arbitrary checks yourself by computing a
flag and ‘?LEAVE’ when the check fails.  Your regular expression code is
enclosed in ‘((’ and ‘))’.

‘((’ ( addr u –  ) regexp-pattern “((”
   start regexp block

‘))’ ( – flag  ) regexp-pattern “))”
   end regexp block

   Pattern matching in regular expressions have character sets as
elements, so a number of functions allow you to create and modify
character sets (called ‘charclass’).  All characters here are bytes, so
this doesn’t extend to unicode characters.

‘charclass’ ( –  ) regexp-cg “charclass”
   Create a charclass

‘+char’ ( char –  ) regexp-cg “+char”
   add a char to the current charclass

‘-char’ ( char –  ) regexp-cg “-char”
   remove a char from the current charclass

‘..char’ ( start end –  ) regexp-cg “..char”
   add a range of chars to the current charclass

‘+chars’ ( addr u –  ) regexp-cg “+chars”
   add a string of chars to the current charclass

‘+class’ ( class –  ) regexp-cg “+class”
   union of charclass CLASS and the current charclass

‘-class’ ( class –  ) regexp-cg “-class”
   subtract the charclass CLASS from the current charclass

   There are predefined charclasses and tests for them, and generic
checks.  If a check fails, the next possible alternative of the regular
expression is tried, or a loop is terminated.

‘c?’ ( addr class –  ) regexp-pattern “c?”
   check ADDR for membership in charclass CLASS

‘-c?’ ( addr class –  ) regexp-pattern “-c?”
   check ADDR for not membership in charclass CLASS

‘\d’ ( addr – addr’  ) regexp-pattern “\d”
   check for digit

‘\s’ ( addr – addr’  ) regexp-pattern “\s”
   check for blanks

‘.?’ ( addr – addr’  ) regexp-pattern “.?”
   check for any single charachter

‘-\d’ ( addr – addr’  ) regexp-pattern “-\d”
   check for not digit

‘-\s’ ( addr – addr’  ) regexp-pattern “-\s”
   check for not blank

‘`’ ( "char" –  ) regexp-pattern “‘”
   check for particular char

‘`?’ ( "char" –  ) regexp-pattern “‘?”

‘-`’ ( "char" –  ) regexp-pattern “-‘”
   check for particular char

   You can certainly also check for start and end of the string, and for
whole string constants.

‘\^’ ( addr – addr  ) regexp-pattern “\^”
   check for string start

‘\$’ ( addr – addr  ) regexp-pattern “\$”
   check for string end

‘str=?’ ( addr1 addr u – addr2  ) regexp-pattern “str=?”
   check for a computed string on the stack (possibly a backreference)

   doc-=”

   Loops that check for repeated character sets can be greedy or
non-greedy.

‘{**’ ( addr – addr addr  ) regexp-pattern “begin-greedy-star”
   greedy zero-or-more pattern

‘**}’ ( sys –  ) regexp-pattern “end-greedy-star”
   end of greedy zero-or-more pattern

‘{++’ ( addr – addr addr  ) regexp-pattern “begin-greedy-plus”
   greedy one-or-more pattern

‘++}’ ( sys –  ) regexp-pattern “end-greedy-plus”
   end of greedy one-or-more pattern

‘{*’ ( addr – addr addr  ) regexp-pattern “begin-non-greedy-star”
   non-greedy zero-or-more pattern

‘*}’ ( addr addr’ – addr’  ) regexp-pattern “end-non-greedy-star”
   end of non-greedy zero-or-more pattern

‘{+’ ( addr – addr addr  ) regexp-pattern “begin-non-greedy-plus”
   non-greedy one-or-more pattern

‘+}’ ( addr addr’ – addr’  ) regexp-pattern “end-non-greedy-plus”
   end of non-greedy one-or-more pattern

   Example: Searching for a substring really is a non-greedy match of
anything in front of it.

‘//’ ( –  ) regexp-pattern “//”
   search for string

   Alternatives are written with

‘{{’ ( addr – addr addr  ) regexp-pattern “begin-alternatives”
   Start of alternatives

‘||’ ( addr addr – addr addr  ) regexp-pattern “next-alternative”
   separator between alternatives

‘}}’ ( addr addr – addr  ) regexp-pattern “end-alternatives”
   end of alternatives

   You can use up to 9 variables named ‘\1’ to ‘\9’ to refer to matched
substrings

‘\(’ ( addr – addr  ) regexp-pattern “\(”
   start of matching variable; variables are referred as \\1–9

‘\)’ ( addr – addr  ) regexp-pattern “\)”
   end of matching variable

‘\0’ ( – addr u  ) regexp-pattern “\0”
   the whole string

   Certainly, you can also write code to replace patterns you found.

‘s>>’ ( addr – addr  ) regexp-replace “s>>”
   Start replace pattern region

‘>>’ ( addr – addr  ) regexp-replace “>>”
   Start arbitrary replacement code, the code shall compute a string on
the stack and pass it to ‘<<’

‘<<’ ( run-addr addr u – run-addr  ) regexp-replace “<<”
   Replace string from start of replace pattern region with ADDR U

‘<<"’ ( "string<">" –  ) regexp-replace “<<"”
   Replace string from start of replace pattern region with STRING

‘s//’ ( addr u – ptr  ) regexp-replace “s//”
   start search/replace loop

‘//s’ ( ptr –  ) regexp-replace “//s”
   search end

‘//o’ ( ptr addr u – addr’ u’  ) regexp-replace “//o”
   end search/replace single loop

‘//g’ ( ptr addr u – addr’ u’  ) regexp-replace “//g”
   end search/replace all loop

   Examples can be found in ‘test/regexp-test.fs’.


File: gforth.info,  Node: Programming Tools,  Next: Multitasker,  Prev: Regular Expressions,  Up: Words

6.26 Programming Tools
======================

* Menu:

* Locating source code definitions::  and editing
* Locating uses of a word::  ‘where’.
* Locating exception source::  バックトレースの検証(examing)
* Examining compiled code::  ‘see’ and friends.
* Examining data::           スタック と メモリ
* Forgetting words::         通常、再ロード前に使われます
* Debugging::                トレーサー ‘~~’
                               を適宜挿入することによって
* Assertions::               あなたのプログラムを自己チェックさせます
* Singlestep Debugger::      あなたのプログラムをワート単位で実行します
* Code Coverage::            実行頻度を測定します


File: gforth.info,  Node: Locating source code definitions,  Next: Locating uses of a word,  Prev: Programming Tools,  Up: Programming Tools

6.26.1 Locating source code definitions
---------------------------------------

Many programming systems are organized as an integrated development
environment (IDE) where the editor is the hub of the system, and allows
building and running programs.  If you want that, Gforth has it, too
(*note Emacs and Gforth::).

   However, several Forth systems have a different kind of IDE: The
Forth command line is the hub of the environment; you can view the
source from there in various ways, and call an editor if needed.

   Gforth also implements such an IDE. It mostly follows the conventions
of SwiftForth where they exist, but implements features beyond them.

   An advantage of this approach is that it allows you to use your
favourite editor: set the environment variable ‘EDITOR’ to your
favourite editor, and the editing commands will call that editor; Gforth
invokes some GUI editors in the background (so you do not need to finish
editing to continue with your Forth session), terminal editors in the
foreground (default for editors not known to Gforth is foreground).  If
you have not set ‘EDITOR’, the default editor is ‘vi’.

‘locate’ ( "name" –  ) gforth-1.0 “locate”
   Show the source code of the word name and set the current location
there.

   doc-xt-locate

   The _current location_ is set by a number of other words in addition
to ‘locate’.  Also, when an error happens while loading a file, the
location of the error becomes the current location.

   A number of words work with the current location:

‘l’ ( –  ) gforth-1.0 “l”
   Display source code lines at the current location.

‘n’ ( –  ) gforth-1.0 “n”
   Display lines behind the current location, or behind the last ‘n’ or
‘b’ output (whichever was later).

‘b’ ( –  ) gforth-1.0 “b”
   Display lines before the current location, or before the last ‘n’ or
‘b’ output (whichever was later).

‘g’ ( –  ) gforth-0.7 “g”
   Enter the editor at the current location, or at the start of the last
‘n’ or ‘b’ output (whichever was later).

   You can control how many lines ‘l’, ‘n’ and ‘b’ show by changing the
values:

‘before-locate’ ( – u  ) gforth-1.0 “before-locate”
   number of lines shown before current location (default 3).

‘after-locate’ ( – u  ) gforth-1.0 “after-locate”
   number of lines shown after current location (default 12).

   Finally, you can directly go to the source code of a word in the
editor with

‘edit’ ( "name" –  ) gforth-1.0 “edit”
   Enter the editor at the location of "name"

   You can see the definitions of similarly-named words with

‘browse’ ( "subname" –  ) gforth-1.0 “browse”
   Show all places where a word with a name that contains subname is
defined (‘mwords’-like, *note Word Lists::).  You can then use ‘ww’,
‘nw’ or ‘bw’ (*note Locating uses of a word::) to inspect specific
occurences more closely.


File: gforth.info,  Node: Locating uses of a word,  Next: Locating exception source,  Prev: Locating source code definitions,  Up: Programming Tools

6.26.2 Locating uses of a word
------------------------------

‘where’ ( "name" –  ) gforth-1.0 “where”
   Show all places where name is used (text-interpreted).  You can then
use ‘ww’, ‘nw’ or ‘bw’ to inspect specific occurences more closely.
Gforth’s ‘where’ does not show the definition of name; use ‘locate’ for
that.

‘ww’ ( u –  ) gforth-1.0 “ww”
   The next ‘l’ or ‘g’ shows the ‘where’ result with index u

‘nw’ ( –  ) gforth-1.0 “nw”
   The next ‘l’ or ‘g’ shows the next ‘where’ result; if the current one
is the last one, after ‘nw’ there is no current one.  If there is no
current one, after ‘nw’ the first one is the current one.

‘bw’ ( –  ) gforth-1.0 “bw”
   The next ‘l’ or ‘g’ shows the previous ‘where’ result; if the current
one is the first one, after ‘bw’ there is no current one.  If there is
no current one, after ‘bw’ the last one is the current one.

‘gg’ ( –  ) gforth-1.0 “gg”
   The next ‘ww’, ‘nw’, ‘bw’, ‘bb’, ‘nb’, ‘lb’ (but not ‘locate’,
‘edit’, ‘l’ or ‘g’) puts it result in the editor (like ‘g’).  Use ‘gg
gg’ to make this permanent rather than one-shot.

‘ll’ ( –  ) gforth-1.0 “ll”
   The next ‘ww’, ‘nw’, ‘bw’, ‘bb’, ‘nb’, ‘lb’ (but not ‘locate’,
‘edit’, ‘l’ or ‘g’) displays in the Forth system (like ‘l’).  Use ‘ll
ll’ to make this permanent rather than one-shot.

‘whereg’ ( "name" –  ) gforth-1.0 “whereg”
   Like ‘where’, but puts the output in the editor.  In Emacs, you can
then use the compilation-mode commands (*note (emacs)Compilation Mode::)
to inspect specific occurences more closely.

‘short-where’ ( –  ) gforth-1.0 “short-where”
   Set up ‘where’ to use a short file format (default).

‘expand-where’ ( –  ) gforth-1.0 “expand-where”
   Set up ‘where’ to use a fully expanded file format (to pass to e.g.
editors).

‘prepend-where’ ( –  ) gforth-1.0 “prepend-where”
   Set up ‘where’ to show the file on a separate line, followed by
‘where’ lines without file names (like SwiftForth).

   The data we have on word usage also allows us to show which words
have no uses:

‘unused-words’ ( –  ) gforth-1.0 “unused-words”
   list all words without usage


File: gforth.info,  Node: Locating exception source,  Next: Examining compiled code,  Prev: Locating uses of a word,  Up: Programming Tools

6.26.3 Locating exception source
--------------------------------

‘tt’ ( u –  ) gforth-1.0 “tt”

‘nt’ (  –  ) gforth-1.0 “nt”

‘bt’ ( –  ) gforth-1.0 “bt”


File: gforth.info,  Node: Examining compiled code,  Next: Examining data,  Prev: Locating exception source,  Up: Programming Tools

6.26.4 Examining compiled code
------------------------------

And finally, ‘see’ and friends show compiled code.  Some of the things
in the source code are not present in the compiled code (e.g.,
formatting and comments), but this is useful to see what threaded code
or native code is produced by macros and Gforth’s optimization features.

‘see’ ( "<spaces>name" –  ) tools “see”
   Locate NAME using the current search order.  Display the definition
of NAME.  Since this is achieved by decompiling the definition, the
formatting is mechanised and some source information (comments,
interpreted sequences within definitions etc.)  is lost.

‘xt-see’ ( xt –  ) gforth-0.2 “xt-see”
   Decompile the definition represented by xt.

‘simple-see’ ( "name" –  ) gforth-0.6 “simple-see”
   Decompile the colon definition name, showing a line for each cell,
and try to guess a meaning for the cell, and show that.

‘xt-simple-see’ ( xt –  ) gforth-1.0 “xt-simple-see”
   Decompile the colon definition xt like ‘simple-see’

‘simple-see-range’ ( addr1 addr2 –  ) gforth-0.6 “simple-see-range”
   Decompile code in [addr1,addr2) like ‘simple-see’

‘see-code’ ( "name" –  ) gforth-0.7 “see-code”
   Like ‘simple-see’, but also shows the dynamic native code for the
inlined primitives.  For static superinstructions, it shows the
primitive sequence instead of the first primitive (the other primitives
of the superinstruction are shown, too).  For primitives for which
native code is generated, it shows the number of stack items in
registers at the beginning and at the end (e.g., ‘1->1’ means 1 stack
item is in a register at the start and at the end).  For each primitive
or superinstruction with native code, the inline arguments and component
primitives are shown first, then the native code.

‘xt-see-code’ ( xt –  ) gforth-1.0 “xt-see-code”
   Decompile the colon definition xt like ‘see-code’.

‘see-code-range’ ( addr1 addr2 –  ) gforth-0.7 “see-code-range”
   Decompile code in [addr1,addr2) like ‘see-code’.

   As an example, consider:

     : foo x f@ fsin drop over ;

   This is not particularly useful, but it demonstrates the various code
generation differences.  Compiling this on ‘gforth-fast’ on AMD64 and
then using ‘see-code foo’ outputs:

     $7FD0CEE8C510 lit f@     1->1
     $7FD0CEE8C518 x
     $7FD0CEE8C520 f@
     7FD0CEB51697:   movsd   [r12],xmm15
     7FD0CEB5169D:   mov     rax,$00[r13]
     7FD0CEB516A1:   sub     r12,$08
     7FD0CEB516A5:   add     r13,$18
     7FD0CEB516A9:   movsd   xmm15,[rax]
     7FD0CEB516AE:   mov     rcx,-$08[r13]
     7FD0CEB516B2:   jmp     ecx
     $7FD0CEE8C528 fsin
     $7FD0CEE8C530 drop    1->0
     7FD0CEB516B4:   add     r13,$08
     $7FD0CEE8C538 over    0->1
     7FD0CEB516B8:   mov     r8,$10[r15]
     7FD0CEB516BC:   add     r13,$08
     $7FD0CEE8C540 ;s    1->1
     7FD0CEB516C0:   mov     r10,[rbx]
     7FD0CEB516C3:   add     rbx,$08
     7FD0CEB516C7:   lea     r13,$08[r10]
     7FD0CEB516CB:   mov     rcx,-$08[r13]
     7FD0CEB516CF:   jmp     ecx

   First, you see a threaded-code cell for a static superinstruction
with the components ‘lit’ and ‘f@’, starting and ending with one data
stack item in a register (‘1->1’); this is followed by the cell for the
argument ‘x’ of ‘lit’, and the cell for the ‘f@’ component of the
superinstruction; the latter cell is not used, but is there for
Gforth-internal reasons.

   Next, the dynamically generated native code for the superinstruction
‘lit f@’ is shown; note that this native code is not mixed with the
threaded code in memory, as you can see by comparing the addresses.

   If you want to understand the native code shown here: the
threaded-code instruction pointer is in ‘r13’, the data stack pointer in
‘r15’; the first data stack register is ‘r8’ (i.e., the top of stack
resides there if there is one data stack item in a register); the return
stack pointer is in ‘rbx’, the FP stack pointer in ‘r12’, and the top of
the floating-pont stack in ‘xmm15’.  Note that the register assignments
vary between engines, so you may see a different register assignment for
this code.

   The dynamic native code for ‘lit f@’ ends with a dispatch jump (aka
NEXT), because the code for the next word ‘fsin’ in the definition is
not dynamically generated.

   Next, you see the threaded-code cell for ‘fsin’.  There is no
dynamically-generated native code for this word, and ‘see-code’ does not
show the static native code for it (you can look at it with ‘see fsin’).
Like all words with static native code in ‘gforth-fast’, the effect on
the data stack representation is ‘1->1’ (for ‘gforth’, ‘0->0’), but this
is not shown.

   Next, you see the threaded-code cell for ‘drop’; the native-code
variant used here starts with one data stack item in registers, and ends
with zero data stack items in registers (‘1->0’).  This is followed by
the native code for this variant of ‘drop’.  There is no NEXT here,
because the native code falls through to the code for the next word.

   Next, you see the threaded-code cell for ‘over’ followed by the
dynamically-generated native code in the ‘0->1’ variant.

   Finally, you see the threaded and native code for ‘;s’ (the primitive
compiled for ‘;’ in ‘foo’).  ‘;s’ performs control flow (it returns), so
it has to end with a NEXT.


File: gforth.info,  Node: Examining data,  Next: Forgetting words,  Prev: Examining compiled code,  Up: Programming Tools

6.26.5 Examining data and code
------------------------------

The following words inspect the stack non-destructively:

‘...’ ( x1 .. xn – x1 .. xn  ) gforth-1.0 “...”
   smart version of ‘.s’

‘.s’ ( –  ) tools “dot-s”
   Display the number of items on the data stack, followed by a list of
the items (but not more than specified by ‘maxdepth-.s’; TOS is the
right-most item.

‘f.s’ ( –  ) gforth-0.2 “f-dot-s”
   Display the number of items on the floating-point stack, followed by
a list of the items (but not more than specified by ‘maxdepth-.s’; TOS
is the right-most item.

‘f.s-precision’ ( – u  ) gforth-1.0 “f.s-precision”
   A ‘value’.  U is the field width for f.s output.  Other precision
details are derived from that value.

‘maxdepth-.s’ ( – addr  ) gforth-0.2 “maxdepth-dot-s”
   A variable containing 9 by default.  ‘.s’ and ‘f.s’ display at most
that many stack items.

   There is a word ‘.r’ but it does not display the return stack!  It is
used for formatted numeric output (*note Simple numeric output::).

   The following words work on the stack as a whole, either by
determining the depth or by clearing them:

‘depth’ ( – +n  ) core “depth”
   +N is the number of values that were on the data stack before +N
itself was placed on the stack.

‘fdepth’ ( – +n  ) floating “f-depth”
   +n is the current number of (floating-point) values on the
floating-point stack.

‘clearstack’ ( ... –  ) gforth-0.2 “clear-stack”
   remove and discard all/any items from the data stack.

‘fclearstack’ ( r0 .. rn –  ) gforth-1.0 “f-clearstack”
   clear the floating point stack

‘clearstacks’ ( ... –  ) gforth-0.7 “clear-stacks”
   empty data and FP stack

   The following words inspect memory.

‘?’ ( a-addr –  ) tools “question”
   Display the contents of address A-ADDR in the current number base.

‘dump’ ( addr u –  ) tools “dump”
   Display U lines of memory starting at address ADDR.  Each line
displays the contents of 16 bytes.  When Gforth is running under an
operating system you may get ‘Invalid memory address’ errors if you
attempt to access arbitrary locations.


File: gforth.info,  Node: Forgetting words,  Next: Debugging,  Prev: Examining data,  Up: Programming Tools

6.26.6 Forgetting words
-----------------------

Forth allows you to forget words (and everything that was alloted in the
dictonary after them) in a LIFO manner.

‘marker’ ( "<spaces> name" –  ) core-ext “marker”
   Create a definition, name (called a mark) whose execution semantics
are to remove itself and everything defined after it.

   The most common use of this feature is during progam development:
when you change a source file, forget all the words it defined and load
it again (since you also forget everything defined after the source file
was loaded, you have to reload that, too).  Note that effects like
storing to variables and destroyed system words are not undone when you
forget words.  With a system like Gforth, that is fast enough at
starting up and compiling, I find it more convenient to exit and restart
Gforth, as this gives me a clean slate.

   Here’s an example of using ‘marker’ at the start of a source file
that you are debugging; it ensures that you only ever have one copy of
the file’s definitions compiled at any time:

     [IFDEF] my-code
         my-code
     [ENDIF]

     marker my-code
     init-included-files

     \ .. definitions start here
     \ .
     \ .
     \ end


File: gforth.info,  Node: Debugging,  Next: Assertions,  Prev: Forgetting words,  Up: Programming Tools

6.26.7 Debugging
----------------

Languages with a slow edit/compile/link/test development loop tend to
require sophisticated tracing/stepping debuggers to facilate debugging.

   A much better (faster) way in fast-compiling languages is to add
printing code at well-selected places, let the program run, look at the
output, see where things went wrong, add more printing code, etc., until
the bug is found.

   The simple debugging aids provided in ‘debugs.fs’ are meant to
support this style of debugging.

   The word ‘~~’ prints debugging information (by default the source
location and the stack contents).  It is easy to insert.  If you use
Emacs it is also easy to remove (‘C-x ~’ in the Emacs Forth mode to
query-replace them with nothing).  The deferred words ‘printdebugdata’
and ‘.debugline’ control the output of ‘~~’.  The default source
location output format works well with Emacs’ compilation mode, so you
can step through the program at the source level using ‘C-x `’ (the
advantage over a stepping debugger is that you can step in any direction
and you know where the crash has happened or where the strange data has
occurred).

‘~~’ ( –  ) gforth-0.2 “tilde-tilde”
   Prints the source code location of the ‘~~’ and the stack contents
with ‘.debugline’.

‘printdebugdata’ ( –  ) gforth-0.2 “print-debug-data”

‘.debugline’ ( nfile nline –  ) gforth-0.6 “print-debug-line”
   Print the source code location indicated by NFILE NLINE, and
additional debugging information; the default ‘.debugline’ prints the
additional information with ‘printdebugdata’.

‘debug-fid’ ( – file-id  ) gforth-1.0 “File-id”
   debugging words for output.  By default it is the process’s ‘stderr’.

   ‘~~’ (and assertions) will usually print the wrong file name if a
marker is executed in the same file after their occurance.  They will
print ‘*somewhere*’ as file name if a marker is executed in the same
file before their occurance.

‘once’ ( –  ) gforth-1.0 “once”
   do the following up to THEN only once

‘~~bt’ ( –  ) gforth-1.0 “~~bt”
   print stackdump and backtrace

‘~~1bt’ ( –  ) gforth-1.0 “~~1bt”
   print stackdump and backtrace once

‘???’ ( –  ) gforth-0.2 “???”
   Open a debuging shell

‘WTF??’ ( –  ) gforth-1.0 “WTF??”
   Open a debugging shell with backtrace and stack dump

‘!!FIXME!!’ ( –  ) gforth-1.0 “!!FIXME!!”
   word that should never be reached

‘replace-word’ ( xt1 xt2 –  ) gforth-1.0 “replace-word”
   make xt2 do xt1, both need to be colon definitions

‘~~Variable’ ( "name" –  ) gforth-1.0 “~~Variable”
   Variable that will be watched on every access

‘~~Value’ ( n "name" –  ) gforth-1.0 “~~Value”
   Value that will be watched on every access

‘+ltrace’ ( –  ) gforth-1.0 “+ltrace”
   turn on line tracing

‘-ltrace’ ( –  ) gforth-1.0 “-ltrace”
   turn off line tracing

‘#loc’ ( nline nchar "file" –  ) gforth-1.0 “#loc”
   set next word’s location to NLINE NCHAR in "FILE"


File: gforth.info,  Node: Assertions,  Next: Singlestep Debugger,  Prev: Debugging,  Up: Programming Tools

6.26.8 Assertions
-----------------

It is a good idea to make your programs self-checking, especially if you
make an assumption that may become invalid during maintenance (for
example, that a certain field of a data structure is never zero).
Gforth supports “assertions” for this purpose.  They are used like this:

     assert( flag )

   The code between ‘assert(’ and ‘)’ should compute a flag, that should
be true if everything is alright and false otherwise.  It should not
change anything else on the stack.  The overall stack effect of the
assertion is ‘( -- )’.  E.g.

     assert( 1 1 + 2 = ) \ what we learn in school
     assert( dup 0<> ) \ assert that the top of stack is not zero
     assert( false ) \ this code should not be reached

   The need for assertions is different at different times.  During
debugging, we want more checking, in production we sometimes care more
for speed.  Therefore, assertions can be turned off, i.e., the assertion
becomes a comment.  Depending on the importance of an assertion and the
time it takes to check it, you may want to turn off some assertions and
keep others turned on.  Gforth provides several levels of assertions for
this purpose:

‘assert0(’ ( –  ) gforth-0.2 “assert-zero”
   Important assertions that should always be turned on.

‘assert1(’ ( –  ) gforth-0.2 “assert-one”
   Normal assertions; turned on by default.

‘assert2(’ ( –  ) gforth-0.2 “assert-two”
   Debugging assertions.

‘assert3(’ ( –  ) gforth-0.2 “assert-three”
   Slow assertions that you may not want to turn on in normal debugging;
you would turn them on mainly for thorough checking.

‘assert(’ ( –  ) gforth-0.2 “assert(”
   Equivalent to ‘assert1(’

‘)’ ( –  ) gforth-0.2 “close-paren”
   End an assertion.  Generic end, can be used for other similar
purposes

   The variable ‘assert-level’ specifies the highest assertions that are
turned on.  I.e., at the default ‘assert-level’ of one, ‘assert0(’ and
‘assert1(’ assertions perform checking, while ‘assert2(’ and ‘assert3(’
assertions are treated as comments.

   The value of ‘assert-level’ is evaluated at compile-time, not at
run-time.  Therefore you cannot turn assertions on or off at run-time;
you have to set the ‘assert-level’ appropriately before compiling a
piece of code.  You can compile different pieces of code at different
‘assert-level’s (e.g., a trusted library at level 1 and newly-written
code at level 3).

‘assert-level’ ( – a-addr  ) gforth-0.2 “assert-level”
   All assertions above this level are turned off.

   If an assertion fails, a message compatible with Emacs’ compilation
mode is produced and the execution is aborted (currently with ‘ABORT"’.
If there is interest, we will introduce a special throw code.  But if
you intend to ‘catch’ a specific condition, using ‘throw’ is probably
more appropriate than an assertion).

   Assertions (and ‘~~’) will usually print the wrong file name if a
marker is executed in the same file after their occurance.  They will
print ‘*somewhere*’ as file name if a marker is executed in the same
file before their occurance.

   Definitions in Standard Forth for these assertion words are provided
in ‘compat/assert.fs’.


File: gforth.info,  Node: Singlestep Debugger,  Next: Code Coverage,  Prev: Assertions,  Up: Programming Tools

6.26.9 Singlestep Debugger
--------------------------

シングルステップ・デバッガーは、 ‘gforth-itc’ エンジンでのみ動作します。

   新しいワードを作成するとき、 それが正しく動作するかどうかを確認する必
要があることがよくあります。 これを行うには、‘dbg badword’ と入力します
。 デバッグ・セッションは以下のようになります:

     : badword 0 DO i . LOOP ;  ok
     2 dbg badword
     : badword
     Scanning code...

     Nesting debugger ready!

     400D4738  8049BC4 0              -> [ 2 ] 00002 00000
     400D4740  8049F68 DO             -> [ 0 ]
     400D4744  804A0C8 i              -> [ 1 ] 00000
     400D4748 400C5E60 .              -> 0 [ 0 ]
     400D474C  8049D0C LOOP           -> [ 0 ]
     400D4744  804A0C8 i              -> [ 1 ] 00001
     400D4748 400C5E60 .              -> 1 [ 0 ]
     400D474C  8049D0C LOOP           -> [ 0 ]
     400D4758  804B384 ;              ->  ok

   各行が 1 ステップです。 次のワードを実行して表示するには、 常に
Return キーを押す必要があります。 次のワード全体を実行したくない場合は、
‘nest’ に対して ‘n’ と入力する必要があります。 利用可能なキーの概要は以
下のとおりです:

<RET>
     Next; 次のワードを実行する(execute)。

n
     Nest; 次のワードまで 1 ステップずつ辿る。

u
     Unnest; デバッグを停止し(stop)、残りのワードを実行します(execute)。
     ネスト(nest)機能でこのワードに到達した場合、 それを呼び出したワード
     でデバッグを続行します。

d
     Done; デバッグを停止し(stop)、 残りを実行します(execute)。

s
     Stop; 直ちに終了(abort)します。

   このメカニズムを使用して大規模なアプリケーションをデバッグすることは
、 あなたが関心のある部分が始まる前にプログラム内に非常に深くネストする
必要があるため、 非常に困難です。 これにはとても時間がかかります。

   これをより直接的に行うには、 ‘BREAK:’ コマンドをあなたのソース・コー
ドに追加します。 プログラムの実行が ‘BREAK:’ に達すると、 シングル・ステ
ップ・デバッガーが呼び出され、 上記すべての機能が利用できるようになりま
す。

   デバッグする部分が複数ある場合、 プログラムが現在どこで停止しているか
を把握できると便利です。 これを行うには、 ‘BREAK" string"’ コマンドを使
用します。 これは ‘BREAK:’ と同様に動作しますが、 「ブレークポイント」に
到達したときに文字列が出力される点が異なります。

‘dbg’ ( "name" –  ) gforth-0.2 “dbg”

‘break:’ ( –  ) gforth-0.4 “break:”

‘break"’ ( ’ccc"’ –  ) gforth-0.4 “break"”


File: gforth.info,  Node: Code Coverage,  Prev: Singlestep Debugger,  Up: Programming Tools

6.26.10 Code Coverage and Execution Frequency
---------------------------------------------

If you run extensive tests on your code, you often want to figure out if
the tests exercise all parts of the code.  This is called (test)
coverage.  The file ‘coverage.fs’ contains tools for measuring the
coverage as well as execution frequency.

   Code coverage inserts counting code in every basic block
(straight-line code sequence) loaded after ‘coverage.fs’.  Each time
that code is run, it increments the counter for that basic block.  Later
you can show the source file with the counts inserted in these basic
blocks.

‘nocov[’ ( –  ) gforth-1.0 “nocov-bracket”
   (Immediate) Turn coverage off temporarily.

‘]nocov’ ( –  ) gforth-1.0 “bracket-nocov”
   (Immediate) End of temporary turned off coverage.

‘coverage?’ ( – f  ) gforth-internal “coverage?”
   Value: Coverage check on/off

‘cov+’ ( –  ) gforth-experimental “cov+”
   (Immediate) Place a coverage counter here.

‘?cov+’ ( flag – flag  ) gforth-experimental “?cov+”
   (Immediate) A coverage counter for a flag; in the coverage output you
see three numbers behind ‘?cov’: The first is the number of executions
where the top-of-stack was non-zero; the second is the number of
executions where it was zero; the third is the total number of
executions.

‘.coverage’ ( –  ) gforth-experimental “.coverage”
   Show code with execution frequencies.

‘annotate-cov’ ( –  ) gforth-experimental “annotate-cov”
   For every file with coverage information, produce a ‘.cov’ file that
has the execution frequencies inserted.  We recommend to use ‘bw-cover’
first (with the default ‘color-cover’ you get escape sequences in the
files).

‘cov%’ ( –  ) gforth-experimental “cov-percent”
   Print the percentage of basic blocks loaded after ‘coverage.fs’ that
are executed at least once.

‘.cover-raw’ ( –  ) gforth-experimental “.cover-raw”
   Print raw execution counts.

   By default, the counts are shown in colour (using ANSI escape
sequences), but you can use ‘bw-cover’ to show them in parenthesized
form without escape sequences.

‘bw-cover’ ( –  ) gforth-1.0 “bw-cover”
   Print execution counts in parentheses (source-code compatible).

‘color-cover’ ( –  ) gforth-1.0 “color-cover”
   Print execution counts in colours (default).

   You can save and reload the coverage counters in binary format, to
aggregate coverage counters across several test runs.

‘save-cov’ ( –  ) gforth-experimental “save-cov”
   Save coverage counters.

‘load-cov’ ( –  ) gforth-experimental “load-cov”
   Load coverage counters.


File: gforth.info,  Node: Multitasker,  Next: C Interface,  Prev: Programming Tools,  Up: Words

6.27 Multitasker
================

* Menu:

* Pthreads::                 ネイティブ Unix 用マルチタスカー
* Cilk::                     Cilk風の spawn+sync 実装

Gforth は 2 つのマルチタスカーを提供します。 1 つは従来の協調的なラウン
ドロビン・マルチタスカー(cooperative round-robin multitasker)で、 もう 1
つはマルチコア・マシン上で複数のスレッドを同時に実行できる pthread ベー
スのマルチタスカーです。 将来、 Forth マルチタスカーの標準化により、 そ
の意味は変更せずにワードの名前が変更される可能性が高いため、 pthread ベ
ースのマルチタスカーは現在、 実験的な機能としてマークされています。


File: gforth.info,  Node: Pthreads,  Next: Cilk,  Prev: Multitasker,  Up: Multitasker

6.27.1 Pthreads
---------------

Posix threads can run in parallel on several cores, or with pre-emptive
multitasking on onecore.  However, many of the following words are the
same as in the traditional cooperative multi-tasker.

   In addition, there are words that allow you to make sure that only
one task at a time changes something, and for communicating between
tasks.  These words are necessary for pre-emptive and multi-core
multi-tasking, because the cooperative-multitasking way of performing
transactions between calls to ‘pause’ does not work in this environment.

* Menu:

* Basic multi-tasking::
* Task-local data::
* Semaphores::
* Hardware operations for multi-tasking::
* Message queues::


File: gforth.info,  Node: Basic multi-tasking,  Next: Task-local data,  Prev: Pthreads,  Up: Pthreads

6.27.1.1 Basic multi-tasking
............................

Tasks can be created with ‘newtask’ or ‘newtask4’ with a given amount of
stack space (either all the same or each stack’s size specified).

‘newtask’ ( stacksize – task  ) gforth-experimental “newtask”
   creates task; each stack (data, return, FP, locals) has size
stacksize.

‘task’ ( ustacksize "name" –  ) gforth-experimental “task”
   creates a task name; each stack (data, return, FP, locals) has size
ustacksize.
name execution: ( – task )

‘newtask4’ ( u-data u-return u-fp u-locals – task  ) gforth-experimental “newtask4”
   creates task with data stack size u-data, return stack size u-return,
FP stack size u-fp and locals stack size u-locals.

   If you don’t know which stack sizes to use for the task, you can use
the size(s) of the main task:

‘stacksize’ ( – u  ) gforth-experimental “stacksize”
   u is the data stack size of the main task.

‘stacksize4’ ( – u-data u-return u-fp u-locals  ) gforth-experimental “stacksize4”
   Pushes the data, return, FP, and locals stack sizes of the main task.

   A task is created in an inactive state.  To let it run, you have to
activate it with one of the following words:

‘initiate’ ( xt task –  ) gforth-experimental “initiate”
   Let task execute xt.  Upon return from the xt, the task terminates
itself (VFX compatible).  Use one-time executable closures to pass
arbitrary paramenters to a task.

   The following legacy words provide the same functionality as
‘initiate’, but with a different interface: Like ‘does>’, they split
their containing colon definition in two parts: The part before
‘activate’/‘pass’ runs in the activating task, and returns to its caller
after activating the task.  The part behind ‘activate’/‘pass’ is
executed in the activated target task.

‘activate’ ( run-time nest-sys1 task –  ) gforth-experimental “activate”
   Let task perform the code behind ‘activate’, and return to the caller
of the word containing ‘activate’.  When the task returns from the code
behind ‘activate’, it terminates itself.

‘pass’ ( x1 .. xn n task –  ) gforth-experimental “pass”
   Pull x1 ..  xn n from the current task’s data stack and push x1 ..
xn on task’s data stack.  Let task perform the code behind ‘pass’, and
return to the caller of the word containing ‘pass’.  When the task
returns from the code behind ‘pass’, it terminates itself.

   You can also do creation and activation in one step:

‘execute-task’ ( xt – task  ) gforth-experimental “execute-task”
   Create a new task TASK with the same stack sizes as the main task.
Let task execute xt.  Upon return from the xt, the task terminates
itself.

   Apart from terminating by running to the end, a task can terminate
itself with ‘kill-task’.  Other tasks can terminate it with ‘kill’.

‘kill-task’ ( –  ) gforth-experimental “kill-task”
   Terminate the current task.

‘kill’ ( task –  ) gforth-experimental “kill”
   Terminate task.

   Tasks can also temporarily stop themselves or be stopped:

‘halt’ ( task –  ) gforth-experimental “halt”
   Stop a task

‘stop’ ( –  ) gforth-experimental “stop”
   stops the current task, and waits for events (which may restart it)

‘stop-ns’ ( timeout –  ) gforth-experimental “stop-ns”
   Stop with timeout (in nanoseconds), better replacement for ms

   A task restarts when the timeout is over or when another task wakes
it with:

‘restart’ ( task –  ) gforth-experimental “restart”
   Wake a task

   There is also:

‘pause’ ( –  ) gforth-experimental “pause”
   voluntarily switch to the next waiting task (‘pause’ is the
traditional cooperative task switcher; in the pthread multitasker, you
don’t need ‘pause’ for cooperation, but you still can use it e.g.  when
you have to resort to polling for some reason).  This also checks for
events in the queue.


File: gforth.info,  Node: Task-local data,  Next: Semaphores,  Prev: Basic multi-tasking,  Up: Pthreads

6.27.1.2 Task-local data
........................

In Forth every task has essentially the same task-local data, called
“user” area (early Forth systems were multi-user systems and there often
was one user per task).  The task result of, e.g.  ‘newtask’ is the
start address of its user area.  Each task gets the user data defined by
the system (e.g., ‘base’).  You can define additional user data with:

‘User’ ( "name" –  ) gforth-0.2 “User”
   Name is a user variable (1 cell).
Name execution: ( – addr )
Addr is the address of the user variable in the current task.

‘AUser’ ( "name" –  ) gforth-0.2 “AUser”
   Name is a user variable containing an address (this only makes a
difference in the cross-compiler).

‘uallot’ ( n1 – n2  ) gforth-0.3 “uallot”
   Reserve n1 bytes of user data.  n2 is the offset of the start of the
reserved area within the user area.

‘UValue’ ( "name" –  ) gforth-1.0 “UValue”
   Name is a user value.
Name execution: ( – x )

‘UDefer’ ( "name" –  ) gforth-1.0 “UDefer”
   Name is a task-local deferred word.
Name execution: ( ...  – ...  )

   There are also the following words for dealing with user data.

‘up@’ ( – a-addr ) new “up-fetch”
   Addr is the start of the user area of the current task (addr also
serves as the task identifier of the current task).

‘user'’ ( "name" – u  ) gforth-experimental “user”’
   U is the offset of the user variable name in the user area of each
task.

‘'s’ ( addr1 task – addr2  ) gforth-experimental “’s”
   With addr1 being an address in the user data of the current task,
addr2 is the corresponding address in task’s user data.


File: gforth.info,  Node: Semaphores,  Next: Hardware operations for multi-tasking,  Prev: Task-local data,  Up: Pthreads

6.27.1.3 Semaphores
...................

A cooperative multitasker can ensure that there is no other task
interacting between two invocations of ‘pause’.  Pthreads however are
really concurrent tasks (at least on a multi-core CPU), and therefore,
several techniques to avoid conflicts when accessing the same resources.

   Semaphores can only be aquired by one thread, all other threads have
to wait until the semapohre is released.

‘semaphore’ ( "name" –  ) gforth-experimental “semaphore”
   create a named semaphore name
name execution: ( – semaphore )

‘lock’ ( semaphore –  ) gforth-experimental “lock”
   lock the semaphore

‘unlock’ ( semaphore –  ) gforth-experimental “unlock”
   unlock the semaphore

   The other approach to prevent concurrent access is the critical
section.  Here, we implement a critical section with a semaphore, so you
have to specify the semaphore which is used for the critical section.
Only those critical sections which use the same semaphore are mutually
exclusive.

‘critical-section’ ( xt semaphore –  ) gforth-experimental “critical-section”
   Execute xt while locking semaphore.  After leaving xt, semaphore is
unlocked even if an exception is thrown.


File: gforth.info,  Node: Hardware operations for multi-tasking,  Next: Message queues,  Prev: Semaphores,  Up: Pthreads

6.27.1.4 Hardware operations for multi-tasking
..............................................

Atomic hardware operations perform the whole operation, without any
other task seeing an intermediate state.  These operations can be used
to synchronize tasks without using slow OS primitives, but compared to
the non-atomic sequences of operations they tend to be slow.  Atomic
operations only work correctly on aligned addresses, even on hardware
that otherwise does not require alignment.

‘!@’ ( u1 a-addr – u2 ) gforth-experimental “store-fetch”
   load U2 from A_ADDR, and store U1 there, as atomic operation

‘+!@’ ( u1 a-addr – u2 ) gforth-experimental “add-store-fetch”
   load U2 from A_ADDR, and increment this location by U1, as atomic
operation

‘?!@’ ( unew uold a-addr – uprev ) gforth-experimental “question-store-fetch”
   load UPREV from A_ADDR, compare it to UOLD, and if equal, store UNEW
there, as atomic operation

   Another hardware operation is the memory barrier.  Unfortunately
modern hardware often can reorder memory operations relative to other
memory operations (as seen by a different core), and the memory barrier
suppresses this reordering for one point in the execution of the task.

‘barrier’ ( – ) gforth-experimental “barrier”
   All memory operations before the barrier are performed before any
memory operation after the barrier.


File: gforth.info,  Node: Message queues,  Prev: Hardware operations for multi-tasking,  Up: Pthreads

6.27.1.5 Message queues
.......................

Gforth’s message queues are a variant of the actor model.

   An event is an xt; the sending task tells the receiving task to run
an event, and the receiving task performs one event from its message
queue when it is ready.  Execute-once closures can be used for events
that pass parameters.

‘send-event’ ( xt task –  ) gforth-experimental “send-event”
   Task IPC: send XT to TASK.  The xt is executed there.  Use a one-shot
closure to pass parameters with the xt.

   When several tasks send event to one task, the events may arrive in
any order.  In order to receive events, you put one of the following
words in the receiving task:

‘?events’ ( –  ) gforth-experimental “question-events”
   Perform all event sequences in the current task’s message queue, one
event sequence at a time.

‘event-loop’ ( –  ) gforth-experimental “event-loop”
   Wait for event sequences, and execute any event sequences when they
arrive.  Return to waiting if no event sequences are in the queue.  This
word never returns.

   Alternatively, when a task is ‘stop’ped, it is also ready for
receiving event, and receiving an event will wake it up.


File: gforth.info,  Node: Cilk,  Prev: Pthreads,  Up: Multitasker

6.27.2 Cilk
-----------

Gforth’s Cilk is a framework for dividing work between multiple tasks
running on several cores, inspired by the programming language of the
same name.  Use ‘require cilk.fs’ if you want to use Cilk.

   The idea is that you identify subproblems that can be solved in
parallel, and the framework assigns worker tasks to these subproblems.
In particular, you use one of the ‘spawn’ words for each subtask.
Eventually you need to wait with ‘cilk-sync’ for the subproblems to be
solved.

   Currently all the spawning has to happen from one task, and
‘cilk-sync’ waits for all subproblems to complete, so using the current
Gforth Cilk for recursive algorithms is not straightforward.

   Do not divide the subproblems too finely, in order to avoid overhead;
how fine is too fine depends on how uniform the run-time for the
subproblems is, but for problems with substantial run-time, having
5*‘cores’ subproblems is probably a good starting point.

‘cores’ ( – u  ) cilk “cores”
   A value containing the number of worker tasks to use.  By default
this is the number of hardware threads (with SMT/HT), if we can
determine that, otherwise 1.  If you want to use a different number,
change ‘cores’ before calling ‘cilk-init’.

‘cilk-init’ ( –  ) cilk “cilk-init”
   Start the worker tasks if not already done.

‘spawn’ ( xt –  ) cilk “spawn”
   Execute xt ( – ) in a worker task.  Use one-time executable closures
to pass heap-allocated closures, allowing to pass arbitrary data from
the spawner to the code running in the worker.
E.g.: ‘( n r ) [{: n f: r :}h1 code ;] spawn’

‘spawn1’ ( x xt –  ) cilk “spawn1”
   Execute xt ( x – ) in a worker task.

‘spawn2’ ( x1 x2 xt –  ) cilk “spawn2”
   Execute xt ( x1 x2 – ) in a worker task.

‘cilk-sync’ ( –  ) cilk “cilk-sync”
   Wait for all subproblems to complete.

‘cilk-bye’ ( –  ) cilk “cilk-bye”
   Terminate all workers.


File: gforth.info,  Node: C Interface,  Next: Assembler and Code Words,  Prev: Multitasker,  Up: Words

6.28 C Interface
================

Gforth の C言語インターフェイスは、 Forth スタックからパラメータを取得し
てC言語の関数を呼び出す、 C言語の関数を含むラッパー・ライブラリをコンパ
イルすることによって機能します。 このラッパー・ライブラリはC言語のコンパ
イラによってコンパイルされます。 コンパイル結果はキャッシュされるため、
ラッパー・ライブラリを変更する必要がある場合、 Gforth は C言語のコンパイ
ルを再実行するだけで済みます。 このビルド処理は自動(automatic)で、 イン
ターフェイス宣言の最後に行われます。 Gforth は、 この処理に libtool と
GCC を使用します。

   C言語のインターフェイスはほぼ完成した状態で、 コールバックも既に追加
されていますが、 構造体については、 独立したスコープを持たない Forth2012
構造体を使用します。 これらの構造体のオフセットは、 SWIG プラグインを使
用してヘッダー・ファイルから抽出されます。

* Menu:

* Calling C Functions::
* Declaring C Functions::
* Calling C function pointers::
* Defining library interfaces::
* Declaring OS-level libraries::
* Callbacks::
* C interface internals::
* Low-Level C Interface Words::
* Automated interface generation using SWIG::
* Migrating the C interface from earlier Gforth::


File: gforth.info,  Node: Calling C Functions,  Next: Declaring C Functions,  Prev: C Interface,  Up: C Interface

6.28.1 Calling C functions
--------------------------

C言語の関数関数が宣言されたら(*note Declaring C Functions:: 参照)、 次の
ように呼び出すことができます: あなたは引数達をスタックにプッシュしてから
、 C言語関数のワードを呼び出します。 引数は、 C言語のドキュメントに記載
されているのと同じ順序でプッシュする必要があります(つまり、 最初の引数が
スタックの最も深いところにあります)。 整数およびポインタ引数はデータ・ス
タックにプッシュする必要があり、 浮動小数点引数は FP スタックにプッシュ
する必要があります。 これらの引数は、 呼び出されたC言語の関数によって消
費されます。

   C言語の関数から戻るとき、 戻り値がある場合、 その戻り値は適切なスタッ
クに置きます。 整数の戻り値はデータ・スタックにプッシュされ、 FP の戻り
値は FP スタックにプッシュされ、 void 戻り値の場合は何もプッシュされませ
ん。 C言語ではあまり使用されない場合でも、 ほとんどのC言語の関数には戻り
値があることに注意してください。 Forth では、 この戻り値を使用しない場合
は、 明示的に捨てる(‘drop’)必要があります。

   C言語インターフェイスは、 必要に応じて、 ベストエフォートで C言語の型
と Forth の型の間で自動的に変換します(場合によっては、 ある程度の損失が
発生する可能性があります)。

   例として、 POSIX 関数 ‘lseek()’ について考察してみましょう:

     off_t lseek(int fd, off_t offset, int whence);

   This function takes three integer arguments, and returns an integer
argument, so a Forth call for setting the current file offset to the
start of the file could look like this:

     fd @ 0 SEEK_SET lseek -1 = if
       ... \ error handling
     then

   You might be worried that an ‘off_t’ does not fit into a cell, so you
could not pass larger offsets to lseek, and might get only a part of the
return values.  In that case, in your declaration of the function (*note
Declaring C Functions::) you should declare it to use double-cells for
the off_t argument and return value, and maybe give the resulting Forth
word a different name, like ‘dlseek’; the result could be called like
this:

     fd @ 0. SEEK_SET dlseek -1. d= if
       ... \ error handling
     then

   Passing and returning structs or unions is currently not supported by
our interface(1).

   Calling functions with a variable number of arguments (_variadic_
functions, e.g., ‘printf()’) is only supported by having you declare one
function-calling word for each argument pattern, and calling the
appropriate word for the desired pattern.

   ---------- Footnotes ----------

   (1) If you know the calling convention of your C compiler, you
usually can call such functions in some way, but that way is usually not
portable between platforms, and sometimes not even between C compilers.


File: gforth.info,  Node: Declaring C Functions,  Next: Calling C function pointers,  Prev: Calling C Functions,  Up: C Interface

6.28.2 Declaring C Functions
----------------------------

Before you can call ‘lseek’ or ‘dlseek’, you have to declare it.  The
declaration consists of two parts:

The C part
     is the C declaration of the function, or more typically and
     portably, a C-style ‘#include’ of a file that contains the
     declaration of the C function.

The Forth part
     declares the Forth types of the parameters and the Forth word name
     corresponding to the C function.

   For the words ‘lseek’ and ‘dlseek’ mentioned earlier, the
declarations are:

     \c #define _FILE_OFFSET_BITS 64
     \c #include <sys/types.h>
     \c #include <unistd.h>
     c-function lseek lseek n n n -- n
     c-function dlseek lseek n d n -- d

   The C part of the declarations is prefixed by ‘\c’, and the rest of
the line is ordinary C code.  You can use as many lines of C
declarations as you like, and they are visible for all further function
declarations.

   The Forth part declares each interface word with ‘c-function’,
followed by the Forth name of the word, the C name of the called
function, and the stack effect of the word.  The stack effect contains
an arbitrary number of types of parameters, then ‘--’, and then exactly
one type for the return value.  The possible types are:

‘n’
     single-cell integer

‘a’
     address (single-cell)

‘d’
     double-cell integer

‘r’
     floating-point value

‘func’
     C function pointer

‘void’
     no value (used as return type for void functions)

   To deal with variadic C functions, you can declare one Forth word for
every pattern you want to use, e.g.:

     \c #include <stdio.h>
     c-function printf-nr printf a n r -- n
     c-function printf-rn printf a r n -- n

   Note that with C functions declared as variadic (or if you don’t
provide a prototype), the C interface has no C type to convert to, so no
automatic conversion happens, which may lead to portability problems in
some cases.  You can add the C type cast in curly braces after the Forth
type.  This also allows to pass e.g.  structs to C functions, which in
Forth cannot live on the stack.

     c-function printfll printf a n{(long long)} -- n
     c-function pass-struct pass_struct a{*(struct foo *)} -- n

   This typecasting is not available to return values, as C does not
allow typecasts for lvalues.

‘\c’ ( "rest-of-line" –  ) gforth-0.7 “backslash-c”
   One line of C declarations for the C interface

‘c-function’ ( "forth-name" "c-name" "{type}" "—" "type" –  ) gforth-0.7 “c-function”
   Define a Forth word forth-name.  Forth-name has the specified stack
effect and calls the C function ‘c-name’.

‘c-value’ ( "forth-name" "c-name" "—" "type" –  ) gforth-1.0 “c-value”
   Define a Forth word forth-name.  Forth-name has the specified stack
effect and gives the C value of ‘c-name’.

‘c-variable’ ( "forth-name" "c-name" –  ) gforth-1.0 “c-variable”
   Define a Forth word forth-name.  Forth-name returns the address of
‘c-name’.

   In order to work, this C interface invokes GCC at run-time and uses
dynamic linking.  If these features are not available, there are other,
less convenient and less portable C interfaces in ‘lib.fs’ and
‘oldlib.fs’.  These interfaces are mostly undocumented and mostly
incompatible with each other and with the documented C interface; you
can find some examples for the ‘lib.fs’ interface in ‘lib.fs’.


File: gforth.info,  Node: Calling C function pointers,  Next: Defining library interfaces,  Prev: Declaring C Functions,  Up: C Interface

6.28.3 Calling C function pointers from Forth
---------------------------------------------

If you come across a C function pointer (e.g., in some C-constructed
structure) and want to call it from your Forth program, you could use
the structures as described above by defining a macro.  Or you use
‘c-funptr’.

‘c-funptr’ ( "forth-name" <{>"c-typecast"<}> "{type}" "—" "type" –  ) gforth-1.0 “c-funptr”
   Define a Forth word forth-name.  Forth-name has the specified stack
effect plus the called pointer on top of stack, i.e.  ‘( {type} ptr --
type )’ and calls the C function pointer ‘ptr’ using the typecast or
struct access ‘c-typecast’.

   Let us assume that there is a C function pointer type ‘func1’ defined
in some header file ‘func1.h’, and you know that these functions take
one integer argument and return an integer result; and you want to call
functions through such pointers.  Just define

     \c #include <func1.h>
     c-funptr call-func1 {((func1)ptr)} n -- n

   and then you can call a function pointed to by, say ‘func1a’ as
follows:

     -5 func1a call-func1 .

   The Forth word ‘call-func1’ is similar to ‘execute’, except that it
takes a C ‘func1’ pointer instead of a Forth execution token, and it is
specific to ‘func1’ pointers.  For each type of function pointer you
want to call from Forth, you have to define a separate calling word.


File: gforth.info,  Node: Defining library interfaces,  Next: Declaring OS-level libraries,  Prev: Calling C function pointers,  Up: C Interface

6.28.4 Defining library interfaces
----------------------------------

You can give a name to a bunch of C function declarations (a library
interface), as follows:

     c-library lseek-lib
     \c #define _FILE_OFFSET_BITS 64
     ...
     end-c-library

   The effect of giving such a name to the interface is that the names
of the generated files will contain that name, and when you use the
interface a second time, it will use the existing files instead of
generating and compiling them again, saving you time.  The generated
file contains a 128 bit hash (not cryptographically safe, but good
enough for that purpose) of the source code, so changing the
declarations will cause a new compilation.  Normally these files are
cached in ‘$HOME/.gforth/’ARCHITECTURE‘/libcc-named’, so if you
experience problems or have other reasons to force a recompilation, you
can delete the files there.

   Note that you should use ‘c-library’ before everything else having
anything to do with that library, as it resets some setup stuff.  The
idea is that the typical use is to put each
‘c-library’...‘end-c-library’ unit in its own file, and to be able to
include these files in any order.  All other words dealing with the C
interface are hidden in the vocabulary ‘c-lib’, which is put on top o
the search stack by ‘c-library’ and removed by ‘end-c-library’.

   Note that the library name is not allocated in the dictionary and
therefore does not shadow dictionary names.  It is used in the file
system, so you have to use naming conventions appropriate for file
systems.  The name is also used as part of the C symbols, but characters
outside the legal C symbol names are replaced with underscores.  Also,
you shall not call a function you declare after ‘c-library’ before you
perform ‘end-c-library’.

   A major benefit of these named library interfaces is that, once they
are generated, the tools used to generated them (in particular, the C
compiler and libtool) are no longer needed, so the interface can be used
even on machines that do not have the tools installed.  The build system
of Gforth can even cross-compile these libraries, so that the libraries
are available for plattforms on which build tools aren’t installed.

‘c-library-name’ ( c-addr u –  ) gforth-0.7 “c-library-name”
   Start a C library interface with name c-addr u.

‘c-library’ ( "name" –  ) gforth-0.7 “c-library”
   Parsing version of ‘c-library-name’

‘end-c-library’ ( –  ) gforth-0.7 “end-c-library”
   Finish and (if necessary) build the latest C library interface.


File: gforth.info,  Node: Declaring OS-level libraries,  Next: Callbacks,  Prev: Defining library interfaces,  Up: C Interface

6.28.5 Declaring OS-level libraries
-----------------------------------

For calling some C functions, you need to link with a specific OS-level
library that contains that function.  E.g., the ‘sin’ function requires
linking a special library by using the command line switch ‘-lm’.  In
our C iterface you do the equivalent thing by calling ‘add-lib’ as
follows:

     clear-libs
     s" m" add-lib
     \c #include <math.h>
     c-function sin sin r -- r

   First, you clear any libraries that may have been declared earlier
(you don’t need them for ‘sin’); then you add the ‘m’ library (actually
‘libm.so’ or somesuch) to the currently declared libraries; you can add
as many as you need.  Finally you declare the function as shown above.
Typically you will use the same set of library declarations for many
function declarations; you need to write only one set for that, right at
the beginning.

   Note that you must not call ‘clear-libs’ inside
‘c-library...end-c-library’; however, ‘c-library’ performs the function
of ‘clear-libs’, so ‘clear-libs’ is not necessary, and you usually want
to put ‘add-lib’ calls inside ‘c-library...end-c-library’.

‘clear-libs’ ( –  ) gforth-0.7 “clear-libs”
   Clear the list of libs

‘add-lib’ ( c-addr u –  ) gforth-0.7 “add-lib”
   Add library libstring to the list of libraries, where string is
represented by c-addr u.

‘add-libpath’ ( c-addr u –  ) gforth-0.7 “add-libpath”
   Add path string to the list of library search pathes, where string is
represented by c-addr u.

‘add-framework’ ( c-addr u –  ) gforth-1.0 “add-framework”
   Add framework libstring to the list of frameworks, where string is
represented by c-addr u.

‘add-incdir’ ( c-addr u –  ) gforth-1.0 “add-incdir”
   Add path c-addr u to the list of include search pathes

‘add-cflags’ ( c-addr u –  ) gforth-1.0 “add-cflags”
   add any kind of cflags to compilation

‘add-ldflags’ ( c-addr u –  ) gforth-1.0 “add-ldflags”
   add flag to linker


File: gforth.info,  Node: Callbacks,  Next: C interface internals,  Prev: Declaring OS-level libraries,  Up: C Interface

6.28.6 Callbacks
----------------

In some cases you have to pass a function pointer to a C function, i.e.,
the library wants to call back to your application (and the pointed-to
function is called a callback function).  You can pass the address of an
existing C function (that you get with ‘lib-sym’, *note Low-Level C
Interface Words::), but if there is no appropriate C function, you
probably want to define the function as a Forth word.  Then you need to
generate a callback as described below:

   You can generate C callbacks from Forth code with ‘c-callback’.

‘c-callback’ ( "forth-name" "{type}" "—" "type" –  ) gforth-1.0 “c-callback”
   Define a callback instantiator with the given signature.  The
callback instantiator forth-name ‘( xt -- addr )’ takes an XT, and
returns the ADDRess of the C function handling that callback.

‘c-callback-thread’ ( "forth-name" "{type}" "—" "type" –  ) gforth-1.0 “c-callback-thread”
   Define a callback instantiator with the given signature.  The
callback instantiator forth-name ‘( xt -- addr )’ takes an XT, and
returns the ADDRess of the C function handling that callback.  This
callback is safe when called from another thread

   This precompiles a number of callback functions (up to the value
‘callback#’).  The prototype of the C function is deduced from its Forth
signature.  If this is not sufficient, you can add types in curly braces
after the Forth type.

     c-callback vector4double: f f f f -- void
     c-callback vector4single: f{float} f{float} f{float} f{float} -- void


File: gforth.info,  Node: C interface internals,  Next: Low-Level C Interface Words,  Prev: Callbacks,  Up: C Interface

6.28.7 How the C interface works
--------------------------------

The documented C interface works by generating a C code out of the
declarations.

   In particular, for every Forth word declared with ‘c-function’, it
generates a wrapper function in C that takes the Forth data from the
Forth stacks, and calls the target C function with these data as
arguments.  The C compiler then performs an implicit conversion between
the Forth type from the stack, and the C type for the parameter, which
is given by the C function prototype.  After the C function returns, the
return value is likewise implicitly converted to a Forth type and
written back on the stack.

   The ‘\c’ lines are literally included in the C code (but without the
‘\c’), and provide the necessary declarations so that the C compiler
knows the C types and has enough information to perform the conversion.

   These wrapper functions are eventually compiled and dynamically
linked into Gforth, and then they can be called.

   The libraries added with ‘add-lib’ are used in the compile command
line to specify dependent libraries with ‘-lLIB’, causing these
libraries to be dynamically linked when the wrapper function is linked.


File: gforth.info,  Node: Low-Level C Interface Words,  Next: Automated interface generation using SWIG,  Prev: C interface internals,  Up: C Interface

6.28.8 Low-Level C Interface Words
----------------------------------

‘open-lib’ ( c-addr1 u1 – u2 ) gforth-0.4 “open-lib”

‘lib-sym’ ( c-addr1 u1 u2 – u3 ) gforth-0.4 “lib-sym”

‘lib-error’ ( – c-addr u ) gforth-0.7 “lib-error”
   Error message for last failed ‘open-lib’ or ‘lib-sym’.

‘call-c’ ( ... w – ... ) gforth-0.2 “call-c”
   Call the C function pointed to by w.  The C function has to access
the stack itself.  The stack pointers are exported into a ptrpair
structure passed to the C function, and returned in that form.


File: gforth.info,  Node: Automated interface generation using SWIG,  Next: Migrating the C interface from earlier Gforth,  Prev: Low-Level C Interface Words,  Up: C Interface

6.28.9 Automated interface generation using SWIG
------------------------------------------------

SWIG, the Simple Wrapper Interface Generator, is used to create C
interfaces for a lot of programming languages.  The SWIG version
extended with a Forth module can be found on github
(https://github.com/GeraldWodni/swig).

6.28.9.1 Basic operation
........................

C-headers are parsed and converted to Forth-Sourcecode which uses the
previously describe C interface functions.

6.28.9.2 Detailed operation:
............................

  1. Select a target, in this example we are using ‘example.h’
  2. Create an interface file for the header.  This can be used to pass
     options, switches and define variables.  In the simplest case it
     just instructs to translate all of ‘example.h’:
          %module example
          %insert("include")
          {
              #include "example.h"
          }
          %include "example.h"
  3. Use SWIG to create a ‘.fsi-c’ file.
     ‘swig -forth -stackcomments -use-structs -enumcomments -o
     example-fsi.c example.i’.
     FSI stands “Forth Source Independent” meaning it can be transferred
     to any host having a C-compiler.  SWIG is not required past this
     point.
  4. On the target machine compile the ‘.fsi-c’ file to a ‘.fsx’ (x
     stands for executable)
     ‘gcc -o example.fsx example-fsi.c’
     The compilation will resolve all constants to the values on the
     target.
  5. The last step is to run the executable and capture its output to a
     ‘.fs’ “Forth Source” file.
     ‘./example.fsx -gforth > example.fs’
     This code can now be used on the target platform.

6.28.9.3 Examples
.................

You can find some examples in SWIG’s Forth Example section
(https://github.com/GeraldWodni/swig/tree/master/Examples/forth).

   A lot of interface files can be found in Forth Posix C-Interface
(https://github.com/GeraldWodni/posix) and Forth C-Interface Modules
(https://github.com/GeraldWodni/forth-c-interfaces).

   Contribution to the Forth C-Interface Module repository
(https://github.com/GeraldWodni/forth-c-interfaces) is always welcome.


File: gforth.info,  Node: Migrating the C interface from earlier Gforth,  Prev: Automated interface generation using SWIG,  Up: C Interface

6.28.10 Migrating from Gforth 0.7
---------------------------------

In this version, you can use ‘\c’, ‘c-function’ and ‘add-lib’ only
inside ‘c-library’...‘end-c-library’.  ‘add-lib’ now always starts from
a clean slate inside a ‘c-library’, so you don’t need to use
‘clear-libs’ in most cases.

   If you have a program that uses these words outside
‘c-library’...‘end-c-library’, just wrap them in
‘c-library’...‘end-c-library’.  You may have to add some instances of
‘add-lib’, however.


File: gforth.info,  Node: Assembler and Code Words,  Next: Carnal words,  Prev: C Interface,  Up: Words

6.29 Assembler and Code Words
=============================

* Menu:

* Assembler Definitions::    Definitions in assembly language
* Common Assembler::         アセンブラ文法
* Common Disassembler::
* 386 Assembler::            逸脱(deviations)と特殊ケース
* AMD64 Assembler::
* Alpha Assembler::          逸脱(deviations)と特殊ケース
* MIPS assembler::           逸脱(deviations)と特殊ケース
* PowerPC assembler::        逸脱(deviations)と特殊ケース
* ARM Assembler::            逸脱(deviations)と特殊ケース
* Other assemblers::         アセンブラ自体の書き方


File: gforth.info,  Node: Assembler Definitions,  Next: Common Assembler,  Prev: Assembler and Code Words,  Up: Assembler and Code Words

6.29.1 Definitions in assembly language
---------------------------------------

Gforth は、 アセンブリ言語でワードを実装する方法(‘abi-code’ … ‘end-code’
を使用)と、 任意の実行時の振る舞いを持つ定義ワードを定義する方法(‘does>’
のようなの)を提供し、 ここで、 この実行時の振る舞いを(‘does>’ とは異なり
、) Forth ではなくアセンブリ言語で定義します。

   ただし、 Gforth のマシン非依存の性質により、 いくつかの問題が生じます
。 まず、 Gforth は複数のアーキテクチャ上で実行されるため、 標準のアセン
ブラを提供できません。 ただし、 実行されるいくつかのアーキテクチャ用のア
センブラは提供されています。 さらに言えば、 Gforth ではシステムに依存し
ないアセンブラを使用したり、 ‘,’ や ‘c,’ を使用してマシン・コードを直接
コンパイルしたりできます。

   もう 1 つの問題は、Gforth の仮想マシンのレジスタ(スタック・ポインタと
仮想マシン命令ポインタ)がインストールとエンジンに依存することです。 また
、 どのレジスタを自由に使用できるかは、 インストールとエンジンによって異
なります。 したがって、 Gforth 仮想マシンのコンテキストで実行するように
記述されたコードは、 基本的に、 そのコードが開発されたインストールとエン
ジンに限定されます(たまたま、 他の場所でも動く可能性はありますが、 それ
に頼ることはできません)。

   幸いなことに、 同じ呼び出し規約(ABI)を持つプラットフォーム上で実行さ
れている Gforth に移植可能(portable)な ‘abi-code’ ワードを Gforth で定義
できます。 通常、 これは同じアーキテクチャと OS の組み合わせへの移植性を
意味し、 しばしば OS の境を越えることができます。

‘assembler’ ( –  ) tools-ext “assembler”
   ボキャブラリ: 検索順序スタック(the search order)のTOSのワードリストを
assembler ワードリストに置き換えます。

‘init-asm’ ( –  ) gforth-0.2 “init-asm”
   assembler ワードリストを検索順序スタック(the search order)にプッシュ
します(訳注:つまり assembler ワードリストが検索順序スタックのTOSになる
)。

‘abi-code’ ( "name" – colon-sys  ) gforth-1.0 “abi-code”
   C言語プロトタイプ(C-prototype)に対応するプラットフォームの ABI 規則を
使用して呼び出されるネイティブ・コード定義を開始します:
     Cell *function(Cell *sp, Float **fpp);
   ここで、 FP スタック・ポインタは、 FP スタック・ポインタを含むメモリ
位置への参照を提供することによって渡され、 (必要な場合)変更された FP ス
タック・ポインタをそこに格納することによって渡されます。

‘;abi-code’ ( –  ) gforth-1.0 “semicolon-abi-code”
   コロン定義を終了しますが、 実行時に最後に定義されたワード X (‘create’
で作られたワードである必要があります)の変更もして、 C言語プロトタイプに
対応するプラットフォームの ABI 規約を使用してネイティブ・コードを呼び出
します:
      Cell *function(Cell *sp, Float **fpp, Address body);
   The FP stack pointer is passed in by providing a reference to a
memory location containing the FP stack pointer and is passed out by
storing the changed FP stack pointer there (if necessary).  The
parameter body is the body of X.

‘end-code’ ( colon-sys –  ) gforth-0.2 “end-code”
   End a code definition.  Note that you have to assemble the return
from the ABI call (for ‘abi-code’) or the dispatch to the next VM
instruction (for ‘code’ and ‘;code’) yourself.

‘code’ ( "name" – colon-sys  ) tools-ext “code”
   Start a native code definition that runs in the context of the Gforth
virtual machine (engine).  Such a definition is not portable between
Gforth installations, so we recommend using ‘abi-code’ instead of
‘code’.  You have to end a ‘code’ definition with a dispatch to the next
virtual machine instruction.

‘;code’ ( compilation. colon-sys1 – colon-sys2  ) tools-ext “semicolon-code”
   The code after ‘;code’ becomes the behaviour of the last defined word
(which must be a ‘create’d word).  The same caveats apply as for ‘code’,
so we recommend using ‘;abi-code’ instead.

‘flush-icache’ ( c-addr u – ) gforth-0.2 “flush-icache”
   Make sure that the instruction cache of the processor (if there is
one) does not contain stale data at c-addr and u bytes afterwards.
‘END-CODE’ performs a ‘flush-icache’ automatically.  Caveat:
‘flush-icache’ might not work on your installation; this is usually the
case if direct threading is not supported on your machine (take a look
at your ‘machine.h’) and your machine has a separate instruction cache.
In such cases, ‘flush-icache’ does nothing instead of flushing the
instruction cache.

   If ‘flush-icache’ does not work correctly, ‘abi-code’ words etc.
will not work (reliably), either.

   The typical usage of these words can be shown most easily by analogy
to the equivalent high-level defining words:

     : foo                              abi-code foo
        <high-level Forth words>              <assembler>
     ;                                  end-code

     : bar                              : bar
        <high-level Forth words>           <high-level Forth words>
        CREATE                             CREATE
           <high-level Forth words>           <high-level Forth words>
        DOES>                              ;code
           <high-level Forth words>           <assembler>
     ;                                  end-code

   For using ‘abi-code’, take a look at the ABI documentation of your
platform to see how the parameters are passed (so you know where you get
the stack pointers) and how the return value is passed (so you know
where the data stack pointer is returned).  The ABI documentation also
tells you which registers are saved by the caller (caller-saved), so you
are free to destroy them in your code, and which registers have to be
preserved by the called word (callee-saved), so you have to save them
before using them, and restore them afterwards.  For some architectures
and OSs we give short summaries of the parts of the calling convention
in the appropriate sections.  More reverse-engineering oriented people
can also find out about the passing and returning of the stack pointers
through ‘see abi-call’.

   Most ABIs pass the parameters through registers, but some (in
particular the most common 386 (aka IA-32) calling conventions) pass
them on the architectural stack.  The common ABIs all pass the return
value in a register.

   Other things you need to know for using ‘abi-code’ is that both the
data and the FP stack grow downwards (towards lower addresses) in
Gforth, with ‘1 cells’ size per cell, and ‘1 floats’ size per FP value.

   Here’s an example of using ‘abi-code’ on the 386 architecture:

     abi-code my+ ( n1 n2 -- n )
     4 sp d) ax mov \ sp into return reg
     ax )    cx mov \ tos
     4 #     ax add \ update sp (pop)
     cx    ax ) add \ sec = sec+tos
     ret            \ return from my+
     end-code

   An AMD64 variant of this example can be found in *note AMD64
Assembler::.

   Here’s a 386 example that deals with FP values:

     abi-code my-f+ ( r1 r2 -- r )
     8 sp d) cx mov  \ load address of fp
     cx )    dx mov  \ load fp
     .fl dx )   fld  \ r2
     8 #     dx add  \ update fp
     .fl dx )   fadd \ r1+r2
     .fl dx )   fstp \ store r
     dx    cx ) mov  \ store new fp
     4 sp d) ax mov  \ sp into return reg
     ret             \ return from my-f+
     end-code


File: gforth.info,  Node: Common Assembler,  Next: Common Disassembler,  Prev: Assembler Definitions,  Up: Assembler and Code Words

6.29.2 Common Assembler
-----------------------

The assemblers in Gforth generally use a postfix syntax, i.e., the
instruction name follows the operands.

   The operands are passed in the usual order (the same that is used in
the manual of the architecture).  Since they all are Forth words, they
have to be separated by spaces; you can also use Forth words to compute
the operands.

   The instruction names usually end with a ‘,’.  This makes it easier
to visually separate instructions if you put several of them on one
line; it also avoids shadowing other Forth words (e.g., ‘and’).

   Registers are usually specified by number; e.g., (decimal) ‘11’
specifies registers R11 and F11 on the Alpha architecture (which one,
depends on the instruction).  The usual names are also available, e.g.,
‘s2’ for R11 on Alpha.

   Control flow is specified similar to normal Forth code (*note
Arbitrary control structures::), with ‘if,’, ‘ahead,’, ‘then,’,
‘begin,’, ‘until,’, ‘again,’, ‘cs-roll’, ‘cs-pick’, ‘else,’, ‘while,’,
and ‘repeat,’.  The conditions are specified in a way specific to each
assembler.

   The rest of this section is of interest mainly for those who want to
define ‘code’ words (instead of the more portable ‘abi-code’ words).

   Note that the register assignments of the Gforth engine can change
between Gforth versions, or even between different compilations of the
same Gforth version (e.g., if you use a different GCC version).  If you
are using ‘CODE’ instead of ‘ABI-CODE’, and you want to refer to
Gforth’s registers (e.g., the stack pointer or TOS), I recommend
defining your own words for refering to these registers, and using them
later on; then you can adapt to a changed register assignment.

   The most common use of these registers is to end a ‘code’ definition
with a dispatch to the next word (the ‘next’ routine).  A portable way
to do this is to jump to ‘' noop >code-address’ (of course, this is less
efficient than integrating the ‘next’ code and scheduling it well).
When using ‘ABI-CODE’, you can just assemble a normal subroutine return
(but make sure you return the data stack pointer).

   Another difference between Gforth versions is that the top of stack
is kept in memory in ‘gforth’ and, on most platforms, in a register in
‘gforth-fast’.  For ‘ABI-CODE’ definitions, any stack caching registers
are guaranteed to be flushed to the stack, allowing you to reliably
access the top of stack in memory.


File: gforth.info,  Node: Common Disassembler,  Next: 386 Assembler,  Prev: Common Assembler,  Up: Assembler and Code Words

6.29.3 Common Disassembler
--------------------------

You can disassemble a ‘code’ word with ‘see’ (*note Debugging::).  You
can disassemble a section of memory with

‘discode’ ( addr u –  ) gforth-0.2 “discode”
   hook for the disassembler: disassemble u bytes of code at addr

   There are two kinds of disassembler for Gforth: The Forth
disassembler (available on some CPUs) and the gdb disassembler
(available on platforms with ‘gdb’ and ‘mktemp’).  If both are
available, the Forth disassembler is used by default.  If you prefer the
gdb disassembler, say

     ' disasm-gdb is discode

   If neither is available, ‘discode’ performs ‘dump’.

   The Forth disassembler generally produces output that can be fed into
the assembler (i.e., same syntax, etc.).  It also includes additional
information in comments.  In particular, the address of the instruction
is given in a comment before the instruction.

   The gdb disassembler produces output in the same format as the gdb
‘disassemble’ command (*note Source and machine code: (gdb)Machine
Code.), in the default flavour (AT&T syntax for the 386 and AMD64
architectures).

   ‘See’ may display more or less than the actual code of the word,
because the recognition of the end of the code is unreliable.  You can
use ‘discode’ if it did not display enough.  It may display more, if the
code word is not immediately followed by a named word.  If you have
something else there, you can follow the word with ‘align latest ,’ to
ensure that the end is recognized.


File: gforth.info,  Node: 386 Assembler,  Next: AMD64 Assembler,  Prev: Common Disassembler,  Up: Assembler and Code Words

6.29.4 386 Assembler
--------------------

The 386 assembler included in Gforth was written by Bernd Paysan, it’s
available under GPL, and originally part of bigFORTH.

   The 386 disassembler included in Gforth was written by Andrew McKewan
and is in the public domain.

   The disassembler displays code in an Intel-like prefix syntax.

   The assembler uses a postfix syntax with AT&T-style parameter order
(i.e., destination last).

   The assembler includes all instruction of the Athlon, i.e.  486 core
instructions, Pentium and PPro extensions, floating point, MMX, 3Dnow!,
but not ISSE. It’s an integrated 16- and 32-bit assembler.  Default is
32 bit, you can switch to 16 bit with .86 and back to 32 bit with .386.

   There are several prefixes to switch between different operation
sizes, ‘.b’ for byte accesses, ‘.w’ for word accesses, ‘.d’ for
double-word accesses.  Addressing modes can be switched with ‘.wa’ for
16 bit addresses, and ‘.da’ for 32 bit addresses.  You don’t need a
prefix for byte register names (‘AL’ et al).

   For floating point operations, the prefixes are ‘.fs’ (IEEE single),
‘.fl’ (IEEE double), ‘.fx’ (extended), ‘.fw’ (word), ‘.fd’
(double-word), and ‘.fq’ (quad-word).  The default is ‘.fx’, so you need
to specify ‘.fl’ explicitly when dealing with Gforth FP values.

   The MMX opcodes don’t have size prefixes, they are spelled out like
in the Intel assembler.  Instead of move from and to memory, there are
PLDQ/PLDD and PSTQ/PSTD.

   The registers lack the ’e’ prefix; even in 32 bit mode, eax is called
ax.  Immediate values are indicated by postfixing them with ‘#’, e.g.,
‘3 #’.  Here are some examples of addressing modes in various syntaxes:

     Gforth          Intel (NASM)   AT&T (gas)      Name
     .w ax           ax             %ax             register (16 bit)
     ax              eax            %eax            register (32 bit)
     3 #             offset 3       $3              immediate
     1000 #)         byte ptr 1000  1000            displacement
     bx )            [ebx]          (%ebx)          base
     100 di d)       100[edi]       100(%edi)       base+displacement
     20 ax *4 i#)    20[eax*4]      20(,%eax,4)     (index*scale)+displacement
     di ax *4 i)     [edi][eax*4]   (%edi,%eax,4)   base+(index*scale)
     4 bx cx di)     4[ebx][ecx]    4(%ebx,%ecx)    base+index+displacement
     12 sp ax *2 di) 12[esp][eax*2] 12(%esp,%eax,2) base+(index*scale)+displacement

   You can use ‘L)’ and ‘LI)’ instead of ‘D)’ and ‘DI)’ to enforce
32-bit displacement fields (useful for later patching).

   Some example of instructions are:

     ax bx mov             \ move ebx,eax
     3 # ax mov            \ mov eax,3
     100 di d) ax mov      \ mov eax,100[edi]
     4 bx cx di) ax mov    \ mov eax,4[ebx][ecx]
     .w ax bx mov          \ mov bx,ax

   The following forms are supported for binary instructions:

     <reg> <reg> <inst>
     <n> # <reg> <inst>
     <mem> <reg> <inst>
     <reg> <mem> <inst>
     <n> # <mem> <inst>

   The shift/rotate syntax is:

     <reg/mem> 1 # shl \ shortens to shift without immediate
     <reg/mem> 4 # shl
     <reg/mem> cl shl

   Precede string instructions (‘movs’ etc.)  with ‘.b’ to get the byte
version.

   The control structure words ‘IF’ ‘UNTIL’ etc.  must be preceded by
one of these conditions: ‘vs vc u< u>= 0= 0<> u<= u> 0< 0>= ps pc < >=
<= >’.  (Note that most of these words shadow some Forth words when
‘assembler’ is in front of ‘forth’ in the search path, e.g., in ‘code’
words).  Currently the control structure words use one stack item, so
you have to use ‘roll’ instead of ‘cs-roll’ to shuffle them (you can
also use ‘swap’ etc.).

   Based on the Intel ABI (used in Linux), ‘abi-code’ words can find the
data stack pointer at ‘4 sp d)’, and the address of the FP stack pointer
at ‘8 sp d)’; the data stack pointer is returned in ‘ax’; ‘Ax’, ‘cx’,
and ‘dx’ are caller-saved, so you do not need to preserve their values
inside the word.  You can return from the word with ‘ret’, the
parameters are cleaned up by the caller.

   For examples of 386 ‘abi-code’ words, see *note Assembler
Definitions::.


File: gforth.info,  Node: AMD64 Assembler,  Next: Alpha Assembler,  Prev: 386 Assembler,  Up: Assembler and Code Words

6.29.5 AMD64 (x86_64) Assembler
-------------------------------

AMD64 アセンブラは、 386 アセンブラをわずかに変更したバージョンであり、
構文の大部分を共有しています。 2 つの新しい接頭辞 ‘.q’ と ‘.qa’ が、 そ
れぞれ 64 ビット・サイズのオペランドやアドレスを選択するために提供されて
います。 64 ビット・サイズがデフォルトであるため、 通常は他のプレフィッ
クスを使用するだけで済みます。 また、 追加のレジスタ・オペランド ‘R8’ ～
‘R15’ もあります。

   レジスタには「e」または「r」プレフィックスがありません。 64 ビット・
モードでも、 ‘rax’ は ‘ax’ と呼ばれます。 すべてのレジスタで最下位バイト
を参照するために追加のレジスタ・オペランドを使用できます: ‘R8L’ 〜
-‘R15L’, ‘SPL’, ‘BPL’, ‘SIL’, ‘DIL’

   Linux-AMD64 の呼び出し規則では、 最初の 6 つの整数パラメーターを rdi,
rsi, rdx, rcx, r8, r9 で渡し、 結果を rax , rdx で返します。 最初の 8 つ
の FP パラメータを xmm0 ～ xmm7 に渡し、 FP 結果を xmm0 ～ xmm1 に返しま
す。 したがって、‘abi-code’ ワードは、 ‘di’ でデータ・スタック・ポインタ
を取得し、 ‘si’ で FP スタック・ポインタのアドレスを取得し、 リターン時
は ‘ax’ にデータ・スタック ポインタをセットします。 呼び出し元が保存する
他のレジスタは、 r10, r11 xmm8 ～ xmm15 です。 この呼び出し規約は、
Microsoft 以外の他の OS でも使用されていると報告されています。

   Windows x64 は、 最初の 4 つの整数パラメータを rcx, rdx, r8, r9 に渡
し、 整数の結果を rax に返します。 他の、呼び出し元保存レジスタは r10 と
r11 です。

   <https://uclibc.org/docs/psABI-x86_64.pdf> の 21ページによると、
Linux プラットフォームでは、 レジスタ AX CX DX SI DI R8 R9 R10 R11 が自
由(scratch)に使えます。

   AMD64 のアドレッシング・モードは以下のとおりです:

     \ ご注意: ワード A を実行すると、レジスタが初期化されていないため、 メモリ・エラーが発生します ;-)
     ABI-CODE A  ( -- )
         500        #               AX  MOV     \ immediate
             DX              AX  MOV     \ register
             200             AX  MOV     \ direct addressing
             DX  )           AX  MOV     \ indirect addressing
         40  DX  D)          AX  MOV     \ base with displacement
             DX  CX      I)  AX  MOV     \ scaled index
             DX  CX  *4  I)  AX  MOV     \ scaled index
         40  DX  CX  *4  DI) AX  MOV     \ scaled index with displacement

             DI              AX  MOV     \ SP Out := SP in
                                 RET
     END-CODE

   AMD64 ‘abi-code’ ワードの例をいくつか示します:

     abi-code my+  ( n1 n2 -- n3 )
     \ SP passed in di, returned in ax,  address of FP passed in si
     8 di d) ax lea        \ compute new sp in result reg ( 結果として di+8 → ax つまり drop と同じ)
     di )    dx mov        \ get old tos ( [di] つまり n2   → dx )
     dx    ax ) add        \ add to new tos ( dx + [ax] → [ax]
     ret
     end-code

     \ Do nothing
     ABI-CODE aNOP  ( -- )
            DI  )       AX      LEA          \ SP out := SP in
                                RET
     END-CODE

     \ Drop TOS
     ABI-CODE aDROP  ( n -- )
        8   DI  D)      AX      LEA          \ SPout := SPin - 1
                                RET
     END-CODE

     \ Push 5 on the data stack
     ABI-CODE aFIVE   ( -- 5 )
        -8  DI  D)      AX      LEA          \ SPout := SPin + 1
        5   #           AX  )   MOV          \ TOS := 5
                                RET
     END-CODE

     \ Push 10 and 20 into data stack
     ABI-CODE aTOS2  ( -- n n )
        -16 DI  D)      AX      LEA          \ SPout := SPin + 2
        10  #       8   AX  D)  MOV          \ TOS - 1 := 10
        20  #           AX  )   MOV          \ TOS := 20
                                RET
     END-CODE

     \ Get Time Stamp Counter as two 32 bit integers
     \ The TSC is incremented every CPU clock pulse
     ABI-CODE aRDTSC   ( -- TSCl TSCh )
                                RDTSC        \ DX:AX := TSC
        $FFFFFFFF #     AX      AND          \ Clear upper 32 bit AX
       0xFFFFFFFF #     DX      AND          \ Clear upper 32 bit DX
            AX          R8      MOV          \ Tempory save AX
        -16 DI  D)      AX      LEA          \ SPout := SPin + 2
            R8      8   AX  D)  MOV          \ TOS-1 := saved AX = TSC low
            DX          AX  )   MOV          \ TOS := Dx = TSC high
                                RET
     END-CODE

     \ Get Time Stamp Counter as 64 bit integer
     ABI-CODE RDTSC   ( -- TSC )
                                RDTSC        \ DX:AX := TSC
        $FFFFFFFF #     AX      AND          \ Clear upper 32 bit AX
        32  #           DX      SHL          \ Move lower 32 bit DX to upper 32 bit
            AX          DX      OR           \ Combine AX wit DX in DX
        -8  DI  D)      AX      LEA          \ SPout := SPin + 1
            DX          AX  )   MOV          \ TOS := DX
                                RET
     END-CODE

     VARIABLE V

     \ Assign 4 to variable V
     ABI-CODE V=4 ( -- )
            BX                  PUSH         \ Save BX, used by gforth
        V   #           BX      MOV          \ BX := address of V
        4   #           BX )    MOV          \ Write 4 to V
            BX                  POP          \ Restore BX
            DI  )       AX      LEA          \ SPout := SPin
                                RET
     END-CODE

     VARIABLE V

     \ Assign 5 to variable V
     ABI-CODE V=5 ( -- )
        V   #           CX      MOV          \ CX := address of V
        5   #           CX )    MOV          \ Write 5 to V
        DI )            AX      LEA          \ SPout := SPin
                                RET
     END-CODE

     ABI-CODE TEST2  ( -- n n )
        -16 DI  D)  AX          LEA          \ SPout := SPin + 2
        5   #       CX          MOV          \ CX := 5
        5   #       CX          CMP
        0= IF
            1   #   8   AX  D)      MOV      \ If CX = 5 then TOS - 1 := 1  <--
        ELSE
            2   #   8   AX  D)      MOV      \ else TOS - 1 := 2
        THEN
        6   #       CX          CMP
        0= IF
            3   #       AX  )       MOV      \ If CX = 6 then TOS := 3
        ELSE
            4   #       AX  )       MOV      \ else TOS := 4  <--
        THEN
                                RET
     END-CODE

     \ Do four loops. Expect : ( 4 3 2 1 -- )
     ABI-CODE LOOP4  ( -- n n n n )
            DI          AX      MOV          \ SPout := SPin
        4   #           DX      MOV          \ DX := 4  loop counter
        BEGIN
            8   #           AX      SUB      \ SP := SP + 1
                DX          AX  )   MOV      \ TOS := DX
            1   #           DX      SUB      \ DX := DX - 1
        0= UNTIL
                                RET
     END-CODE

   Here’s a AMD64 example that deals with FP values:

     abi-code my-f+  ( r1 r2 -- r )
     \ SP passed in di, returned in ax,  address of FP passed in si
     si )       dx mov         \ load fp
     8 dx d)  xmm0 movsd       \ r2
     dx )     xmm0 addsd       \ r1+r2
     xmm0  8 dx d) movsd       \ store r
     8 #      si ) add         \ update fp
     di         ax mov         \ sp into return reg
     ret
     end-code


File: gforth.info,  Node: Alpha Assembler,  Next: MIPS assembler,  Prev: AMD64 Assembler,  Up: Assembler and Code Words

6.29.6 Alpha Assembler
----------------------

The Alpha assembler and disassembler were originally written by Bernd
Thallner.

   The register names ‘a0’–‘a5’ are not available to avoid shadowing hex
numbers.

   Immediate forms of arithmetic instructions are distinguished by a ‘#’
just before the ‘,’, e.g., ‘and#,’ (note: ‘lda,’ does not count as
arithmetic instruction).

   You have to specify all operands to an instruction, even those that
other assemblers consider optional, e.g., the destination register for
‘br,’, or the destination register and hint for ‘jmp,’.

   You can specify conditions for ‘if,’ by removing the first ‘b’ and
the trailing ‘,’ from a branch with a corresponding name; e.g.,

     11 fgt if, \ if F11>0e
       ...
     endif,

   ‘fbgt,’ gives ‘fgt’.


File: gforth.info,  Node: MIPS assembler,  Next: PowerPC assembler,  Prev: Alpha Assembler,  Up: Assembler and Code Words

6.29.7 MIPS assembler
---------------------

The MIPS assembler was originally written by Christian Pirker.

   Currently the assembler and disassembler covers most of the MIPS32
architecture and doesn’t support FP instructions.

   The register names ‘$a0’–‘$a3’ are not available to avoid shadowing
hex numbers.  Use register numbers ‘$4’–‘$7’ instead.

   Nothing distinguishes registers from immediate values.  Use explicit
opcode names with the ‘i’ suffix for instructions with immediate
argument.  E.g.  ‘addiu,’ in place of ‘addu,’.

   Where the architecture manual specifies several formats for the
instruction (e.g., for ‘jalr,’),use the one with more arguments (i.e.
two for ‘jalr,’).  When in doubt, see ‘arch/mips/testasm.fs’ for an
example of correct use.

   Branches and jumps in the MIPS architecture have a delay slot.  You
have to fill it manually (the simplest way is to use ‘nop,’), the
assembler does not do it for you (unlike ‘as’).  Even ‘if,’, ‘ahead,’,
‘until,’, ‘again,’, ‘while,’, ‘else,’ and ‘repeat,’ need a delay slot.
Since ‘begin,’ and ‘then,’ just specify branch targets, they are not
affected.  For branches the argument specifying the target is a relative
address.  Add the address of the delay slot to get the absolute address.

   Note that you must not put branches nor jumps (nor control-flow
instructions) into the delay slot.  Also it is a bad idea to put
pseudo-ops such as ‘li,’ into a delay slot, as these may expand to
several instructions.  The MIPS I architecture also had load delay
slots, and newer MIPSes still have restrictions on using ‘mfhi,’ and
‘mflo,’.  Be careful to satisfy these restrictions, the assembler does
not do it for you.

   Some example of instructions are:

     $ra  12 $sp  sw,         \ sw    ra,12(sp)
     $4    8 $s0  lw,         \ lw    a0,8(s0)
     $v0  $0  lui,            \ lui   v0,0x0
     $s0  $s4  $12  addiu,    \ addiu s0,s4,0x12
     $s0  $s4  $4  addu,      \ addu  s0,s4,$a0
     $ra  $t9  jalr,          \ jalr  t9

   You can specify the conditions for ‘if,’ etc.  by taking a
conditional branch and leaving away the ‘b’ at the start and the ‘,’ at
the end.  E.g.,

     4 5 eq if,
       ... \ do something if $4 equals $5
     then,

   The calling conventions for 32-bit MIPS machines is to pass the first
4 arguments in registers ‘$4’..‘$7’, and to use ‘$v0’-‘$v1’ for return
values.  In addition to these registers, it is ok to clobber registers
‘$t0’-‘$t8’ without saving and restoring them.

   If you use ‘jalr,’ to call into dynamic library routines, you must
first load the called function’s address into ‘$t9’, which is used by
position-indirect code to do relative memory accesses.

   Here is an example of a MIPS32 ‘abi-code’ word:

     abi-code my+  ( n1 n2 -- n3 )
       \ SP passed in $4, returned in $v0
       $t0  4 $4  lw,         \ load n1, n2 from stack
       $t1  0 $4  lw,
       $t0  $t0  $t1  addu,   \ add n1+n2, result in $t0
       $t0  4 $4  sw,         \ store result (overwriting n1)
       $ra  jr,               \ return to caller
       $v0  $4  4  addiu,     \ (delay slot) return uptated SP in $v0
     end-code


File: gforth.info,  Node: PowerPC assembler,  Next: ARM Assembler,  Prev: MIPS assembler,  Up: Assembler and Code Words

6.29.8 PowerPC assembler
------------------------

The PowerPC assembler and disassembler were contributed by Michal
Revucky.

   This assembler does not follow the convention of ending mnemonic
names with a “,”, so some mnemonic names shadow regular Forth words (in
particular: ‘and or xor fabs’); so if you want to use the Forth words,
you have to make them visible first, e.g., with ‘also forth’.

   Registers are referred to by their number, e.g., ‘9’ means the
integer register 9 or the FP register 9 (depending on the instruction).

   Because there is no way to distinguish registers from immediate
values, you have to explicitly use the immediate forms of instructions,
i.e., ‘addi,’, not just ‘add,’.

   The assembler and disassembler usually support the most general form
of an instruction, but usually not the shorter forms (especially for
branches).


File: gforth.info,  Node: ARM Assembler,  Next: Other assemblers,  Prev: PowerPC assembler,  Up: Assembler and Code Words

6.29.9 ARM Assembler
--------------------

The ARM assembler includes all instruction of ARM architecture version
4, and the BLX instruction from architecture 5.  It does not (yet) have
support for Thumb instructions.  It also lacks support for any
co-processors.

   The assembler uses a postfix syntax with the same operand order as
used in the ARM Architecture Reference Manual.  Mnemonics are suffixed
by a comma.

   Registers are specified by their names ‘r0’ through ‘r15’, with the
aliases ‘pc’, ‘lr’, ‘sp’, ‘ip’ and ‘fp’ provided for convenience.  Note
that ‘ip’ refers to the“intra procedure call scratch register” (‘r12’)
and does not refer to an instruction pointer.  ‘sp’ refers to the ARM
ABI stack pointer (‘r13’) and not the Forth stack pointer.

   Condition codes can be specified anywhere in the instruction, but
will be most readable if specified just in front of the mnemonic.  The
’S’ flag is not a separate word, but encoded into instruction mnemonics,
ie.  just use ‘adds,’ instead of ‘add,’ if you want the status register
to be updated.

   The following table lists the syntax of operands for general
instructions:

     Gforth          normal assembler      description
     123 #           #123                  immediate
     r12             r12                   register
     r12 4 #LSL      r12, LSL #4           shift left by immediate
     r12 r1 LSL      r12, LSL r1           shift left by register
     r12 4 #LSR      r12, LSR #4           shift right by immediate
     r12 r1 LSR      r12, LSR r1           shift right by register
     r12 4 #ASR      r12, ASR #4           arithmetic shift right
     r12 r1 ASR      r12, ASR r1           ... by register
     r12 4 #ROR      r12, ROR #4           rotate right by immediate
     r12 r1 ROR      r12, ROR r1           ... by register
     r12 RRX         r12, RRX              rotate right with extend by 1

   Memory operand syntax is listed in this table:

     Gforth            normal assembler      description
     r4 ]              [r4]                  register
     r4 4 #]           [r4, #+4]             register with immediate offset
     r4 -4 #]          [r4, #-4]             with negative offset
     r4 r1 +]          [r4, +r1]             register with register offset
     r4 r1 -]          [r4, -r1]             with negated register offset
     r4 r1 2 #LSL -]   [r4, -r1, LSL #2]     with negated and shifted offset
     r4 4 #]!          [r4, #+4]!            immediate preincrement
     r4 r1 +]!         [r4, +r1]!            register preincrement
     r4 r1 -]!         [r4, +r1]!            register predecrement
     r4 r1 2 #LSL +]!  [r4, +r1, LSL #2]!    shifted preincrement
     r4 -4 ]#          [r4], #-4             immediate postdecrement
     r4 r1 ]+          [r4], r1              register postincrement
     r4 r1 ]-          [r4], -r1             register postdecrement
     r4 r1 2 #LSL ]-   [r4], -r1, LSL #2     shifted postdecrement
     ' xyz >body [#]   xyz                   PC-relative addressing

   Register lists for load/store multiple instructions are started and
terminated by using the words ‘{’ and ‘}’ respectively.  Between braces,
register names can be listed one by one or register ranges can be formed
by using the postfix operator ‘r-r’.  The ‘^’ flag is not encoded in the
register list operand, but instead directly encoded into the instruction
mnemonic, ie.  use ‘^ldm,’ and ‘^stm,’.

   Addressing modes for load/store multiple are not encoded as
instruction suffixes, but instead specified like an addressing mode, Use
one of ‘DA’, ‘IA’, ‘DB’, ‘IB’, ‘DA!’, ‘IA!’, ‘DB!’ or ‘IB!’.

   The following table gives some examples:

     Gforth                           normal assembler
     r4 ia  { r0 r7 r8 }  stm,        stmia    r4, {r0,r7,r8}
     r4 db!  { r0 r7 r8 }  ldm,       ldmdb    r4!, {r0,r7,r8}
     sp ia!  { r0 r15 r-r }  ^ldm,    ldmfd    sp!, {r0-r15}^

   Control structure words typical for Forth assemblers are available:
‘if,’ ‘ahead,’ ‘then,’ ‘else,’ ‘begin,’ ‘until,’ ‘again,’ ‘while,’
‘repeat,’ ‘repeat-until,’.  Conditions are specified in front of these
words:

     r1 r2 cmp,    \ compare r1 and r2
     eq if,        \ equal?
        ...          \ code executed if r1 == r2
     then,

   Example of a definition using the ARM assembler:

     abi-code my+ ( n1 n2 --  n3 )
        \ arm abi: r0=SP, r1=&FP, r2,r3,r12 saved by caller
        r0 IA!  { r2 r3 }  ldm,     \ pop r2 = n2, r3 = n1
        r3  r2  r3         add,     \ r3 = n1+n1
        r3  r0 -4 #]!      str,     \ push r3
        pc  lr             mov,     \ return to caller, new SP in r0
     end-code


File: gforth.info,  Node: Other assemblers,  Prev: ARM Assembler,  Up: Assembler and Code Words

6.29.10 Other assemblers
------------------------

If you want to contribute another assembler/disassembler, please contact
us (<anton@mips.complang.tuwien.ac.at>) to check if we have such an
assembler already.  If you are writing them from scratch, please use a
similar syntax style as the one we use (i.e., postfix, commas at the end
of the instruction names, *note Common Assembler::); make the output of
the disassembler be valid input for the assembler, and keep the style
similar to the style we used.

   Hints on implementation: The most important part is to have a good
test suite that contains all instructions.  Once you have that, the rest
is easy.  For actual coding you can take a look at ‘arch/mips/disasm.fs’
to get some ideas on how to use data for both the assembler and
disassembler, avoiding redundancy and some potential bugs.  You can also
look at that file (and *note Advanced does> usage example::) to get
ideas how to factor a disassembler.

   Start with the disassembler, because it’s easier to reuse data from
the disassembler for the assembler than the other way round.

   For the assembler, take a look at ‘arch/alpha/asm.fs’, which shows
how simple it can be.


File: gforth.info,  Node: Carnal words,  Next: Passing Commands to the OS,  Prev: Assembler and Code Words,  Up: Words

6.30 Carnal words
=================

These words deal with the mechanics of Gforth (in Forth circles called
“carnal knowledge” of a Forth system), but we consider them stable
enough to document them.

* Menu:

* Header fields::
* Header methods::
* Threading Words::


File: gforth.info,  Node: Header fields,  Next: Header methods,  Prev: Carnal words,  Up: Carnal words

6.30.1 Header fields
--------------------

In Gforth 1.0 we switched to a new word header layout.  For a detailed
description, read: Bernd Paysan and M. Anton Ertl.  ‘The new Gforth
header (http://www.euroforth.org/ef19/papers/paysan.pdf)’.  In 35th
EuroForth Conference, pages 5-20, 2019.  Since this paper was published,
xt and nt have been changed to point to the parameter field, like the
body, but otherwise it is still up-to-date.

   This section explains just the data structure and the words used to
access it.  A header has the following fields:

     name
     >f+c
     >link
     >cfa
     >namehm
     >body

   Currently Gforth has the names shown above for getting from the
xt/nt/body to the field, but apart from the standard ‘>body’ they are
not stable Gforth words.  Instead, we provide access words.  Note that
the documented access words have survived the reorganization of the
header layout.

   Some of the words expect an nt, some expect an xt.  Given that both
nt and xt point to the body of a word, what is the difference?  For most
words, the xt and nt use the same header, and with nt=xt, they point to
the same place.  However, for a synonym (*note Aliases::) there is a
difference; consider the example

     create x
     synonym y x
     synonym z y

   In this case the nt of ‘z’ points to the body of ‘z’, while the xt of
‘z’ points to the body of ‘x’.  Words defined with ‘alias’ or ‘forward’
(*note Forward::) also have different nts and xts.

   The name field is variable-length and is accessed with ‘name>string’
(*note Name token::).

   The ‘>f+c’ field contains flags and the name length (count).  You
read the count with ‘name>string’, and the flags with

‘compile-only?’ ( nt – flag  ) gforth-1.0 “compile-only?”
   true if nt is marked as compile-only.

   The ‘>link’ field contains a link to the previous word in the same
word list.  You can read it with ‘name>link’ (*note Name token::).

   The name, ‘>f+c’ and ‘>link’ fields are not present for ‘noname’
words, but ‘name>string’ and ‘name>link’ work nevertheless, producing 0
0 and 0, respectively.

   The ‘>cfa’ field (aka code field) contains the code address used for
‘execute’ing the word; you can read it with ‘>code-address’ and write it
with ‘code-address!’ (*note Threading Words::).

   The ‘>namehm’ field contains the address of the header methods table,
described below.  You access it by performing or accessing header
methods (*note Header methods::).

   The ‘>body’ (aka parameter) field contains data or threaded code
specific to the word type; its length depends on the word type.  E.g.,
for a ‘constant’ it contains a cell with the value of the constant.  You
can access it through ‘>body’ (*note CREATE..DOES> details::), but this
is only standard for words you defined with ‘create’.


File: gforth.info,  Node: Header methods,  Next: Threading Words,  Prev: Header fields,  Up: Carnal words

6.30.2 Header methods
---------------------

The new Gforth word header is object-oriented and supports the following
methods (method selectors):

     .hm label method          overrider        field
               execute         set-execute      >cfa
     opt:      opt-compile,    set-optimizer    >hmcompile,
     to:       (to)            set-to           >hmto
     extra:                                     >hmextra
     >int:     name>interpret  set->int         >hm>int
     >comp:    name>compile    set->comp        >hm>comp
     >string:  name>string     set-name>string  >hm>string
     >link:    name>link       set-name>link    >hm>link

   Many of these words are not stable Gforth words, but Gforth has
stable higher-level words that we mention below.

   You can look at the header methods of a word with

‘.hm’ ( nt –  ) gforth-1.0 “dot-h-m”
   print the header methods of nt

   Overrider (setter) words change the method implementation for the
most recent definition.  Quotations or closures restore the previous
most recent definition when they are completed, so they are not
considered most recent, and you can do things like:

     : my2dup over over ;
     [: drop ]] over over [[ ;] set-optimizer

   The ‘execute’ method is actually stored in the ‘>cfa’ field in the
header rather than in the header-methods table for performance reasons;
also it is implemented through a native-code address, while the other
methods are implemented by calling an xt.  The high-level way to set
this method is

‘set-execute’ ( ca –  ) gforth-1.0 “set-execute”
   Changes the current word such that it jumps to the native code at ca.
Also changes the ‘compile,’ implementation to the most general (and
slowest) one.  Call ‘set-optimizer’ afterwards if you want a more
efficient ‘compile,’ implementation.

   To get a code address for use with ‘set-execute’, you can use words
like ‘docol:’ or ‘>code-address’, *Note Threading Words::.

   As an alternative to ‘set-execute’, there is also ‘set-does>’ (*note
User-defined Defining Words::), which takes an xt.

   Moreover, there are the low-level ‘code-address!’ and ‘definer!’
(*note Threading Words::).

   The ‘opt-compile,’ method is what ‘compile,’ does on most Gforth
engines (‘gforth-itc’ uses ‘,’ instead).  You can define a more
efficient implementation of ‘compile,’ for the current word with
‘set-optimizer’ (*note User-defined compile-comma::).  Note that the end
result must be equivalent to ‘postpone literal postpone execute’.

   As an example of the use of ‘set-optimizer’, consider the following
definition of ‘constant’:

     : constant ( n "name" -- ; name: -- n )
       create ,
       ['] @ set-does>
     ;

     5 constant five
     : foo five ; see foo

   The Forth system does not know that the value of a constant must not
be changed, and just sees a ‘create’d word (which can be changed with
‘>body’), and ‘foo’ first pushes the body address of ‘five’ and then
fetches from there.  With ‘set-optimizer’ the definition of ‘constant’
can be optimized as follows:

     : constant ( n "name" -- ; name: -- n )
       create ,
       ['] @ set-does>
       [: >body @ postpone literal ;] set-optimizer
     ;

   Now ‘foo’ contains the literal 5 rather than a call to ‘five’.

   Note that ‘set-execute’ and ‘set-does>’ perform ‘set-optimizer’
themselves in order to ensure that ‘execute’ and ‘compile,’ agree, so if
you want to add your own optimizer, you should add it afterwards.

   The ‘defer!’ (aka ‘(to)’ method (*note User-defined TO and DEFER@::)
implements ‘defer!’ for words defined with ‘defer’ and similar words,
but it is also the core of ‘to’.  The general stack effect of the
‘defer!’/‘(to)’ method is ‘( val xt -- )’, where xt identifies the word
stored into, and val is the value (of appropriate type) stored there.

   たとえば、 以下のように ‘fvalue’ を実装できます:

     : fvalue-to ( r xt -- ) >body f! ;

     : fvalue ( r -- )
       create f,
       ['] f@ set-does>
       ['] fvalue-to set-to ;

     5e fvalue foo
     : bar foo 1e f+ to foo ;
     see bar

   You can improve the generated code with ‘set-optimizer’:

     : compile-fvalue-to ( xt-value-to -- )
       drop ]] >body f! [[ ;

     : fvalue-to ( r xt -- ) >body f! ;
     ' compile-fvalue-to set-optimizer

     : fvalue ( r -- )
       create f,
       ['] f@ set-does>
       [: >body ]] literal f@ [[ ;] set-optimizer
       ['] fvalue-to set-to ;

     5e fvalue foo
     : bar foo 1e f+ to foo ;
     see bar

   In practice Gforth has a few additional twists to implement, e.g.,
‘+TO’.

   ‘Set-defer@’ (*note User-defined TO and DEFER@::) allows to implement
variants of the ‘defer@’ (*note Deferred Words::) method for
‘defer’-like words.

   The ‘>hmextra’ field is used for cases where additional data needs to
be stored in the header methods table.  In particular, it stores the xt
passed to ‘set-does>’ (and ‘does>’ calls ‘set-does>’) and the code
address behind ‘;abi-code’.

   The methods above all consume an xt, not an nt, but the override
words work on the most recent definition.  This means that if you use,
e.g., ‘set-optimizer’ on a synonym, the effect will probably not be what
you intended: When ‘compile,’ing the xt of the word, the ‘opt-compile,’
implementation of the original word will be used, not the freshly-set
one of the synonym.

   The following methods consume an nt.

   The ‘name>interpret’ method is implemented as noop for most words,
except synonyms and similar words.

‘set->int’ ( xt –  ) gforth-1.0 “set-to-int”
   Sets the implementation of the ‘name>interpret ( nt -- xt2 )’ method
of the current word to xt.

   The ‘name>compile’ method produces the compilation semantics of the
nt.  By changing it with ‘set->comp’, you can change the compilation
semantics, but it’s not as simple as just pushing the xt of the desired
compilation semantics, because of the stack effect of ‘name>compile’.
Generally you should avoid changing the compilation semantics, and if
you do, use a higher-level word like ‘immediate’ or
‘interpret/compile:’, *Note Combined words::.

‘set->comp’ ( xt –  ) gforth-1.0 “set-to-comp”
   Sets the implementation of the ‘name>compile ( nt -- w xt2 )’ method
of the current word to xt.

‘immediate?’ ( nt – flag  ) gforth-1.0 “immediate?”
   true if the word nt has non-default compilation semantics (that’s not
quite according to the definition of immediacy, but many people mean
that when they call a word “immediate”).

   ‘Name>string’ and ‘Name>link’ are methods in order to make it
possible to eliminate the name, ‘>f+c’ and ‘link’ fields from noname
headers, but still produce meaningful results when using these words.
You will typically not change the implementations of these methods
except with ‘noname’, but we still have

‘set-name>string’ ( xt –  ) gforth-1.0 “set-name-to-string”
   Sets the implementation of the ‘name>string ( nt -- addr u )’ method
of the current word to xt.

‘set-name>link’ ( xt –  ) gforth-1.0 “set-name-to-link”
   Sets the implementation of the ‘name>link ( nt1 -- nt2|0 )’ method of
the current word to xt.


File: gforth.info,  Node: Threading Words,  Prev: Header methods,  Up: Carnal words

6.30.3 Threading Words
----------------------

The terminology used here stems from indirect threaded Forth systems; in
such a system, the XT of a word is represented by the CFA (code field
address) of a word; the CFA points to a cell that contains the code
address.  The code address is the address of some machine code that
performs the run-time action of invoking the word (e.g., the ‘dovar:’
routine pushes the address of the body of the word (a variable) on the
stack).

   These words provide access to code fields, code addresses and other
threading stuff in Gforth.  It more or less abstracts away the
differences between direct and indirect threading.

   Up to and including Gforth 0.7, the code address (plus, for
‘does>’-defined words, the address returned by ‘>does-code’) was
sufficient to know the type of the word.  However, since Gforth-1.0 the
behaviour or at least implementation of words like ‘compile,’ and
‘name>compile’ can be determined independently as described in *note
Header methods::.

   The following words for create a code field and at the same time
initialize the header methods:

‘hmcopy,’ ( xt –  ) gforth-experimental “hmcopy-comma”
   While constructing a header, allocate the code field, and use xt as
prototype for setting the code field and the header methods.

‘docol,’ ( –  ) gforth-1.0 “docol,”
   The code address of a colon definition.

‘docon,’ ( –  ) gforth-1.0 “docon,”
   The code address of a ‘CONSTANT’.

‘dovar,’ ( –  ) gforth-1.0 “dovar,”
   The code address of a ‘CREATE’d word.

‘douser,’ ( –  ) gforth-1.0 “douser,”
   The code address of a ‘USER’ variable.

‘dodefer,’ ( –  ) gforth-1.0 “dodefer,”
   The code address of a ‘defer’ed word.

‘dofield,’ ( –  ) gforth-1.0 “dofield,”
   The code address of a ‘field’.

‘dovalue,’ ( –  ) gforth-1.0 “dovalue,”
   The code address of a ‘CONSTANT’.

‘doabicode,’ ( –  ) gforth-1.0 “doabicode,”
   The code address of a ‘ABI-CODE’ definition.

   For ‘does>’-defined words, use ‘hmcopy,’.

   Or you use a higher-level word like ‘create-from’ (*note Creating
from a prototype::).

   The following words were designed before the introduction of header
methods, and are therefore not the best (and recommended) way to deal
with different word types in Gforth.

   In an indirect threaded Forth, you can get the code address of name
with ‘' name @’; in Gforth you can get it with ‘' name >code-address’,
independent of the threading method.

‘threading-method’ ( – n ) gforth-0.2 “threading-method”
   0 if the engine is direct threaded.  Note that this may change during
the lifetime of an image.

‘>code-address’ ( xt – c_addr  ) gforth-0.2 “>code-address”
   c-addr is the code address of the word xt.

‘code-address!’ ( c_addr xt –  ) gforth-obsolete “code-address!”
   Change a code field with code address c-addr at xt.

   The code addresses produced by various defining words are produced by
the following words:

‘docol:’ ( – addr  ) gforth-0.2 “docol:”
   The code address of a colon definition.

‘docon:’ ( – addr  ) gforth-0.2 “docon:”
   The code address of a ‘CONSTANT’.

‘dovar:’ ( – addr  ) gforth-0.2 “dovar:”
   The code address of a ‘CREATE’d word.

‘douser:’ ( – addr  ) gforth-0.2 “douser:”
   The code address of a ‘USER’ variable.

‘dodefer:’ ( – addr  ) gforth-0.2 “dodefer:”
   The code address of a ‘defer’ed word.

‘dofield:’ ( – addr  ) gforth-0.2 “dofield:”
   The code address of a ‘field’.

‘dovalue:’ ( – addr  ) gforth-0.7 “dovalue:”
   The code address of a ‘CONSTANT’.

‘dodoes:’ ( – addr  ) gforth-0.6 “dodoes:”
   The code address of a ‘DOES>’-defined word.

‘doabicode:’ ( – addr  ) gforth-1.0 “doabicode:”
   The code address of a ‘ABI-CODE’ definition.

   For a word X defined with ‘set-does>’, the code address points to
‘dodoes:’, and the ‘>hmextra’ field of the header methods contains the
xt of the word that is called after pushing the body addres of X.

   If you want to know whether a word is a ‘DOES>’-defined word, and
what Forth code it executes, ‘>does-code’ tells you that:

‘>does-code’ ( xt1 – xt2  ) gforth-0.2 “>does-code”
   If xt1 is the execution token of a child of a ‘set-does>’-defined
word, xt2 is the xt passed to ‘set-does>’, i.e, the xt of the word that
is executed when executing xt1 (but first the body address of xt1 is
pushed).  If xt1 does not belong to a ‘set-does>’-defined word, xt2 is
0.

   You can use the resulting xt2 with ‘set-does>’ (preferred) to change
the latest word or with

‘does-code!’ ( xt2 xt1 –  ) gforth-0.2 “does-code!”
   Change xt1 to be a ‘xt2 set-does>’-defined word.

   to change an arbitrary word.

   The following two words generalize ‘>code-address’, ‘>does-code’,
‘code-address!’, and ‘does-code!’:

‘>definer’ ( xt – definer  ) gforth-0.2 “>definer”
   DEFINER is a unique identifier for the way the XT was defined.  Words
defined with different ‘does>’-codes have different definers.  The
definer can be used for comparison and in ‘definer!’.

‘definer!’ ( definer xt –  ) gforth-obsolete “definer!”
   The word represented by XT changes its behaviour to the behaviour
associated with DEFINER.

   ‘Code-address!’, ‘does-code!’, and ‘definer!’ update the
‘opt-compile,’ method to a somewhat generic compiler for that word type
(in particular, primitives get the slow ‘general-compile,’ method rather
than the primitive-specific ‘peephole-compile,’).


File: gforth.info,  Node: Passing Commands to the OS,  Next: Keeping track of Time,  Prev: Carnal words,  Up: Words

6.31 Passing Commands to the Operating System
=============================================

Gforth allows you to pass an arbitrary string to the host operating
system shell (if such a thing exists) for execution.

‘sh’ ( "..." –  ) gforth-0.2 “sh”
   Execute the rest of the command line as shell command(s).
Afterwards, ‘$?’ produces the exit status of the command.

‘system’ ( c-addr u –  ) gforth-0.2 “system”
   Pass the string specified by C-ADDR U to the host operating system
for execution in a sub-shell.  Afterwards, ‘$?’ produces the exit status
of the command.  The value of the environment variable
‘GFORTHSYSTEMPREFIX’ (or its default value) is prepended to the string
(mainly to support using ‘command.com’ as shell in Windows instead of
whatever shell Cygwin uses by default; *note Environment variables::).

‘sh-get’ ( c-addr u – c-addr2 u2  ) gforth-1.0 “sh-get”
   Run the shell command addr u; c-addr2 u2 is the output of the
command.  The exit code is in ‘$?’, the output also in ‘sh$ 2@’.

‘$?’ ( – n  ) gforth-0.2 “dollar-question”
   ‘Value’ – the exit status returned by the most recently executed
‘system’ command.

‘getenv’ ( c-addr1 u1 – c-addr2 u2 ) gforth-0.2 “getenv”
   The string c-addr1 u1 specifies an environment variable.  The string
c-addr2 u2 is the host operating system’s expansion of that environment
variable.  If the environment variable does not exist, c-addr2 u2
specifies a string 0 characters in length.


File: gforth.info,  Node: Keeping track of Time,  Next: Miscellaneous Words,  Prev: Passing Commands to the OS,  Up: Words

6.32 Keeping track of Time
==========================

‘ms’ ( n –  ) facility-ext “ms”

‘ns’ ( d –  ) gforth-1.0 “ns”

‘time&date’ ( – nsec nmin nhour nday nmonth nyear  ) facility-ext “time-and-date”
   Report the current time of day.  Seconds, minutes and hours are
numbered from 0.  Months are numbered from 1.

‘>time&date&tz’ ( udtime – nsec nmin nhour nday nmonth nyear fdst ndstoff c-addrtz utz ) gforth-1.0 “to-time-and-date”
   Convert time in seconds since 1.1.1970 0:00Z to the current time of
day.  Seconds, minutes and hours are numbered from 0.  Months are
numbered from 1.

‘utime’ ( – dtime ) gforth-0.5 “utime”
   Report the current time in microseconds since some epoch.  Use
‘#1000000 um/mod nip’ to convert to seconds

‘ntime’ ( – dtime ) gforth-1.0 “ntime”
   Report the current time in nanoseconds since some epoch.

‘cputime’ ( – duser dsystem ) gforth-0.5 “cputime”
   duser and dsystem are the respective user- and system-level CPU times
used since the start of the Forth system (excluding child processes), in
microseconds (the granularity may be much larger, however).  On
platforms without the getrusage call, it reports elapsed time (since
some epoch) for duser and 0 for dsystem.


File: gforth.info,  Node: Miscellaneous Words,  Prev: Keeping track of Time,  Up: Words

6.33 Miscellaneous Words
========================

This section lists the Standard Forth words that are not documented
elsewhere in this manual.  Ultimately, they all need proper homes.

‘quit’ ( ?? – ??  ) core “quit”
   Empty the return stack, make the user input device the input source,
enter interpret state and start the text interpreter.

   The following Standard Forth words are not currently supported by
Gforth (*note Standard conformance::):

   ‘EDITOR’ ‘EMIT?’ ‘FORGET’


File: gforth.info,  Node: Error messages,  Next: Tools,  Prev: Words,  Up: Top

7 Error messages
****************

A typical Gforth error message looks like this:

     in file included from \evaluated string/:-1
     in file included from ./yyy.fs:1
     ./xxx.fs:4: Invalid memory address
     >>>bar<<<
     Backtrace:
     $400E664C @
     $400E6664 foo

   The message identifying the error is ‘Invalid memory address’.  The
error happened when text-interpreting line 4 of the file ‘./xxx.fs’.
This line is given (it contains ‘bar’), and the word on the line where
the error happened, is pointed out (with ‘>>>’ and ‘<<<’).

   The file containing the error was included in line 1 of ‘./yyy.fs’,
and ‘yyy.fs’ was included from a non-file (in this case, by giving
‘yyy.fs’ as command-line parameter to Gforth).

   At the end of the error message you find a return stack dump that can
be interpreted as a backtrace (possibly empty).  On top you find the top
of the return stack when the ‘throw’ happened, and at the bottom you
find the return stack entry just above the return stack of the topmost
text interpreter.

   To the right of most return stack entries you see a guess for the
word that pushed that return stack entry as its return address.  This
gives a backtrace.  In our case we see that ‘bar’ called ‘foo’, and
‘foo’ called ‘@’ (and ‘@’ had an _Invalid memory address_ exception).

   Note that the backtrace is not perfect: We don’t know which return
stack entries are return addresses (so we may get false positives); and
in some cases (e.g., for ‘abort"’) we cannot determine from the return
address the word that pushed the return address, so for some return
addresses you see no names in the return stack dump.

   The return stack dump represents the return stack at the time when a
specific ‘throw’ was executed.  In programs that make use of ‘catch’, it
is not necessarily clear which ‘throw’ should be used for the return
stack dump (e.g., consider one ‘throw’ that indicates an error, which is
caught, and during recovery another error happens; which ‘throw’ should
be used for the stack dump?).  Gforth presents the return stack dump for
the first ‘throw’ after the last executed (not returned-to) ‘catch’ or
‘nothrow’; this works well in the usual case.  To get the right
backtrace, you usually want to insert ‘nothrow’ or ‘['] false catch
2drop’ after a ‘catch’ if the error is not rethrown.

   ‘Gforth’ is able to do a return stack dump for throws generated from
primitives (e.g., invalid memory address, stack empty etc.);
‘gforth-fast’ is only able to do a return stack dump from a directly
called ‘throw’ (including ‘abort’ etc.).  Given an exception caused by a
primitive in ‘gforth-fast’, you will typically see no return stack dump
at all; however, if the exception is caught by ‘catch’ (e.g., for
restoring some state), and then ‘throw’n again, the return stack dump
will be for the first such ‘throw’.

   ‘gforth-fast’ also does not attempt to differentiate between division
by zero and division overflow, because that costs time in every
division.


File: gforth.info,  Node: Tools,  Next: Standard conformance,  Prev: Error messages,  Up: Top

8 Tools
*******

* Menu:

* Standard Report::          使用されたワードをワードセットごとにソートして報告します
* Stack depth changes::      このスタック値はどこから来たのか?

See also *note Emacs and Gforth::.


File: gforth.info,  Node: Standard Report,  Next: Stack depth changes,  Prev: Tools,  Up: Tools

8.1 ‘ans-report.fs’: Report the words used, sorted by wordset
=============================================================

If you want to label a Forth program as Standard Program, you must
document which wordsets the program uses.

   The ‘ans-report.fs’ tool makes it easy for you to determine which
words from which wordset and which non-standard words your application
uses.  You simply have to include ‘ans-report.fs’ before loading the
program you want to check.  After loading your program, you can get the
report with ‘print-ans-report’.  A typical use is to run this as batch
job like this:
     gforth ans-report.fs myprog.fs -e "print-ans-report bye"

   The output looks like this (for ‘compat/control.fs’):
     The program uses the following words
     from CORE :
     : POSTPONE THEN ; immediate ?dup IF 0=
     from BLOCK-EXT :
     \
     from FILE :
     (

   ‘ans-report.fs’ reports both Forth-94 and Forth-2012 wordsets.  For
words that are in both standards, it reports the wordset without suffix
(e.g., ‘CORE-EXT’).  For Forth-2012-only words, it reports the wordset
with a ‘-2012’ suffix (e.g., ‘CORE-EXT-2012’); and likewise for the
words that are Forth-94-only (i.e., that have been removed in
Forth-2012).

8.1.1 Caveats
-------------

Note that ‘ans-report.fs’ just checks which words are used, not whether
they are used in a standard-conforming way!

   Some words are defined in several wordsets in the standard.
‘ans-report.fs’ reports them for only one of the wordsets, and not
necessarily the one you expect.  It depends on usage which wordset is
the right one to specify.  E.g., if you only use the compilation
semantics of ‘S"’, it is a Core word; if you also use its interpretation
semantics, it is a File word.


File: gforth.info,  Node: Stack depth changes,  Prev: Standard Report,  Up: Tools

8.2 Stack depth changes during interpretation
=============================================

Sometimes you notice that, after loading a file, there are items left on
the stack.  The tool ‘depth-changes.fs’ helps you find out quickly where
in the file these stack items are coming from.

   The simplest way of using ‘depth-changes.fs’ is to include it before
the file(s) you want to check, e.g.:

     gforth depth-changes.fs my-file.fs

   This will compare the stack depths of the data and FP stack at every
empty line (in interpretation state) against these depths at the last
empty line (in interpretation state).  If the depths are not equal, the
position in the file and the stack contents are printed with ‘~~’ (*note
Debugging::).  This indicates that a stack depth change has occured in
the paragraph of non-empty lines before the indicated line.  It is a
good idea to leave an empty line at the end of the file, so the last
paragraph is checked, too.

   Checking only at empty lines usually works well, but sometimes you
have big blocks of non-empty lines (e.g., when building a big table),
and you want to know where in this block the stack depth changed.  You
can check all interpreted lines with

     gforth depth-changes.fs -e "' all-lines is depth-changes-filter" my-file.fs

   This checks the stack depth at every end-of-line.  So the depth
change occured in the line reported by the ‘~~’ (not in the line
before).

   Note that, while this offers better accuracy in indicating where the
stack depth changes, it will often report many intentional stack depth
changes (e.g., when an interpreted computation stretches across several
lines).  You can suppress the checking of some lines by putting
backslashes at the end of these lines (not followed by white space), and
using

     gforth depth-changes.fs -e "' most-lines is depth-changes-filter" my-file.fs


File: gforth.info,  Node: Standard conformance,  Next: Standard vs Extensions,  Prev: Tools,  Up: Top

9 Standard conformance
**********************

(標準適合度)私達の知る限り、 Gforth は…

   ANS Forth System and a Forth-2012 System
   • providing the Core Extensions word set
   • providing the Block word set
   • providing the Block Extensions word set
   • providing the Double-Number word set
   • providing the Double-Number Extensions word set
   • providing the Exception word set
   • providing the Exception Extensions word set
   • providing the Facility word set
   • providing the Facility Extensions word set, except ‘EMIT?’
   • providing the File Access word set
   • providing the File Access Extensions word set
   • providing the Floating-Point word set
   • providing the Floating-Point Extensions word set
   • providing the Locals word set
   • providing the Locals Extensions word set
   • providing the Memory-Allocation word set
   • providing the Memory-Allocation Extensions word set
   • providing the Programming-Tools word set
   • providing the Programming-Tools Extensions word set, except
     ‘EDITOR’ and ‘FORGET’
   • providing the Search-Order word set
   • providing the Search-Order Extensions word set
   • providing the String word set
   • providing the String Extensions word set
   • providing the Extended-Character wordset

   Gforth has the following environmental restrictions:

   • While processing the OS command line, if an exception is not
     caught, Gforth exits with a non-zero exit code instead of
     performing QUIT.

   • When an ‘throw’ is performed after a ‘query’, Gforth does not
     always restore the input source specification in effect at the
     corresponding catch.

   In addition, Standard Forth systems are required to document certain
implementation choices.  This chapter tries to meet these requirements
for the Forth-94 standard.  For the Forth-2012 standard, we decided to
produce the additional documentation only if there is demand.  So if you
are really missing this documentation, please let us know.

   In many cases, the following documentation gives a way to ask the
system for the information instead of providing the information
directly, in particular, if the information depends on the processor,
the operating system or the installation options chosen, or if they are
likely to change during the maintenance of Gforth.

* Menu:

* The Core Words::
* The optional Block word set::
* The optional Double Number word set::
* The optional Exception word set::
* The optional Facility word set::
* The optional File-Access word set::
* The optional Floating-Point word set::
* The optional Locals word set::
* The optional Memory-Allocation word set::
* The optional Programming-Tools word set::
* The optional Search-Order word set::


File: gforth.info,  Node: The Core Words,  Next: The optional Block word set,  Prev: Standard conformance,  Up: Standard conformance

9.1 The Core Words
==================

* Menu:

* core-idef::                Implementation Defined Options
* core-ambcond::             あいまいな条件
* core-other::               その他のシステム・ドキュメント


File: gforth.info,  Node: core-idef,  Next: core-ambcond,  Prev: The Core Words,  Up: The Core Words

9.1.1 Implementation Defined Options
------------------------------------

(Cell) aligned addresses:
     processor-dependent.  Gforth’s alignment words perform natural
     alignment (e.g., an address aligned for a datum of size 8 is
     divisible by 8).  Unaligned accesses usually result in a ‘-23
     THROW’.

‘EMIT’ and non-graphic characters:
     The character is output using the C library function (actually,
     macro) ‘putc’.

character editing of ‘ACCEPT’ and ‘EXPECT’:
     This is modeled on the GNU readline library (*note Command Line
     Editing: (readline)Readline Interaction.) with Emacs-like key
     bindings.  ‘Tab’ deviates a little by producing a full word
     completion every time you type it (instead of producing the common
     prefix of all completions).  *Note Command-line editing::.

character set:
     The character set of your computer and display device.  Gforth is
     8-bit-clean (but some other component in your system may make
     trouble).

Character-aligned address requirements:
     installation-dependent.  Currently a character is represented by a
     C ‘unsigned char’; in the future we might switch to ‘wchar_t’
     (Comments on that requested).

character-set extensions and matching of names:
     Any character except the ASCII NUL character can be used in a name.
     Matching is case-insensitive (except in ‘TABLE’s).  The matching is
     performed using the C library function ‘strncasecmp’, whose
     function is probably influenced by the locale.  E.g., the ‘C’
     locale does not know about accents and umlauts, so they are matched
     case-sensitively in that locale.  For portability reasons it is
     best to write programs such that they work in the ‘C’ locale.  Then
     one can use libraries written by a Polish programmer (who might use
     words containing ISO Latin-2 encoded characters) and by a French
     programmer (ISO Latin-1) in the same program (of course, ‘WORDS’
     will produce funny results for some of the words (which ones,
     depends on the font you are using)).  Also, the locale you prefer
     may not be available in other operating systems.  Hopefully,
     Unicode will solve these problems one day.

conditions under which control characters match a space delimiter:
     If ‘word’ is called with the space character as a delimiter, all
     white-space characters (as identified by the C macro ‘isspace()’)
     are delimiters.  ‘Parse’, on the other hand, treats space like
     other delimiters.  ‘Parse-name’, which is used by the outer
     interpreter (aka text interpreter) by default, treats all
     white-space characters as delimiters.

format of the control-flow stack:
     The data stack is used as control-flow stack.  The size of a
     control-flow stack item in cells is given by the constant
     ‘cs-item-size’.  At the time of this writing, an item consists of a
     (pointer to a) locals list (third), an address in the code
     (second), and a tag for identifying the item (TOS). The following
     tags are used: ‘defstart’, ‘live-orig’, ‘dead-orig’, ‘dest’,
     ‘do-dest’, ‘scopestart’.

conversion of digits > 35
     The characters ‘[\]^_'’ are the digits with the decimal value
     36−41.  There is no way to input many of the larger digits.

display after input terminates in ‘ACCEPT’ and ‘EXPECT’:
     The cursor is moved to the end of the entered string.  If the input
     is terminated using the ‘Return’ key, a space is typed.

exception abort sequence of ‘ABORT"’:
     The error string is stored into the variable ‘"error’ and a ‘-2
     throw’ is performed.

input line terminator:
     For interactive input, ‘C-m’ (CR) and ‘C-j’ (LF) terminate lines.
     One of these characters is typically produced when you type the
     ‘Enter’ or ‘Return’ key.

maximum size of a counted string:
     ‘s" /counted-string" environment? drop .’.  Currently 255
     characters on all platforms, but this may change.

maximum size of a parsed string:
     Given by the constant ‘/line’.  Currently 255 characters.

maximum size of a definition name, in characters:
     MAXU/8

maximum string length for ‘ENVIRONMENT?’, in characters:
     MAXU/8

method of selecting the user input device:
     The user input device is the standard input.  There is currently no
     way to change it from within Gforth.  However, the input can
     typically be redirected in the command line that starts Gforth.

method of selecting the user output device:
     ‘EMIT’ and ‘TYPE’ output to the file-id stored in the value
     ‘outfile-id’ (‘stdout’ by default).  Gforth uses unbuffered output
     when the user output device is a terminal, otherwise the output is
     buffered.

methods of dictionary compilation:
     What are we expected to document here?

number of bits in one address unit:
     ‘s" address-units-bits" environment? drop .’.  8 in all current
     platforms.

number representation and arithmetic:
     Processor-dependent.  Binary two’s complement on all current
     platforms.

ranges for integer types:
     Installation-dependent.  Make environmental queries for ‘MAX-N’,
     ‘MAX-U’, ‘MAX-D’ and ‘MAX-UD’.  The lower bounds for unsigned (and
     positive) types is 0.  The lower bound for signed types on two’s
     complement and one’s complement machines machines can be computed
     by adding 1 to the upper bound.

read-only data space regions:
     The whole Forth data space is writable.

size of buffer at ‘WORD’:
     ‘PAD HERE - .’.  104 characters on 32-bit machines.  The buffer is
     shared with the pictured numeric output string.  If overwriting
     ‘PAD’ is acceptable, it is as large as the remaining dictionary
     space, although only as much can be sensibly used as fits in a
     counted string.

size of one cell in address units:
     ‘1 cells .’.

size of one character in address units:
     ‘1 chars .’.  1 on all current platforms.

size of the keyboard terminal buffer:
     Varies.  You can determine the size at a specific time using ‘lp@
     tib - .’.  It is shared with the locals stack and TIBs of files
     that include the current file.  You can change the amount of space
     for TIBs and locals stack at Gforth startup with the command line
     option ‘-l’.

size of the pictured numeric output buffer:
     ‘PAD HERE - .’.  104 characters on 32-bit machines.  The buffer is
     shared with ‘WORD’.

size of the scratch area returned by ‘PAD’:
     The remainder of dictionary space.  ‘unused pad here - - .’.

system case-sensitivity characteristics:
     Dictionary searches are case-insensitive (except in ‘TABLE’s).
     However, as explained above under character-set extensions, the
     matching for non-ASCII characters is determined by the locale you
     are using.  In the default ‘C’ locale all non-ASCII characters are
     matched case-sensitively.

system prompt:
     ‘ ok’ in interpret state, ‘ compiled’ in compile state.

division rounding:
     The ordinary division words ‘/ mod /mod */ */mod’ perform floored
     division (with the default installation of Gforth).  You can check
     this with ‘s" floored" environment? drop .’.  If you write programs
     that need a specific division rounding, best use ‘fm/mod’ or
     ‘sm/rem’ for portability.

values of ‘STATE’ when true:
     -1.

values returned after arithmetic overflow:
     On two’s complement machines, arithmetic is performed modulo
     2**bits-per-cell for single arithmetic and 4**bits-per-cell for
     double arithmetic (with appropriate mapping for signed types).
     Division by zero typically results in a ‘-55 throw’ (Floating-point
     unidentified fault) or ‘-10 throw’ (divide by zero).  Integer
     division overflow can result in these throws, or in ‘-11 throw’; in
     ‘gforth-fast’ division overflow and divide by zero may also result
     in returning bogus results without producing an exception.

whether the current definition can be found after DOES>:
     No.

