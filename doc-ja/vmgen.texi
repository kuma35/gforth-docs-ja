\input texinfo    @c -*-texinfo-*-
@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================

@comment %**start of header
@setfilename vmgen.info
@include version.texi
@settitle Vmgen (Gforth @value{VERSION})
@c @syncodeindex pg cp
@comment %**end of header
@copying
このマニュアルは、 仮想マシン・インタープリタ・ジェネレーターである Vmgen (バージョン
@value{VERSION}、@value{UPDATED}) 用です

Author: Anton Ertl Copyright @copyright{} 2002,2003,2005,2007,2008,2019 Free
Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.2 or any later
version published by the Free Software Foundation; with no Invariant
Sections, with the Front-Cover texts being ``A GNU Manual,'' and with the
Back-Cover Texts as in (a) below.  A copy of the license is included in the
section entitled ``GNU Free Documentation License.''

(a) The FSF's Back-Cover Text is: ``You have freedom to copy and modify this
GNU Manual, like GNU software.  Copies published by the Free Software
Foundation raise funds for GNU development.''
@end quotation
@end copying

@dircategory Software development
@direntry
* Vmgen: (vmgen).            Virtual machine interpreter generator
@end direntry

@titlepage
@title Vmgen
@subtitle for Gforth version @value{VERSION}, @value{UPDATED}
@author M. Anton Ertl (@email{anton@@mips.complang.tuwien.ac.at})
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top, Introduction, (dir), (dir)
@top Vmgen

@insertcopying
@end ifnottex

@menu
* Introduction::             What can Vmgen do for you?
* Why interpreters?::        Advantages and disadvantages
* Concepts::                 VM interpreter background
* Invoking Vmgen::           
* Example::                  
* Input File Format::        
* Error messages::           reported by Vmgen
* Using the generated code::  
* Hints::                    VM archictecture, efficiency
* The future::               
* Changes::                  from earlier versions
* Contact::                  Bug reporting etc.
* Copying This Manual::      Manual License
* Index::                                           

@detailmenu
 --- The Detailed Node Listing ---



Concepts



* Front end and VM interpreter::  Modularizing an interpretive system
* Data handling::            Stacks, registers, immediate arguments
* Dispatch::                 From one VM instruction to the next

Example



* Example overview::         
* Using profiling to create superinstructions::    

Input File Format



* Input File Grammar::       
* Simple instructions::      
* Superinstructions::        
* Store Optimization::       
* Register Machines::        How to define register VM instructions

Input File Grammar



* Eval escapes::             what follows \E

Simple instructions



* Explicit stack access::    C言語コードからスタック・ポインターへアクセス
* C Code Macros::            Vmgen が認識するマクロ
* C Code restrictions::      Vmgen が仮定するC言語コード
* Stack growth direction::   is configurable per stack

Using the generated code



* VM engine::                Executing VM code
* VM instruction table::     
* VM code generation::       Creating VM code (in the front-end)
* Peephole optimization::    Creating VM superinstructions
* VM disassembler::          for debugging the front end
* VM profiler::              for finding worthwhile superinstructions

Hints



* Floating point::           and stacks

Copying This Manual



* GNU Free Documentation License::  License for copying this manual.

@end detailmenu
@end menu

@c @ifnottex
@c This file documents Vmgen (Gforth @value{VERSION}).

@c ************************************************************
@node Introduction, Why interpreters?, Top, Top
@chapter Introduction

Vmgen は、 効率的なインタープリターを作成するためのツールです。  これは、 単純な仮想マシンの記述を受け取り、
さまざまな方法で仮想マシン・コードを処理する(特に、 それを実行する)ための効率的な C 言語のコードを生成します。
その結果得られるインタープリターの実行効率は、 最適化コンパイラーによって生成されるマシンコードの10分の1以内に収まるのが普通です。

Vmgen がサポートするインタープリター設計戦略は、 インタープリターを以下の 2 つの部分に分割することです:

@itemize @bullet

@item
「フロント・エンド」は、 実装する言語のソース・コードを取得し、 それを仮想マシン・コードに変換します。
これは通常のコンパイラー・フロント・エンドに似ています。 通常、 インタープリターのフロント・エンドは最適化を実行しないため、 実装が比較的簡単で、
高速に実行されます。

@item
「仮想マシン・インタープリター」は仮想マシン・コードを実行します。

@end itemize

このような分割は通常、 モジュール性と効率性のためにインタープリターで使用されます。  仮想マシン・コードは通常、 load-and-go
コンパイラーのように、 フロント・エンドとメモリ内の仮想マシン・インタープリターの間で受け渡されます。 これにより、
コードをファイルに書き込んで再度読み取るという複雑さと時間のコストが回避されます。

「仮想マシン」(VM) は、 実際のマシン・コードと同様に、 メモリ内で相互に続く「VM 命令」のシーケンスとしてプログラムを表します。
制御フローは、 実際のマシンと同様に、 VM 分岐命令を通じて発生します。

@cindex functionality features overview
このセットアップでは、 Vmgen は、 仮想マシン命令の簡単な記述(@pxref{Input File
Format})から仮想マシン命令を処理するほとんどのコードを生成できます。 特に以下のようなものです:

@table @strong

@item VM instruction execution

@item VM code generation
フロント・エンドで役立ちます。

@item VM code decompiler
フロント・エンドのデバッグに役立ちます。

@item VM code tracing
フロント・エンドと VM インタープリターのデバッグに役立ちます。  あなたは、 通常は、
ユーザーのプログラムをソース・レベルでデバッグするための他の手段を提供するでしょう。

@item VM code profiling
スーパー命令(superinstructions)を使用して VM インタープリターを最適化するのに役立ちます(@pxref{VM
profiler})。

@end table

VM 命令を処理しないインタープリター・システムのパーツを作成するには、 他のツール(例: @command{bison})を使用するか、
手動でコーディングする必要があります。

@cindex efficiency features overview
@noindent
Vmgen は、さまざまな最適化を通じて効率的なインタープリターをサポートします。 特に

@itemize @bullet

@item コードのスレッド化

@item TOSをレジスターにキャッシュ

@item VM 命令をスーパー命令(superinstructions)に結合

@item
BTB 予測精度を向上させるために VM (スーパー) 命令を複製(vmgen-ex にはまだ含まれていませんが、 Gforth
にはすでに含まれています)。

@end itemize

@cindex speed for JVM
その結果、Vmgen ベースのインタープリターは、 小規模なベンチマークでは、 最適化された C 言語コンパイラーからのネイティブ・コードよりも 1
桁ほど遅いだけです。 ランタイム・システムでより多くの時間を費やす大規模なベンチマークでは、 多くの場合、 速度低下は少なくなります(たとえば、
Vmgen で生成された JVM インタープリターの速度の低下は、 大規模なベンチマークの場合、 測定した最高​​の JVM JIT
コンパイラーと比べてわずか 2 から 3 分の 1 です。 他のいくつかの JIT と、 私たちが調べた他のすべてのインタープリターは、
私たちのインタープリターよりも遅かったです)。

VM は通常、 スタック・シン(VM 命令間のデータを受け渡しをスタック上で行う)として設計されており、 Vmgen
はそのような設計を特に適切にサポートします。 ただし、 Vmgen を使用して レジスター型 VM (@pxref{Register
Machines}) を実装することもでき、 それでも Vmgen が提供する利点のほとんどを活用できます。

今現在では実装されていない命令記述(instruction descriptions)には多くの潜在的な用途がありうるものと思います。
私達は機能のリクエストは受け付けており、 誰かがリクエストした場合は新しい機能を検討します。 そのため、
上記の機能リストはすべてを網羅したものではありません。

@c *********************************************************************
@node Why interpreters?, Concepts, Introduction, Top
@chapter Why interpreters?
@cindex interpreters, advantages
@cindex advantages of interpreters
@cindex advantages of vmgen

インタープリターは、 以下の 3 つの利点をすべて兼ね備えた、 人気のある言語実装手法です:

@itemize @bullet

@item 実装の容易さ

@item 移植性が高い

@item 編集、コンパイル、実行のサイクルが速い

@end itemize

Vmgen を使用すると、 インタープリターの実装がさらに簡単になります。

@cindex speed of interpreters
インタープリターの主な欠点は、 実行速度です。 ただし、 実行速度の分野では、 インタープリターごとに大きな違いがあります。
単純な操作で構成されるプログラム上の最適化された C 言語コードの速度の低下は、 通常、 より効率的なインタープリターでは 10 倍、
効率の低いインタープリタでは 1000 倍になります(複雑な操作を実行するためのライブラリで費やされる時間はすべての実装戦略で同一であるため、
複雑な操作を実行するプログラムの速度低下は少なくなります)。

Vmgen は、 効率的なインタープリターを構築するための手法をサポートしています。

@c ********************************************************************
@node Concepts, Invoking Vmgen, Why interpreters?, Top
@chapter Concepts

@menu
* Front end and VM interpreter::  Modularizing an interpretive system
* Data handling::            Stacks, registers, immediate arguments
* Dispatch::                 From one VM instruction to the next
@end menu

@c --------------------------------------------------------------------
@node Front end and VM interpreter, Data handling, Concepts, Concepts
@section Front end and VM interpreter
@cindex modularization of interpreters

@cindex front-end
インタープリター・ステムは通常、 入力言語をパースしてプログラムの中間表現を生成する「フロント・エンド」と、
プログラムの中間表現を実行するインタープリターに分かれます。

@cindex virtual machine
@cindex VM
@cindex VM instruction
@cindex instruction, VM
@cindex VM branch instruction
@cindex branch instruction, VM
@cindex VM register
@cindex register, VM
@cindex opcode, VM instruction
@cindex immediate argument, VM instruction
効率的なインタープリターの場合、 選択される中間表現は(抽象構文ツリーなどではなく、 )仮想マシン・コードです。 「仮想仮想マシン」(VM) コードは、
メモリー内に順番に配置された VM 命令で構成されます。 これらは VM インタープリターによって順番に実行されますが、 VM
分岐命令は制御フローを変更することができ、 制御構造の実装に使用されます。  実際のマシン・コードと概念的に類似しているため、
「仮想マシン」という名前が付けられます。  実機の用語に類似したさまざまな用語が使用されています。 たとえば、 「VM
レジスター」(命令ポインターやスタック・ポインターなど)があり、 VM 命令は 「オペコード」と 「直接引数」(immediate
arguments)で構成されます。

このフレームワークでは、 Vmgen は VM インタープリターと、 VM 命令を処理するその他のコンポーネントの構築をサポートします。  VM
コード生成のサポートを除いて、 フロント・エンドのサポートはありません。  フロント・エンドは、 @command{flex} や
@command{bison} などのツールでサポートされる、 従来のコンパイラー・フロント・エンド手法を使用して実装できます。

中間表現は通常、 インタープリターの内部にのみ存在しますが、 一部のシステムでは、 イメージ・ファイルとして、
または完全なリンク可能なファイル形式(JVM など)でのファイルへの保存もサポートしています。  現在、 Vmgen
ではそのような機能に対する特別なサポートはありませんが、 命令記述に記載されている情報が役に立つ可能性があります。 また、
私達は機能のリクエストや提案をお待ちしています。

@c --------------------------------------------------------------------
@node Data handling, Dispatch, Front end and VM interpreter, Concepts
@section Data handling

@cindex stack machine
@cindex register machine
ほとんどの VM は、 VM 命令間で一時データを渡すために 1 つ以上のスタックを使用します。  私達は、 通常、
スタック・アーキテクチャを使用する方が簡単かつ高速であると考えていますが、 もう一つのオプションとして、
仮想マシンにレジスター・マシン・アーキテクチャを使用することが考えられます。

ただし、 このオプションはスタック・マシン・アーキテクチャよりも実装に時間がかかるか、 非常に複雑です。

Vmgen にはスタック VM に対する特別なサポートと最適化があり、 スタック VM の実装が簡単かつ効率的に行えます。

また、 Vmgen (@pxref{Register Machines}) を使用して レジスター VM を実装することもできます。 その場合でも、
あなたは Vmgen のほとんどの機能を活用できます。

@cindex stack item size
@cindex size, stack items
スタック項目はすべて同一サイズなので、 通常は整数やポインターや浮動小数点数値は同じサイズ幅になります。  Vmgen は、 2
つの連続したスタック項目を単一の値として扱うことをサポートしていますが、 それより大きいものは、 スタックに置いた、 データへのポインターを使用して、
他のメモリ領域(ヒープなど)に保持するのが最適です。

@cindex instruction stream
@cindex immediate arguments
もう 1 つのデータ源は、 (VM 命令ストリーム内の) 即時引数 VM 命令達(immediate arguments VM
instructions)です。 VM 命令ストリームは、 Vmgen のスタックと同様に処理されます。

@cindex garbage collection
@cindex reference counting
@c reference counting might be possible by including counting code in 
@c the conversion macros.
Vmgen には、 「ガーベジ・コレクション」に対するサポートも制限も組み込まれていません。  ガベージ・コレクションが必要な場合は、
ランタイム・ライブラリでそれを提供する必要があります。  「参照カウント」(reference counting)を使用するのはおそらく困難、
可能な場合もあります(興味がある場合は私達にお問い合わせください)。

@c --------------------------------------------------------------------
@node Dispatch, , Data handling, Concepts
@section Dispatch
@cindex Dispatch of VM instructions
@cindex main interpreter loop

Vmgen を使用する場合、 このセクションを理解する必要はおそらくありませんが、 役立つ場合もあります。 ここでスキップして、
あとでディスパッチ方法に関する記述がわかりにくい場合にこのセクションを読むといいでしょう。

1 つの VM 命令を実行した後、 VM インタープリターは次の VM
命令にディスパッチ(dispatch;切り替え作業)する必要があります(Vmgen はディスパッチ・ルーチン「NEXT」を呼び出します)。  Vmgen
は 2 つのディスパッチ方法をサポートしています:

@table @strong

@item switch dispatch
@cindex switch dispatch
この方法では、 VM インタープリターに巨大な @code{switch} ステートメントが含まれており、 VM 命令ごとに 1 つの
@code{case} があります。  VM 命令のオペコードは、 VM コード内の整数(@code{enum}
によって生成されるなどする)によって表され、 ディスパッチは、 次のオペコードをロードし、 @code{switch} して、 適切な
@code{case} で続行することによって行います。 VM 命令の実行後、 VM インタープリタはディスパッチ・コードに戻ります。

@item threaded code
@cindex threaded code
このメソッドは、 VM 命令を実行するためのマシン・コード断片の開始アドレスによって VM 命令オペコードを表します。 ディスパッチ(切り替え作業)は、
このアドレスのロードと、 そこへのジャンプと VM 命令ポインターのインクリメントで構成されます。  通常、 スレッド化コードのディスパッチ・コードは、
VM 命令を実行するコードに直接追加されます。  スレッド化コードは ANSI C では実装できませんが、 GNU C の
label-as-values 拡張機能を使用して実装できます(@pxref{Labels as Values, , Labels as Values,
gcc.info, GNU C Manual})。

@c call threading
@end table

インタープリターやベンチマークやマシンによっては、 スレッド化コードはスイッチ・ディスパッチより 2 倍早くなることがあります。

@c *************************************************************
@node Invoking Vmgen, Example, Concepts, Top
@chapter Invoking Vmgen
@cindex Invoking Vmgen

Vmgen を呼び出す通常の方法は以下のとおりです:

@example
vmgen @var{inputfile}
@end example

ここで @var{inputfile} は VM 命令記述ファイルで、 通常は @file{.vmg} で終わります。  それぞれの出力ファイル名は、
@file{inputfile} のベース名を取得し(つまり、 出力ファイルは現在の作業ディレクトリに作成されます)、 @file{.vmg}
の部分を、 @file{-vm.i} と @file{-disasm.i} と @file{-gen.i} と  @file{-labels.i} と
@file{-profile.i} と @file{-peephole.i} とにに置き換えることによって作成されます。
たとえば、@command{vmgen hack/foo.vmg} なら、 @file{foo-vm.i} と @file{foo-disasm.i}
と @file{foo-gen.i} と @file{foo-labels.i} と @file{foo-profile.i} と
@file{foo-peephole.i} を作成します。

Vmgen でサポートされるコマンドライン・オプションは以下のとおりです

@table @option

@cindex -h, command-line option
@cindex --help, command-line option
@item --help
@itemx -h
コマンドライン・オプションに関するメッセージを出力します

@cindex -v, command-line option
@cindex --version, command-line option
@item --version
@itemx -v
バージョンを出力して終了(exit)
@end table

@c env vars GFORTHDIR GFORTHDATADIR

@c ****************************************************************
@node Example, Input File Format, Invoking Vmgen, Top
@chapter Example
@cindex example of a Vmgen-based interpreter

@menu
* Example overview::         
* Using profiling to create superinstructions::    
@end menu

@c --------------------------------------------------------------------
@node Example overview, Using profiling to create superinstructions, Example, Example
@section Example overview
@cindex example overview
@cindex @file{vmgen-ex}
@cindex @file{vmgen-ex2}

Vmgen を使用する同一の例として、 @file{vmgen-ex} と @file{vmgen-ex2} の 2 つのバージョンがあります(例として
Gforth もありますが、 追加の(文書化されていない)機能が使用されており、 他のいくつかの点でも異なります)。  この例では、 JavaVM
のような小さな仮想マシンを備えた小さな Modula-2 のような言語である「mini」言語を実装しています。

2つの例の違いは、 @file{vmgen-ex} は多くのキャスト(cast)を使用するのに対し、 @file{vmgen-ex2}
はほとんどのキャストを回避し、 代わりに共用体(unions)を使用することです。  このマニュアルの残りの部分では、 通常、
@file{vmgen-ex} 内のファイルについてのみ言及します。 共用体(union)を使用したい場合は、 @file{vmgen-ex2}
内の同等のファイルを使用してください。
@cindex unions example
@cindex casts example

各例で提供されるファイルは以下のとおりです:
@cindex example files

@example
Makefile
README
disasm.c           wrapper file
engine.c           wrapper file
peephole.c         wrapper file
profile.c          wrapper file
mini-inst.vmg      simple VM instructions
mini-super.vmg     superinstructions (empty at first)
mini.h             common declarations
mini.l             scanner
mini.y             front end (parser, VM code generator)
support.c          main() and other support functions
fib.mini           example mini program
simple.mini        example mini program
test.mini          example mini program (tests everything)
test.out           test.mini output
stat.awk           プロファイル情報を集約するためのスクリプト
peephole-blacklist スーパー命令で許可されない命令のリスト
seq2rule.awk       スーパー命令を生成するためのスクリプト
@end example

あなた独自のインタープリターを作る場合、 通常、 以下のファイル群はコピーして使い、 変更することはほとんどないでしょう:
@cindex wrapper files

@example
disasm.c           wrapper file
engine.c           wrapper file
peephole.c         wrapper file
profile.c          wrapper file
stat.awk           プロファイル情報を集約するためのスクリプト
seq2rule.awk       スーパー命令を生成するためのスクリプト
@end example

@noindent
そして、 通常、 あなたは、 以下のファイル群を大幅に変更するか、 置き換える事になります:

@example
Makefile
mini-inst.vmg      simple VM instructions
mini.h             common declarations
mini.l             scanner
mini.y             front end (parser, VM code generator)
support.c          main() and other support functions
peephole-blacklist スーパー命令で許可されない命令のリスト
@end example

example のディレクトリに @code{cd} してから @code{make} と入力すると、 example をビルドできます。
@code{make check} で動作することを確認できます。  以下のようにして mini 言語のプログラムを実行できます:

@example
./mini fib.mini
@end example

オプションについて詳しくは、 @code{./mini -h} と入力してください。

@c --------------------------------------------------------------------
@node Using profiling to create superinstructions, , Example overview, Example
@section Using profiling to create superinstructions
@cindex profiling example
@cindex superinstructions example

作者は @file{Makefile} には、
プロファイリングを使用してスーパー命令を作成するためのルールを追加していません(スーパー命令選択の選択肢はたくさんありますが、 それらの選択肢を
@file{Makefile} にハードコードしたくありませんでした)が、 サポートするスクリプトがいくつかあります。 例:

@file{fib.mini} と @file{test.mini} をトレーニング・プログラムとして使用すると、
以下のようなプロファイルが得られます:

@example
make fib.prof test.prof #数秒かかります
@end example

これらのプロファイルは @file{stat.awk} で集約できます:

@example
awk -f stat.awk fib.prof test.prof
@end example

結果には以下のような行が含まれます:

@example
      2      16        36910041 loadlocal lit
@end example

これは、 シーケンス @code{loadlocal lit} が 2 つのプロファイルで合計 16 回静的に発生し、 動的実行数が 36910041
であることを意味します。

数値はスーパー命令を選択するためにさまざまな方法で使用できます。  たとえば、 動的実行数が 10000 を超えるシーケンスをすべて選択したい場合は、
以下のパイプラインを使用します:

@example
awk -f stat.awk fib.prof test.prof|
awk '$3>=10000'|                #シーケンスを選択
fgrep -v -f peephole-blacklist| #良くない命令を排除
awk -f seq2rule.awk|  #シーケンスをスーパー命令ルールに変換
sort -k 3 >mini-super.vmg       #シーケンスを並べ替え
@end example

ファイル @file{peephole-blacklist} には、スタックまたはスタック・ポインター(mini 言語の場合: @code{call}
、@code{return})に直接アクセスするすべての命令が含まれています。 並べ替え手順は、 プレフィックスが、
大きなスーパー命令よりも前に配置されるようにするために必要です。

いまや、 あなたは @samp{make} と言うだけでスーパー命令を備えたバージョンの mini 言語を作成できるようになりました。


@c ***************************************************************
@node Input File Format, Error messages, Example, Top
@chapter Input File Format
@cindex input file format
@cindex format, input file

Vmgen は、 仮想マシン命令の仕様を含むファイルを入力として受け取ります。  通常、 このファイルの名前は @file{.vmg} で終わります。

ほとんどの例は @file{vmgen-ex} のを使っています。

@menu
* Input File Grammar::       
* Simple instructions::      
* Superinstructions::        
* Store Optimization::       
* Register Machines::        How to define register VM instructions
@end menu

@c --------------------------------------------------------------------
@node Input File Grammar, Simple instructions, Input File Format, Input File Format
@section Input File Grammar
@cindex grammar, input file
@cindex input file grammar

文法は EBNF 形式で、 @code{@var{a}|@var{b}} は「@var{a} または @var{b}」、
@code{@{@var{c}@}} は @var{c} の 0 回以上の繰り返しを意味し、 @code{[@var{d}]} は @var{d} の
0 回または 1 回の繰り返しを意味します。

@cindex free-format, not
@cindex newlines, significance in syntax
Vmgen の入力は自由書式ではないため、 改行(および場合によっては空白)をどこに入れるかに注意する必要があります。

@example
description: @{instruction|comment|eval-escape|c-escape@}

instruction: simple-inst|superinst

simple-inst: ident '(' stack-effect ')' newline c-code newline newline

stack-effect: @{ident@} '--' @{ident@}

super-inst: ident '=' ident @{ident@}  

comment:      '\ '  text newline

eval-escape:  '\E ' text newline

c-escape:     '\C ' text newline
@end example
@c \+ \- \g \f \c

注意: この文法の @code{\} は、 印刷不可能な文字の C 言語スタイルのエンコーディングではなく、
文字通りの意味であることに注意してください。

@code{simple-inst} で C 言語コードを区切る(delimit)方法は 2 つあります:

@itemize @bullet

@item
行頭が @samp{@{} で始まる場合(つまり、 その前に空白も無い場合)、 (改行に続いて)行頭の @samp{@}} で終了する必要があります。
この場合、 C 言語コード内に空行が含まれる可能性があります(通常、 変数定義とステートメントの間で使用されます)。

@item
@samp{@{} で始めない場合。 この場合、 C 言語コードは最初の空行で終了するため、 このコード内に空行を含めることはできません。

@end itemize

@code{comment} と @code{eval-escape} と @code{c-escape} 内の text
には改行を含めることはできません。  @code{Ide​​nt} は、 C 言語識別子の通常の規則に準拠する必要があります(そうしないと、 Vmgen
出力で C 言語のコンパイラーが詰まり(choke)ます)。 @code{Ide​​nt} は、 @code{stack-effect} の ident
にスタック・プレフィックス(スタック・プレフィックス構文については @pxref{Eval escapes} 参照)が付いている場合がある点を除き、 C
言語識別子の通常の規則に準拠する必要があります。

@cindex C escape
@cindex @code{\C}
@cindex conditional compilation of Vmgen output
@code{c-escape} は text を各出力ファイルに渡します(@samp{\C} 無しで)。
これは主に条件付きコンパイルに役立ちます(つまり、 @samp{\C #if ...} などを記述します)。

@cindex sync lines
@cindex @code{#line}
文法で指定された構文に加えて、 Vmgen は @samp{m4 -s} (@pxref{Invoking m4, , Invoking m4,
m4.info, GNU m4})や、 同様のツールによって生成された同期行(sync lines)(@samp{#line}
で始まる行)も処理します。 これにより、 C 言語コンパイラーのエラー・メッセージを C 言語コードの元のソースに関連付けることができます。

Vmgen は、 ここで説明した文法を超えたいくつかの拡張機能を理解しますが、 これらの拡張機能は Gforth を構築する場合にのみ役立ちます。
Gforth に使用される書式の説明は @file{prim} にあります。

@menu
* Eval escapes::             what follows \E
@end menu

@node Eval escapes, , Input File Grammar, Input File Grammar
@subsection Eval escapes
@cindex escape to Forth
@cindex eval escape
@cindex @code{\E}

@c woanders?
@code{eval-escape} 内の text は、 Vmgen が行を読み取るときに評価(eval)される Forth コードです。  通常、
この機能を使用してスタックと型を定義します。

あなたが Forth を知らない (そして学びたくない) 場合は、 以下の文法に従って text を作成できます。 これらのルールは通常、 Vmgen
を使用するために必要な Forth の全てです:

@example
text: stack-decl|type-prefix-decl|stack-prefix-decl|set-flag

stack-decl: 'stack ' ident ident ident
type-prefix-decl: 
    's" ' string '" ' ('single'|'double') ident 'type-prefix' ident
stack-prefix-decl:  ident 'stack-prefix' string
set-flag: ('store-optimization'|'include-skipped-insts') ('on'|'off')
@end example

このコードの構文は完全にはチェックされていないことに注意してください(eval-escape で記述できる Forth
プログラムの断片は他にも多数あります)。

スタック・プレフィックスには文字または数字または @samp{:} を含めることができ、@samp{#} で始まる場合もあります。
たとえば、Gforth では、 リターン・スタックにはスタック・プレフィックス @samp{R:} が付きます。  この制限は、
スタック・プレフィックスの定義ではチェックされませんが、 後でスタック項目のパース・ルールによって強制されます。

あなたが既に Forth をご存知の場合、 関連する非標準ワードのスタック効果は以下のとおりです:
@findex stack
@findex type-prefix
@findex single
@findex double
@findex stack-prefix
@findex store-optimization
@example
stack                 ( "name" "pointer" "type" -- )
                      ( name execution: -- stack )
type-prefix           ( addr u item-size stack "prefix" -- )
single                ( -- item-size )
double                ( -- item-size )
stack-prefix          ( stack "prefix" -- )
store-optimization    ( -- addr )
include-skipped-insts ( -- addr )
@end example

@var{item-size} はスタック上で 3 つのセルを占有します。

@c --------------------------------------------------------------------
@node Simple instructions, Superinstructions, Input File Grammar, Input File Format
@section Simple instructions
@cindex simple VM instruction
@cindex instruction, simple VM

例として、 以下の簡単な VM 命令の記述を使用します:

@example
sub ( i1 i2 -- i )
i = i1-i2;
@end example

最初の行には、 VM 命令の名前 (@code{sub}) とそのスタック効果 (@code{i1 i2 -- i}) を指定します。
最初の行以外の記述の残りの部分は単なる C 言語コードです。

@cindex stack effect
@cindex effect, stack
スタック効果では、 @code{sub} がデータ・スタックから 2 つの整数を取得し、 それらを C 言語の変数 @code{i1} と
@code{i2} に格納することを指定します(右端の項目 (@code{i2}) が、 スタックのトップです: @code{i1}
をスタックにプッシュし、 次に @code{i2} をスタックにプッシュすると、 結果のスタック状態は @code{i1 i2} になります)。
そしてその後、 その後 1 つの整数 (@code{i}) をスタックにプッシュします(右端の項目がスタックの一番上になります)。

@cindex prefix, type
@cindex type prefix
@cindex default stack of a type prefix
スタック項目の型とスタックを知るにはどうすればよいでしょうか?  Vmgen は、 Fortran と同様にプレフィックスを使用します。 Fortran
とは対照的に、 あなたは最初にプレフィックスを定義する必要があります:

@example
\E s" Cell"   single data-stack type-prefix i
@end example

これは、 型 @code{Cell} (@file{mini.h} では @code{long} として定義)を参照するプレフィックス @code{i}
を定義し、 デフォルトでは @code{data-stack} を参照します。 また、 この型が 1
つのスタック項目(@code{single})を占めることも指定します。  型プレフィックスは変数名の一部です。

@cindex stack definition
@cindex defining a stack
@code{data-stack} を使用する前に、 この方法で @code{data-stack} を定義する必要があります:

@example
\E stack data-stack sp Cell
@end example
@c !! use something other than Cell

@cindex stack basic type
@cindex basic type of a stack
@cindex type of a stack, basic
この行は、 スタック・ポインター @code{sp} を使用するスタック @code{data-stack} を定義し、 各項目の基本タイプは
@code{Cell} です。 他の型は 1 つまたは 2 つの @code{Cell} に収まる必要があり(型の幅が @code{single} か
@code{double} かによって異なります)、 型キャスト・マクロ(@pxref{VM engine})を使用して
@code{data-stack} にアクセスするときに Cell との間でキャストされます。 Vmgen 製インタープリターではスタックは、
デフォルトでは、 より低いアドレスに向かって伸長します(@pxref{Stack growth direction})。

@cindex stack prefix
@cindex prefix, stack
スタック・プレフィックスを使用して、 スタック項目のデフォルト・スタックをオーバーライドできます。 たとえば、 以下の命令について考えてみましょう:

@example
lit ( #i -- i )
@end example

VM 命令 @code{lit} は、 命令ストリームから(プレフィックス @code{#} で示される) 項目 @code{i} を取得し、
それを(デフォルトの)データ・スタックにプッシュします。  スタック・プレフィックスは変数名の一部ではありません。
スタック・プレフィックスは以下のように定義されます:

@example
\E inst-stream stack-prefix #
\E data-stack  stack-prefix S:
@end example

この定義は、 スタック・プレフィックス @code{#} が「スタック」 @code{inst-stream} を指定することを定義します。
命令ストリームは通常のスタックとは振る舞いが少し異なるため、 事前に定義されており、 あなたが定義する必要はありません。

@cindex instruction stream
命令ストリームには命令とその直接引数(immediate arguments)が含まれるため、
引数が命令ストリームからのものであることを指定することは、 直接引数であることを示しています。  もちろん、 命令ストリーム引数は、 スタック効果の
@code{--} の左側にのみ出現できます。  複数の命令ストリーム引数がある場合、 (あなたの直観どおり)左端が最初の引数になります。

@menu
* Explicit stack access::    C言語コードからスタック・ポインターへアクセス
* C Code Macros::            Vmgen が認識するマクロ
* C Code restrictions::      Vmgen が仮定するC言語コード
* Stack growth direction::   is configurable per stack
@end menu

@c --------------------------------------------------------------------
@node Explicit stack access, C Code Macros, Simple instructions, Simple instructions
@subsection Explicit stack access
@cindex stack access, explicit
@cindex Stack pointer access
@cindex explicit stack access

This feature is not needed and not supported in the 0.6.2 version of vmgen
that is documented here (and that is invoked by default).

Not all stack effects can be specified using the stack effect specifications
above.  For VM instructions that have other stack effects, you can specify
them explicitly by accessing the stack pointer in the C code; however, you
have to notify Vmgen of such explicit stack accesses, otherwise Vmgens
optimizations could conflict with your explicit stack accesses.

You notify Vmgen by putting @code{...} with the appropriate stack prefix
into the stack comment.  Then the VM instruction will first take the other
stack items specified in the stack effect into C variables, then make sure
that all other stack items for that stack are in memory, and that the stack
pointer for the stack points to the top-of-stack (by default, unless you
change the stack access transformation: @pxref{Stack growth direction}).

The general rule is: If you mention a stack pointer in the C code of a VM
instruction, you should put a @code{...} for that stack in the stack effect.

Consider this example:

@example
return ( #iadjust S:... target afp i1 -- i2 )
SET_IP(target);
sp = (Cell *)(((char *)sp)+iadjust);
fp = afp;
i2=i1;
@end example

First the variables @code{target afp i1} are popped off the stack, then the
stack pointer @code{sp} is set correctly for the new stack depth, then the C
code changes the stack depth and does other things, and finally @code{i2} is
pushed on the stack with the new depth.

The position of the @code{...} within the stack effect does not matter.  You
can use several @code{...}s, for different stacks, and also several for the
same stack (that has no additional effect).  If you use @code{...} without a
stack prefix, this specifies all the stacks except the instruction stream.

You cannot use @code{...} for the instruction stream, but that is not
necessary: At the start of the C code, @code{IP} points to the start of the
next VM instruction (i.e., right beyond the end of the current VM
instruction), and you can change the instruction pointer with @code{SET_IP}
(@pxref{VM engine}).


@c --------------------------------------------------------------------
@node C Code Macros, C Code restrictions, Explicit stack access, Simple instructions
@subsection C Code Macros
@cindex macros recognized by Vmgen
@cindex basic block, VM level

Vmgen recognizes the following strings in the C code part of simple
instructions:

@table @code

@item SET_IP
@findex SET_IP
As far as Vmgen is concerned, a VM instruction containing this ends a VM
basic block (used in profiling to delimit profiled sequences).  On the C
level, this also sets the instruction pointer.

@item SUPER_END
@findex SUPER_END
This ends a basic block (for profiling), even if the instruction contains no
@code{SET_IP}.

@item INST_TAIL;
@findex INST_TAIL;
Vmgen replaces @samp{INST_TAIL;} with code for ending a VM instruction and
dispatching the next VM instruction.  Even without a @samp{INST_TAIL;} this
happens automatically when control reaches the end of the C code.  If you
want to have this in the middle of the C code, you need to use
@samp{INST_TAIL;}.  A typical example is a conditional VM branch:

@example
if (branch_condition) @{
  SET_IP(target); INST_TAIL;
@}
/* implicit tail follows here */
@end example

In this example, @samp{INST_TAIL;} is not strictly necessary, because there
is another one implicitly after the if-statement, but using it improves
branch prediction accuracy slightly and allows other optimizations.

@item SUPER_CONTINUE
@findex SUPER_CONTINUE
This indicates that the implicit tail at the end of the VM instruction
dispatches the sequentially next VM instruction even if there is a
@code{SET_IP} in the VM instruction.  This enables an optimization that is
not yet implemented in the vmgen-ex code (but in Gforth).  The typical
application is in conditional VM branches:

@example
if (branch_condition) @{
  SET_IP(target); INST_TAIL; /* now this INST_TAIL is necessary */
@}
SUPER_CONTINUE;
@end example

@c !! uncomment for post-0.6.2 docs
@c @item VM_JUMP
@c @findex VM_JUMP
@c @code{VM_JUMP(target)} is equivalent to @code{goto *(target)}, but
@c allows Vmgen to do dynamic superinstructions and replication.  You
@c still need to say @code{SUPER_END}.  Also, the goto only happens at
@c the end (wherever the VM_JUMP is).  Essentially, this just suppresses
@c much of the ordinary dispatch mechanism.

@end table

Note that Vmgen is not smart about C-level tokenization, comments, strings,
or conditional compilation, so it will interpret even a commented-out
SUPER_END as ending a basic block (or, e.g., @samp{RESET_IP;} as
@samp{SET_IP;}).  Conversely, Vmgen requires the literal presence of these
strings; Vmgen will not see them if they are hiding in a C preprocessor
macro.


@c --------------------------------------------------------------------
@node C Code restrictions, Stack growth direction, C Code Macros, Simple instructions
@subsection C Code restrictions
@cindex C code restrictions
@cindex restrictions on C code
@cindex assumptions about C code

@cindex accessing stack (pointer)
@cindex stack pointer, access
@cindex instruction pointer, access
Vmgen generates code and performs some optimizations under the assumption
that the user-supplied C code does not access the stack pointers or stack
items, and that accesses to the instruction pointer only occur through
special macros.  In general you should heed these restrictions.  However, if
you need to break these restrictions, read the following.

Accessing a stack or stack pointer directly can be a problem for several
reasons: 
@cindex stack caching, restriction on C code
@cindex superinstructions, restrictions on components

@itemize @bullet

@item
@c sometimes flushing and/or reloading unnecessary
Vmgen optionally supports caching the top-of-stack item in a local variable
(that is allocated to a register).  This is the most frequent source of
trouble.  You can deal with it either by not using top-of-stack caching
(slowdown factor 1-1.4, depending on machine), or by inserting flushing code
(e.g., @samp{IF_spTOS(sp[...] = spTOS);}) at the start and reloading code
(e.g., @samp{IF_spTOS(spTOS = sp[0])}) at the end of problematic C code.
Vmgen inserts a stack pointer update before the start of the user-supplied C
code, so the flushing code has to use an index that corrects for that.  In
the future, this flushing may be done automatically by mentioning a special
string in the C code.

@item
The Vmgen-erated code loads the stack items from stack-pointer-indexed
memory into variables before the user-supplied C code, and stores them from
variables to stack-pointer-indexed memory afterwards.  If you do any writes
to the stack through its stack pointer in your C code, it will not affect
the variables, and your write may be overwritten by the stores after the C
code.  Similarly, a read from a stack using a stack pointer will not reflect
computations of stack items in the same VM instruction.

@item
Superinstructions keep stack items in variables across the whole
superinstruction.  So you should not include VM instructions, that access a
stack or stack pointer, as components of superinstructions (@pxref{VM
profiler}).

@end itemize

You should access the instruction pointer only through its special macros
(@samp{IP}, @samp{SET_IP}, @samp{IPTOS}); this ensure that these macros can
be implemented in several ways for best performance.  @samp{IP} points to
the next instruction, and @samp{IPTOS} is its contents.

@c --------------------------------------------------------------------
@node Stack growth direction, , C Code restrictions, Simple instructions
@subsection Stack growth direction
@cindex stack growth direction

@cindex @code{stack-access-transform}
By default, the stacks grow towards lower addresses.  You can change this
for a stack by setting the @code{stack-access-transform} field of the stack
to an xt @code{( itemnum -- index )} that performs the appropriate index
transformation.

E.g., if you want to let @code{data-stack} grow towards higher addresses,
with the stack pointer always pointing just beyond the top-of-stack, use
this right after defining @code{data-stack}:

@example
\E : sp-access-transform ( itemnum -- index ) negate 1- ;
\E ' sp-access-transform ' data-stack >body stack-access-transform !
@end example

This means that @code{sp-access-transform} will be used to generate indexes
for accessing @code{data-stack}.  The definition of
@code{sp-access-transform} above transforms n into -n-1, e.g, 1 into -2.
This will access the 0th data-stack element (top-of-stack) at sp[-1], the
1st at sp[-2], etc., which is the typical way upward-growing stacks are
used.  If you need a different transform and do not know enough Forth to
program it, let me know.

@c --------------------------------------------------------------------
@node Superinstructions, Store Optimization, Simple instructions, Input File Format
@section Superinstructions
@cindex superinstructions, defining
@cindex defining superinstructions

Note: don't invest too much work in (static) superinstructions; a future
version of Vmgen will support dynamic superinstructions (see Ian Piumarta
and Fabio Riccardi, @cite{Optimizing Direct Threaded Code by Selective
Inlining}, PLDI'98), and static superinstructions have much less benefit in
that context (preliminary results indicate only a factor 1.1 speedup).

Here is an example of a superinstruction definition:

@example
lit_sub = lit sub
@end example

@code{lit_sub} is the name of the superinstruction, and @code{lit} and
@code{sub} are its components.  This superinstruction performs the same
action as the sequence @code{lit} and @code{sub}.  It is generated
automatically by the VM code generation functions whenever that sequence
occurs, so if you want to use this superinstruction, you just need to add
this definition (and even that can be partially automatized, @pxref{VM
profiler}).

@cindex prefixes of superinstructions
Vmgen requires that the component instructions are simple instructions
defined before superinstructions using the components.  Currently, Vmgen
also requires that all the subsequences at the start of a superinstruction
(prefixes) must be defined as superinstruction before the superinstruction.
I.e., if you want to define a superinstruction

@example
foo4 = load add sub mul
@end example

you first have to define @code{load}, @code{add}, @code{sub} and @code{mul},
plus

@example
foo2 = load add
foo3 = load add sub
@end example

Here, @code{sumof4} is the longest prefix of @code{sumof5}, and
@code{sumof3} is the longest prefix of @code{sumof4}.

Note that Vmgen assumes that only the code it generates accesses stack
pointers, the instruction pointer, and various stack items, and it performs
optimizations based on this assumption.  Therefore, VM instructions where
your C code changes the instruction pointer should only be used as last
component; a VM instruction where your C code accesses a stack pointer
should not be used as component at all.  Vmgen does not check these
restrictions, they just result in bugs in your interpreter.

@cindex include-skipped-insts
The Vmgen flag @code{include-skipped-insts} influences superinstruction code
generation.  Currently there is no support in the peephole optimizer for
both variations, so leave this flag alone for now.

@c -------------------------------------------------------------------
@node Store Optimization, Register Machines, Superinstructions, Input File Format
@section Store Optimization
@cindex store optimization
@cindex optimization, stack stores
@cindex stack stores, optimization
@cindex eliminating stack stores

This minor optimization (0.6%--0.8% reduction in executed instructions for
Gforth) puts additional requirements on the instruction descriptions and is
therefore disabled by default.

What does it do? Consider an instruction like

@example
dup ( n -- n n )
@end example

For simplicity, also assume that we are not caching the top-of-stack in a
register.  Now, the C code for dup first loads @code{n} from the stack, and
then stores it twice to the stack, one time to the address where it came
from; that time is unnecessary, but gcc does not optimize it away, so vmgen
can do it instead (if you turn on the store optimization).

Vmgen uses the stack item's name to determine if the stack item contains the
same value as it did at the start.  Therefore, if you use the store
optimization, you have to ensure that stack items that have the same name on
input and output also have the same value, and are not changed in the C code
you supply.  I.e., the following code could fail if you turn on the store
optimization:

@example
add1 ( n -- n )
n++;
@end example

Instead, you have to use different names, i.e.:

@example
add1 ( n1 -- n2 )
n2=n1+1;
@end example

Similarly, the store optimization assumes that the stack pointer is only
changed by Vmgen-erated code.  If your C code changes the stack pointer, use
different names in input and output stack items to avoid a (probably wrong)
store optimization, or turn the store optimization off for this VM
instruction.

To turn on the store optimization, write

@example
\E store-optimization on
@end example

at the start of the file.  You can turn this optimization on or off between
any two VM instruction descriptions.  For turning it off again, you can use

@example
\E store-optimization off
@end example

@c -------------------------------------------------------------------
@node Register Machines, , Store Optimization, Input File Format
@section Register Machines
@cindex Register VM
@cindex Superinstructions for register VMs
@cindex tracing of register VMs

If you want to implement a register VM rather than a stack VM with Vmgen,
there are two ways to do it: Directly and through superinstructions.

If you use the direct way, you define instructions that take the register
numbers as immediate arguments, like this:

@example
add3 ( #src1 #src2 #dest -- )
reg[dest] = reg[src1]+reg[src2];
@end example

A disadvantage of this method is that during tracing you only see the
register numbers, but not the register contents.  Actually, with an
appropriate definition of @code{printarg_src} (@pxref{VM engine}), you can
print the values of the source registers on entry, but you cannot print the
value of the destination register on exit.

If you use superinstructions to define a register VM, you define simple
instructions that use a stack, and then define superinstructions that have
no overall stack effect, like this:

@example
loadreg ( #src -- n )
n = reg[src];

storereg ( n #dest -- )
reg[dest] = n;

adds ( n1 n2 -- n )
n = n1+n2;

add3 = loadreg loadreg adds storereg
@end example

An advantage of this method is that you see the values and not just the
register numbers in tracing.  A disadvantage of this method is that
currently you cannot generate superinstructions directly, but only through
generating a sequence of simple instructions (we might change this in the
future if there is demand).

Could the register VM support be improved, apart from the issues mentioned
above? It is hard to see how to do it in a general way, because there are a
number of different designs that different people mean when they use the
term @emph{register machine} in connection with VM interpreters.  However,
if you have ideas or requests in that direction, please let me know
(@pxref{Contact}).

@c ********************************************************************
@node Error messages, Using the generated code, Input File Format, Top
@chapter Error messages
@cindex error messages

These error messages are created by Vmgen:

@table @code

@cindex @code{# can only be on the input side} error
@item # can only be on the input side
You have used an instruction-stream prefix (usually @samp{#}) after the
@samp{--} (the output side); you can only use it before (the input side).

@cindex @code{prefix for this combination must be defined earlier} error
@item the prefix for this superinstruction must be defined earlier
You have defined a superinstruction (e.g. @code{abc = a b c}) without
defining its direct prefix (e.g., @code{ab = a b}),
@xref{Superinstructions}.

@cindex @code{sync line syntax} error
@item sync line syntax
If you are using a preprocessor (e.g., @command{m4}) to generate Vmgen input
code, you may want to create @code{#line} directives (aka sync lines).  This
error indicates that such a line is not in th syntax expected by Vmgen (this
should not happen; please report the offending line in a bug report).

@cindex @code{syntax error, wrong char} error
@item syntax error, wrong char
A syntax error.  If you do not see right away where the error is, it may be
helpful to check the following: Did you put an empty line in a VM
instruction where the C code is not delimited by braces (then the empty line
ends the VM instruction)? If you used brace-delimited C code, did you put
the delimiting braces (and only those) at the start of the line, without
preceding white space? Did you forget a delimiting brace?

@cindex @code{too many stacks} error
@item too many stacks
Vmgen currently supports 3 stacks (plus the instruction stream); if you need
more, let us know.

@cindex @code{unknown prefix} error
@item unknown prefix
The stack item does not match any defined type prefix (after stripping away
any stack prefix).  You should either declare the type prefix you want for
that stack item, or use a different type prefix

@cindex @code{unknown primitive} error
@item unknown primitive
You have used the name of a simple VM instruction in a superinstruction
definition without defining the simple VM instruction first.

@end table

In addition, the C compiler can produce errors due to code produced by
Vmgen; e.g., you need to define type cast functions.

@c ********************************************************************
@node Using the generated code, Hints, Error messages, Top
@chapter Using the generated code
@cindex generated code, usage
@cindex Using vmgen-erated code

The easiest way to create a working VM interpreter with Vmgen is probably to
start with @file{vmgen-ex}, and modify it for your purposes.  This chapter
explains what the various wrapper and generated files do.  It also contains
reference-manual style descriptions of the macros, variables etc. used by
the generated code, and you can skip that on first reading.

@menu
* VM engine::                Executing VM code
* VM instruction table::     
* VM code generation::       Creating VM code (in the front-end)
* Peephole optimization::    Creating VM superinstructions
* VM disassembler::          for debugging the front end
* VM profiler::              for finding worthwhile superinstructions
@end menu

@c --------------------------------------------------------------------
@node VM engine, VM instruction table, Using the generated code, Using the generated code
@section VM engine
@cindex VM instruction execution
@cindex engine
@cindex executing VM code
@cindex @file{engine.c}
@cindex @file{-vm.i} output file

The VM engine is the VM interpreter that executes the VM code.  It is
essential for an interpretive system.

Vmgen supports two methods of VM instruction dispatch: @emph{threaded code}
(fast, but gcc-specific), and @emph{switch dispatch} (slow, but portable
across C compilers); you can use conditional compilation
(@samp{defined(__GNUC__)}) to choose between these methods, and our example
does so.

For both methods, the VM engine is contained in a C-level function.  Vmgen
generates most of the contents of the function for you
(@file{@var{name}-vm.i}), but you have to define this function, and macros
and variables used in the engine, and initialize the variables.  In our
example the engine function also includes @file{@var{name}-labels.i}
(@pxref{VM instruction table}).

@cindex tracing VM code
@cindex superinstructions and tracing
In addition to executing the code, the VM engine can optionally also print
out a trace of the executed instructions, their arguments and results.  For
superinstructions it prints the trace as if only component instructions were
executed; this allows to introduce new superinstructions while keeping the
traces comparable to old ones (important for regression tests).

It costs significant performance to check in each instruction whether to
print tracing code, so we recommend producing two copies of the engine: one
for fast execution, and one for tracing.  See the rules for @file{engine.o}
and @file{engine-debug.o} in @file{vmgen-ex/Makefile} for an example.

The following macros and variables are used in @file{@var{name}-vm.i}:

@table @code

@findex LABEL
@item LABEL(@var{inst_name})
This is used just before each VM instruction to provide a jump or
@code{switch} label (the @samp{:} is provided by Vmgen).  For switch
dispatch this should expand to @samp{case @var{label}:}; for threaded-code
dispatch this should just expand to @samp{@var{label}:}.  In either case
@var{label} is usually the @var{inst_name} with some prefix or suffix to
avoid naming conflicts.

@findex LABEL2
@item LABEL2(@var{inst_name})
This will be used for dynamic superinstructions; at the moment, this should
expand to nothing.

@findex NAME
@item NAME(@var{inst_name_string})
Called on entering a VM instruction with a string containing the name of the
VM instruction as parameter.  In normal execution this should be expand to
nothing, but for tracing this usually prints the name, and possibly other
information (several VM registers in our example).

@findex DEF_CA
@item DEF_CA
Usually empty.  Called just inside a new scope at the start of a VM
instruction.  Can be used to define variables that should be visible during
every VM instruction.  If you define this macro as non-empty, you have to
provide the finishing @samp{;} in the macro.

@findex NEXT_P0
@findex NEXT_P1
@findex NEXT_P2
@item NEXT_P0 NEXT_P1 NEXT_P2
The three parts of instruction dispatch.  They can be defined in different
ways for best performance on various processors (see @file{engine.c} in the
example or @file{engine/threaded.h} in Gforth).  @samp{NEXT_P0} is invoked
right at the start of the VM instruction (but after @samp{DEF_CA}),
@samp{NEXT_P1} right after the user-supplied C code, and @samp{NEXT_P2} at
the end.  The actual jump has to be performed by @samp{NEXT_P2} (if you
would do it earlier, important parts of the VM instruction would not be
executed).

The simplest variant is if @samp{NEXT_P2} does everything and the other
macros do nothing.  Then also related macros like @samp{IP}, @samp{SET_IP},
@samp{IP}, @samp{INC_IP} and @samp{IPTOS} are very straightforward to
define.  For switch dispatch this code consists just of a jump to the
dispatch code (@samp{goto next_inst;} in our example); for direct threaded
code it consists of something like @samp{(@{cfa=*ip++; goto *cfa;@})}.

Pulling code (usually the @samp{cfa=*ip++;}) up into @samp{NEXT_P1} usually
does not cause problems, but pulling things up into @samp{NEXT_P0} usually
requires changing the other macros (and, at least for Gforth on Alpha, it
does not buy much, because the compiler often manages to schedule the
relevant stuff up by itself).  An even more extreme variant is to pull code
up even further, into, e.g., NEXT_P1 of the previous VM instruction
(prefetching, useful on PowerPCs).

@findex INC_IP
@item INC_IP(@var{n})
This increments @code{IP} by @var{n}.

@findex SET_IP
@item SET_IP(@var{target})
This sets @code{IP} to @var{target}.

@cindex type cast macro
@findex vm_@var{A}2@var{B}
@item vm_@var{A}2@var{B}(a,b)
Type casting macro that assigns @samp{a} (of type @var{A}) to @samp{b} (of
type @var{B}).  This is mainly used for getting stack items into variables
and back.  So you need to define macros for every combination of stack basic
type (@code{Cell} in our example) and type-prefix types used with that stack
(in both directions).  For the type-prefix type, you use the type-prefix
(not the C type string) as type name (e.g., @samp{vm_Cell2i}, not
@samp{vm_Cell2Cell}).  In addition, you have to define a vm_@var{X}2@var{X}
macro for the stack's basic type @var{X} (used in superinstructions).

@cindex instruction stream, basic type
The stack basic type for the predefined @samp{inst-stream} is @samp{Cell}.
If you want a stack with the same item size, making its basic type
@samp{Cell} usually reduces the number of macros you have to define.

@cindex unions in type cast macros
@cindex casts in type cast macros
@cindex type casting between floats and integers
Here our examples differ a lot: @file{vmgen-ex} uses casts in these macros,
whereas @file{vmgen-ex2} uses union-field selection (or assignment to union
fields).  Note that casting floats into integers and vice versa changes the
bit pattern (and you do not want that).  In this case your options are to
use a (temporary) union, or to take the address of the value, cast the
pointer, and dereference that (not always possible, and sometimes
expensive).

@findex vm_two@var{A}2@var{B}
@findex vm_@var{B}2two@var{A}
@item vm_two@var{A}2@var{B}(a1,a2,b)
@item vm_@var{B}2two@var{A}(b,a1,a2)
Type casting between two stack items (@code{a1}, @code{a2}) and a variable
@code{b} of a type that takes two stack items.  This does not occur in our
small examples, but you can look at Gforth for examples (see
@code{vm_twoCell2d} in @file{engine/forth.h}).

@cindex stack pointer definition
@cindex instruction pointer definition
@item @var{stackpointer}
For each stack used, the stackpointer name given in the stack declaration is
used.  For a regular stack this must be an l-expression; typically it is a
variable declared as a pointer to the stack's basic type.  For
@samp{inst-stream}, the name is @samp{IP}, and it can be a plain r-value;
typically it is a macro that abstracts away the differences between the
various implementations of @code{NEXT_P*}.

@cindex IMM_ARG
@findex IMM_ARG
@item IMM_ARG(access,value)
Define this to expland to ``(access)''.  This is just a placeholder for
future extensions.

@cindex top of stack caching
@cindex stack caching
@cindex TOS
@findex IPTOS
@item @var{stackpointer}TOS
The top-of-stack for the stack pointed to by @var{stackpointer}.  If you are
using top-of-stack caching for that stack, this should be defined as
variable; if you are not using top-of-stack caching for that stack, this
should be a macro expanding to @samp{@var{stackpointer}[0]}.  The stack
pointer for the predefined @samp{inst-stream} is called @samp{IP}, so the
top-of-stack is called @samp{IPTOS}.

@findex IF_@var{stackpointer}TOS
@item IF_@var{stackpointer}TOS(@var{expr})
Macro for executing @var{expr}, if top-of-stack caching is used for the
@var{stackpointer} stack.  I.e., this should do @var{expr} if there is
top-of-stack caching for @var{stackpointer}; otherwise it should do nothing.

@findex SUPER_END
@item SUPER_END
This is used by the VM profiler (@pxref{VM profiler}); it should not do
anything in normal operation, and call @code{vm_count_block(IP)} for
profiling.

@findex SUPER_CONTINUE
@item SUPER_CONTINUE
This is just a hint to Vmgen and does nothing at the C level.

@findex MAYBE_UNUSED
@item MAYBE_UNUSED
This should be defined as @code{__attribute__((unused))} for gcc-2.7 and
higher.  It suppresses the warnings about unused variables in the code for
superinstructions.  You need to define this only if you are using
superinstructions.

@findex VM_DEBUG
@item VM_DEBUG
If this is defined, the tracing code will be compiled in (slower
interpretation, but better debugging).  Our example compiles two versions of
the engine, a fast-running one that cannot trace, and one with potential
tracing and profiling.

@findex vm_debug
@item vm_debug
Needed only if @samp{VM_DEBUG} is defined.  If this variable contains true,
the VM instructions produce trace output.  It can be turned on or off at any
time.

@findex vm_out
@item vm_out
Needed only if @samp{VM_DEBUG} is defined.  Specifies the file on which to
print the trace output (type @samp{FILE *}).

@findex printarg_@var{type}
@item printarg_@var{type}(@var{value})
Needed only if @samp{VM_DEBUG} is defined.  Macro or function for printing
@var{value} in a way appropriate for the @var{type}.  This is used for
printing the values of stack items during tracing.  @var{Type} is normally
the type prefix specified in a @code{type-prefix} definition (e.g.,
@samp{printarg_i}); in superinstructions it is currently the basic type of
the stack.

@end table


@c --------------------------------------------------------------------
@node VM instruction table, VM code generation, VM engine, Using the generated code
@section VM instruction table
@cindex instruction table
@cindex opcode definition
@cindex labels for threaded code
@cindex @code{vm_prim}, definition
@cindex @file{-labels.i} output file

For threaded code we also need to produce a table containing the labels of
all VM instructions.  This is needed for VM code generation (@pxref{VM code
generation}), and it has to be done in the engine function, because the
labels are not visible outside.  It then has to be passed outside the
function (and assigned to @samp{vm_prim}), to be used by the VM code
generation functions.

This means that the engine function has to be called first to produce the VM
instruction table, and later, after generating VM code, it has to be called
again to execute the generated VM code (yes, this is ugly).  In our example
program, these two modes of calling the engine function are differentiated
by the value of the parameter ip0 (if it equals 0, then the table is passed
out, otherwise the VM code is executed); in our example, we pass the table
out by assigning it to @samp{vm_prim} and returning from @samp{engine}.

In our example (@file{vmgen-ex/engine.c}), we also build such a table for
switch dispatch; this is mainly done for uniformity.

For switch dispatch, we also need to define the VM instruction opcodes used
as case labels in an @code{enum}.

For both purposes (VM instruction table, and enum), the file
@file{@var{name}-labels.i} is generated by Vmgen.  You have to define the
following macro used in this file:

@table @code

@findex INST_ADDR
@item INST_ADDR(@var{inst_name})
For switch dispatch, this is just the name of the switch label (the same
name as used in @samp{LABEL(@var{inst_name})}), for both uses of
@file{@var{name}-labels.i}.  For threaded-code dispatch, this is the address
of the label defined in @samp{LABEL(@var{inst_name})}); the address is taken
with @samp{&&} (@pxref{Labels as Values, , Labels as Values, gcc.info, GNU C
Manual}).

@end table


@c --------------------------------------------------------------------
@node VM code generation, Peephole optimization, VM instruction table, Using the generated code
@section VM code generation
@cindex VM code generation
@cindex code generation, VM
@cindex @file{-gen.i} output file

Vmgen generates VM code generation functions in @file{@var{name}-gen.i} that
the front end can call to generate VM code.  This is essential for an
interpretive system.

@findex gen_@var{inst}
For a VM instruction @samp{x ( #a b #c -- d )}, Vmgen generates a function
with the prototype

@example
void gen_x(Inst **ctp, a_type a, c_type c)
@end example

The @code{ctp} argument points to a pointer to the next instruction.
@code{*ctp} is increased by the generation functions; i.e., you should
allocate memory for the code to be generated beforehand, and start with *ctp
set at the start of this memory area.  Before running out of memory,
allocate a new area, and generate a VM-level jump to the new area (this
overflow handling is not implemented in our examples).

@cindex immediate arguments, VM code generation
The other arguments correspond to the immediate arguments of the VM
instruction (with their appropriate types as defined in the
@code{type_prefix} declaration.

The following types, variables, and functions are used in
@file{@var{name}-gen.i}:

@table @code

@findex Inst
@item Inst
The type of the VM instruction; if you use threaded code, this is @code{void
*}; for switch dispatch this is an integer type.

@cindex @code{vm_prim}, use
@item vm_prim
The VM instruction table (type: @code{Inst *}, @pxref{VM instruction
table}).

@findex gen_inst
@item gen_inst(Inst **ctp, Inst i)
This function compiles the instruction @code{i}.  Take a look at it in
@file{vmgen-ex/peephole.c}.  It is trivial when you don't want to use
superinstructions (just the last two lines of the example function), and
slightly more complicated in the example due to its ability to use
superinstructions (@pxref{Peephole optimization}).

@findex genarg_@var{type_prefix}
@item genarg_@var{type_prefix}(Inst **ctp, @var{type} @var{type_prefix})
This compiles an immediate argument of @var{type} (as defined in a
@code{type-prefix} definition).  These functions are trivial to define (see
@file{vmgen-ex/support.c}).  You need one of these functions for every type
that you use as immediate argument.

@end table

@findex BB_BOUNDARY
In addition to using these functions to generate code, you should call
@code{BB_BOUNDARY} at every basic block entry point if you ever want to use
superinstructions (or if you want to use the profiling supported by Vmgen;
but this support is also useful mainly for selecting superinstructions).  If
you use @code{BB_BOUNDARY}, you should also define it (take a look at its
definition in @file{vmgen-ex/mini.y}).

You do not need to call @code{BB_BOUNDARY} after branches, because you will
not define superinstructions that contain branches in the middle (and if you
did, and it would work, there would be no reason to end the superinstruction
at the branch), and because the branches announce themselves to the
profiler.


@c --------------------------------------------------------------------
@node Peephole optimization, VM disassembler, VM code generation, Using the generated code
@section Peephole optimization
@cindex peephole optimization
@cindex superinstructions, generating
@cindex @file{peephole.c}
@cindex @file{-peephole.i} output file

You need peephole optimization only if you want to use superinstructions.
But having the code for it does not hurt much if you do not use
superinstructions.

A simple greedy peephole optimization algorithm is used for superinstruction
selection: every time @code{gen_inst} compiles a VM instruction, it checks
if it can combine it with the last VM instruction (which may also be a
superinstruction resulting from a previous peephole optimization); if so, it
changes the last instruction to the combined instruction instead of laying
down @code{i} at the current @samp{*ctp}.

The code for peephole optimization is in @file{vmgen-ex/peephole.c}.  You
can use this file almost verbatim.  Vmgen generates
@file{@var{file}-peephole.i} which contains data for the peephole optimizer.

@findex init_peeptable
You have to call @samp{init_peeptable()} after initializing @samp{vm_prim},
and before compiling any VM code to initialize data structures for peephole
optimization.  After that, compiling with the VM code generation functions
will automatically combine VM instructions into superinstructions.  Since
you do not want to combine instructions across VM branch targets (otherwise
there will not be a proper VM instruction to branch to), you have to call
@code{BB_BOUNDARY} (@pxref{VM code generation}) at branch targets.


@c --------------------------------------------------------------------
@node VM disassembler, VM profiler, Peephole optimization, Using the generated code
@section VM disassembler
@cindex VM disassembler
@cindex disassembler, VM code
@cindex @file{disasm.c}
@cindex @file{-disasm.i} output file

A VM code disassembler is optional for an interpretive system, but highly
recommended during its development and maintenance, because it is very
useful for detecting bugs in the front end (and for distinguishing them from
VM interpreter bugs).

Vmgen supports VM code disassembling by generating
@file{@var{file}-disasm.i}.  This code has to be wrapped into a function, as
is done in @file{vmgen-ex/disasm.c}.  You can use this file almost
verbatim.  In addition to @samp{vm_@var{A}2@var{B}(a,b)}, @samp{vm_out},
@samp{printarg_@var{type}(@var{value})}, which are explained above, the
following macros and variables are used in @file{@var{file}-disasm.i} (and
you have to define them):

@table @code

@item ip
This variable points to the opcode of the current VM instruction.

@cindex @code{IP}, @code{IPTOS} in disassmbler
@item IP IPTOS
@samp{IPTOS} is the first argument of the current VM instruction, and
@samp{IP} points to it; this is just as in the engine, but here @samp{ip}
points to the opcode of the VM instruction (in contrast to the engine, where
@samp{ip} points to the next cell, or even one further).

@findex VM_IS_INST
@item VM_IS_INST(Inst i, int n)
Tests if the opcode @samp{i} is the same as the @samp{n}th entry in the VM
instruction table.

@end table


@c --------------------------------------------------------------------
@node VM profiler, , VM disassembler, Using the generated code
@section VM profiler
@cindex VM profiler
@cindex profiling for selecting superinstructions
@cindex superinstructions and profiling
@cindex @file{profile.c}
@cindex @file{-profile.i} output file

The VM profiler is designed for getting execution and occurence counts for
VM instruction sequences, and these counts can then be used for selecting
sequences as superinstructions.  The VM profiler is probably not useful as
profiling tool for the interpretive system.  I.e., the VM profiler is useful
for the developers, but not the users of the interpretive system.

The output of the profiler is: for each basic block (executed at least
once), it produces the dynamic execution count of that basic block and all
its subsequences; e.g.,

@example
       9227465  lit storelocal 
       9227465  storelocal branch 
       9227465  lit storelocal branch 
@end example

I.e., a basic block consisting of @samp{lit storelocal branch} is executed
9227465 times.

@cindex @file{stat.awk}
@cindex @file{seq2rule.awk}
This output can be combined in various ways.  E.g., @file{vmgen-ex/stat.awk}
adds up the occurences of a given sequence wrt dynamic execution, static
occurence, and per-program occurence.  E.g.,

@example
      2      16        36910041 loadlocal lit 
@end example

@noindent
indicates that the sequence @samp{loadlocal lit} occurs in 2 programs, in 16
places, and has been executed 36910041 times.  Now you can select
superinstructions in any way you like (note that compile time and space
typically limit the number of superinstructions to 100--1000).  After you
have done that, @file{vmgen/seq2rule.awk} turns lines of the form above into
rules for inclusion in a Vmgen input file.  Note that this script does not
ensure that all prefixes are defined, so you have to do that in other ways.
So, an overall script for turning profiles into superinstructions can look
like this:

@example
awk -f stat.awk fib.prof test.prof|
awk '$3>=10000'|                #select sequences
fgrep -v -f peephole-blacklist| #eliminate wrong instructions
awk -f seq2rule.awk|            #turn into superinstructions
sort -k 3 >mini-super.vmg       #sort sequences
@end example

Here the dynamic count is used for selecting sequences (preliminary results
indicate that the static count gives better results, though); the third line
eliminates sequences containing instructions that must not occur in a
superinstruction, because they access a stack directly.  The dynamic count
selection ensures that all subsequences (including prefixes) of longer
sequences occur (because subsequences have at least the same count as the
longer sequences); the sort in the last line ensures that longer
superinstructions occur after their prefixes.

But before using this, you have to have the profiler.  Vmgen supports its
creation by generating @file{@var{file}-profile.i}; you also need the
wrapper file @file{vmgen-ex/profile.c} that you can use almost verbatim.

@cindex @code{SUPER_END} in profiling
@cindex @code{BB_BOUNDARY} in profiling
The profiler works by recording the targets of all VM control flow changes
(through @code{SUPER_END} during execution, and through @code{BB_BOUNDARY}
in the front end), and counting (through @code{SUPER_END}) how often they
were targeted.  After the program run, the numbers are corrected such that
each VM basic block has the correct count (entering a block without
executing a branch does not increase the count, and the correction fixes
that), then the subsequences of all basic blocks are printed.  To get all
this, you just have to define @code{SUPER_END} (and @code{BB_BOUNDARY})
appropriately, and call @code{vm_print_profile(FILE *file)} when you want to
output the profile on @code{file}.

@cindex @code{VM_IS_INST} in profiling
The @file{@var{file}-profile.i} is similar to the disassembler file, and it
uses variables and functions defined in @file{vmgen-ex/profile.c}, plus
@code{VM_IS_INST} already defined for the VM disassembler (@pxref{VM
disassembler}).

@c **********************************************************
@node Hints, The future, Using the generated code, Top
@chapter Hints
@cindex hints

@menu
* Floating point::           and stacks
@end menu

@c --------------------------------------------------------------------
@node Floating point, , Hints, Hints
@section Floating point

How should you deal with floating point values? Should you use the same
stack as for integers/pointers, or a different one? This section discusses
this issue with a view on execution speed.

The simpler approach is to use a separate floating-point stack.  This allows
you to choose FP value size without considering the size of the
integers/pointers, and you avoid a number of performance problems.  The main
downside is that this needs an FP stack pointer (and that may not fit in the
register file on the 386 arhitecture, costing some performance, but
comparatively little if you take the other option into account).  If you use
a separate FP stack (with stack pointer @code{fp}), using an fpTOS is
helpful on most machines, but some spill the fpTOS register into memory, and
fpTOS should not be used there.

The other approach is to share one stack (pointed to by, say, @code{sp})
between integer/pointer and floating-point values.  This is ok if you do not
use @code{spTOS}.  If you do use @code{spTOS}, the compiler has to decide
whether to put that variable into an integer or a floating point register,
and the other type of operation becomes quite expensive on most machines
(because moving values between integer and FP registers is quite
expensive).  If a value of one type has to be synthesized out of two values
of the other type (@code{double} types), things are even more interesting.

One way around this problem would be to not use the @code{spTOS} supported
by Vmgen, but to use explicit top-of-stack variables (one for integers, one
for FP values), and having a kind of accumulator+stack architecture (e.g.,
Ocaml bytecode uses this approach); however, this is a major change, and its
ramifications are not completely clear.

@c **********************************************************
@node The future, Changes, Hints, Top
@chapter The future
@cindex future ideas

We have a number of ideas for future versions of Vmgen.  However, there are
so many possible things to do that we would like some feedback from you.
What are you doing with Vmgen, what features are you missing, and why?

One idea we are thinking about is to generate just one @file{.c} file
instead of letting you copy and adapt all the wrapper files (you would still
have to define stuff like the type-specific macros, and stack pointers
etc. somewhere).  The advantage would be that, if we change the wrapper
files between versions, you would not need to integrate your changes and our
changes to them; Vmgen would also be easier to use for beginners.  The main
disadvantage of that is that it would reduce the flexibility of Vmgen a
little (well, those who like flexibility could still patch the resulting
@file{.c} file, like they are now doing for the wrapper files).  In any
case, if you are doing things to the wrapper files that would cause problems
in a generated-@file{.c}-file approach, please let us know.

@c **********************************************************
@node Changes, Contact, The future, Top
@chapter Changes
@cindex Changes from old versions

User-visible changes between 0.5.9-20020822 and 0.5.9-20020901:

The store optimization is now disabled by default, but can be enabled by the
user (@pxref{Store Optimization}).  Documentation for this optimization is
also new.

User-visible changes between 0.5.9-20010501 and 0.5.9-20020822:

There is now a manual (in info, HTML, Postscript, or plain text format).

There is the vmgen-ex2 variant of the vmgen-ex example; the new variant uses
a union type instead of lots of casting.

Both variants of the example can now be compiled with an ANSI C compiler
(using switch dispatch and losing quite a bit of performance); tested with
@command{lcc}.

Users of the gforth-0.5.9-20010501 version of Vmgen need to change several
things in their source code to use the current version.  I recommend keeping
the gforth-0.5.9-20010501 version until you have completed the change (note
that you can have several versions of Gforth installed at the same time).  I
hope to avoid such incompatible changes in the future.

The required changes are:

@table @code

@cindex @code{TAIL;}, changes
@item TAIL;
has been renamed into @code{INST_TAIL;} (less chance of an accidental
match).

@cindex @code{vm_@var{A}2@var{B}}, changes
@item vm_@var{A}2@var{B}
now takes two arguments.

@cindex @code{vm_two@var{A}2@var{B}}, changes
@item vm_two@var{A}2@var{B}(b,a1,a2);
changed to vm_two@var{A}2@var{B}(a1,a2,b) (note the absence of the
@samp{;}).

@end table

Also some new macros have to be defined, e.g., @code{INST_ADDR}, and
@code{LABEL}; some macros have to be defined in new contexts, e.g.,
@code{VM_IS_INST} is now also needed in the disassembler.

@c *********************************************************
@node Contact, Copying This Manual, Changes, Top
@chapter Contact

To report a bug, use
@url{https://savannah.gnu.org/bugs/?func=addbug&group_id=2672}.

For discussion on Vmgen (e.g., how to use it), use the mailing list
@email{bug-vmgen@@mail.freesoftware.fsf.org} (use
@url{http://mail.gnu.org/mailman/listinfo/help-vmgen} to subscribe).

You can find vmgen information at
@url{http://www.complang.tuwien.ac.at/anton/vmgen/}.

@c ***********************************************************
@node Copying This Manual, Index, Contact, Top
@appendix Copying This Manual

@menu
* GNU Free Documentation License::  License for copying this manual.
@end menu

@node GNU Free Documentation License, , Copying This Manual, Copying This Manual
@appendixsec GNU Free Documentation License
@include fdl.texi


@node Index, , Copying This Manual, Top
@unnumbered Index

@printindex cp

@bye
