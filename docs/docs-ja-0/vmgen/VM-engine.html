<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- このマニュアルは、 仮想マシン・インタープリタ・ジェネレーターである Vmgen (バージョン
0.7.9_20240418、April 18, 2024) 用です

Author: Anton Ertl Copyright © 2002,2003,2005,2007,2008,2019 Free
Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.2 or any later
version published by the Free Software Foundation; with no Invariant
Sections, with the Front-Cover texts being "A GNU Manual," and with the
Back-Cover Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have freedom to copy and modify this
GNU Manual, like GNU software.  Copies published by the Free Software
Foundation raise funds for GNU development." -->
<title>VM engine (Vmgen (Gforth 0.7.9_20240418))</title>

<meta name="description" content="VM engine (Vmgen (Gforth 0.7.9_20240418))">
<meta name="keywords" content="VM engine (Vmgen (Gforth 0.7.9_20240418))">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Using-the-generated-code.html" rel="up" title="Using the generated code">
<link href="VM-instruction-table.html" rel="next" title="VM instruction table">
<link href="Using-the-generated-code.html" rel="prev" title="Using the generated code">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
span:hover a.copiable-link {visibility: visible}
-->
</style>


</head>

<body lang="en">
<div class="section-level-extent" id="VM-engine">
<div class="nav-panel">
<p>
Next: <a href="VM-instruction-table.html" accesskey="n" rel="next">VM instruction table</a>, Previous: <a href="Using-the-generated-code.html" accesskey="p" rel="prev">Using the generated code</a>, Up: <a href="Using-the-generated-code.html" accesskey="u" rel="up">Using the generated code</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="VM-engine-1"><span>8.1 VM engine<a class="copiable-link" href="#VM-engine-1"> &para;</a></span></h3>
<a class="index-entry-id" id="index-VM-instruction-execution"></a>
<a class="index-entry-id" id="index-engine"></a>
<a class="index-entry-id" id="index-executing-VM-code"></a>
<a class="index-entry-id" id="index-engine_002ec"></a>
<a class="index-entry-id" id="index-_002dvm_002ei-output-file"></a>

<p>The VM engine is the VM interpreter that executes the VM code.  It is
essential for an interpretive system.
</p>
<p>Vmgen supports two methods of VM instruction dispatch: <em class="emph">threaded code</em>
(fast, but gcc-specific), and <em class="emph">switch dispatch</em> (slow, but portable
across C compilers); you can use conditional compilation
(&lsquo;<samp class="samp">defined(__GNUC__)</samp>&rsquo;) to choose between these methods, and our example
does so.
</p>
<p>For both methods, the VM engine is contained in a C-level function.  Vmgen
generates most of the contents of the function for you
(<samp class="file"><var class="var">name</var>-vm.i</samp>), but you have to define this function, and macros
and variables used in the engine, and initialize the variables.  In our
example the engine function also includes <samp class="file"><var class="var">name</var>-labels.i</samp>
(see <a class="pxref" href="VM-instruction-table.html">VM instruction table</a>).
</p>
<a class="index-entry-id" id="index-tracing-VM-code"></a>
<a class="index-entry-id" id="index-superinstructions-and-tracing"></a>
<p>In addition to executing the code, the VM engine can optionally also print
out a trace of the executed instructions, their arguments and results.  For
superinstructions it prints the trace as if only component instructions were
executed; this allows to introduce new superinstructions while keeping the
traces comparable to old ones (important for regression tests).
</p>
<p>It costs significant performance to check in each instruction whether to
print tracing code, so we recommend producing two copies of the engine: one
for fast execution, and one for tracing.  See the rules for <samp class="file">engine.o</samp>
and <samp class="file">engine-debug.o</samp> in <samp class="file">vmgen-ex/Makefile</samp> for an example.
</p>
<p>The following macros and variables are used in <samp class="file"><var class="var">name</var>-vm.i</samp>:
</p>
<dl class="table">
<dt><a id="index-LABEL"></a><span><code class="code">LABEL(<var class="var">inst_name</var>)</code><a class="copiable-link" href="#index-LABEL"> &para;</a></span></dt>
<dd><p>This is used just before each VM instruction to provide a jump or
<code class="code">switch</code> label (the &lsquo;<samp class="samp">:</samp>&rsquo; is provided by Vmgen).  For switch
dispatch this should expand to &lsquo;<samp class="samp">case <var class="var">label</var>:</samp>&rsquo;; for threaded-code
dispatch this should just expand to &lsquo;<samp class="samp"><var class="var">label</var>:</samp>&rsquo;.  In either case
<var class="var">label</var> is usually the <var class="var">inst_name</var> with some prefix or suffix to
avoid naming conflicts.
</p>
</dd>
<dt><a id="index-LABEL2"></a><span><code class="code">LABEL2(<var class="var">inst_name</var>)</code><a class="copiable-link" href="#index-LABEL2"> &para;</a></span></dt>
<dd><p>This will be used for dynamic superinstructions; at the moment, this should
expand to nothing.
</p>
</dd>
<dt><a id="index-NAME"></a><span><code class="code">NAME(<var class="var">inst_name_string</var>)</code><a class="copiable-link" href="#index-NAME"> &para;</a></span></dt>
<dd><p>Called on entering a VM instruction with a string containing the name of the
VM instruction as parameter.  In normal execution this should be expand to
nothing, but for tracing this usually prints the name, and possibly other
information (several VM registers in our example).
</p>
</dd>
<dt><a id="index-DEF_005fCA"></a><span><code class="code">DEF_CA</code><a class="copiable-link" href="#index-DEF_005fCA"> &para;</a></span></dt>
<dd><p>Usually empty.  Called just inside a new scope at the start of a VM
instruction.  Can be used to define variables that should be visible during
every VM instruction.  If you define this macro as non-empty, you have to
provide the finishing &lsquo;<samp class="samp">;</samp>&rsquo; in the macro.
</p>
</dd>
<dt><a class="index-entry-id" id="index-NEXT_005fP1"></a>
<a class="index-entry-id" id="index-NEXT_005fP2"></a>
<a id="index-NEXT_005fP0"></a><span><code class="code">NEXT_P0 NEXT_P1 NEXT_P2</code><a class="copiable-link" href="#index-NEXT_005fP0"> &para;</a></span></dt>
<dd><p>The three parts of instruction dispatch.  They can be defined in different
ways for best performance on various processors (see <samp class="file">engine.c</samp> in the
example or <samp class="file">engine/threaded.h</samp> in Gforth).  &lsquo;<samp class="samp">NEXT_P0</samp>&rsquo; is invoked
right at the start of the VM instruction (but after &lsquo;<samp class="samp">DEF_CA</samp>&rsquo;),
&lsquo;<samp class="samp">NEXT_P1</samp>&rsquo; right after the user-supplied C code, and &lsquo;<samp class="samp">NEXT_P2</samp>&rsquo; at
the end.  The actual jump has to be performed by &lsquo;<samp class="samp">NEXT_P2</samp>&rsquo; (if you
would do it earlier, important parts of the VM instruction would not be
executed).
</p>
<p>The simplest variant is if &lsquo;<samp class="samp">NEXT_P2</samp>&rsquo; does everything and the other
macros do nothing.  Then also related macros like &lsquo;<samp class="samp">IP</samp>&rsquo;, &lsquo;<samp class="samp">SET_IP</samp>&rsquo;,
&lsquo;<samp class="samp">IP</samp>&rsquo;, &lsquo;<samp class="samp">INC_IP</samp>&rsquo; and &lsquo;<samp class="samp">IPTOS</samp>&rsquo; are very straightforward to
define.  For switch dispatch this code consists just of a jump to the
dispatch code (&lsquo;<samp class="samp">goto next_inst;</samp>&rsquo; in our example); for direct threaded
code it consists of something like &lsquo;<samp class="samp">({cfa=*ip++; goto *cfa;})</samp>&rsquo;.
</p>
<p>Pulling code (usually the &lsquo;<samp class="samp">cfa=*ip++;</samp>&rsquo;) up into &lsquo;<samp class="samp">NEXT_P1</samp>&rsquo; usually
does not cause problems, but pulling things up into &lsquo;<samp class="samp">NEXT_P0</samp>&rsquo; usually
requires changing the other macros (and, at least for Gforth on Alpha, it
does not buy much, because the compiler often manages to schedule the
relevant stuff up by itself).  An even more extreme variant is to pull code
up even further, into, e.g., NEXT_P1 of the previous VM instruction
(prefetching, useful on PowerPCs).
</p>
</dd>
<dt><a id="index-INC_005fIP"></a><span><code class="code">INC_IP(<var class="var">n</var>)</code><a class="copiable-link" href="#index-INC_005fIP"> &para;</a></span></dt>
<dd><p>This increments <code class="code">IP</code> by <var class="var">n</var>.
</p>
</dd>
<dt><a id="index-SET_005fIP-1"></a><span><code class="code">SET_IP(<var class="var">target</var>)</code><a class="copiable-link" href="#index-SET_005fIP-1"> &para;</a></span></dt>
<dd><p>This sets <code class="code">IP</code> to <var class="var">target</var>.
</p>
</dd>
<dt><a class="index-entry-id" id="index-vm_005fA2B"></a>
<a id="index-type-cast-macro"></a><span><code class="code">vm_<var class="var">A</var>2<var class="var">B</var>(a,b)</code><a class="copiable-link" href="#index-type-cast-macro"> &para;</a></span></dt>
<dd><p>Type casting macro that assigns &lsquo;<samp class="samp">a</samp>&rsquo; (of type <var class="var">A</var>) to &lsquo;<samp class="samp">b</samp>&rsquo; (of
type <var class="var">B</var>).  This is mainly used for getting stack items into variables
and back.  So you need to define macros for every combination of stack basic
type (<code class="code">Cell</code> in our example) and type-prefix types used with that stack
(in both directions).  For the type-prefix type, you use the type-prefix
(not the C type string) as type name (e.g., &lsquo;<samp class="samp">vm_Cell2i</samp>&rsquo;, not
&lsquo;<samp class="samp">vm_Cell2Cell</samp>&rsquo;).  In addition, you have to define a vm_<var class="var">X</var>2<var class="var">X</var>
macro for the stack&rsquo;s basic type <var class="var">X</var> (used in superinstructions).
</p>
<a class="index-entry-id" id="index-instruction-stream_002c-basic-type"></a>
<p>The stack basic type for the predefined &lsquo;<samp class="samp">inst-stream</samp>&rsquo; is &lsquo;<samp class="samp">Cell</samp>&rsquo;.
If you want a stack with the same item size, making its basic type
&lsquo;<samp class="samp">Cell</samp>&rsquo; usually reduces the number of macros you have to define.
</p>
<a class="index-entry-id" id="index-unions-in-type-cast-macros"></a>
<a class="index-entry-id" id="index-casts-in-type-cast-macros"></a>
<a class="index-entry-id" id="index-type-casting-between-floats-and-integers"></a>
<p>Here our examples differ a lot: <samp class="file">vmgen-ex</samp> uses casts in these macros,
whereas <samp class="file">vmgen-ex2</samp> uses union-field selection (or assignment to union
fields).  Note that casting floats into integers and vice versa changes the
bit pattern (and you do not want that).  In this case your options are to
use a (temporary) union, or to take the address of the value, cast the
pointer, and dereference that (not always possible, and sometimes
expensive).
</p>
</dd>
<dt><a class="index-entry-id" id="index-vm_005fB2twoA"></a>
<a id="index-vm_005ftwoA2B"></a><span><code class="code">vm_two<var class="var">A</var>2<var class="var">B</var>(a1,a2,b)</code><a class="copiable-link" href="#index-vm_005ftwoA2B"> &para;</a></span></dt>
<dt><code class="code">vm_<var class="var">B</var>2two<var class="var">A</var>(b,a1,a2)</code></dt>
<dd><p>Type casting between two stack items (<code class="code">a1</code>, <code class="code">a2</code>) and a variable
<code class="code">b</code> of a type that takes two stack items.  This does not occur in our
small examples, but you can look at Gforth for examples (see
<code class="code">vm_twoCell2d</code> in <samp class="file">engine/forth.h</samp>).
</p>
</dd>
<dt><a class="index-entry-id" id="index-instruction-pointer-definition"></a>
<a id="index-stack-pointer-definition"></a><span><code class="code"><var class="var">stackpointer</var></code><a class="copiable-link" href="#index-stack-pointer-definition"> &para;</a></span></dt>
<dd><p>For each stack used, the stackpointer name given in the stack declaration is
used.  For a regular stack this must be an l-expression; typically it is a
variable declared as a pointer to the stack&rsquo;s basic type.  For
&lsquo;<samp class="samp">inst-stream</samp>&rsquo;, the name is &lsquo;<samp class="samp">IP</samp>&rsquo;, and it can be a plain r-value;
typically it is a macro that abstracts away the differences between the
various implementations of <code class="code">NEXT_P*</code>.
</p>
</dd>
<dt><a class="index-entry-id" id="index-IMM_005fARG-1"></a>
<a id="index-IMM_005fARG"></a><span><code class="code">IMM_ARG(access,value)</code><a class="copiable-link" href="#index-IMM_005fARG"> &para;</a></span></dt>
<dd><p>Define this to expland to &ldquo;(access)&rdquo;.  This is just a placeholder for
future extensions.
</p>
</dd>
<dt><a class="index-entry-id" id="index-stack-caching"></a>
<a class="index-entry-id" id="index-TOS"></a>
<a class="index-entry-id" id="index-IPTOS"></a>
<a id="index-top-of-stack-caching"></a><span><code class="code"><var class="var">stackpointer</var>TOS</code><a class="copiable-link" href="#index-top-of-stack-caching"> &para;</a></span></dt>
<dd><p>The top-of-stack for the stack pointed to by <var class="var">stackpointer</var>.  If you are
using top-of-stack caching for that stack, this should be defined as
variable; if you are not using top-of-stack caching for that stack, this
should be a macro expanding to &lsquo;<samp class="samp"><var class="var">stackpointer</var>[0]</samp>&rsquo;.  The stack
pointer for the predefined &lsquo;<samp class="samp">inst-stream</samp>&rsquo; is called &lsquo;<samp class="samp">IP</samp>&rsquo;, so the
top-of-stack is called &lsquo;<samp class="samp">IPTOS</samp>&rsquo;.
</p>
</dd>
<dt><a id="index-IF_005fstackpointerTOS"></a><span><code class="code">IF_<var class="var">stackpointer</var>TOS(<var class="var">expr</var>)</code><a class="copiable-link" href="#index-IF_005fstackpointerTOS"> &para;</a></span></dt>
<dd><p>Macro for executing <var class="var">expr</var>, if top-of-stack caching is used for the
<var class="var">stackpointer</var> stack.  I.e., this should do <var class="var">expr</var> if there is
top-of-stack caching for <var class="var">stackpointer</var>; otherwise it should do nothing.
</p>
</dd>
<dt><a id="index-SUPER_005fEND-1"></a><span><code class="code">SUPER_END</code><a class="copiable-link" href="#index-SUPER_005fEND-1"> &para;</a></span></dt>
<dd><p>This is used by the VM profiler (see <a class="pxref" href="VM-profiler.html">VM profiler</a>); it should not do
anything in normal operation, and call <code class="code">vm_count_block(IP)</code> for
profiling.
</p>
</dd>
<dt><a id="index-SUPER_005fCONTINUE-1"></a><span><code class="code">SUPER_CONTINUE</code><a class="copiable-link" href="#index-SUPER_005fCONTINUE-1"> &para;</a></span></dt>
<dd><p>This is just a hint to Vmgen and does nothing at the C level.
</p>
</dd>
<dt><a id="index-MAYBE_005fUNUSED"></a><span><code class="code">MAYBE_UNUSED</code><a class="copiable-link" href="#index-MAYBE_005fUNUSED"> &para;</a></span></dt>
<dd><p>This should be defined as <code class="code">__attribute__((unused))</code> for gcc-2.7 and
higher.  It suppresses the warnings about unused variables in the code for
superinstructions.  You need to define this only if you are using
superinstructions.
</p>
</dd>
<dt><a id="index-VM_005fDEBUG"></a><span><code class="code">VM_DEBUG</code><a class="copiable-link" href="#index-VM_005fDEBUG"> &para;</a></span></dt>
<dd><p>If this is defined, the tracing code will be compiled in (slower
interpretation, but better debugging).  Our example compiles two versions of
the engine, a fast-running one that cannot trace, and one with potential
tracing and profiling.
</p>
</dd>
<dt><a id="index-vm_005fdebug"></a><span><code class="code">vm_debug</code><a class="copiable-link" href="#index-vm_005fdebug"> &para;</a></span></dt>
<dd><p>Needed only if &lsquo;<samp class="samp">VM_DEBUG</samp>&rsquo; is defined.  If this variable contains true,
the VM instructions produce trace output.  It can be turned on or off at any
time.
</p>
</dd>
<dt><a id="index-vm_005fout"></a><span><code class="code">vm_out</code><a class="copiable-link" href="#index-vm_005fout"> &para;</a></span></dt>
<dd><p>Needed only if &lsquo;<samp class="samp">VM_DEBUG</samp>&rsquo; is defined.  Specifies the file on which to
print the trace output (type &lsquo;<samp class="samp">FILE *</samp>&rsquo;).
</p>
</dd>
<dt><a id="index-printarg_005ftype"></a><span><code class="code">printarg_<var class="var">type</var>(<var class="var">value</var>)</code><a class="copiable-link" href="#index-printarg_005ftype"> &para;</a></span></dt>
<dd><p>Needed only if &lsquo;<samp class="samp">VM_DEBUG</samp>&rsquo; is defined.  Macro or function for printing
<var class="var">value</var> in a way appropriate for the <var class="var">type</var>.  This is used for
printing the values of stack items during tracing.  <var class="var">Type</var> is normally
the type prefix specified in a <code class="code">type-prefix</code> definition (e.g.,
&lsquo;<samp class="samp">printarg_i</samp>&rsquo;); in superinstructions it is currently the basic type of
the stack.
</p>
</dd>
</dl>


</div>
<hr>
<div class="nav-panel">
<p>
Next: <a href="VM-instruction-table.html">VM instruction table</a>, Previous: <a href="Using-the-generated-code.html">Using the generated code</a>, Up: <a href="Using-the-generated-code.html">Using the generated code</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
