<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- このマニュアルは、 仮想マシン・インタープリタ・ジェネレーターである Vmgen (バージョン
0.7.9_20240418、April 18, 2024) 用です

Author: Anton Ertl Copyright © 2002,2003,2005,2007,2008,2019 Free
Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.2 or any later
version published by the Free Software Foundation; with no Invariant
Sections, with the Front-Cover texts being "A GNU Manual," and with the
Back-Cover Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have freedom to copy and modify this
GNU Manual, like GNU software.  Copies published by the Free Software
Foundation raise funds for GNU development." -->
<title>Introduction (Vmgen (Gforth 0.7.9_20240418))</title>

<meta name="description" content="Introduction (Vmgen (Gforth 0.7.9_20240418))">
<meta name="keywords" content="Introduction (Vmgen (Gforth 0.7.9_20240418))">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="index.html" rel="up" title="Top">
<link href="Why-interpreters_003f.html" rel="next" title="Why interpreters?">
<link href="index.html" rel="prev" title="Top">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
span:hover a.copiable-link {visibility: visible}
ul.mark-bullet {list-style-type: disc}
-->
</style>


</head>

<body lang="en">
<div class="chapter-level-extent" id="Introduction">
<div class="nav-panel">
<p>
Next: <a href="Why-interpreters_003f.html" accesskey="n" rel="next">Why interpreters?</a>, Previous: <a href="index.html" accesskey="p" rel="prev">Vmgen</a>, Up: <a href="index.html" accesskey="u" rel="up">Vmgen</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h2 class="chapter" id="Introduction-1"><span>1 Introduction<a class="copiable-link" href="#Introduction-1"> &para;</a></span></h2>

<p>Vmgen は、 効率的なインタープリターを作成するためのツールです。  これは、 単純な仮想マシンの記述を受け取り、
さまざまな方法で仮想マシン・コードを処理する(特に、 それを実行する)ための効率的な C 言語のコードを生成します。
その結果得られるインタープリターの実行効率は、 最適化コンパイラーによって生成されるマシンコードの10分の1以内に収まるのが普通です。
</p>
<p>Vmgen がサポートするインタープリター設計戦略は、 インタープリターを以下の 2 つの部分に分割することです:
</p>
<ul class="itemize mark-bullet">
<li>「フロント・エンド」は、 実装する言語のソース・コードを取得し、 それを仮想マシン・コードに変換します。
これは通常のコンパイラー・フロント・エンドに似ています。 通常、 インタープリターのフロント・エンドは最適化を実行しないため、 実装が比較的簡単で、
高速に実行されます。

</li><li>「仮想マシン・インタープリター」は仮想マシン・コードを実行します。

</li></ul>

<p>このような分割は通常、 モジュール性と効率性のためにインタープリターで使用されます。  仮想マシン・コードは通常、 load-and-go
コンパイラーのように、 フロント・エンドとメモリ内の仮想マシン・インタープリターの間で受け渡されます。 これにより、
コードをファイルに書き込んで再度読み取るという複雑さと時間のコストが回避されます。
</p>
<p>「仮想マシン」(VM) は、 実際のマシン・コードと同様に、 メモリ内で相互に続く「VM 命令」のシーケンスとしてプログラムを表します。
制御フローは、 実際のマシンと同様に、 VM 分岐命令を通じて発生します。
</p>
<a class="index-entry-id" id="index-functionality-features-overview"></a>
<p>このセットアップでは、 Vmgen は、 仮想マシン命令の簡単な記述(see <a class="pxref" href="Input-File-Format.html">Input File Format</a>)から仮想マシン命令を処理するほとんどのコードを生成できます。 特に以下のようなものです:
</p>
<dl class="table">
<dt><strong class="strong">VM instruction execution</strong></dt>
<dt><strong class="strong">VM code generation</strong></dt>
<dd><p>フロント・エンドで役立ちます。
</p>
</dd>
<dt><strong class="strong">VM code decompiler</strong></dt>
<dd><p>フロント・エンドのデバッグに役立ちます。
</p>
</dd>
<dt><strong class="strong">VM code tracing</strong></dt>
<dd><p>フロント・エンドと VM インタープリターのデバッグに役立ちます。  あなたは、 通常は、
ユーザーのプログラムをソース・レベルでデバッグするための他の手段を提供するでしょう。
</p>
</dd>
<dt><strong class="strong">VM code profiling</strong></dt>
<dd><p>スーパー命令(superinstructions)を使用して VM インタープリターを最適化するのに役立ちます(see <a class="pxref" href="VM-profiler.html">VM profiler</a>)。
</p>
</dd>
</dl>

<p>VM 命令を処理しないインタープリター・システムのパーツを作成するには、 他のツール(例: <code class="command">bison</code>)を使用するか、
手動でコーディングする必要があります。
</p>
<a class="index-entry-id" id="index-efficiency-features-overview"></a>
<p>Vmgen は、さまざまな最適化を通じて効率的なインタープリターをサポートします。 特に
</p>
<ul class="itemize mark-bullet">
<li>コードのスレッド化

</li><li>TOSをレジスターにキャッシュ

</li><li>VM 命令をスーパー命令(superinstructions)に結合

</li><li>BTB 予測精度を向上させるために VM (スーパー) 命令を複製(vmgen-ex にはまだ含まれていませんが、 Gforth
にはすでに含まれています)。

</li></ul>

<a class="index-entry-id" id="index-speed-for-JVM"></a>
<p>その結果、Vmgen ベースのインタープリターは、 小規模なベンチマークでは、 最適化された C 言語コンパイラーからのネイティブ・コードよりも 1
桁ほど遅いだけです。 ランタイム・システムでより多くの時間を費やす大規模なベンチマークでは、 多くの場合、 速度低下は少なくなります(たとえば、
Vmgen で生成された JVM インタープリターの速度の低下は、 大規模なベンチマークの場合、 測定した最高​​の JVM JIT
コンパイラーと比べてわずか 2 から 3 分の 1 です。 他のいくつかの JIT と、 私たちが調べた他のすべてのインタープリターは、
私たちのインタープリターよりも遅かったです)。
</p>
<p>VM は通常、 スタック・シン(VM 命令間のデータを受け渡しをスタック上で行う)として設計されており、 Vmgen
はそのような設計を特に適切にサポートします。 ただし、 Vmgen を使用して レジスター型 VM (see <a class="pxref" href="Register-Machines.html">Register Machines</a>) を実装することもでき、 それでも Vmgen が提供する利点のほとんどを活用できます。
</p>
<p>今現在では実装されていない命令記述(instruction descriptions)には多くの潜在的な用途がありうるものと思います。
私達は機能のリクエストは受け付けており、 誰かがリクエストした場合は新しい機能を検討します。 そのため、
上記の機能リストはすべてを網羅したものではありません。
</p>
</div>



</body>
</html>
