\input texinfo   @c -*-texinfo-*-
@c ===========================================================================
@c
@c This file was generated with po4a. Translate the source file.
@c
@c ===========================================================================

@comment The source is gforth.texi.in, from which gforth.texi is generated

@c s/@c <ebook>/@/g this if you want a smartphone/ebook PDF
@c <ebook>iftex
@c <ebook>internalpagesizes{150mm}{97mm}{-0.666in}{-0.95in}{0in}{0in}{160mm}{100mm}
@c <ebook>contentsrightmargin=0pt
@c <ebook>tableindent=0.1in
@c <ebook>itemindent=0.2in
@c <ebook>tolerance=700
@c <ebook>defbodyindent=0.1in
@c <ebook>lispnarrowing=0pt
@c <ebook>end iftex

@comment TODO: nac29jan99 - a list of things to add in the next edit:
@comment 1. x-ref all ambiguous or implementation-defined features?
@comment 2. Describe the use of Auser Avariable AConstant A, etc.
@comment 3. words in miscellaneous section need a home.
@comment 4. search for TODO for other minor and major works required.
@comment 5. [rats] change all @var to @i in Forth source so that info
@comment    file looks decent.
@c          Not an improvement IMO - anton
@c          and anyway, this should be taken up
@c          with Karl Berry (the texinfo guy) - anton
@c
@c Karl Berry writes:
@c  If they don't like the all-caps for @var Info output, all I can say is
@c  that it's always been that way, and the usage of all-caps for
@c  metavariables has a long tradition.  I think it's best to just let it be
@c  what it is, for the sake of consistency among manuals.
@c
@comment .. would be useful to have a word that identified all deferred words
@comment should semantics stuff in intro be moved to another section

@c POSTPONE, COMPILE, [COMPILE], LITERAL should have their own section

@comment %**start of header (This is for running Texinfo on a region.)
@setfilename gforth.info
@include version.texi
@settitle Gforth マニュアル
@c @syncodeindex pg cp

@c Don't use UTF-8; it will produce a large number of non-ASCII chars.
@c Instead, recode afterwards if necessary.
@documentencoding UTF-8


@macro progstyle {}
プログラミング・スタイル・メモ:

@end macro

@macro assignment {}
@table @i
@item Assignment:
@end macro
@macro endassignment {}
@end table
@end macro

@comment macros for beautifying glossary entries
@macro GLOSS-START {}
@iftex
@ninerm
@end iftex
@end macro

@macro GLOSS-END {}
@iftex
@rm
@end iftex
@end macro

@comment %**end of header (This is for running Texinfo on a region.)
@copying
このマニュアルは、 標準 Forth 言語の高速で移植可能な実装である Gforth (バージョン @value{VERSION},
@value{UPDATED})用です。 これはリファレンス・マニュアルとして機能しますが、 Forth の概要と Forth
チュートリアルも含まれています。

Authors: Bernd Paysan, Anton Ertl, Gerald Wodni Copyright @copyright{} 1995,
1996, 1997, 1998, 2000, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
2011, 2012, 2013, 2014,2015,2016,2017,2018,2019,2020,2021,2022,2023 Free
Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant
Sections, with the Front-Cover texts being ``A GNU Manual,'' and with the
Back-Cover Texts as in (a) below.  A copy of the license is included in the
section entitled ``GNU Free Documentation License.''

(a) The FSF's Back-Cover Text is: ``You have freedom to copy and modify this
GNU Manual, like GNU software.  Copies published by the Free Software
Foundation raise funds for GNU development.''
@end quotation
@end copying

@dircategory Software development
@direntry
* Gforth: (gforth).          forth言語のための高速インタプリタ
@end direntry
@c The Texinfo manual also recommends doing this, but for Gforth it may
@c  not make much sense
@c @dircategory Individual utilities
@c @direntry
@c * Gforth: (gforth)Invoking Gforth.      gforth, gforth-fast, gforthmi
@c @end direntry

@titlepage
@title Gforth
@subtitle for version @value{VERSION}, @value{UPDATED}
@author Neal Crook
@author Anton Ertl
@author David Kuehling
@author Bernd Paysan
@author Jens Wilke
@author Gerald Wodni
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top, Goals, (dir), (dir)
@top Gforth

@insertcopying

@menu
* Goals::                    Gforthプロジェクトについて
* Gforth Environment::       Gforthの開始(と終了)
* Tutorial::                 実践的な Forth チュートリアル
* Introduction::             標準Forth(Standard Forth)の紹介
* Literals in source code::
* Words::                    Gforth で使用可能な Forth ワード
* Error messages::           エラーメッセージをどのように読み解けばいいのか
* Tools::                    プログラム作成支援ツール
* Standard conformance::     Gforth実装用に定義されたオプションなど
* Standard vs Extensions::   拡張機能を使用する必要ある?
* Model::                    Gforth の抽象マシン
* Integrating Gforth::       アプリのスクリプト言語としてのForth
* Emacs and Gforth::         The Gforth Mode
* Image Files::              @code{.fi} 
                               ファイルはコンパイル済のコード
* Engine::                   内部インタプリタとプリミティブ・ワード
* Cross Compiler::           The Cross Compiler
* MINOS2::                   The GUI library
* Bugs::                     バグの報告方法について
* Origin::                   Gforthの作者とGforthの祖先
* Forth-related information::  書籍とWeb上の情報
* Licenses::
* Word Index::               Forth ワードのインデックス
* Concept Index::            多くのトピックを網羅したインデックス

@detailmenu
 --- The Detailed Node Listing ---



Goals of Gforth



* Stability Goals::          

Gforth Environment



* Invoking Gforth::          Gforth を起動
* Leaving Gforth::           Gforth を終了
* Help on Gforth::           Gforth内のヘルプ
* Command-line editing::     Gforth内のラインエディタ
* Environment variables::    Gforth起動に影響する環境変数
* Gforth Files::             何が何処にインストールされるか
* Gforth in pipes::          Gforth とのパイプライン入出力
* Startup speed::            14msが満足な速度ではない場合…

Forth Tutorial



* Starting Gforth Tutorial::
* Syntax Tutorial::
* Crash Course Tutorial::
* Stack Tutorial::
* Arithmetics Tutorial::
* Stack Manipulation Tutorial::
* Using files for Forth code Tutorial::
* Comments Tutorial::
* Colon Definitions Tutorial::
* Decompilation Tutorial::
* Stack-Effect Comments Tutorial::
* Types Tutorial::
* Factoring Tutorial::
* Designing the stack effect Tutorial::
* Local Variables Tutorial::
* Conditional execution Tutorial::
* Flags and Comparisons Tutorial::
* General Loops Tutorial::
* Counted loops Tutorial::
* Recursion Tutorial::
* Leaving definitions or loops Tutorial::
* Return Stack Tutorial::
* Memory Tutorial::
* Characters and Strings Tutorial::
* Alignment Tutorial::
* Floating Point Tutorial::
* Files Tutorial::
* Interpretation and Compilation Semantics and Immediacy Tutorial::
* Execution Tokens Tutorial::
* Exceptions Tutorial::
* Defining Words Tutorial::
* Arrays and Records Tutorial::
* POSTPONE Tutorial::
* Literal Tutorial::
* Advanced macros Tutorial::
* Compilation Tokens Tutorial::
* Wordlists and Search Order Tutorial::  

An Introduction to Standard Forth



* Introducing the Text Interpreter::
* Stacks and Postfix notation::
* Your first definition::
* How does that work?::
* Forth is written in Forth::
* Review - elements of a Forth system::
* Where to go next::
* Exercises::                

Forth Words



* Notation::
* Case insensitivity::
* Comments::
* Boolean Flags::
* Arithmetic::
* Stack Manipulation::
* Memory::
* Strings and Characters::
* Control Structures::
* Defining Words::
* Interpretation and Compilation Semantics::
* Tokens for Words::
* Compiling words::
* The Text Interpreter::
* The Input Stream::
* Word Lists::
* Environmental Queries::
* Files::
* Blocks::
* Other I/O::
* OS command line arguments::
* Locals::
* Structures::
* Object-oriented Forth::
* Regular Expressions::
* Programming Tools::
* Multitasker::
* C Interface::
* Assembler and Code Words::
* Carnal words::
* Passing Commands to the OS::
* Keeping track of Time::
* Miscellaneous Words::      

Arithmetic



* Single precision::
* Double precision::         2倍長整数演算
* Mixed precision::          1倍長整数と2倍長整数の操作
* Integer division::
* Two-stage integer division::
* Bitwise operations::
* Numeric comparison::
* Floating Point::           

Stack Manipulation



* Data stack::
* Floating point stack::
* Return stack::
* Locals stack::
* Stack pointer manipulation::  

Memory



* Memory model::
* Dictionary allocation::
* Heap Allocation::
* Memory Access::
* Special Memory Accesses::
* Address arithmetic::
* Memory Blocks::            

Strings and Characters



* Characters::
* String representations::
* String and character literals::
* String words::
* ＄tring words::
* Counted string words::     

Control Structures



* Selection::                IF ... ELSE ... ENDIF
* Simple Loops::             BEGIN ...
* Counted Loops::            DO
* BEGIN loops with multiple exits::
* General control structures with CASE::
* Arbitrary control structures::
* Calls and returns::
* Exception Handling::       

Defining Words



* CREATE::
* Variables::                Variables and user variables
* Constants::
* Values::                   Initialised variables
* Varues::
* Colon Definitions::
* Anonymous Definitions::    名前無しのワード定義
* Quotations::
* Supplying names::          定義ワードの名前を文字列として渡す
* User-defined Defining Words::
* Deferred Words::           前方参照の許容
* Forward::                  自動解決される前方参照
* Aliases::                  

User-defined Defining Words



* User-defined defining words with colon definitions::
* User-defined defining words using CREATE::
* CREATE..DOES> applications::
* CREATE..DOES> details::
* Advanced does> usage example::
* User-defined TO and DEFER@@::
* User-defined compile-comma::
* Creating from a prototype::
* Making a word current::
* Const-does>::              

Interpretation and Compilation Semantics



* Combined words::           

Tokens for Words



* Execution token::          実行/インタプリタ 
                               機能(execution/interpretation semantics)
* Name token::               名前付きワード
* Compilation token::        コンパイル機能(compilation semantics)

Compiling words



* Literals::                 データ値をコンパイルします
* Macros::                   Compiling words

The Text Interpreter



* Input Sources::
* Number Conversion::
* Interpret/Compile states::
* Interpreter Directives::
* Recognizers::
* Text Interpreter Hooks::   

Recognizers



* Default Recognizers::
* Dealing with existing Recognizers::
* Defining Recognizers::     

Word Lists



* Vocabularies::
* Why use word lists?::
* Word list example::        

Files



* Forth source files::
* General files::
* Redirection::
* Directories::
* Search Paths::             

Search Paths



* Source Search Paths::
* General Search Paths::     

Other I/O



* Simple numeric output::    定義済みの書式
* Formatted numeric output::  書式化された(目に見える)出力
* Floating-point output::
* Miscellaneous output::
* Displaying characters and strings::  その他もろもろ
* Terminal output::          カーソル移動等
* Single-key input::
* Line input and conversion::
* Pipes::                    あなた独自のパイプラインの作り方
* Xchars and Unicode::       非ASCII文字
* i18n and l10n::            国際化(I18n)とローカライズ
* Substitute::               テキストマクロ置換
* CSV Reader::               データ・インポート機能

Locals



* Gforth locals::
* Standard Forth locals::    

Gforth locals



* Locals definition words::
* Where are locals visible by name?::
* How long do locals live?::
* Locals programming style::
* Locals implementation::
* Closures::                 

Structures



* Why explicit structure support?::
* Structure Usage::
* Structure Naming Convention::
* Structure Implementation::
* Structure Glossary::
* Forth200x Structures::     

Object-oriented Forth



* Why object-oriented programming?::
* Object-Oriented Terminology::
* Objects::
* OOF::
* Mini-OOF::
* Mini-OOF2::
* Comparison with other object models::  

The @file{objects.fs} model



* Properties of the Objects model::
* Basic Objects Usage::
* The Objects base class::
* Creating objects::
* Object-Oriented Programming Style::
* Class Binding::
* Method conveniences::
* Classes and Scoping::
* Dividing classes::
* Object Interfaces::
* Objects Implementation::
* Objects Glossary::         

The @file{oof.fs} model



* Properties of the OOF model::
* Basic OOF Usage::
* The OOF base class::
* Class Declaration::
* Class Implementation::     

The @file{mini-oof.fs} model



* Basic Mini-OOF Usage::
* Mini-OOF Example::
* Mini-OOF Implementation::  

Programming Tools



* Locating source code definitions::  and editing
* Locating uses of a word::  @code{where}.
* Locating exception source::  バックトレースの検証(examing)
* Examining compiled code::  @code{see} and friends.
* Examining data::           スタック と メモリ
* Forgetting words::         通常、再ロード前に使われます
* Debugging::                トレーサー @code{~~} 
                               を適宜挿入することによって
* Assertions::               あなたのプログラムを自己チェックさせます
* Singlestep Debugger::      あなたのプログラムをワート単位で実行します
* Code Coverage::            実行頻度を測定します

Multitasker



* Pthreads::                 ネイティブ Unix 用マルチタスカー
* Cilk::                     Cilk風の spawn+sync 実装

Pthreads



* Basic multi-tasking::
* Task-local data::
* Semaphores::
* Hardware operations for multi-tasking::
* Message queues::           

C Interface



* Calling C Functions::
* Declaring C Functions::
* Calling C function pointers::
* Defining library interfaces::
* Declaring OS-level libraries::
* Callbacks::
* C interface internals::
* Low-Level C Interface Words::
* Automated interface generation using SWIG::
* Migrating the C interface from earlier Gforth::  

Assembler and Code Words



* Assembler Definitions::    Definitions in assembly language
* Common Assembler::         アセンブラ文法
* Common Disassembler::
* 386 Assembler::            逸脱(deviations)と特殊ケース
* AMD64 Assembler::
* Alpha Assembler::          逸脱(deviations)と特殊ケース
* MIPS assembler::           逸脱(deviations)と特殊ケース
* PowerPC assembler::        逸脱(deviations)と特殊ケース
* ARM Assembler::            逸脱(deviations)と特殊ケース
* Other assemblers::         アセンブラ自体の書き方

Carnal words



* Header fields::
* Header methods::
* Threading Words::          

Tools



* Standard Report::          使用されたワードをワードセットごとにソートして報告します
* Stack depth changes::      このスタック値はどこから来たのか?

Standard conformance



* The Core Words::
* The optional Block word set::
* The optional Double Number word set::
* The optional Exception word set::
* The optional Facility word set::
* The optional File-Access word set::
* The optional Floating-Point word set::
* The optional Locals word set::
* The optional Memory-Allocation word set::
* The optional Programming-Tools word set::
* The optional Search-Order word set::  

The Core Words



* core-idef::                実装毎オプション(Implementation Defined 
                               Options;idef)
* core-ambcond::             あいまいな条件
* core-other::               その他のシステム・ドキュメント                  

The optional Block word set



* block-idef::               実装毎オプション(Implementation Defined 
                               Options;idef)
* block-ambcond::            あいまいな条件
* block-other::              その他のシステム・ドキュメント                 

The optional Double Number word set



* double-ambcond::           あいまいな条件              

The optional Exception word set



* exception-idef::           実装毎オプション(Implementation Defined 
                               Options;idef)              

The optional Facility word set



* facility-idef::            実装毎オプション(Implementation Defined 
                               Options;idef)
* facility-ambcond::         あいまいな条件            

The optional File-Access word set



* file-idef::                実装毎オプション(Implementation Defined 
                               Options;idef)
* file-ambcond::             あいまいな条件                

The optional Floating-Point word set



* floating-idef::            実装毎オプション(Implementation Defined 
                               Options;idef)
* floating-ambcond::         あいまいな条件            

The optional Locals word set



* locals-idef::              実装毎オプション(Implementation Defined 
                               Options;idef)
* locals-ambcond::           あいまいな条件              

The optional Memory-Allocation word set



* memory-idef::              実装毎オプション(Implementation Defined 
                               Options;idef)                 

The optional Programming-Tools word set



* programming-idef::         実装毎オプション(Implementation Defined 
                               Options;idef)
* programming-ambcond::      あいまいな条件         

The optional Search-Order word set



* search-idef::              実装毎オプション(Implementation Defined 
                               Options;idef)
* search-ambcond::           あいまいな条件              

Emacs and Gforth



* Installing gforth.el::     Emacs に Forth を認識させる
* Emacs Tags::               ワードのソースを Emacs で閲覧
* Hilighting::               Forth コードの見栄えを良くします
* Auto-Indentation::         自動インデントのカスタマイズ
* Blocks Files::             ブロック・ファイルの読み書き

Image Files



* Image Licensing Issues::   イメージの配布条件
* Image File Background::    なぜイメージ・ファイルがあるのですか?
* Non-Relocatable Image Files::  ※これは常に機能するとは限りません
* Data-Relocatable Image Files::  ※こちらの方がよいです
* Fully Relocatable Image Files::  ※こちらの方がもっといいです
* Stack and Dictionary Sizes::  イメージでのデフォルト・サイズを設定
* Running Image Files::      @code{gforth -i @i{file}} or @i{file}.
* Modifying the Startup Sequence::  ターンキー・アプリケーションにする事もできる

Fully Relocatable Image Files



* gforthmi::                 通常の方法
* cross.fs::                 困難な方法

Engine



* Portability::
* Threading::
* Primitives::
* Performance::              

Threading



* Scheduling::
* Direct or Indirect Threaded?::
* Dynamic Superinstructions::
* DOES>::                    

Primitives



* Automatic Generation::
* TOS Optimization::
* Produced code::            

Cross Compiler



* Using the Cross Compiler::
* How the Cross Compiler Works::  

MINOS2, a GUI library



* MINOS2 object framework::
* MINOS2 tutorial::          

MINOS2 object framework



* actor methods::
* widget methods::           

Licenses



* GNU Free Documentation License::  このマニュアルのコピー時のライセンス
* Copying::                  GPL (このソフトウェアのコピー用)

@end detailmenu
@end menu

@end ifnottex

@c ----------------------------------------------------------
@iftex
@unnumbered Preface
@cindex Preface
このマニュアルは Gforth について説明します。 Forth に慣れていない読者、 または他の Forth コンパイラから Gforth
に移行する読者向けに、 いくつかの入門資料が提供されています。 ただし、 このマニュアルの主体はリファレンス・マニュアルです。
@end iftex

@comment TODO much more blurb here.

@c ******************************************************************
@node Goals, Gforth Environment, Top, Top
@comment node-name,     next,           previous, up
@chapter Goals of Gforth
@cindex goals of the Gforth project
Gforth プロジェクトの目標(goal)は 標準Forth(Standard Forth)のための標準の模範(model)を開発することです。
これは以下のように、 幾つかの副目標に落とし込めます:

@itemize @bullet
@item
Gforth は Forth 標準(Forth Standard)に準拠すべきです。
@item
これは模範(model)になるべきです。 つまり、 実装に依存するものをすべて定義する必要があります。
@item
これは標準、つまり、広く受け入れられ、使用されるべきです。 この目標は最も難しい目標です。
@end itemize

上記の目標を達成するには Gforth は以下のようにするべきです
@itemize @bullet
@item
以前の模範(model)(fig-Forth, F83)に似にせること。
@item
強力であること。 今日必要であると考えられているすべてのものと、 まだ必要であると考えられていないものさえも提供する必要があります。
@item
効率的であること。 異常に遅いという評判を得るべきではありません。
@item
無料であること。
@item
多くのマシンで利用可能かつ移植も簡単であること。
@end itemize

私達はこれらの目標を達成できているでしょうか？ Gforth は、 Forth-94 (ANS Forth) と Forth-2012
標準に準拠しています。 内部データ構造の一部 (特にヘッダー) は時間の経過とともに変更されているため、 Gforth
は安定しているモデルとは見なさていません。 確かにまだ事実上​​の標準にはなっていませんが、 かなり人気があるようです。
以前のモデルとの類似点と相違点がいくつかあります。 いくつかの強力な機能がありますが、 まだ私たちが想像していたもの全てを備えているわけではありません。
私たちは確かに実行速度の目標を達成しました(@pxref{Performance})@footnote{ただし、 1998 年に主要な商用 Forth
ベンダーがネイティブ・コード・コンパイラに切り替えたとき、 その基準は引き上げられてしまいました。 }。 Gforth
は無料で、多くのマシンで利用できます。


@menu
* Stability Goals::          
@end menu

@c ******************************************************************
@node Stability Goals, , Goals, Goals
@section Stability Goals
@cindex Gforth stability
@cindex stability of Gforth

(Gforthの安定性)Gforth の以前のバージョンで動作するプログラムは、 新しいバージョンでも動作するはずです。 ただし、
以下のようないくつかの注意点があります:

Gforth の内部データ構造 (コンパイル済みコードの表現を含む) は、 文書化されていない限り、 バージョン間で変更される可能性があります。

さらに、 私達は、 標準のワード (つまり、 標準のワードセットにある名前のワード)と、 永続的な Gforth
拡張機能として文書化されたワード(ワードセット名が @code{gforth} または @code{gforth-@i{<version>}}
であるワード)(@pxref{Notation} 参照)は、 保持する義務があると考えています。
他のワードは新しいリリースでは削除される可能性があります。

とりわけ、 あなたは @code{locate} を使用するか、 または、 Gforth のソース・コードを調べることでワードを見つけることができ、
スタック効果コメントの直後のコメントでワードセットを確認できます。 そのワードにワードセットがない場合、 それは内部実装であり、
将来のバージョンでは削除される可能性があります。 ワードセットが @code{gforth-experimental} または
@code{gforth-internal} または @code{gforth-obsolete} の場合、
そのワードは将来のバージョンで削除される可能性があります。

あなたが永続的としてマークされていない特定のワードを使用したい場合、 私達にご連絡ください。
そのワードを永続的ワードとして追加することを検討します(または、このワードに代わる代替案を提案する場合もあります)。

@c ******************************************************************
@node Gforth Environment, Tutorial, Goals, Top
@chapter Gforth Environment
@cindex Gforth environment

メモ: Gforth のマニュアル・ページ(man page)は、 結局のところ、 この章の内容から自動生成されています。

@menu
* Invoking Gforth::          Gforth を起動
* Leaving Gforth::           Gforth を終了
* Help on Gforth::           Gforth内のヘルプ
* Command-line editing::     Gforth内のラインエディタ
* Environment variables::    Gforth起動に影響する環境変数
* Gforth Files::             何が何処にインストールされるか
* Gforth in pipes::          Gforth とのパイプライン入出力
* Startup speed::            14msが満足な速度ではない場合…
@end menu

イメージの作成に関する関連情報については @ref{Image Files} を参照してください。

@comment ----------------------------------------------
@node Invoking Gforth, Leaving Gforth, Gforth Environment, Gforth Environment
@section Invoking Gforth
@cindex invoking Gforth
@cindex running Gforth
@cindex command-line options
@cindex options on the command line
@cindex flags on the command line

Gforth は 2 つの部分から成ります。 実行可能「エンジン」(@command{gforth} または @command{gforth-fast}
という名前)と、イメージ・ファイルです。 Gforth を開始するには、 通常は @code{gforth} とするだけです。 これにより、
デフォルトのイメージ・ファイル @file{gforth.fi} が自動的にロードされます。 他の多くの場合、 デフォルトの Gforth
イメージは以下のように呼び出されます:
@example
gforth [file | -e forth-code] ...
@end example
@noindent
これにより、 ファイルの内容や、 (訳注:コマンドラインに記述された、) Forth コードが、 指定の順序で通訳(interpret)されます。

@command{gforth} エンジンに加えて、 @command{gforth-fast} というエンジンもあります。 これは高速ですが、
表示されるエラー・メッセージ(@pxref{Error messages})の情報が少なく、 そして、 一部のエラーのキャッチ(特に、
スタック・アンダーフローや整数除算エラーなど)が遅れて発生するか、 あるいはまったく発生しません。 デバッグ済みの、
パフォーマンスが重要なプログラムに対して使用するべきです。

さらに、 @command{gforth-itc} というエンジンがあり、 下位互換性が必要な状況(@pxref{Direct or Indirect
Threaded?})で役に立ちます。

一般に、 コマンドラインは以下のようになります:

@example
gforth[-fast] [engine options] [image options]
@end example

エンジン・オプションは、 コマンド・ラインの他の部分より前に指定する必要があります。 それらは以下のとおりです:

@c !! vollstaendig?
@table @code
@cindex -i, command-line option
@cindex --image-file, command-line option
@item --image-file @i{file}
@itemx -i @i{file}
デフォルトの @file{gforth.fi} の代わりに、 指定の Forth イメージ・ファイルをロードします(@pxref{Image
Files})。

@cindex --appl-image, command-line option
@item --appl-image @i{file}
指定のイメージ・ファイルをロードし、 これ以降のコマンドライン引数は(エンジンのオプションとして処理するのではなく)、
すべてそのイメージが処理する為に残します。 これは、 @code{gforthmi --application ...} で構築された、 Unix
上で実行可能なアプリケーション・イメージを構築する場合に便利です。

@cindex --path, command-line option
@cindex -p, command-line option
@item --path @i{path}
@itemx -p @i{path}
デフォルトである環境変数 @code{GFORTHPATH} 、 またはインストール時に指定されたパス(例:
@file{/usr/local/share/gforth/0.2.0:.})と作業ディレクトリ @code{.} の代わりに、
指定のパスを使用してイメージ・ファイルと Forth ソース・コード・ファイルを検索します。 パスは @samp{:}
で区切られたディレクトリのリストとして指定されます(以前のバージョンには他の OS 用に @samp{;} がありましたが、 Cygwin は現在は
@code{/cygdrive/<letter>} のみを受け入れ、 かつ、 私達は OS/2 や MS-DOS のサポートは終了してしまったため、
どこでも全部 @samp{:} になりました)。

@cindex --dictionary-size, command-line option
@cindex -m, command-line option
@cindex @i{size} parameters for command-line options
@cindex size of the dictionary and the stacks
@item --dictionary-size @i{size}
@itemx -m @i{size}
イメージで指定されているデフォルト(通常は 256K)を使用する代わりに、 Forth
ディクショナリ用のスペースに指定サイズ(@i{size})のスペースを割り当てます。
このオプションと、下記のオプションのサイズ(@i{size})指定は整数と単位で構成されます(例: @code{4M})。 単位は @code{b}
(バイト)、 @code{e} (elementの略。セル単位)、 @code{k} (キロバイト)、 @code{M} (メガバイト)、
@code{G} (ギガバイト)、 @code{T} (テラバイト)のいずれかになります。 単位が指定されていない場合 @code{e}
が使用されます。

@cindex --data-stack-size, command-line option
@cindex -d, command-line option
@item --data-stack-size @i{size}
@itemx -d @i{size}
イメージで指定されているデフォルト(通常は 16K) を使用する代わりに、
データ・スタックに指定のサイズ(@i{size})のスペースを割り当てます。サイズ(@i{size})指定は整数と単位で構成されます(例:
@code{4M})。 単位は @code{b} (バイト)、 @code{e} (elementの略。セル単位)、 @code{k} (キロバイト)、
@code{M} (メガバイト)、 @code{G} (ギガバイト)、 @code{T} (テラバイト)のいずれかになります。
単位が指定されていない場合 @code{e} が使用されます。

@cindex --return-stack-size, command-line option
@cindex -r, command-line option
@item --return-stack-size @i{size}
@itemx -r @i{size}
イメージで指定されたデフォルト(通常は 15K)を使用する代わりに、 リターン・スタックに指定のサイズ(@i{size})のスペースを割り当てます。
サイズ(@i{size})指定は整数と単位で構成されます(例: @code{4M})。 単位は @code{b} (バイト)、 @code{e}
(elementの略。セル単位)、 @code{k} (キロバイト)、 @code{M} (メガバイト)、 @code{G} (ギガバイト)、
@code{T} (テラバイト)のいずれかになります。 単位が指定されていない場合 @code{e} が使用されます。

@cindex --fp-stack-size, command-line option
@cindex -f, command-line option
@item --fp-stack-size @i{size}
@itemx -f @i{size}
イメージで指定されているデフォルト(通常は 15.5K)を使用する代わりに、
浮動小数点スタックに指定のサイズ(@i{size})のスペースを割り当てます。この場合、単位指定子 @code{e} は浮動小数点数を参照します。
サイズ(@i{size})指定は整数と単位で構成されます(例: @code{4M})。 単位は @code{b} (バイト)、 @code{e}
(elementの略。セル単位)、 @code{k} (キロバイト)、 @code{M} (メガバイト)、 @code{G} (ギガバイト)、
@code{T} (テラバイト)のいずれかになります。 単位が指定されていない場合 @code{e} が使用されます。

@cindex --locals-stack-size, command-line option
@cindex -l, command-line option
@item --locals-stack-size @i{size}
@itemx -l @i{size}
イメージで指定されているデフォルト(通常は 14.5K)を使用する代わりに、 ローカル・スタック(locals
stack)に指定サイズ(@i{size})のスペースを割り当てます。 サイズ(@i{size})指定は整数と単位で構成されます(例:
@code{4M})。 単位は @code{b} (バイト)、 @code{e} (elementの略。セル単位)、 @code{k} (キロバイト)、
@code{M} (メガバイト)、 @code{G} (ギガバイト)、 @code{T} (テラバイト)のいずれかになります。
単位が指定されていない場合 @code{e} が使用されます。

@cindex --vm-commit, command-line option
@cindex overcommit memory for dictionary and stacks
@cindex memory overcommit for dictionary and stacks
@item --vm-commit
通常 Gforth は、 ディクショナリとスタックに十分な仮想メモリ(virtual memory)がない場合でも起動しようとします(OS
がサポートしていれば @code{MAP_NORESERVE} を使用します)。 したがって、
あなたは非常に大きなディクショナリやスタックを要求することができ、 利用可能なのを超える仮想メモリを使用しない限り、
すべて問題ありません(ただし、それを超えて使用すると、 プロセスが強制終了(kill)されます)。 このオプションを使用すると、 OS
のデフォルトの割り当てポリシーを使用するようになります。 とりわけ、 オーバーコミットしない OS (Solaris など) の場合、 これは、
大きなディクショナリやスタックを要求することはできませんし、 要求すべきではないことを意味しますが、 しかし、 Gforth
が正常に起動する事に成功したならば、 メモリ不足によって強制終了(kill)させられることはありません。

@cindex -h, command-line option
@cindex --help, command-line option
@item --help
@itemx -h
コマンドライン・オプションに関するメッセージを出力します

@cindex -v, command-line option
@cindex --version, command-line option
@item --version
@itemx -v
バージョンを出力して終了(exit)

@cindex --debug, command-line option
@item --debug
起動時のデバッグに役立ついくつかの情報を出力します。

@cindex --offset-image, command-line option
@item --offset-image
それ以外の場合に使用される位置とはわずかに異なる位置でディクショナリを開始します (データ再配置可能イメージ(data-relocatable
images)の作成に役立ちます @pxref{Data-Relocatable Image Files})。

@cindex --no-offset-im, command-line option
@item --no-offset-im
ディクショナリを通常の位置で開始します。

@cindex --clear-dictionary, command-line option
@item --clear-dictionary
イメージをロードする前に、 ディクショナリ内の全てのバイトを 0 に初期化します(@pxref{Data-Relocatable Image
Files})。

@cindex --die-on-signal, command-line-option
@item --die-on-signal
通常、 Gforth はほとんどのシグナル(例えば、 ユーザー割り込みの SIGINT や、 セグメンテーション違反 SIGSEGV)を Forth の
@code{THROW} に変換することで処理します。 このオプションを使用すると、 Gforth
はそのようなシグナルを受信すると終了(exit)します。 このオプションは、
(最初のシグナルから回復する前に別のシグナルが発生するなど、)エンジンやイメージがひどく壊れている可能性がある場合に役立ちます。 このオプションは、
そのような場合の無限ループを回避します。

@cindex --no-dynamic, command-line option
@cindex --dynamic, command-line option
@item --no-dynamic
@item --dynamic
レプリケーション(replication)を伴う動的スーパー命令(dynamic
superinstructions)を無効または有効にします(@pxref{Dynamic Superinstructions})。

@cindex --no-super, command-line option
@item --no-super
動的スーパー命令(dynamic superinstructions)を無効にし、 動的レプリケーション(dynamic
replication)のみを使用します。 これは、 スレッド化コード(threaded
code)にパッチを適用する場合に便利です(@pxref{Dynamic Superinstructions})。

@cindex --ss-number, command-line option
@item --ss-number=@var{N}
エンジンにコンパイル済みの最初の @var{N} 個の静的スーパー命令(static
superinstructions)のみを使用します(デフォルトでは全てを使用します。 注意: @code{gforth-fast}
のみのオプションです)。 このオプションは、 静的スーパー命令(static
superinstructions)のパフォーマンスへの影響を測定するのに役立ちます。

@cindex --ss-min-..., command-line options
@item --ss-min-codesize
@item --ss-min-ls
@item --ss-min-lsu
@item --ss-min-nexts
指定のメトリックを使用して、 静的スーパー命令の選択(static superinstruction
selection)をするためにプリミティブまたは静的スーパー命令のコストを決定します。 @code{Codesize}
はプリミティブまたは静的スーパー命令のネイティブ・コード・サイズ、 そして、 @code{ls} はロードとストアの数、 そして、 @code{lsu}
はロードとストアと更新の数、 そして、 @code{nexts} は(動的スーパー命令を考慮しない)ディスパッチの数です。 ここで、
すべてのプリミティブまたは静的スーパー命令のコストは 1 です。 デフォルトでは、 動的コード生成を使用する場合は @code{codesize}、
それ以外の場合は @code{nexts} です。

@cindex --ss-greedy, command-line option
@item --ss-greedy
このオプションは、 静的スーパー命令のパフォーマンスへの影響を測定するのに役立ちます。 デフォルトでは、
静的スーパー命令の選択には最適な最短パス・アルゴリズム(shortest-path algorithm)が使用されます。
@option{--ss-greedy} を使用すると、 そのアルゴリズムは、
現在検討中の静的スーパー命令以降は静的スーパー命令に結合されないと想定するように変更されます。 @option{--ss-min-nexts}
を使用すると、 その時点で利用可能な最長のスーパー命令を常に選択する貪欲なアルゴリズムと同じ結果が生成されます。 たとえば、スーパー命令 AB と
BCD がある場合、 シーケンス A B C D に対して、 最適アルゴリズムは A BCD を選択し、 貪欲アルゴリズムは AB C D
を選択します。

@cindex --print-metrics, command-line option
@item --print-metrics
静的スーパー命令の選択中に使用されるいくつかのメトリックを出力します。 @code{code size} は、
動的に生成されたコードの実際のサイズです。  @code{Metric codesize}
は、静的スーパー命令の選択によって確認できるコードサイズ・メトリック(codesize metrics)の合計で、 @code{code size}
とは異なります。 これは、 すべてのプリミティブと静的スーパー命令が動的に生成されるコードにコンパイルされるわけではないことと、
マーカーがあるためです。 他のメトリクスは @option{ss-min-...} オプションに対応します。
このオプションは、@option{--ss-...} オプションの効果を評価するのに役立ちます。

@end table

@cindex loading files at startup
@cindex executing code on startup
@cindex batch processing with Gforth
上記にて説明したように、 デフォルト・イメージである @file{gforth.fi} のイメージ固有のコマンドライン引数は、 一連のファイル名と、
指定した順序で通訳(interpret)される @code{-e @var{forth-code}} オプションで構成されます。 @code{-e
@var{forth-code}} または @code{--evaluate @var{forth-code}} オプションは Forth
コードを評価(evaluate)します。 このオプションは引数を 1 つだけ取ります。 あなたが、もし、 さらに多くの Forth
ワードを評価したい場合は、 ワードを引用符で囲むか、 @code{-e} を複数回使用する必要があります。
コマンド・ラインの処理後に(対話モードに入るのではなく、)終了(exit)するには、 コマンド・ラインに @code{-e bye} を追加します。
Forth プログラムではコマンド・ライン引数を処理することもできます(@pxref{OS command line arguments})。

@cindex versions, invoking other versions of Gforth
複数のバージョンの Gforth がインストールされている場合、 @code{gforth} は最後にインストールされたバージョンを呼び出します。
@code{gforth-@i{<version>}} は特定のバージョンを呼び出します。 あなたの環境に環境変数 @code{GFORTHPATH}
がある場合、 @code{--path} オプションを使用してこの環境変数をオーバーライドできます。

起動時、 イメージ・オプションを処理する前に、 環境変数 @code{GFORTH_ENV} で指定されたユーザー初期化ファイル、
またはその環境変数が設定されていない場合は(存在する場合、) @file{~/.config/gforthrc0} がインクルードされます。
@code{GFORTH_ENV} が「@code{off}」の場合は何もインクルードしません。 すべてのイメージ・オプションを処理した後、
ブート・メッセージを出力する直前に、 オプション @code{--no-rc} が指定されていない限り、 ホーム・ディレクトリのユーザー初期化ファイル
@file{~/.config/gforthrc} がインクルードされます。

警告レベルは以下のように設定できます

@table @code
@cindex -W, command-line option
@item -W
警告(warnings)をオフにする

@cindex -Won, command-line option
@item -Won
警告(warnings)をオンにする(レベル 1)

@cindex -Wall, command-line option
@item -Wall
初心者向け警告をオンにする(レベル 2)

@cindex -Wpedantic, command-line option
@item -Wpedantic
細かい構文的な警告(pedantic warnings)をオンにする(レベル 3)

@cindex -Werror, command-line option
@item -Werror
警告をエラーとして出す(レベル 4)
@end table

@comment ----------------------------------------------
@node Leaving Gforth, Help on Gforth, Invoking Gforth, Gforth Environment
@section Leaving Gforth
@cindex Gforth - leaving
@cindex leaving Gforth

@code{bye} または (行の先頭で、) @kbd{Ctrl-d} または (@code{--die-on-signal} オプションを指定して
Gforth を起動した場合、) @kbd{Ctrl+C} を入力すると、 Gforth を終了できます。 Gforth を終了すると、
あなたの定義とデータはすべて破棄されます。 Gforth を終了する前にシステムの状態を保存する方法については、 @ref{Image Files}
を参照してください。

@code{bye} (@i{ -- }) \ gforth を正常に終了する。

@comment ----------------------------------------------
@node Help on Gforth, Command-line editing, Leaving Gforth, Gforth Environment
@section Help on Gforth
@cindex help

Gforth には、 シンプルなテキストベースのオンライン・ヘルプ・システムがあります。

@findex help ( @var{ "rest-of-line" --   } ) gforth-1.0
@cindex @code{help}
@kindex help
@format
@code{help} ( @i{"rest-of-line" --  }) gforth-1.0 ``help''
@end format
名前が指定されていない場合は、 基礎的なヘルプが表示されます。 ドキュメント・ノード名に `::` が続く場合、 ノードの最初を表示します。
ワードの名前が指定されている場合、 そのワードのドキュメントが存在する場合はそのドキュメントを、 存在しない場合はソース・コードを表示します。
@code{g} を使用して、 @code{help} で表示された場所でエディタに入ります。 @code{Help} は現在の位置をマークするため、
@code{n} と @code{b} を使用してテキストの詳細を表示したり、 @code{g}
を使用してエディターでドキュメントにアクセスしたりできます(@pxref{Locating source code definitions})。


@findex authors ( @var{ --   } ) gforth-1.0
@cindex @code{authors}
@kindex authors
@format
@code{authors} ( @i{--  }) gforth-1.0 ``authors''
@end format
著者のリストを表示


@findex license ( @var{ --   } ) gforth-0.2
@cindex @code{license}
@kindex license
@format
@code{license} ( @i{--  }) gforth-0.2 ``license''
@end format
ライセンス声明を出力します



@comment ----------------------------------------------
@node Command-line editing, Environment variables, Help on Gforth, Gforth Environment
@section Command-line editing
@cindex command-line editing

Gforth は、 テキスト・インタプリタに入力したすべての行を記録するヒストリ・ファイルを維持しています。
このファイルはセッションをまたいで保存され、 コマンドラインの再呼び出し機能を提供するために使用されます。 @kbd{Ctrl-P}
を繰り返し入力すると、このセッション(または前のセッション)から古いコマンドを連続して呼び出すことができます。
コマンドライン編集機能の完全なリストは以下のとおりです:

@itemize @bullet
@item
@kbd{Ctrl-p} (``previous'') (または「↑」上矢印)を使用して、 ヒストリ・バッファーから古い行を順に呼び出します。
@item
@kbd{Ctrl-n} (``next'')(または「↓」下矢印)を押すと、 ヒストリ・バッファーからより新しい行を連続して呼び出します。
以前に古い行に移動し、 それをテキスト解釈(text-interpretation)のために Gforth に与えた場合、
最初の編集コマンドとして「nextコマンド」を要求すると、 最後に選択した行の次の行が表示されます。
@item
@kbd{Ctrl-f} (または「→」右矢印)を使用して、 非破壊的にカーソルを右に移動します。
@item
@kbd{Ctrl-b} (または「←」左矢印)を使用して、 非破壊的にカーソルを左に移動します。
@item
@kbd{Ctrl-h} (backspace) カーソルの左側の文字を削除し、 桁を詰めます。
@item
@kbd{Ctrl-k} カーソルから行末までを削除 (``kill'') します。
@item
@kbd{Ctrl-a} カーソルを行頭に移動します。
@item
@kbd{Ctrl-e} カーソルを行末に移動します。
@item
@key{RET} (@kbd{Ctrl-m}) または @key{LFD} (@kbd{Ctrl-j}) 現在行を gforth へ送ります
@item
@key{TAB} 現在入力中のワードの、 可能なすべての全ワード補完をステップ実行します。
@item
@kbd{Ctrl-d} 空行で押すと Gforth を終了(terminate)します。 (@code{bye} 使用すると正常に終了します)。 
@item
@kbd{Ctrl-x} (空行以外では @code{Ctrl-d} も使えます) カーソル位置の文字を削除します。
@end itemize

編集中、 表示可能な文字はカーソル位置の左側に挿入されます。
行は常に(「上書きモード」(overstrike)ではなく、)「挿入モード」(insert)です。

@cindex history file
@cindex @file{.gforth-history}
Unix システムでは、 ヒストリ・ファイルは デフォルトでは
@file{$HOME/.local/share/gforth/history}です@footnote{つまり、
ユーザーのホーム・ディレクトリに保存されます。}。 以下のコマンドを使用して、 ヒストリ・ファイルの名前と場所を確認できます:

@example
history-file type \ Unix-class systems

history-file type \ Other systems
history-dir  type
@end example

あなたが長い定義を手入力した場合、 テキスト・エディターを使用してヒストリ・ファイルから Forth ソース・ファイルに貼り付け、 後で再利用できます。

Gforth はヒストリ・ファイルのサイズを決して削減しないため、 あなたは必要に応じて定期的にヒストリ・ファイルのサイズを削減する必要があります。

@comment this is all defined in history.fs
@comment NAC TODO the ctrl-D behaviour can either do a bye or a beep.. how is that option
@comment chosen?


@comment ----------------------------------------------
@node Environment variables, Gforth Files, Command-line editing, Gforth Environment
@section Environment variables
@cindex environment variables

Gforth は以下の環境変数を使用します:

@itemize @bullet
@item
@cindex @code{GFORTHHIST} -- environment variable
@code{GFORTHHIST} -- (Unix系のみ) ヒストリ・ファイル @file{.gforth-history} のパスを指定。
デフォルト: @code{$HOME/.local/share/gforth/history}.

@item
@cindex @code{GFORTHPATH} -- environment variable
@code{GFORTHPATH} -- gforth イメージ・ファイルと Forth ソースコード・ファイル
を検索するときに使用するパスを指定(通常 @samp{.} 、現在の作業ディレクトリ)。 パス区切り文字は @samp{:} です。
@file{/usr/local/share/gforth/1.0:.} みたいなのが典型です。

@item
@cindex @code{LANG} -- environment variable
@code{LANG} -- @code{LC_CTYPE} 参照

@item
@cindex @code{LC_ALL} -- environment variable
@code{LC_ALL} -- @code{LC_CTYPE} 参照

@item
@cindex @code{LC_CTYPE} -- environment variable
@code{LC_CTYPE} -- Gforth の起動時にこの環境変数が ``UTF-8'' を含んでいる場合、 Gforth は内部で文字列に
UTF-8 エンコーディングを使用し、 UTF-8 エンコーディングでの入力を期待し、 UTF-8 エンコーディングで出力を生成します。
それ以外の場合、 エンコーディングは 8 ビットです(@pxref{Xchars and Unicode})。 この環境変数が設定されていない場合、
Gforth は @code{LC_ALL} を調べ、 それも設定されていない場合は @code{LANG} を調べます。

@item
@cindex @code{GFORTHSYSTEMPREFIX} -- environment variable
@code{GFORTHSYSTEMPREFIX} -- C言語 の @code{system()} に渡す前に @code{system}
の引数に何を付加するかを指定します。 デフォルト: Windows では @code{"./$COMSPEC /c "}で、他の OS では
@code{""} です。 このプレフィックスとコマンドは直接連結されるため、 間にスペースが必要な場合はプレフィックスに追加してください。

@item
@cindex @code{GFORTH} -- environment variable
@code{GFORTH} -- @file{gforthmi} によって使用されます(@xref{gforthmi})。

@item
@cindex @code{GFORTHD} -- environment variable
@code{GFORTHD} -- @file{gforthmi} によって使用されます(@xref{gforthmi})。

@item
@cindex @code{TMP}, @code{TEMP} - environment variable
@code{TMP}, @code{TEMP} - (Unix系以外) ヒストリ・ファイルの場所として暗黙に使用されます。
@end itemize

@comment also POSIXELY_CORRECT LINES COLUMNS HOME but no interest in
@comment mentioning these.

すべての Gforth 環境変数は、 設定されていない場合、 デフォルトで適切な値になります。


@comment ----------------------------------------------
@node Gforth Files, Gforth in pipes, Environment variables, Gforth Environment
@section Gforth files
@cindex Gforth files

Gforth を Unix系にインストールすると、 デフォルトでは以下の場所にファイルがインストールされます:

@itemize @bullet
@item
@file{/usr/local/bin/gforth}
@item
@file{/usr/local/bin/gforthmi}
@item
@file{/usr/local/man/man1/gforth.1} - man page.
@item
@file{/usr/local/info} - the Info version of this manual.
@item
@file{/usr/local/lib/gforth/<version>/...} - Gforth @file{.fi} files.
@item
@file{/usr/local/share/gforth/<version>/TAGS} - Emacs TAGS file.
@item
@file{/usr/local/share/gforth/<version>/...} - Gforth source files.
@item
@file{.../emacs/site-lisp/gforth.el} - Emacs gforth mode.
@end itemize

@code{configure} のオプションを使用すると、 インストール先に違う場所を選択できます(どんなオプションがあるかは
@code{configure --help} してください)。

@comment ----------------------------------------------
@node Gforth in pipes, Startup speed, Gforth Files, Gforth Environment
@section Gforth in pipes
@cindex pipes, Gforth as part of

Gforth は、他の場所で作成されたパイプラインを使用できます(以下で説明します)。
独自にパイプラインを作成することもできます(@pxref{Pipes})。

@cindex input from pipes
Gforth にパイプライン入力する場合、 プログラムは @code{stdin} から @code{read-file} または
@code{read-line} を使用して読み取る必要があります(@pxref{General files})。 @code{Key}
は入力の終わりを認識しません。  @code{accept} のようなワードは入力をエコーするため、
通常はパイプラインからの読み取りには役に立ちません。 あなたは、
(Forthのテキスト・インタプリタはパイプライン入力を通訳(interpret)しようとしてしまうため、)Forth内のコマンド・ラインを使用する機会はなく、
OSのコマンド・ライン・オプションを使用して Forth プログラムを呼び出す必要があります。

@cindex output in pipes
あなたは @code{type}、 @code{emit}、 @code{cr} などでパイプラインへ出力できます。

@cindex silent exiting from Gforth
もう一方の端で既に閉じられているパイプラインに書き込むと、 Gforth は SIGPIPE シグナル(「パイプが壊れた」シグナル)を受け取ります。
Gforth はこれを例外 @code{broken-pipe-error} に変換します。 あなたのアプリケーションがその例外をキャッチしない場合、
システムはその例外をキャッチして、 通常は黙って終了(exit)します(Forth コマンド・ラインで作業している場合を除き、
エラー・メッセージを出力して終了します)。 これは通常、 望ましい動作です。

この振る舞いが気に入らない場合は、 自分で例外をキャッチし、 対応する必要があります。

ここで、 パイプライン内で使用できる Gforth の呼び出しの例を以下に示します:

@example
gforth -e ": foo begin pad dup 10 stdin read-file throw dup while \
 type repeat ; foo bye"
@end example

この例では、 入力をそのまま出力にコピーするだけです。 この例を含む非常に単純なパイプラインは以下のようになります:

@example
cat startup.fs |
gforth -e ": foo begin pad dup 80 stdin read-file throw dup while \
 type repeat ; foo bye"|
head
@end example

@cindex stderr and pipes
Gforth の @code{stderr} 出力に関連するパイプラインは機能しません。

@comment ----------------------------------------------
@node Startup speed, , Gforth in pipes, Gforth Environment
@section Startup speed
@cindex Startup speed
@cindex speed, startup

Gforth を CGI スクリプトやシェルスクリプトで使用する場合、 起動速度が問題になる場合があります。 libc-2.7 を搭載した 64 ビット
Linux 2.6.27.8 上の 3GHz Core 2 Duo E8400 では、 @code{gforth-fast -e bye}
でユーザー時間は 13.1 ミリ秒、システム時間は 1.2 ミリ秒かかります(@code{gforth -e bye} は、
下記で説明するオプションの一部を組み込んでいるため、 ユーザー時間は約 3.4 ミリ秒、 システム時間は 1.2 ミリ秒で起動がより高速になります)。

起動速度が問題になる場合は、 以下の改善方法を検討してください。 または、 起動の数を減らす方法(Fast-CGI
の使用など)を検討することもできます。 以下の最初の手順では、 (コンパイル時間を含む)実行時間を犠牲にして起動時間を短縮するため、
それで利益が得られるかどうかはあなたのアプリケーションでのこれらの時間のバランスによって決まることに注意してください。

Gforth の起動速度に影響を及ぼす簡単な手順は、 実行時間(run-time)を増加させながらイメージの読み込み時間(image-loading
time)を短縮する多数のオプションを使用してみることです。

最初に試す必要があるのは @code{--ss-number=0 --ss-states=1} です。
このオプションは実行時の高速化が比較的わずかなのに、 起動時にかなりの時間がかかるためです。 @code{gforth-fast
--ss-number=0 --ss-states=1 -e bye} には、 ユーザー時間が約 2.8 ミリ秒、 システム時間が約 1.5
ミリ秒かかります。

次のオプションは @code{--no-dynamic} です。 これは実行時間に大きな影響を及ぼします(いくつかのプラットフォームでは約 2
倍です)が、 それでも起動速度が若干速くなります。 @code{gforth-fast -- ss-number=0 --ss-states=1
--no-dynamic -e bye} は、 約 2.6 ミリ秒のユーザー時間と 1.2 ミリ秒のシステム時間を消費します。

@c !! check
起動速度を向上させるための次のステップは、 データ再配置可能イメージ(data-relocatable
image)を使用することです(@pxref{Data-Relocatable Image Files})。 これにより、
イメージ内のコードの再配置コストが回避されます(ただし、 データの再配置コストは回避されません)。 イメージは、 使用している特定のバイナリ(つまり、
@code{gforth}、 @code{gforth-fast}、さらには特定のビルド)に固有であることに注意してください。
@code{./gforth-fast} で動作するデータ再配置可能イメージを作成するには、 @code{GFORTHD="./gforth-fast
--no-dynamic" gforthmi gforthdr.fi} とします(これには @code{--no-dynamic}
が必要です。そうしないとこのイメージは機能しません)。 そして、 @code{gforth-fast -i gforthdr.fi ... -e
bye} で実行します(上記で説明したフラグは、 再配置可能なコードでのみ機能するため、ここでは重要ではありません)。
@code{gforth-fast -i gforthdr.fi -e bye} では、 ユーザー時間は約 1.1 ミリ秒、 システム時間は約 1.2
ミリ秒かかります。

さらにもう 1 つのステップは、 再配置不可イメージ(non-relocatable image)を使用することで、
すべての再配置コストと書き換え時コピー(copy-on-write;COW)コストの一部を回避することです(@pxref{Non-Relocatable
Image Files})。ただし、 アドレス空間のランダム化が行われているオペレーティング・システム(最近の Linux 等ではこれがデフォルト)や、
その他の理由でディクショナリが移動した場合(OS カーネルの変更や、 ライブラリ更新などの場合)には機能しないという欠点があるため、
あまりお勧めできません。再配置不可イメージ(non-relocatable image)を作成するために @code{gforth-fast
--no-dynamic -e "savesystem gforthnr.fi bye"} とします(ここでも @code{--no-dynamic}
が必要です)。  そして、  @code{gforth-fast -i gforthnr.fi ... -e bye} として実行します(ここでも、
上記で説明したフラグは重要ではありません)。  @code{gforth-fast -i gforthdr.fi -e bye} はユーザー時間は約
0.9 ミリ秒、 システム時間は約 0.9 ミリ秒かかります。

実行するスクリプトに大量のコードが含まれている場合は、 起動時のコンパイルのコストを避けるために、
それをイメージにコンパイルすると有益な場合があります。

@c ******************************************************************
@node Tutorial, Introduction, Gforth Environment, Top
@chapter Forth Tutorial
@cindex Tutorial
@cindex Forth Tutorial

@c Topics from nac's Introduction that could be mentioned:
@c press <ret> after each line
@c Prompt
@c numbers vs. words in dictionary on text interpretation
@c what happens on redefinition
@c parsing words (in particular, defining words)

この章と Introduction(@pxref{Introduction}) の違いは、 このチュートリアルの方がハイペースで、 かつ、
あなたがコンピューターをさわれるときに読む必要があり、 かつ、 より多くの内容をカバーしていますが、 しかし、 Forth
システムがどのように機能するかについては説明してい無いことです。

このチュートリアルは、 標準に準拠した任意の Forth でご利用できます。 Gforth 固有の機能はすべてその旨の目印が付けられており、 別の
Forth を使用する場合はその部分はスキップできます。 このチュートリアルでは、 Forth のすべての機能について説明するわけではありませんが、
あなたが Forth を使い始めて、 Forth で使用できる機能についていくつかのアイデアを得るには十分です。 このチュートリアルが終わったら、
マニュアルの残りの部分をお読みください。

このチュートリアルの使用目的は、 あなたがコンソールの前に座って作業を進め、 例を見てその結果を予測してから、 自分で試してみるというものです。
結果が期待どおりでない場合は、 何が起こっているのかを理解できるように(類似の例を試すなどして)理由を調べます。 いくつか課題も出題してあります。

このチュートリアルでは、 あなたが以前にプログラミングをしたことがあり、 例えば、 ループとは何か、とかを理解していることを前提としています。

@c !! explain compat library

@menu
* Starting Gforth Tutorial::
* Syntax Tutorial::
* Crash Course Tutorial::
* Stack Tutorial::
* Arithmetics Tutorial::
* Stack Manipulation Tutorial::
* Using files for Forth code Tutorial::
* Comments Tutorial::
* Colon Definitions Tutorial::
* Decompilation Tutorial::
* Stack-Effect Comments Tutorial::
* Types Tutorial::
* Factoring Tutorial::
* Designing the stack effect Tutorial::
* Local Variables Tutorial::
* Conditional execution Tutorial::
* Flags and Comparisons Tutorial::
* General Loops Tutorial::
* Counted loops Tutorial::
* Recursion Tutorial::
* Leaving definitions or loops Tutorial::
* Return Stack Tutorial::
* Memory Tutorial::
* Characters and Strings Tutorial::
* Alignment Tutorial::
* Floating Point Tutorial::
* Files Tutorial::
* Interpretation and Compilation Semantics and Immediacy Tutorial::
* Execution Tokens Tutorial::
* Exceptions Tutorial::
* Defining Words Tutorial::
* Arrays and Records Tutorial::
* POSTPONE Tutorial::
* Literal Tutorial::
* Advanced macros Tutorial::
* Compilation Tokens Tutorial::
* Wordlists and Search Order Tutorial::  
@end menu

@node Starting Gforth Tutorial, Syntax Tutorial, Tutorial, Tutorial
@section Starting Gforth
@cindex starting Gforth tutorial
あなたが Gforth を開始するには、その名前をタイプします:

@example
gforth
@end example

これにより、 対話モードに入ります。 @code{bye} と入力すると Gforth を終了できます。 Gforth では、 bash と同様に、
コマンド・ラインを編集し、 カーソル・キーを使用してコマンド・ライン・ヒストリ(履歴)にアクセスできます。


@node Syntax Tutorial, Crash Course Tutorial, Starting Gforth Tutorial, Tutorial
@section Syntax
@cindex syntax tutorial

@dfn{word} は、任意の文字のシーケンスです(空白(white space)を除く)。 ワードは空白(white space)で区切られます。
たとえば、 以下の各行には正確にただ 1 つのワードが含まれています:

@example
word
!@@#$%^&*()
1234567890
5!a
@end example

初心者によくある間違いは、 必要な空白を省略することです。 その結果、 @samp{Undefined word}
のようなエラーが発生します。そのため、 このようなエラーが表示された場合は、 必要な場所に空白を入れてあるかどうかを確認してください。

@example
." hello, world" \ correct
."hello, world"  \ gives an "Undefined word" error
@end example

Gforth および他のほとんどの Forth システムは、 大文字と小文字の違いを無視します(大文字と小文字は区別されません)。 つまり、
@samp{word} は @samp{Word} と同一です。 あなたのシステムで大文字と小文字が区別される場合は、
ここに示されているすべての例を大文字で入力する必要がある場合があります。


@node Crash Course Tutorial, Stack Tutorial, Syntax Tutorial, Tutorial
@section Crash Course

Forth は、 自分の足を撃つような馬鹿げた事を妨げたりはしません。 以下のように Gforth をクラッシュさせるいくつかの方法を試してみましょう:

@example
0 0 !
here execute
' catch >body 20 erase abort
' (quit1) >body 20 erase
@end example

最後の 2 つの例は、Gforth (および他のほとんどのシステム) の重要な部分を破壊することが保証されているため、 (Gforth
が自動的に終了していない場合、) この後は Gforth を終了させたほうがよいでしょう。 一部のシステムでは、 外部から gforth
を強制終了する必要がある場合があります(例: Unix系 では @code{kill} を使用します)。

これらの行が何を行うのか、 なぜクラッシュが発生するのかは後ほど分かります。

クラッシュを発生させる方法がわかったので(そして、 それは大したことがない事がわかったので)、
今度は意味のあるプログラムを作成する方法を学ぶとしましょう。


@node Stack Tutorial, Arithmetics Tutorial, Crash Course Tutorial, Tutorial
@section Stack
@cindex stack tutorial

Forth の最も明々白々な機能はスタックです。 数値を入力すると、 その数値がスタックにプッシュされます。 @code{.s}
を使用してスタックの内容を表示できます。

@example
1 2 .s
3 .s
@end example

@code{.s} はスタックの最上位(top-of-stack)が一番右になるように表示します。 つまり、 数値は入力時に表記されたとおりに
@code{.s} 出力に表れます。

@code{.} を使用してスタックの最上位要素を出力できます。

@example
1 2 3 . . .
@end example

一般に、 ワードはスタック引数を消費します(@code{.s} は例外です)。

@quotation 研究課題(assignment)
@code{5 6 7 .} の後、 スタックには何が含まれていますか？
@end quotation


@node Arithmetics Tutorial, Stack Manipulation Tutorial, Stack Tutorial, Tutorial
@section Arithmetics
@cindex arithmetics tutorial

@code{+} や @code{-} や @code{*} や @code{/} や @code{mod} というワードは、 常に頂上から見て 2
つのスタック項目に作用します:

@example
2 2 .s
+ .s
.
2 1 - .
7 3 mod .
@end example

@code{-} や @code{/} や @code{mod} のオペランドは、 対応する中置式と同じ順序になります(これが Forth
における一般的なケースです)。

ワードの順序によって評価の順序とオペランドが明確に決定されるため、 括弧は不要です(そして、 括弧は使用不可です):

@example
3 4 + 5 * .
3 4 5 * + .
@end example

@quotation 研究課題(assignment)
上記の Forth コードに対応する中置式はどうなるでしょうか？ また、 @code{6-7*8+9} を Forth
表記で記述してください@footnote{この表記法は、 後値記法(postfix notation) または RPN (逆ポーランド記法)
と呼ばれます。}。
@end quotation

符号を変更するには、 以下のように @code{negate} を使用します:

@example
2 negate .
@end example

@quotation 研究課題(assignment)
`-(-3)*4-5` を Forth に変換してみましょう。
@end quotation

@code{/mod} は @code{/} と @code{mod} の両方を実行します。

@example
7 3 /mod . .
@end example

詳しくはこちらを参照ください: @ref{Arithmetic}


@node Stack Manipulation Tutorial, Using files for Forth code Tutorial, Arithmetics Tutorial, Tutorial
@section Stack Manipulation
@cindex stack manipulation tutorial

スタック操作ワードはスタックのデータを並べ替えます。

@example
1 .s drop .s
1 .s dup .s drop drop .s
1 2 .s over .s drop drop drop
1 2 .s swap .s drop drop
1 2 3 .s rot .s drop drop drop
@end example

上記は最も重要なスタック操作ワードです。 以下のように2つペアでスタック項目を操作する亜種もあります:

@example
1 2 3 4 .s 2swap .s 2drop 2drop
@end example

さらに 2 つ、 以下のスタック操作ワードがあります:

@example
1 2 .s nip .s drop
1 2 .s tuck .s 2drop drop
@end example

@quotation 研究課題(assignment)
@code{nip} と @code{tuck} を他のスタック操作ワードの組み合わせに置き換えてみましょう。

@example
以下の結果になるスタック操作を考えてみましょう
Given:          How do you get:
1 2 3           3 2 1
1 2 3           1 2 3 2
1 2 3           1 2 3 3
1 2 3           1 3 3
1 2 3           2 1 3
1 2 3 4         4 3 2 1
1 2 3           1 2 3 1 2 3
1 2 3 4         1 2 3 4 1 2
1 2 3
1 2 3           1 2 3 4
1 2 3           1 3
@end example
@end quotation

@example
5 dup * . \ 5^2
@end example

@quotation 研究課題(assignment)
@code{17} を複数回書かずに、 Forth で 17^3 と 17^4 を書いてみましょう。 また、 スタック上の 2 つの数値
(@var{a} と @var{b}、 スタック頂上を @var{b} とする) を想定し、@code{(a-b)(a+1)} を計算する Forth
コードを作成してみましょう。 
@end quotation

こちらも参照してください: @ref{Stack Manipulation}


@node Using files for Forth code Tutorial, Comments Tutorial, Stack Manipulation Tutorial, Tutorial
@section Using files for Forth code
@cindex loading Forth code, tutorial
@cindex files containing Forth code, tutorial

Forth コマンド・ラインでの作業は、 1 行の例や短い 1 回限りのコードの場合には便利ですが、 あなたは編集や永続化に便利なように、
ソース・コードをファイルに保存したいと思うかもしれません。 お気に入りのエディター(なお、 Gforth には Emacs サポートがあります
@pxref{Emacs and Gforth})を使用して @var{file.fs} を作成し以下のようにします

@example
s" @var{file.fs}" included
@end example

こうすると、 @var{file.fs} ファイルを Forth システムにロードします。 私達は Forth ファイルの拡張子には
@samp{.fs} を使っています。

以下のようにいくつかのファイルをロードして、 Gforth を簡単に開始できます:

@example
gforth @var{file1.fs} @var{file2.fs}
@end example

これらのファイルのロード中にエラーが発生した場合、 Gforth は終了(terminate)しますが、 Gforth 内で
@code{INCLUDED} 中にエラーが発生すると、 通常は Gforth コマンド・ラインになります。 Forth システムを毎回開始させれば、
あなたの以前の試行の結果に影響されることなく、 毎回クリーンな開始が可能になります。

私達は多くの場合、 すべてのテストをファイルに入れて、 それからそのコードをロードし以下のようにしてテストを実行します

@example
gforth @var{code.fs} @var{tests.fs} -e bye
@end example

(多くの場合、 Emacs内 で @kbd{C-x C-e} を使用してこのコマンドを実行します。) @code{-e bye} により、 テスト後に
Gforth が確実に終了(terminate)するので、 面倒なくこのコマンドを再度開始できます。

このアプローチの利点は、 プログラムが変更されるたびにテストを簡単に繰り返すことができ、 変更によって生じたバグを簡単に発見できることです。

こちらも参照してください: @ref{Forth source files}


@node Comments Tutorial, Colon Definitions Tutorial, Using files for Forth code Tutorial, Tutorial
@section Comments
@cindex comments tutorial

@example
\ これはコメントです。これは行末で終わります
( もう一つのコメント。 これはこのように閉じ丸括弧で終わります: )  .s
@end example

@code{\} と @code{(} は通常の Forth ワードであるため、 その後ろのテキストと空白(white
space)で区切る必要があります。

@example
\This gives an "Undefined word" error
@end example

最初にあらわれる @code{)} が @code{(} で始まるコメントを終了するため、 「@code{(}
型のコメント」を入れ子(nest)にすることはできません。 そして、 @code{( ... )} を使用して @code{)}
を含むテキストをコメントアウトすることはできません@footnote{したがって、 ワード名には @code{)} を使用しないことをお勧めします。}。

私達は、 説明テキストや、 1 行以上のコードのコメントアウトに @code{\} コメントを使用します。 @code{(} コメントは、
スタック効果やスタックの内容を説明したり、 コードの下位部分をコメントアウトしたりするために使用します。

Emacs モード @file{gforth.el} (@pxref{Emacs and Gforth}) は、 @kbd{C-x \}
でリージョンをコメントアウトし、 @kbd{C-u C-x \} でリージョンのコメントを解除し、 @code{\} でコメントされた領域を
@kbd{M-q} でフィル(fill)します。

こちらも参照してください: @ref{Comments}


@node Colon Definitions Tutorial, Decompilation Tutorial, Comments Tutorial, Tutorial
@section Colon Definitions
@cindex colon definitions, tutorial
@cindex definitions, tutorial
@cindex procedures, tutorial
@cindex functions, tutorial

コロン定義(Colon Definitions)は、 他のプログラミング言語のプロシージャや関数に似ています。

@example
: squared ( n -- n^2 )
   dup * ;
5 squared .
7 squared .
@end example

@code{:} はコロン定義を開始します。 その名前は @code{squared} です。 それに続くコメントは、
そのスタック効果について説明しています。  @code{dup *} というワードは実行はされませんが、 定義にコンパイルされます(compiled
into the definition)。 @code{;} はコロン定義を終了します。

新しく定義されたワードは、 他の定義での使用を含め、 他のワードと同様に使用できます:

@example
: cubed ( n -- n^3 )
   dup squared * ;
-5 cubed .
: fourth-power ( n -- n^4 )
   squared squared ;
3 fourth-power .
@end example

@quotation 研究課題(assignment)
@code{nip} や @code{tuck} や @code{negate} や @code{/mod} のコロン定義を他の Forth
ワードで記述し、 それらが機能するかどうかを確認してみましょう (ヒント:
最初にオリジナルであなたの作成したテストコードをテストして結果を確認してから、 その後あなたが定義して、 再度テストして結果を比較しましょう)。
@samp{redefine} メッセージに驚かないでください。 これらは単なる警告です。 (訳注: redefine;
同じ名前のワードを定義したという警告。 置き換えではなく追加となる。 これ以降の通訳(interpret)・コンパイルは新しい方のワードを参照するが、
通常は新しい方のワード定義後も、 既にコンパイル済みのワードは古い方のワードを参照しつづける。 詳しくはディクショナリ等の項目を参照)
@end quotation

こちらも参照してください: @ref{Colon Definitions}


@node Decompilation Tutorial, Stack-Effect Comments Tutorial, Colon Definitions Tutorial, Tutorial
@section Decompilation
@cindex decompilation tutorial
@cindex see tutorial

@code{see}: を使用してコロン定義を逆コンパイルできます:

@example
see squared
see cubed
@end example

Gforth では、 @code{see} は実行可能コードからソース・コードを再構築したものを示します。 ソースには存在するが、
実行可能コードには存在しない情報(コメントなど)は失われます。

最初から義済みのワードを逆コンパイルすることもできます:

@example
see .
see +
@end example


@node Stack-Effect Comments Tutorial, Types Tutorial, Decompilation Tutorial, Tutorial
@section Stack-Effect Comments
@cindex stack-effect comments, tutorial
@cindex --, tutorial
慣例により、 定義名の後のコメントはスタック効果を説明します。 @samp{--} の前の部分は、 定義の実行前のスタックの状態、
つまりコロン定義に渡されるパラメータを説明します。 @samp{--} の後ろの部分は、 定義の実行後のスタックの状態、 つまり定義の実行結果です。
スタック・コメントには、 定義がアクセス、 または、変更する、 (訳注: 定義の外部から見える、 )スタック項目のみを記述します。

たとえ スタック効果が @code{( -- )} (訳注: スタックに何の効果も及ぼさない)であっても、 あなたは、
すべての定義に正しいスタック効果を記述するべきです。 また、 より複雑なワードには説明的なコメントを追加する必要があります(通常、 これは
@code{:} の後ろに続けます)。 これを行わないと、 あなたコードの行動は解読不能になります(なぜなら、 とある定義を理解するためには、
全ての定義を辿るハメになるから)。

@quotation 研究課題(assignment)
例えば @code{swap} のスタック効果は、 @code{x1 x2 -- x2 x1} のように記述できます。 同様に、 @code{-} や
@code{drop} や @code{dup} や @code{over} や @code{rot} や @code{nip} や
@code{tuck} のスタック効果を書いてみましょう。 ヒント: 書けたら、
このマニュアルに書いてあるスタック効果と合っているかどうかチェックしましょう(@pxref{Word Index})。
@end quotation

プログラマーは、 コロン定義内のさまざまな場所に、 その場所のスタックの内容を説明するコメント(スタック・コメント)を挿入することがあります。 つまり、
スタック効果コメントの最初の部分のようなものです。 例えば以下のようなのです

@example
: cubed ( n -- n^3 )
   dup squared  ( n n^2 ) * ;
@end example

この場合、 ワードが十分に単純であるため、 スタック・コメントは割と余計です。 あなたが、
読みやすさを高めるためにそのようなコメントを追加することが良いと思った場合、
ワードをいくつかの単純なワードにファクタリング(因数分解)することも検討する必要があります(@pxref{Factoring Tutorial,,
Factoring})。 ファクタリングにより、 通常はスタック・コメントが不要になります。 ただし、
あなたが結果としてリファクタリングしないことに決めた場合は、 そのようなコメントがある方が、 無いよりも良いです。

標準や、 このマニュアルや、 多くのプログラムの、 スタック効果およびスタック・コメント内のスタック項目の名前は、 Fortran
やハンガリアン記法と同様に、 型プレフィックスによって型を指定します。 最も頻繁に使用されるプレフィックスは以下のとおりです:

@table @code
@item n
符号付き整数
@item u
符号なし整数
@item c
文字(character)
@item f
二値フラグ(Boolean flags)。 つまり @code{false} または @code{true}
@item a-addr,a-
セル・アライメント・アドレス
@item c-addr,c-
文字(char)アライメント・アドレス(注意: Windows NT では文字(char)は 2 バイトになる場合があることに注意)
@item xt
実行トークン(Execution token)。 セルと同一サイズ
@item w,x
セル(cell)。 セルには整数またはアドレスを含めることができます。 通常は 32ビットまたは 64 ビットまたは 16
ビットを必要とします(プラットフォームと Forth システムによって異なります)。 cell は一般には machine word
として知られていますが、 Forth では @emph{word} という用語はすでに別の意味を持っています。
@item d
符号付き2倍長整数(signed double-cell integer)
@item ud
符号無し2倍長整数(unsigned double-cell integer)
@item r
浮動小数点数(Float)(FP スタック上に置かれる)
@end table

より完全なリストは @ref{Notation} にあります。

@quotation 研究課題(assignment)
あなたがここまでで記述したすべての定義に対してスタック効果コメントを記述してみましょう。
@end quotation


@node Types Tutorial, Factoring Tutorial, Stack-Effect Comments Tutorial, Tutorial
@section Types
@cindex types tutorial

Forth では、 演算子の名前はオーバーロードされません。 したがって、 異なる型に対する同様の演算には異なる名前が必要です。 たとえば、
@code{+} は整数の加算をしますが、 浮動小数点数を加算するには @code{f+} を使用する必要があります。 以下のプレフィックスは、
さまざまな型の関連する演算によく使用されます:

@table @code
@item (none)
符号付き整数
@item u
符号なし整数
@item c
文字(character)
@item d
符号付き2倍長整数(signed double-cell integer)
@item ud, du
符号無し2倍長整数(unsigned double-cell integer)
@item 2
2 つのセル(必ずしも 2倍長整数(double-cell numbers)とは限りません)
@item m, um
単一セルとダブル・セルの混合操作
@item f
浮動小数点(注意: スタック・コメントでは、 @samp{f} はフラグを表し、 @samp{r} は FP 数値を表すことに注意してください。 また、
リテラル FP 数値には指数部分を含める必要があります @pxref{Floating Point Tutorial})。
@end table

符号付きのバリエーションと符号なしのバリエーションに違いがない場合(例えば @code{+} の場合)、
プレフィックスのないバリエーションのみが存在します。

Forth は、 コンパイル・モード時もインタプリタ・モード時も型チェックを実行しません。 以下のように間違った操作を行うと、
データが正しく通訳(interpret)されません:

@example
-1 u.
@end example

あなたが、 これまで型チェック言語しか使用したことがなく、 型チェックがいかに重要であるかを聞いたことがある場合でも、 パニックに陥る必要はありません。
著者の経験(および他の Forth 利用者(Forthers)の経験)では、 Forth コードの型エラーは通常(慣れてしまえば)簡単に見つかります。
プログラマの警戒心が高まると、 ほとんどの型エラーに加えて、 より困難なエラーも発見される傾向があります。 型システムを回避する必要がまったくないため、
ほとんどの状況では型チェックがないことが利点であるようです(Forth に型チェックを追加するプロジェクトは普及していません)。


@node Factoring Tutorial, Designing the stack effect Tutorial, Types Tutorial, Tutorial
@section Factoring
@cindex factoring tutorial

あなたが長ったらしい定義を書こうとすると、 スタックの内容を追跡するのがすぐに困難になることがわかります。 したがって、優れた Forth
プログラマは短い定義 (たとえば 3 行)のみを記述する傾向があります。 意味のある短い定義を見つける技術は、 (多項式の因数分解(factoring
polynomials)と同様に)ファクタリング(factoring)として知られています。

よくファクタリングされたプログラムには、 追加の利点もあります。 つまり、小さくて一般的なワードは、
大きくて特殊なワードよりもテストとデバッグが容易で、より再利用性に富みます。

したがって、 あなたが、 スタック管理に問題を抱えてるなら、 コードを記述するときにワードに意味のある要素を定義し、
それらの観点からワードを定義するようにしてください。 たった 2 つのワードしかしか含まれないような定義でも、 多くの場合役に立ちます。

上手なファクタリングは簡単ではなく、 コツを掴むにはある程度の練習が必要です。 しかし、経験豊富な Forth プログラマーであっても、
すぐには適切な解決策を見つけられないことが多く、 プログラムの書き直し時に見つかるのです。 したがって、 すぐに良い解決策が思い浮かばなくても、
絶望しないで試し続けてください。(訳注: 参考: 拙訳 Thinking Forth 第6章 ファクタリング
@url{https://thinking-forth-ja.readthedocs.io/ja/latest/chapter6.html})

@c example !!


@node Designing the stack effect Tutorial, Local Variables Tutorial, Factoring Tutorial, Tutorial
@section Designing the stack effect
@cindex Stack effect design, tutorial
@cindex design of stack effects, tutorial

他の言語では、 関数(function)のパラメータに任意の順序を使用できます。 また、 結果は 1 つだけなので、 結果の順序を扱う必要もありません。

Forth (および他のスタック・ベースの言語、 たとえば PostScript)では、 定義のパラメーターの順序と結果の順序が重要であり、
適切に設計する必要があります。 一般的なガイドラインは、 ワードの実装が複雑になる場合でも、
ワードがほとんどの場合に簡単に使用できるようにスタック効果を設計することです。 いくつかの具体的なルールは以下のとおりです:

@itemize @bullet

@item
ワードがパラメータの全てを消費する(例: @code{.})。

@item
パラメータの順序に関する慣習がある場合(数学や他のプログラミング言語など)、 それに従ってください(例: @code{-})。

@item
1 つのパラメータが通常短い計算のみを必要とする場合(たとえば、それが定数である場合)、 それをスタック頂上(top of
stack;TOS)に渡します。 逆に、 通常、 計算に長いコード シーケンスが必要なパラメータは、 スタック底(bottom) (つまり、最初の)
パラメータとして渡す必要があります。 これにより、 リーダーはコードの長いシーケンス(またはスタック操作)を通じてスタック底の項目(bottom
item)を追跡する必要がなくなるため、 コードが読みやすくなります。 たとえば、 @code{!}(「ストア」 @pxref{Memory})は、
通常、 格納されている値よりも計算が簡単であるため、 スタック頂上にアドレスがあるのを期待します(多くの場合、 アドレスは単なる変数です)。

@item
同様に、 通常すぐに消費される結果はスタック頂上(top of stack)に返されるべきですが、
長い計算でよく使用される結果はスタック底(bottom)の結果として渡される必要があります。 たとえば、 @code{open-file}
のようなファイル・ワードは、スタック頂上にエラー・コードを返します。 これは、 通常、 @code{throw} によってすぐに消費されるためです。
さらに言えば、 他の結果に対して何かを行う前に、 エラー・コードをチェックする必要があります。

@end itemize

これらのルールは一般的なガイドラインに過ぎません。 ワードを使いやすくするという全体的な目標を見失わないでください。 例えば、
慣習のルールが計算長のルールと衝突する場合、 ワードがあまり使われない場合は慣習を優先するかもしれません。 一方、 ワードが頻繁に使われる場合は、
計算長のルールを優先するかもしれません(だからといって頻繁に使うと、 計算長のルールを破るコストが非常に高くなりますし、
頻繁に使うことで非慣習的な順序を覚えてしまいがちになります)。

@c example !! structure package


@node Local Variables Tutorial, Conditional execution Tutorial, Designing the stack effect Tutorial, Tutorial
@section Local Variables
@cindex local variables, tutorial

コロン定義内でローカル変数(local)を定義できます:

@example
: swap @{ a b -- b a @}
  b a ;
1 2 swap .s 2drop
@end example

(あなたの Forth システムがこの構文をサポートしていない場合は、  最初に @file{compat/anslocal.fs}
をインクルードしてください)

この例では、 @code{@{ a b -- b a @}} がローカル変数定義です。 スタックから 2 つのセルを取得し、 スタック頂上を
@code{b} に入れ、 その次のスタック要素を @code{a} に入れます(訳注: a b はスタック上から取り除かれる)。 @code{--}
は @code{@}} で終わるコメントを開始します。 ローカル変数の定義後、 ローカル変数の名前を使用すると、 その値がスタックに積まれます。
コメント部分(@code{-- b a})は省略できます:

@example
: swap ( x1 x2 -- x2 x1 )
  @{ a b @} b a ;
@end example

Gforth では、 コロン定義内の任意の場所に複数のローカル変数定義を含めることができます。 対照的に、 標準Forthのプログラムでは、
コロン定義ごとにローカル変数定義を 1 つだけしか持つことができず、 そのローカル変数定義は制御構造の外側にある必要があります。

ローカル変数を使用すると、 スタックの問題に遭遇することなく、 少し長い定義を書くことができます。
ただし、重要な、ファクタリング技能を身につけるための演習として、 ローカル変数を使用せずにコロン定義を記述してみることをお勧めします。

@quotation 研究課題(assignment)
ここまでのあなたの定義をローカル変数を使って書き換えてみましょう。
@end quotation

こちらも参照下さい: @ref{Locals}


@node Conditional execution Tutorial, Flags and Comparisons Tutorial, Local Variables Tutorial, Tutorial
@section Conditional execution
@cindex conditionals, tutorial
@cindex if, tutorial

Forth では、 コロン定義内でのみ制御構造を使用できます。 @code{if} 構造は以下のようになります:

@example
: abs ( n1 -- +n2 )
    dup 0 < if
        negate
    endif ;
5 abs .
-5 abs .
@end example

@code{if} はスタックからフラグを取得します。 フラグがゼロ以外 (true) の場合は、 その次のコードが実行されます。 そうでない場合は、
@code{endif} (または @code{else}) の後から実行が続けられます。 @code{<} は、 頂上から 2
つのスタック要素を比較し、 フラグを生成します。

@example
1 2 < .
2 1 < .
1 1 < .
@end example

実は、 @code{endif} の標準Forthでの名前は @code{then} です。 このチュートリアルでは、 @code{endif}
を使用した例を示します。 なぜなら、 @code{then} が異なる意味を持つ他のプログラミング言語に慣れている人々にとっては、
@code{endif} を使用する方が混乱が少ないからです。 システムに @code{endif} がない場合は、 以下のように定義します

@example
: endif postpone then ; immediate
@end example

あなたはオプションで @code{else} 部分を使用できます:

@example
: min ( n1 n2 -- n )
  2dup < if
    drop
  else
    nip
  endif ;
2 3 min .
3 2 min .
@end example

@quotation 研究課題(assignment)
@code{else} 部分を付けずに @code{min} を記述してみましょう。 (ヒント: @code{nip} の定義は何ですか?)。
@end quotation

こちらも参照下さい: @ref{Selection}


@node Flags and Comparisons Tutorial, General Loops Tutorial, Conditional execution Tutorial, Tutorial
@section Flags and Comparisons
@cindex flags tutorial
@cindex comparison tutorial

false フラグはすべてのビットがクリアです(整数として通訳(interpret)される場合は 0)。 正規化された true フラグは、
すべてのビットがセットされています(2の補数の符号付き整数として -1)。 多くの文脈(例: @code{if})では、ゼロ以外の値はすべて true
フラグとして扱われます。

@example
false .
true .
true hex u. decimal
@end example

比較ワードは正規化フラグを生成します:

@example
1 1 = .
1 0= .
0 1 < .
0 0 < .
-1 1 u< . \ 型エラー。 u< は -1 を 大きな符号なし数として扱ってしまいます
-1 1 < .
@end example

Gforth は、接頭辞 @code{0 u d d0 du f f0} (または「 接頭辞なし」)との比較 @code{= <> < > <= >=}
のすべての組み合わせをサポートします。 これらの組み合わせの一部のみが標準Forthです (詳細については、標準Forth または
@ref{Numeric comparison} または @ref{Floating Point} または @ref{Word Index}
を参照してください)。

@code{and or xor invert} を正規化フラグ用の演算子として使用できます。 実際には、 これらはビット単位演算です:

@example
1 2 and .
1 2 or .
1 3 xor .
1 invert .
@end example

@code{0<>} を使用して ゼロ/非ゼロ フラグを正規化フラグに変換できます(そして、 その途中で @code{0=} を使用して ゼロ/非ゼロ
フラグの余数(complement)を取ります。 実際、 正規化フラグでは @code{invert} の代わりに @code{0=}
を使用するのが一般的です)。

@example
1 0= .
1 0<> .
@end example

@code{0<>} 無しでも @code{if} で ゼロ/非ゼロ をテストすることはできますが、 ゼロ/非ゼロ 値を @code{and or
xor} と組み合わせる場合、 @code{and or xor} はビット単位での操作なので、 @code{0<>}
を使用する必要がある場合があります。 最も単純で、 エラーが少なく、 おそらく最も明確な方法は、 これらすべての場合に @code{0<>}
を使用することですが、 場合によっては、 使用する @code{0<>} の数を減らすこともできます。 以下にいくつかのスタック効果を示します。
@i{fc} は正規化フラグ(canonical flag)を表し、 @i{fz} は ゼロ/非ゼロ を表します(すべての @i{fc} は
@i{fz} としても機能します):

@example
or  ( fz1 fz2 -- fz3 )
and ( fz1 fc  -- fz2 )
and ( fc  fz1 -- fz2 )
@end example

したがって、 以下のようなコードの場合:

@example
( n1 n2 ) 0<> and if
@end example

これは、 n1 and n2 (n1 かつ n2)がゼロ以外であるかどうかをテストし、 イエスの場合は @code{if} の後のコードを実行します。
n1 を ゼロ/非ゼロ として扱い、 @code{0<>} を使用して n2 を正規化フラグに変換します。 @code{and} は fz を生成し、
それは @code{if} によって消費されます。

正規化フラグの全ビットセット機能とブール演算のビット単位の演算を使用して、 @code{if} を回避することもできます:

@example
: foo ( n1 -- n2 )
  0= if
    14
  else
    0
  endif ;
0 foo .
1 foo .

: foo ( n1 -- n2 )
  0= 14 and ;
0 foo .
1 foo .
@end example

@quotation 研究課題(assignment)
@code{min} を @code{if} 無しで書いてみましょう。
@end quotation

こちらも参照下さい: @ref{Boolean Flags}, @ref{Numeric comparison}, @ref{Bitwise
operations}


@node General Loops Tutorial, Counted loops Tutorial, Flags and Comparisons Tutorial, Tutorial
@section General Loops
@cindex loops, indefinite, tutorial

無限ループは非常に単純です:

@example
: endless ( -- )
  0 begin
    dup . 1+
  again ;
endless
@end example

(Gforth の場合、) @kbd{Ctrl-C} を押してこのループを終了します。  @code{begin} は実行時に何も行わず、
@code{again} は @code{begin} にジャンプします。

任意の場所に 1 つの出口があるループは以下のようになります:

@example
: log2 ( +n1 -- n2 )
\ logarithmus dualis of n1>0, rounded down to the next integer
  assert( dup 0> )
  2/ 0 begin
    over 0> while
      1+ swap 2/ swap
  repeat
  nip ;
7 log2 .
8 log2 .
@end example

実行時には @code{while} はフラグを1つ消費します。 フラグが 0 の場合、 @code{repeat} の後ろへ飛んで実行が継続されます。
フラグがゼロ以外の場合、 実行は @code{while} の後ろから継続されます。 @code{Repeat} は、 @code{again}
と全く同じように、  @code{begin} に戻ります。

Forth には、 @code{1+} など、多数の 組み合わせ/省略形 があります。 しかし、 @code{2/} は 組み合わせ/省略形
ではありません。 これは引数を 1 ビット右にシフトし、 Gforth の (Gforth 0.7 以降の) @code{/} と同様、
常に負の無限大方向に向かって小数点以下を丸める除算(フロア除算)と見なされますが、 他の多くの Forth システムの @code{/}
とは異なります。

@example
-5 2 / . \ -2 or -3
-5 2/ .  \ -3
@end example

@code{assert(} は標準Forthのワードではありませんが、 Gforth 以外のシステムでも
@file{compat/assert.fs} を含めることで取得できます。 それが何をするかは、 以下のように試してみることで確認できます。

@example
0 log2 .
@end example

以下は、 最後に出口があるループです:

@example
: log2 ( +n1 -- n2 )
\ logarithmus dualis of n1>0, rounded down to the next integer
  assert( dup 0 > )
  -1 begin
    1+ swap 2/ swap
    over 0 <=
  until
  nip ;
@end example

@code{Until} はフラグを消費します。 フラグがゼロの場合は @code{begin} から実行が継続され、 それ以外の場合は
@code{until} の後から実行が継続されます。

@quotation 研究課題(assignment)
最大公約数を計算する定義を書いてみましょう。
@end quotation

こちらも参照ください: @ref{Simple Loops}


@node Counted loops Tutorial, Recursion Tutorial, General Loops Tutorial, Tutorial
@section Counted loops
@cindex loops, counted, tutorial

@example
: ^ ( n1 u -- n )
\ n = the uth power of n1
  1 swap 0 u+do
    over *
  loop
  nip ;
3 2 ^ .
4 3 ^ .
@end example

@code{U+do} (あなたの Forth システムにない場合は @file{compat/loops.fs} をインクルードしてください)は、
@code{( u3 u4 -- )} 、 つまり、 スタックから 2 つの数値を取得し、 @code{u+do} と @code{loop}
の間のコードを @code{u3 - u4} 回実行します(@code{ u3 - u4 < 0} の場合はまったく実行しません)。

ループ開始ワードのスタック効果を見れば、スタック効果の設計ルールが機能していることがわかります。
ループの開始値は終了値と比べて定数であることが多いため、 開始値はスタック頂上(top-of-stack)に渡されます。

@code{i} を使用して、 ループ・カウンターにアクセスできます:

@example
: fac ( u -- u! )
  1 swap 1+ 1 u+do
    i *
  loop ;
5 fac .
7 fac .
@end example

@code{+do} もあります。 これは符号付きの数値を期待します(それはループに入るかどうかを決定するために重要です)。

@quotation 研究課題(assignment)
n 番目のフィボナッチ数を計算するための定義を記述してみましょう。
@end quotation

増分として 1 以外も使用できます:

@example
: up2 ( n1 n2 -- )
  +do
    i .
  2 +loop ;
10 0 up2

: down2 ( n1 n2 -- )
  -do
    i .
  2 -loop ;
0 10 down2
@end example

こちらも参照ください: @ref{Counted Loops}


@node Recursion Tutorial, Leaving definitions or loops Tutorial, Counted loops Tutorial, Tutorial
@section Recursion
@cindex recursion tutorial

通常、 定義の名前はその定義内に表れません。ただし、 それ以前の(同名の)定義は普通に表れます(訳注: 下記例は再帰呼出しではなくて、 '/'
の古いバージョンを呼び出しているに過ぎない事に注意。同じ名前の古いバージョンが存在しなければエラーになるが、存在すればエラーにならないので注意。):

@example
1 0 / . \ "Floating-point unidentified fault" in Gforth on some platforms
: / ( n1 n2 -- n )
  dup 0= if
    -10 throw \ report division by zero
  endif
  /           \ old version
;
1 0 /
@end example

再帰定義の場合は、 @code{recursive} (非標準) または @code{recurse} を使用できます:

@example
: fac1 ( n -- n! ) recursive
 dup 0> if
   dup 1- fac1 *
 else
   drop 1
 endif ;
7 fac1 .

: fac2 ( n -- n! )
 dup 0> if
   dup 1- recurse *
 else
   drop 1
 endif ;
8 fac2 .
@end example

@quotation 研究課題(assignment)
n 番目のフィボナッチ数を計算するための再帰定義を記述してみましょう。
@end quotation

こちらも参照ください (間接再帰に関してもコチラ): @xref{Calls and returns}


@node Leaving definitions or loops Tutorial, Return Stack Tutorial, Recursion Tutorial, Tutorial
@section Leaving definitions or loops
@cindex leaving definitions, tutorial
@cindex leaving loops, tutorial

@code{EXIT} は、 現在の定義をすぐに終了(exit)します。 @code{EXIT} の実行前に、
(残ったループ・カウンタ達を全て取り除くために、)ネストしたカウンタ付きループの数だけ @code{UNLOOP} を実行する必要があります(訳注:
下記例は1重のループなので unloop が1つ。 2重ループになったら unloop unloop と2つ必要):

@c !! real examples
@example
: ...
 ... u+do
   ... if
     ... unloop exit
   endif
   ...
 loop
 ... ;
@end example

@code{LEAVE} は、 (@code{LEAVE} から見て)最も内側にあるカウンタ付きループを直ちに終了します:

@example
: ...
 ... u+do
   ... if
     ... leave
   endif
   ...
 loop
 ... ;
@end example

@c !! example

こちらも参照ください: @ref{Calls and returns}, @ref{Counted Loops}


@node Return Stack Tutorial, Memory Tutorial, Leaving definitions or loops Tutorial, Tutorial
@section Return Stack
@cindex return stack tutorial

データ・スタックに加えて、 Forth には 2 番目のスタックであるリターン・スタックもあります。 ほとんどの Forth
システムは、プロシージャ呼び出しの戻りアドレスをそこに保存します(したがって、 リターン・スタックという名前が付けられています)。
プログラマもリターン・スタックを利用することができます。

@example
: foo ( n1 n2 -- )
 .s
 >r .s
 r@@ .
 >r .s
 r@@ .
 r> .
 r@@ .
 r> . ;
1 2 foo
@end example

@code{>r} はデータ・スタックから1つの要素を取得し、 それをリターン・スタックにプッシュします。 逆に、 @code{r>}
は1つの要素をリターンからデータ・スタックに移動します。 @code{r@@} は、リターン・スタック頂上のコピーをデータ・スタックにプッシュします。

Forth プログラマーは通常、 データ・スタックのみを使用すると複雑すぎて、 かつ、 ファクタリングやローカル変数が選択肢に無い場合、
データを一時的に保存するためにリターン・スタックを使用します。

@example
: 2swap ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
 rot >r rot r> ;
@end example

定義のリターン・アドレスとカウント付きループのループ制御パラメータは通常、 リターン・スタック上に存在するため、
コロン定義またはカウント付きループでリターン
スタックにプッシュしたすべての項目を、定義の終了やループの終了の前にリターン・スタックから取得する必要があります。
ある定義の外側やループの外側でリターン・スタックにプッシュしたアイテムに、 ループの定義内からアクセスすることはできません。

リターン・スタック項目の数を間違えると、 通常はクラッシュします:

@example
: crash ( n -- )
  >r ;
5 crash
@end example

ローカル変数の使用とリターン・スタックの使用を混在させることはできません(標準Forthの場合。 Gforth では問題ありません)。 ただし、
これらは同一の問題の解決なので、 問題にはなりません。

@quotation 研究課題(assignment)
リターン・スタックを使用して、 ここまでにあなたが書いた定義をより良い方法で書き直すことができるでしょうか？
@end quotation

こちらも参照ください: @ref{Return stack}


@node Memory Tutorial, Characters and Strings Tutorial, Return Stack Tutorial, Tutorial
@section Memory
@cindex memory access/allocation tutorial

以下使用してグローバル変数 @code{v} を作成できます:

@example
variable v ( -- addr )
@end example

@code{v} は、スタックにメモリ内の、とあるセルのアドレスをプッシュします。 このセルは @code{variable}
によって予約されています。 @code{!}(ストア)を使用してスタックからこのセルに値を保存し、
@code{@@}(フェッチ)を使用して値をメモリからスタックにロードできます:

@example
v .
5 v ! .s
v @@ .
@end example

@code{dump} を使用すると、 メモリの生のダンプ(メモリー・ダンプ)を確認できます:

@example
v 1 cells .s dump
@end example

@code{Cells ( n1 -- n2 )} は、 n1 個のセル が占めるバイト数(より一般的にはアドレス単位(address
units)(aus))を与えます。 そして、 あなたは、 さらに多くのメモリを予約することもできます:

@example
create v2 20 cells allot
v2 20 cells dump
@end example

変数のようなワード @code{v2} を作成し、 20 個の初期化されていないセルを予約します。 @code{v2}
によってプッシュされたアドレスは、 これら 20 個のセルの先頭を指します(@pxref{CREATE})。 あなたは、 アドレス演算を使用して、
これらのセルにアクセスできます:

@example
3 v2 5 cells + !
v2 20 cells dump
@end example

@code{,} を使用してメモリを予約 かつ 初期化できます:

@example
create v3
  5 , 4 , 3 , 2 , 1 ,
v3 @@ .
v3 cell+ @@ .
v3 2 cells + @@ .
v3 5 cells dump
@end example

@quotation 研究課題(assignment)
最初のセルは @code{addr} 、 次のセルは @code{addr cell+} などとして、 @code{u}
個のセルの値の合計を計算する定義 @code{vsum ( addr u -- n )} を記述してみましょう。
@end quotation

@code{variable} と @code{create} の違いは、@code{variable} がセルを割り当てる(allots)ことと、
標準 Forth では変数(variable)に追加のメモリを割り当てることができないことです。

新しいワードを作成せずにメモリを予約することもできます:

@example
here 10 cells allot .
here .
@end example

最初の @code{here} は(最初の @code{here} 時点の)ディクショナリ領域の後のアドレスをプッシュし、
メモリ領域の開始アドレスとして使い、 2 番目の @code{here} は(2 番目の @code{here}
時点の)ディクショナリ領域の後のアドレスをプッシュします。 この開始アドレスはどこかに保存する必要があります。 そうしないと、
あなたはこのメモリ領域を再度見つけるのが困難になります。

@code{Allot} はディクショナリ・メモリを管理します。 ディクショナリ・メモリには、 Gforth や他のほとんどの Forth システムの、
ワードなどのシステムのデータ構造が含まれています。 これはスタックのように管理されます。
あなたは以下のようにして割り当て(@code{allot})したメモリを解放できます:

@example
-10 cells allot
here .
@end example

注意: その合間に新しいワードを作成した場合、 それを実行できないことに注意してください(@code{allot} で作成されたメモリが、
もはやディクショナリ「スタック」の頂上ではなくなるため)。

その代わりに、 @code{allocate} や @code{free} を使用すると、 任意の順序でメモリを解放できます:

@example
10 cells allocate throw .s
20 cells allocate throw .s
swap
free throw
free throw
@end example

@code{throw} はエラー(メモリ不足など)を処理します。

また、 @uref{https://www.complang.tuwien.ac.at/forth/garbage-collection.zip,
ガベージ・コレクター} なら、 メモリを明示的に解放(@code{free})する必要がなくなります。

こちらも参照ください: @ref{Memory}


@node Characters and Strings Tutorial, Alignment Tutorial, Memory Tutorial, Tutorial
@section Characters and Strings
@cindex strings tutorial
@cindex characters tutorial

スタック上では、 数と同様に文字がセルを占めます。 メモリ内では文字は独自のサイズ(ほとんどのシステムでは 8 ビットのバイト値)であるため、
メモリ・アクセスには文字独自のワードが必要です:

@example
create v4 
  104 c, 97 c, 108 c, 108 c, 111 c,
v4 4 chars + c@@ .
v4 5 chars dump
@end example

スタック上の文字列の推奨される表現は @code{addr u-count} です。ここで、@code{addr} は文字列の最初の文字のアドレスで、
@code{u-count} は文字列の文字数です。

@example
v4 5 type
@end example

以下を使用すると文字列定数を取得できます

@example
s" hello, world" .s
type
@end example

@code{s"} と文字列の間にスペースがあることを確かめてください。 @code{s"} は通常の Forth ワードであり、 空白(white
space)で区切る必要があります(スペースを削除するとどうなるかを試してみましょう)。

ただし、 この @code{s"} のインタプリタでの使用(interpretive use)は非常に制限されています。 文字列は、 @code{s"}
が次に呼び出されるまでの間だけ存在します(一部の Forth システムはこれらの文字列を複数保持しますが、 普通は未だ限られた寿命です)。

@example
s" hello," s" world" .s
type
type
@end example

あなたは定義内で @code{s"} を使用することもでき、 (定義が続く限り、)その結果の文字列は永久に存続します:

@example
: foo s" hello," s" world" ;
foo .s
type
type
@end example

@quotation 研究課題(assignment)
@code{Emit ( c -- )} は @code{c} を(数値ではなく)文字として出力します。 これを使って @code{type (
addr u -- )} を実装してみましょう。
@end quotation

こちらも参照ください: @ref{Memory Blocks}


@node Alignment Tutorial, Floating Point Tutorial, Characters and Strings Tutorial, Tutorial
@section Alignment
@cindex alignment tutorial
@cindex memory alignment tutorial

多くのプロセッサでは、 @code{@@} と @code{!} を使用してセルにアクセスする場合、 メモリ内でセ​​ルをアライメントする必要があります
(プロセッサがアライメントを必要としない場合でも、 アライメントされたセルへのアクセスは高速です)。

@code{Create} は @code{here}(つまり、 次の割り当てが行われる場所、
そして@code{create}されたワードが指す場所)でアライメントします。 同様に、
@code{allocate}によって生成されたメモリはアライメントしたアドレスから始まります。 アライメントしたアドレスに @code{cells}
の数値 を足すと、 次のアライメントされたアドレスが生成されます。

ただし、 @code{char+} および @code{chars}
を含むアドレス演算では、セルにアライメントしていないアドレスが作成される可能性があります。 @code{Aligned ( addr -- a-addr
)} は、 その次のアライメントせされたアドレスを生成します:

@example
v3 char+ aligned .s @@ .
v3 char+ .s @@ .
@end example

同様に、 @code{align} は @code{here} を次のアライメントされたアドレスに進めます:

@example
create v5 97 c,
here .
align here .
1000 ,
@end example

注意: プログラムを移植可能にしたい場合は、 プロセッサがそれらを必要としない場合でも、
アライメントれたアドレスを使用する必要があることに注意してください。

こちらも参照ください: @ref{Address arithmetic}

@node Floating Point Tutorial, Files Tutorial, Alignment Tutorial, Tutorial
@section Floating Point
@cindex floating point tutorial
@cindex FP tutorial

Forth の浮動小数点(floating-point)(FP)の、 数値と算術演算は、 ほぼ期待された通りに機能しますが、
特筆すべき点がいくつかあります:

最初の点は Forth に固有のものではありませんが、 非常に重要で、 まだ広く知られていないため、 ここで言及します。
浮動小数点数は実数(real)ではありません。 実数(real)が持ち、 あらゆる種類の数値に期待される多くの性質(算術法則など)は、
浮動小数点数には当てはまりません。 浮動小数点演算したい場合、 浮動小数点演算の問題とその回避方法について学ぶ必要があります。 良い出発点は
@cite{David Goldberg,
@uref{https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html,What
Every Computer Scientist Should Know About Floating-Point Arithmetic}, ACM
Computing Surveys 23(1):5@minus{}48, March 1991} です(訳注:
@url{https://docs.oracle.com/cd/E19957-01/806-4847/ncg_goldberg.html}
これが合ってるかどうか不明。一部文字化けあり2024/06現在)。

Forth ソース・コードでは、リテラル浮動小数点数には指数が必要です(例: @code{1e0})。これは、 @code{1e}
のように短く書くことも、 @code{+1.0e+0} のように長く書くこともでき、 その間にはさまざまなバリエーションがあります。 その理由は、
歴史的な理由により、 Forth は小数点のみ(例: @code{1.}) の数を 2 セル整数を示すものとして通訳(interpret)するためです。
例:

@example
2e 2e f+ f.
@end example

リテラル浮動小数点数のもう 1 つの要件は、 現在の基数が 10 進数であることです。 16 進数の @code{1e}
は整数として通訳(interpret)されます:

Forth には、Forth-2012 に準拠した浮動小数点数用の別個のスタックがあります。 このモデルの利点の 1 つは、
浮動小数点数にアクセスするときにセルが邪魔にならないこと、 またその逆も同様であることです。 Forth には、 浮動小数点スタック(FP
スタック)を操作するためのワードのセットがあります:  @code{fdup fswap fdrop fover frot} や (非標準の、)
@code{fnip ftuck fpick}

FP 算術ワードには @code{F} という接頭辞が付きます。 通常の @code{f+ f- f* f/ f** fnegate} のほか、 他の、
関数用の多数のワード (例: @code{fsqrt fsin fln fmin}) があります。 期待されるワードの 1 つが @code{f=}
ですが、 @code{f=} は標準にはありません。 浮動小数点数の計算結果は通常不正確であるため、 正確な比較は通常間違いであり、
近似的な比較を使用する必要があります。 残念ながら、この目的のための標準のワードである @code{f~} は適切に設計されていないため、 Gforth
では @code{f~abs} と @code{f~rel} も提供しています。

そしてもちろん、 メモリ内の浮動小数点数にアクセスするためのワード(@code{f@@ f!})や、 アドレス演算用のワード(@code{floats
float+ faligned})もあります。 メモリ内の IEEE 書式の単精度および倍精度数にアクセスするために、 @code{sf} および
@code{df} プレフィックスを付けた、 これらのワードのバリエーションもあります。 その主な目的は、
外部浮動小数点数データ(ファイルから読み取られた、 またはファイルに書き込まれるデータなど)にアクセスすることです。

以下は、 ドット出力ワード(dot-product word)とその使用例です:

@example
: v* ( f_addr1 nstride1 f_addr2 nstride2 ucount -- r )
  >r swap 2swap swap 0e r> 0 ?DO
    dup f@@ over + 2swap dup f@@ f* f+ over + 2swap
  LOOP
  2drop 2drop ;

create v 1.23e f, 4.56e f, 7.89e f,

v 1 floats  v 1 floats  3  v* f.
@end example

@quotation 研究課題(assignment)
二次方程式を解くプログラムを作成してみましょう。 次に、 @cite{Henry G. Baker,
@uref{https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.111.4448&rep=rep1&type=pdf,You
Could Learn a Lot from a Quadratic}, ACM SIGPLAN Notices,
33(1):30@minus{}39, January 1998} を読んで、 そのプログラムを改善できるかどうか確認してください。 最後に、
元のバージョンと改良されたバージョンで異なる結果が生成されるテスト・ケースを探しましょう。
@end quotation

こちらも参照ください: @ref{Floating Point}; @ref{Floating point stack}; @ref{Number
Conversion}; @ref{Memory Access}; @ref{Address arithmetic}.

@node Files Tutorial, Interpretation and Compilation Semantics and Immediacy Tutorial, Floating Point Tutorial, Tutorial
@section Files
@cindex files tutorial

このセクションでは、 Forth 内でファイルを使用する方法について簡単に説明します。 それは 5 つの簡単なステップに分かれています:

@enumerate 1
@item 入力用に ASCII テキスト・ファイルを開きます
@item 出力用にファイルを開く
@item 文字列が一致する (または他の条件が満たされる) まで入力ファイルを読み取ります
@item 入力 (が変更されたかどうかに関係なく、) から数行を出力に書き込みます
@item ファイルを閉じます。
@end enumerate

こちらも参照ください: @ref{General files}

@subsection Open file for input

@example
s" foo.in"  r/o open-file throw Value fd-in
@end example

@subsection Create file for output

@example
s" foo.out" w/o create-file throw Value fd-out
@end example

使用可能なファイル・モードは、 読み取り専用アクセスの場合は r/o 、 読み取り/書き込み アクセスの場合は r/w 、書き込み専用アクセスの場合は
w/o です。 必要に応じて、 読み取りと書き込みの両方のファイルを r/w で開くこともできます。 すべてのファイル用ワードはエラーコードを返します。
ほとんどのアプリケーションでは、 @code{throw} を使用してエラー・コードを外部のエラー・ハンドラーに渡すのが最善(best)です。

開いたり(opening)割り当てたり(assigning)するためのワードが必要な場合は、 以下のように定義します:

@example
0 Value fd-in
0 Value fd-out
: open-input ( addr u -- )  r/o open-file throw to fd-in ;
: open-output ( addr u -- )  w/o create-file throw to fd-out ;
@end example

使用例:

@example
s" foo.in" open-input
s" foo.out" open-output
@end example

@subsection ファイルの特定の行をスキャン

@example
256 Constant max-line
Create line-buffer  max-line 2 + allot

: scan-file ( addr u -- )
  begin
      line-buffer max-line fd-in read-line throw
  while
         >r 2dup line-buffer r> compare 0=
     until
  else
     drop
  then
  2drop ;
@end example

@code{read-line ( addr u1 fd -- u2 flag ior )} は、 addr からのバッファーに最大 u1
バイトを読み取り、 読み取ったバイト数と、 ファイルの終わりに達した場合に false になるフラグと、 エラーコードを返します。

@code{compare ( addr1 u1 addr2 u2 -- n )} は 2 つの文字列を比較し、 両方の文字列が等しい場合は 0
を返します。 最初の文字列の方が字句的に大きい(lexically greater)場合は正の数値を返し、 2
番目の文字列の方が字句的に大きい(lexically greater)場合は負の数値を返します。

このループは、 まだ見たことがないですよね。 このループは出口が2つあります。  @code{while}
はスタック上にある読み取ったバイト数で終了するため、 それを個別にクリーンアップする必要があります。 そのクリーンアップする部分は
@code{else} の後にあります。

使用例:

@example
s" The text I search is here" scan-file
@end example

@subsection Copy input to output

@example
: copy-file ( -- )
  begin
      line-buffer max-line fd-in read-line throw
  while
      line-buffer swap fd-out write-line throw
  repeat 
  drop ;
@end example
@c !! does not handle long lines, no newline at end of file

@subsection Close files

@example
fd-in close-file throw
fd-out close-file throw
@end example

これも、同様に、 定義に組み込むことができます:

@example
: close-input ( -- )  fd-in close-file throw ;
: close-output ( -- )  fd-out close-file throw ;
@end example

@quotation 研究課題(assignment)
@code{copy-file} を変更して、 2 行目が一致するまでコピーするようにするにはどうすればよいでしょうか？
セクションの開始行と終了行を指定して、 テキスト・ファイルのセクションを抽出するプログラムを作成できますか？
@end quotation

@node Interpretation and Compilation Semantics and Immediacy Tutorial, Execution Tokens Tutorial, Files Tutorial, Tutorial
@section Interpretation and Compilation Semantics and Immediacy
@cindex semantics tutorial
@cindex interpretation semantics tutorial
@cindex compilation semantics tutorial
@cindex immediate, tutorial

ワードがコンパイルされる時と、 通訳(interpret)される時では異なる振る舞いをします。 たとえば、 @code{+} について考えてみましょう:

@example
1 2 + .
: foo + ;
@end example

これらの 2 つの振る舞いは、 コンパイル機能(compilation semantics)とインタプリタ機能(interpretation
semantics)として知られています。 通常のワード(例: @code{+})の場合、 コンパイル機能は、 現在定義中のワード(上記の例では
@code{foo})にインタプリタ機能を追加します。 つまり、 後で @code{foo} が実行されると、 @code{+}
のインタプリタ機能(interpretation semantics)(つまり、2 つの数値の加算)が実行されます。

ただし、 @code{if} のような制御フロー・ワードなど、 デフォルト以外のコンパイル機能を持つワードが存在します。
@code{immediate} を使用すると、 最後に定義されたワードのコンパイル機能をインタプリタ機能と等しくなるように変更できます:

@example
: [FOO] ( -- )
 5 . ; immediate

[FOO]
: bar ( -- )
  [FOO] ;
bar
see bar
@end example

デフォルト以外のコンパイル機能をもつワードだと知らしめる 2 つの慣習は、 名前を括弧で囲む(より頻繁に使用される)ことと、
名前をすべて大文字で記述する(あまり使用されない)ことです。

@code{if} などの一部のワードについては、 インタプリタ機能を使用するのは通常間違いであるため、 それらを
@code{compile-only} としてマークし、 インタプリタ機能を使用すると警告が表示されます。

@example
: flip ( -- )
 6 . ; compile-only \ but not immediate
flip

: flop ( -- )
 flip ;
flop
@end example

この例では、 最初に @code{flip} のインタプリタ機能を使用します(警告が表示されます)。 @code{flip} の 2 番目の使用では、
コンパイル機能を使用します(警告は表示されません)。 この例では、 compile-only
が実行時(run-time)ではなくテキスト・インタプリタ時に評価される属性であることもわかります。

テキスト・インタプリタには 2 つの状態があります。 インタプリタ・モード(interpret)は、
遭遇したワードのインタプリタ機能(interpretation semantics)を実行します。 コンパイル・モードでは、
これらのワードのコンパイル機能(compilation semantics)が実行されます。

特に、 @code{:} はコンパイル状態に切り替え、 @code{;} はインタプリタ状態に戻します。 これらには、 状態を切り替えるだけの効果である
@code{]} (コンパイル状態に切り替える) と @code{[} (インタプリタ状態に切り替える) が含まれています。

@example
: xxx ( -- )
  [ 5 . ]
;

xxx
see xxx
@end example

これらの角括弧(brackets)は、 上記の命名慣習の源でもあります。

こちらも参照ください: @ref{Interpretation and Compilation Semantics}


@node Execution Tokens Tutorial, Exceptions Tutorial, Interpretation and Compilation Semantics and Immediacy Tutorial, Tutorial
@section Execution Tokens
@cindex execution tokens tutorial
@cindex XT tutorial

@code{' word} は、 ワードの実行トークン(execution token)(XT)を提供します。 XT は、
ワードのインタプリタ機能(interpretation semantics)表すセルです。 これは @code{execute} で実行できます:

@example
' + .s
1 2 rot execute .
@end example

XT は C の関数ポインタに似ています。 ただし、 パラメータがスタックで渡されるため、もう少し柔軟になります:

@example
: map-array ( ... addr u xt -- ... )
\ addr で始まり u 個の要素を含む配列のすべての要素に対して
\ xt ( ... x -- ... ) を実行します
  @{ xt @}
  cells over + swap ?do
    i @@ xt execute
  1 cells +loop ;

create a 3 , 4 , 2 , -1 , 4 ,
a 5 ' . map-array .s
0 a 5 ' + map-array .

s" max-n" environment? drop .s \ 下記比較初期値用に整数最大値を得る
a 5 ' min map-array . \ 最初の要素は、 environment? で取得した整数最大値と比較
@end example

生成するより消費する要素が 1 つ多いワードの XT に対して map-array を使用できます。 理論的には、他の XT でも使用できますが、
スタック効果は配列のサイズに依存するため、理解するのが困難です。

XT はセルサイズであるため、 メモリに保存し、 他のセルと同様にスタック上で操作できます。 @code{compile,} を使用して XT
をワードにコンパイルすることもできます:

@example
: foo1 ( n1 n2 -- n )
   [ ' + compile, ] ;
see foo1
@end example

@code{compile,} は標準ではコンパイル機能(compilation semantics)がないため、 上記は標準ではないけれども、 良い
Forth システムでは動作します。 うまくいかなかったモノついては、 以下を使用してください

@example
: [compile,] compile, ; immediate

: foo1 ( n1 n2 -- n )
   [ ' + ] [compile,] ;
see foo1
@end example

@code{'} は、 デフォルトでコンパイル機能(compilation semantics)を持つワードです。
そのワードのインタプリタ機能(interpretation semantics)を実行すると、 その次のワードを構文解析(parse)します。

@example
: foo ( -- xt )
  ' ;
see foo
: bar ( ... "word" -- ... )
  ' execute ;
see bar
1 2 bar + .
@end example

コンパイル中にワードを解析(parse)し、 その XT をコンパイルして、 実行時にスタックにプッシュされるようにしたいことがよくあります。
@code{[']} はこれを行います:

@example
: xt-+ ( -- xt )
  ['] + ;
see xt-+
1 2 xt-+ execute .
@end example

多くのプログラマーは、 @code{'} とそれが解析(parse)するワードを 1 つの単位として認識し、 コンパイル時に @code{[']}
のように動作することを期待し、 実際の動作に混乱する傾向があります。 あなたがもしそうなら、 Forth システムは @code{'} を 1
つの単位として捉えているだけであり、
それが解析(parse)ワードであるとはまったく考えていないことを覚えておいてください(この問題でプログラマーの便宜を図る試みは、 通常、
さらにひどい落とし穴につながります。
@uref{https://www.complang.tuwien.ac.at/papers/ertl98.ps.gz,
@code{State}-smartness---Why it is evil and How to Exorcise it})。

XT の作成および実行は、 インタプリタの状態には影響を受けないことに注意してください。 つまり、 コンパイル状態で @code{'}
を実行した場合でも、 インタプリタ機能(interpretation semantics)が得られます。 そして、 そこでの状態が何であれ、
@code{execute} は XT によって表されるコード(つまり、@code{'} で生成された XT
の場合はインタプリタ機能(interpretation semantics))を実行します。

こちらも参照ください: @ref{Tokens for Words}


@node Exceptions Tutorial, Defining Words Tutorial, Execution Tokens Tutorial, Tutorial
@section Exceptions
@cindex exceptions tutorial

@code{throw ( n -- )} は、 n がゼロでない限り例外を引き起こします。

@example
100 throw .s
0 throw .s
@end example

@code{catch ( ... xt -- ... n )} は @code{execute} と同様に動作しますが、 例外をキャッチし、
スタック上に例外の数値(または XT が例外なしで実行された場合は 0)をプッシュします。 例外があった場合、 スタックの深さは
@code{catch} の実行直前と同一です。

@example
.s
3 0 ' / catch .s
3 2 ' / catch .s
@end example

@quotation 研究課題(assignment)
@code{catch} の代わりに @code{execute} を使用して同じことを試してみましょう。
@end quotation

@code{throw} は、常に動的に直近にこの @code{throw} を囲んでいる(定義の) @code{catch} にジャンプします、
たとえそのジャンプを達成するために複数の呼び出しレベルを飛び越す必要がある場合でもです:

@example
: foo 100 throw ;
: foo1 foo ." after foo" ;
: bar ['] foo1 catch ;
bar .
@end example

多くの場合、 定義が例外によって終了した場合でも、 定義を終了したときに値を復元することが重要です。 以下のようにしてみるのはどうでしょうか:

@example
: ...
   save-x
   ['] word-changing-x catch ( ... n )
   restore-x
   ( ... n ) throw ;
@end example

しかし、 これでも、 たとえば、@code{catch} と @code{restore-x} の間を実行中にユーザーが @kbd{Ctrl-C}
を押すなどしたら安全ではありません。

Gforth は、そのような場合に対して安全な代替例外処理構文(alternative exception handling syntax)
@code{try ...restore ... endtry} を提供します。  @code{try} と @code{endtry}
の間のコードに例外があった場合、 スタックの深さが復元され、 例外数値がスタックにプッシュされ、 @code{restore}
の直後から実行が続行されます。

以下は、 上記のコードと同等の、 より安全なコードです

@example
: ...
  save-x
  try
    word-changing-x 0
  restore
    restore-x
  endtry
  throw ;
@end example

こちらも参照ください: @ref{Exception Handling}


@node Defining Words Tutorial, Arrays and Records Tutorial, Exceptions Tutorial, Tutorial
@section Defining Words
@cindex defining words tutorial
@cindex does> tutorial
@cindex create...does> tutorial

@c before semantics?

これまでに出てきた @code{:} や @code{create} や @code{variable} は定義ワードです。
これらは他のワードを定義します。 @code{Constant} はもう一つの定義ワードです:

@example
5 constant foo
foo .
@end example

@code{variable} や @code{constant} でも接頭辞 @code{2} (2倍長セル) や @code{f} (浮動小数点)
を使用することができます。

あなた独自の定義ワードを定義することもできます。 例:

@example
: variable ( "name" -- )
  create 0 , ;
@end example

また、 単にアドレスを生成する以外のことを行うワードを作成する定義ワードを定義することもできます:

@example
: constant ( n "name" -- )
  create ,
does> ( -- n )
  ( addr ) @@ ;

5 constant foo
foo .
@end example

上記の @code{constant} の定義は @code{does>} で終了します。 つまり、 @code{does>} は @code{;}
を置き換えるのですが、 他のことも行います。 最後に定義されたワードを変更して、 ワード本体(body)のアドレスをプッシュし、 呼び出されるたびに
@code{does>} の後のコードを実行します。

上の例では、 @code{constant} は @code{,} を使用して @code{foo} の本体に 5 を格納します。
@code{foo} が実行されると、 本体のアドレスがスタックにプッシュされ、 (@code{does>} の後のコードにより、)そこから 5
がフェッチされます。

@code{does>} の脇のスタック・コメントは、 @code{does>} の後のコードのスタック効果ではなく、
定義されたワードのスタック効果です(違いは、 @code{does>} の後のコードは @code{does>}
の脇のスタック・コメントには書いてない、 ワード本体(body)のアドレスを期待している点です)。

これらの定義ワードを使用すると、 (他の)定義ワードが関係する場合にファクタリングを行うことができます。  たとえば、
フィールド・オフセットは常にアドレスに加算するものですが、 その代わりに以下を定義します

@example
2 cells constant offset-field1
@end example

この offset-field1 は以下のように使います

@example
( addr ) offset-field1 +
@end example

ここで、 あなたは以下のような定義ワードをを定義できます

@example
: simple-field ( n "name" -- )
  create ,
does> ( n1 -- n1+n )
  ( addr ) @@ + ;
@end example

フィールド・オフセットの定義と使用は以下のようになります:

@example
2 cells simple-field field1
create mystruct 4 cells allot
mystruct .s field1 .s drop
@end example

@code{does>} の後のコードを実行せずに、 そのワードで何かをしたい場合は、 @code{>body ( xt -- addr )}
を使用すれば @code{create} したワードの本体(body)にアクセスできます:

@example
: value ( n "name" -- )
  create ,
does> ( -- n1 )
  @@ ;
: to ( n "name" -- )
  ' >body ! ;

5 value foo
foo .
7 to foo
foo .
@end example

@quotation 研究課題(assignment)
(@code{abort} の XT の先頭に、) XT を格納するワードを作成する、 @code{defer ( "name" -- )} を定義し、
実行時に XT を @code{execute} で実行するようにしてみましょう。 間接再帰は @code{defer} の応用の 1 つです。
@end quotation

こちらも参照ください: @ref{User-defined Defining Words}


@node Arrays and Records Tutorial, POSTPONE Tutorial, Defining Words Tutorial, Tutorial
@section Arrays and Records
@cindex arrays tutorial
@cindex records tutorial
@cindex structs tutorial

Forth には配列を定義するための標準ワードはありませんが、 アドレス演算に基づいて自分で配列を構築できます。
配列とレコードを定義するためのワードを定義することもできます(@pxref{Defining Words Tutorial,, Defining
Words})。

Forth の初心者がワードの定義について学ぶときに最初に着手するプロジェクトの 1 つが配列定義ワード(ことによっては n 次元配列)です。
さぁあなたもやってみましょう。 あなたはそこから何かを学ぶでしょう。 ただし、
後からこれらのワードをほとんど使用しないことがわかってもがっかりしないでください(不適切に使用するとさらに悪いことになります)。
著者はまだ有用な配列ワードのセットを見つけられていません。 ニーズがあまりにも多様で、
(定義ワードを単純に使用した結果である、)名前付きのグローバル配列は、 柔軟性が十分ではないことがよくあります(たとえば、
どのようにしてパラメーターを渡すか、など)。 同様のプロジェクトのもう 1 つは、 文字列の処理に役立つワードのセットです。

その一方、 レコード・ワードには便利なセットがあり、 @file{compat/struct.fs} で定義されています。 これらのワードは
Gforth で事前定義されています。 これらについては、 このマニュアルの他の場所で詳しく説明されています(@pxref{Structures}
参照)。 上記の @code{simple-field} の例は、 このパッケージのフィールドの簡略化されたバリエーションです。


@node POSTPONE Tutorial, Literal Tutorial, Arrays and Records Tutorial, Tutorial
@section @code{POSTPONE}
@cindex postpone tutorial

@code{POSTPONE} (訳注: (期限が定まってる)延期)を使用すると、 (そのワードのインタプリタ機能(interpretation
semantics)をコンパイルする代わりに、) そのワードのコンパイル機能(compilation semantics)をコンパイルできます:

@example
: MY-+ ( Compilation: -- ; Run-time of compiled code: n1 n2 -- n )
 POSTPONE + ; immediate
: foo ( n1 n2 -- n )
 MY-+ ;
1 2 foo .
see foo
@end example

@code{foo} の定義中に、 テキスト・インタプリタは @code{MY-+} のコンパイル機能(compilation
semantics)を実行し、 そのコンパイル機能が @code{+} のコンパイル機能を実行します。 つまり、 @code{+} を
@code{foo} 内にコンパイルします。

この例では、 コンパイル機能(compilation
semantics)とコンパイルされたコードのスタック効果について個別のスタック・コメントも表示します。 デフォルトのコンパイル機能を持つワードの場合、
通常、 これらのスタック効果は表示されません。 これらのワードのコンパイル機能のスタック効果は常に @code{( -- )} であり、
コンパイルされたコードのスタック効果はインタプリタ機能(interpretation semantics)のスタック効果です。

注意: この方法でコンパイル機能(compilation semantics)を実行する場合、
インタプリタの状態には影響を受けないことに注意してください。 あなたはそれを対話的(interpretively)に実行することもできます。 例:

@example
: foo2 ( n1 n2 -- n )
 [ MY-+ ] ;
1 2 foo2 .
see foo2
@end example

@c !! repair.fs
ただし、 これが常に機能するとは限らない、良くない Forth システムがいくつかあるため、 この方法は 1999 年に非標準となりました。

@code{POSTPONE} を使用する別の例を以下に示します:

@example
: MY-- ( Compilation: -- ; Run-time of compiled code: n1 n2 -- n )
 POSTPONE negate POSTPONE + ; immediate compile-only
: bar ( n1 n2 -- n )
  MY-- ;
2 1 bar .
see bar
@end example

@code{ENDIF} は以下の方法で定義できます:

@example
: ENDIF ( Compilation: orig -- )
  POSTPONE then ; immediate
@end example

@quotation 研究課題(assignment)
@code{2dup} と同等のコンパイル機能(compilation semantics)を持つ @code{MY-2DUP} を作成しますが、
コンパイルされるのは @code{over over} になるようにしてみましょう。
@end quotation

@c !! @xref{Macros} for reference


@node Literal Tutorial, Advanced macros Tutorial, POSTPONE Tutorial, Tutorial
@section @code{Literal}
@cindex literal tutorial

数値を @code{POSTPONE} することはできません:

@example
: [FOO] POSTPONE 500 ; immediate
@end example

代わりに @code{LITERAL (compilation: n --; run-time: -- n )} を使用します:

@example
: [FOO] ( compilation: --; run-time: -- n )
  500 POSTPONE literal ; immediate

: flip [FOO] ;
flip .
see flip
@end example

@code{LITERAL} は、 コンパイル時(コンパイル機能(compilation semantics)が実行される時)に数値を消費し、
実行時(コンパイルされたコードが実行されるとき)にそれをプッシュします。 @code{LITERAL} のよくある使用法は、
コンパイル時に計算された数値を現在のワードにコンパイルすることです:

@example
: bar ( -- n )
  [ 2 2 + ] literal ;
see bar
@end example

@quotation 研究課題(assignment)
上記の例を @code{: bar ( -- n ) [ 2 2 + ]L ;} と記述できるような @code{]L} を定義してみましょう。
@end quotation

@c !! @xref{Macros} for reference


@node Advanced macros Tutorial, Compilation Tokens Tutorial, Literal Tutorial, Tutorial
@section Advanced macros
@cindex macros, advanced tutorial
@cindex run-time code generation, tutorial

@ref{Execution Tokens Tutorial,, Execution Tokens} の @code{map-array}
について再検討してみましょう。 @code{map-array} は @code{execute} を頻繁に実行しますが、 これは一部の Forth
実装では比較的高価な操作です。 @code{compile,} と @code{POSTPONE} を使用すると、 これらの
@code{execute} を削除し、 直接実行されるワードを含むワードを生成できます:

@c use ]] ... [[
@example
: compile-map-array ( compilation: xt -- ; run-time: ... addr u -- ... )
\ at run-time, execute xt ( ... x -- ... ) for each element of the
\ array beginning at addr and containing u elements
  @{ xt @}
  POSTPONE cells POSTPONE over POSTPONE + POSTPONE swap POSTPONE ?do
    POSTPONE i POSTPONE @@ xt compile,
  1 cells POSTPONE literal POSTPONE +loop ;

: sum-array ( addr u -- n )
 0 rot rot [ ' + compile-map-array ] ;
see sum-array
a 5 sum-array .
@end example

コードの生成には Forth の機能を最大限に活用できます。 以下に、 コードがループ内で生成される例を示します:

@example
: compile-vmul-step ( compilation: n --; run-time: n1 addr1 -- n2 addr2 )
\ n2=n1+(addr1)*n, addr2=addr1+cell
  POSTPONE tuck POSTPONE @@
  POSTPONE literal POSTPONE * POSTPONE +
  POSTPONE swap POSTPONE cell+ ;

: compile-vmul ( compilation: addr1 u -- ; run-time: addr2 -- n )
\ n=v1*v2 (inner product), where the v_i are represented as addr_i u
  0 postpone literal postpone swap
  [ ' compile-vmul-step compile-map-array ]
  postpone drop ;
see compile-vmul

: a-vmul ( addr -- n )
\ n=a*v, where v is a vector that's as long as a and starts at addr
 [ a 5 compile-vmul ] ;
see a-vmul
a a-vmul .
@end example

この例では @code{compile-map-array} を使用していますが、 代わりに @code{map-array}
を使用することもできます(是非試してみてください)。

この手法を使用すると、 巨大な行列を効率的に乗算できます。 行列の乗算では、 一方の行列のすべての行ともう一方の行列のすべての列を乗算します。 1
行のコードを 1 回生成し、 それをすべての列に使用できます。 この手法の唯一の欠点は、
生成されたコードによって消費されたメモリを完了時に開放するのが面倒なことです(さらに複雑な場合は移植可能ではありません)。

@c !! @xref{Macros} for reference


@node Compilation Tokens Tutorial, Wordlists and Search Order Tutorial, Advanced macros Tutorial, Tutorial
@section Compilation Tokens
@cindex compilation tokens, tutorial
@cindex CT, tutorial

このセクションは Gforth 固有です。 スキップしても構いません。

@code{' word compile,} はインタプリタ機能(interpretation semantics)をコンパイルします。
デフォルトのコンパイル機能(compilation semantics)を持つワードの場合、 これはコンパイル機能を実行するのと同じです。
他のワードのコンパイル機能(インタプリタ機能を持たない @code{if} などのワード)を表すために、 Gforth
にはコンパイル・トークン(CTと略します。 2つのセルで構成)と、 ワード @code{comp'} と、 ワード @code{[comp']}
の概念があります。 @code{execute} を使用して、 CT によって表されるコンパイル機能を実行できます:

@example
: foo2 ( n1 n2 -- n )
   [ comp' + execute ] ;
see foo2
@end example

@code{postpone,} を使用して、 CT によって表されるコンパイル機能をコンパイルできます:

@example
: foo3 ( -- )
  [ comp' + postpone, ] ;
see foo3
@end example

@code{[ comp' word postpone, ]} @code{POSTPONE word} と同等です。  @code{comp'} は、
インタプリタ・モードコードを持たないワードに対して特に役立ちます:

@example
' if
comp' if .s 2drop
@end example

こちらも参照ください: @ref{Tokens for Words}


@node Wordlists and Search Order Tutorial, , Compilation Tokens Tutorial, Tutorial
@section Wordlists and Search Order
@cindex wordlists tutorial
@cindex search order, tutorial

ディクショナリ(辞書)は、 @code{allot} でメモリを割り当てることができる、 単なるメモリ領域ではなく、
複数のワード・リスト(wordlist)上にある Forth ワード達も含まれています。  ワード・リスト内のワードを検索するとき、 概念的には、
最も新しいワードから検索を開始し、 古いワードに向かって進みます(実際には、 最近のほとんどのシステムはハッシュ・テーブルを使用します)。 つまり、
古いワードと同一の名前のワードを定義すると、 新しいワードが古いワードを隠します。

どのワードリストがどの順序で検索されるかは、 検索順序スタック(the search order)によって決まります。  @code{order}
で検索順序を表示できます。 最初に検索されるワードリストから順に検索順序を表示し、 その次に、 新しく定義されるワードを含むワードリストを表示します。

@code{wordlist ( -- wid )} を使用して、 新しい空のワード・リスト(wordlist)を作成できます:

@example
wordlist constant mywords
@end example

@code{Set-current ( wid -- )} は、 新しく定義されたワードを入れるワード・リストを設定します(the current
wordlist):

@example
mywords set-current
order
@end example

このワード・リストは @code{wordlist} を使用して匿名で作成されたため、 Gforth は @code{mywords}
のワード・リスト名を表示しません。

@code{get-current ( -- wid)} で現在のワード・リストを取得できます。  現在のワード・リストに影響を与えずに、
指定のワード・リストに何かを入れたい場合、 通常は以下のようにします:

@example
get-current mywords set-current ( wid )
create someword
( wid ) set-current
@end example

検索順序スタック(the search order)は @code{set-order ( wid1 .. widn n -- )} で記述し、
@code{get-order ( -- wid1 .. widn n )} で読み取ることができます。  ( n を除いて) もっとも TOS
側のワード・リストが最初に検索されます。

@example
get-order mywords swap 1+ set-order
order
@end example

ええ、 @code{order} の出力内のワードリストの順序は、 スタック・コメントや @code{.s} の出力とは逆になっているため、
直感的ではありません。

@quotation 研究課題(assignment)
@code{>order ( wid -- )} を定義して、 最初に検索されるワード・リスト(wordlist)として @code{wid}
を検索順序スタック(the search order)に追加してみましょう。 @code{previous ( -- )} を定義してみましょう。
これは、 最初に検索されたワードリスト(wordlist)を検索順序スタックから削除するものです。 定義したら、
境界条件を試してみましょう(クラッシュや、 そこから抜け出すことが困難または不可能な状況がいくつか見られる事でしょう)。
@end quotation

検索順序スタック(the search order)は、 Modula-2 モジュールや、 C++
の名前空間と同様の機能を提供するための強力な基盤です。  ただし、 この方法でプログラムをモジュール化しようとすると、 デバッグや
再利用/ファクタリング に関しては、 (大規模なプロジェクトの経験はありませんけれども、)著者の経験では利点を上回る欠点があります。
他の言語/プログラミング環境では、 デバッグや再利用がそれほど強力ではないため、 これらの欠点はそれほど目立ちません。

@c !! example

こしらも参照ください: @ref{Word Lists}

@c ******************************************************************
@node Introduction, Literals in source code, Tutorial, Top
@comment node-name,     next,           previous, up
@chapter An Introduction to Standard Forth
@cindex Forth - an introduction

この章とチュートリアル(@pxref{Tutorial})との違いは、 急ぎ足のチュートリアルと違ってじっくり腰を据えて、
チュートリアルではカバーしきれていない、 Forth の内部を詳しく説明していることです。  それはさておき、
この章で取り上げる内容はチュートリアルに比べはるかに少ないので、 パソコンを使わずに読むのに適しています。

このマニュアルの主な目的は、 Gforth を文書化することです。 ただし、Forth は広く知られている言語ではなく、 最新の教材が不足しているため、
入門用の教材を提供する価値があると思われます。  巷の Forth 関連情報その他の情報源については @ref{Forth-related
information} を参照下さい。

このセクションの例は、 どの標準 Forth でも動作するはずです。 示されている出力は Gforth を使用して生成されました。 各例では、
Gforth が生成する正確な出力を再現しようとしています。 あなたが例を試してみれば(そして、あなたはそうするべきです)、 入力すべき内容は
@kbd{like this} と示され、 Gforth の応答は @code{like this} で示されます。 唯一の例外は、 例で
@key{RET} が示されている場合、 これは「Enter」キー(機種によりReturnキー)を押す必要があることを意味します。 残念ながら、
このマニュアルの一部の出力形式では @kbd{this} と @code{this} の違いを表示できないため、
例を試してみるのが困難かもしれません(ただし、 不可能ではありません)。

Forth は珍しい言語です。 インタプリタとコンパイラの両方を含む対話型開発環境を提供します。 Forth のプログラミング・スタイルでは、
問題をいくつかの要素に分割することが推奨されます
@cindex factoring
小さな断片を作成し(ファクタリング)、 各断片を対話的に開発・テストします。 Forth の支持者は、
従来のプログラミング言語で使用されている編集・コンパイル・テストのサイクルを打ち破ることで、 生産性の大幅な向上につながる可能性があると主張しています。

@menu
* Introducing the Text Interpreter::
* Stacks and Postfix notation::
* Your first definition::
* How does that work?::
* Forth is written in Forth::
* Review - elements of a Forth system::
* Where to go next::
* Exercises::                
@end menu

@comment ----------------------------------------------
@node Introducing the Text Interpreter, Stacks and Postfix notation, Introduction, Introduction
@section Introducing the Text Interpreter
@cindex text interpreter
@cindex outer interpreter

@c IMO this is too detailed and the pace is too slow for
@c an introduction.  If you know German, take a look at
@c https://www.complang.tuwien.ac.at/anton/lvas/skriptum-stack.html 
@c to see how I do it - anton 

@c nac-> Where I have accepted your comments 100% and modified the text
@c accordingly, I have deleted your comments. Elsewhere I have added a
@c response like this to attempt to rationalise what I have done. Of
@c course, this is a very clumsy mechanism for something that would be
@c done far more efficiently over a beer. Please delete any dialogue
@c you consider closed.

Forth イメージを呼び出すと、 起動バナーが出力されますが、 他には何も表示されません (システムに Gforth がインストールされている場合は、
@kbd{gforth@key{RET}} と入力して今すぐ呼び出してみてください)。 今、 Forth は、 テキスト・インタプリタ(Text
Interpreter)と呼ばれるコマンド・ライン・インタプリタを実行しています(外部インタプリタとも呼ばれます;訳注: 別途存在する
内部インタプリタ(inner interpreter)に対してこう呼ばれる)。
(この章を読み進ればテキスト・インタプリタについて多くのことを学ぶことができます。 詳細については @pxref{The Text
Interpreter} を参照してください)。

明白ではなくて分かりにくいですが、 今や Forth はユーザーの入力を待っています。 数字の 4 と 5 を入力し @key{RET}
キーを押します:

@example
@kbd{45@key{RET}}  ok
@end example

テキスト・インタプリタは、  次の入力を促すプロンプトを表示するのではなく、 入力行を処理した後に(改行無しで)ステータス・メッセージを出力します。
この場合のステータス・メッセージ(@key{RET} (「エンター」(リターン)キー押下)の後の @code{ ok} )は、
テキスト・インタプリタがすべての入力を正常に処理できたことを示します。 それでは次に、 不正な文字列を入力してみましょう:

@example
@kbd{qwer341@key{RET}}
*the terminal*:2: Undefined word
>>>qwer341<<<
Backtrace:
$2A95B42A20 throw 
$2A95B57FB8 no.extensions 
@end example

`Undefined word` 以外の文章はシステムによって若干異なる場合がありますが、 意味は同じです。
テキスト・インタプリタがエラーを検出すると、 行に残っているテキストを破棄し、 特定の内部状態をリセットして、 エラー・メッセージを出力します。
エラー・メッセージの詳細な説明については、 @ref{Error messages} を参照してください。

テキスト・インタプリタは、エンター・キー(リターン・キー)が押されるのを待ち、 その後入力行を処理します。 行頭から開始して、
行をスペースで区切られた文字のグループに分割します。 文字のグループごとに、 以下の順番で、 何かするために計 2 回の試みを行います:

@itemize @bullet
@item
@cindex name dictionary
@cindex word
@cindex definition
@cindex execution token
@cindex xt
その文字のグループをコマンドとして扱おうとします。 これは、 名前ディクショナリ(name dictionary)を検索することによって行われます。
その文字のグループが名前ディクショナリのエントリと一致する場合、 名前ディクショナリは、
いくつかのアクションを実行できるようにする情報をテキスト・インタプリタに提供します。 Forth 流に言うと、文字のグループを「ワードの名前」といい、
ディクショナリ検索でワードの定義(definition)に対応する実行トークン(execution token;xt)が返され、
テキスト・インタプリタは xt を実行します。 多くの場合、「ワード」(word)と「定義」(definition)という用語は同じ意味で使用されます。
@item
テキスト・インタプリタが名前ディクショナリ内で一致するものを見つけられなかった場合、
文字のグループを現在の基数の数値として処理しようとします(Forth を起動したときの、 現在の基数は 10 です)。
文字のグループが正当な数値を表す場合、 テキスト・インタプリタはその数値をスタックにプッシュします(これについては次のセクションで詳しく説明します)。
@end itemize

テキスト・インタプリタが文字グループに対して上記のいずれも実行不可能な場合、 その文字グループと行の残りの部分が破棄され、
エラー・メッセージが出力されます。 テキスト・インタプリタがエラーなく行末に到達すると、 ステータス・メッセージ @code{ ok}
に続いて改行を出力します。

以下は、 テキスト・インタプリタに与えることができる最もシンプルなコマンドです:

@example
@key{RET}  ok
@end example

ここで、 テキスト・インタプリタは、 私たちが要求したことをすべて(何もせずに)エラーなしで実行したため、 すべてが @code{ ok}
であると表示しました。 今度は少し長いコマンドを試して見ましょう:

@example
@kbd{12 dup fred dup@key{RET}}
*the terminal*:3: Undefined word
12 dup >>>fred<<< dup
Backtrace:
$2A95B42A20 throw 
$2A95B57FB8 no.extensions 
@end example

エンター・キー(リターン・キー)を押すと、 テキスト・インタプリタが行に沿って動作を開始します:

@itemize @bullet
@item
@code{2} の後のスペースに到達すると、 文字グループ @code{12} を取得し、
それらを名前ディクショナリで検索します@footnote{見つかったかどうかはわかりませんが、いまのところ、 見つからなかったと仮定します。 訳注:
12 というワードを定義することもでき、その場合はワード 12 の方が数値 12 より優先される}。
名前ディクショナリにはこの文字グループに一致するものがないため、それらを数値として処理しようとし、 そして、
数値として処理するのは正常に実行できたので、 (それが何を意味するにせよ) 数値 12 を「スタック上」に置きます。
@item
テキスト・インタプリタは行のスキャンを再開し、 次の文字グループ `dup` を取得します。  `dup` を名前ディクショナリで探し、
(これは著者の言葉を信じてもらうしかありませんが)  `dup` を名前ディクショナリで見付けて、 ワード @code{dup}
を実行します(それが何を意味していても)。
@item
更に再び、 テキスト・インタプリタは行のスキャンを再開し、 文字グループ @code{fred} を取得します。
名前ディクショナリで調べますが、見つかりません。 それらを数値として扱おうとしますが、 正当な数値を表すものではありませんでした。
@end itemize

この時点で、 テキスト・インタプリタは諦めてエラー・メッセージを出力します。 エラー・メッセージには、
テキスト・インタプリタが行の処理でどこまで到達したかが正確に示されます。 これは、 特に、 テキスト・インタプリタが最後の文字グループ
@code{dup} に対して何も行おうとしなかったことを示しています。 テキスト・インタプリタがそのワード @code{dup} を検索して、
一度はちゃんと実行されたのですから、 もう一度実行することに何の問題はないはずなのに、 です。 


@comment ----------------------------------------------
@node Stacks and Postfix notation, Your first definition, Introducing the Text Interpreter, Introduction
@section Stacks, postfix notation and parameter passing
@cindex text interpreter
@cindex outer interpreter

手続き型プログラミング言語(C や Pascal など)では、 プログラムの構成要素は関数(function)やプロシージャ(procedure)です。
これらの関数またはプロシージャは、 明示的なパラメータを使用して呼び出されます。 たとえば、 C では以下のように記述できます:

@example
total = total + new_volume(length,height,depth);
@end example

@noindent
ここで、  new_volume は別のコード片への関数呼び出し(function-call)であり、 total, length, height,
depth はすべて変数です。 length, height, depth は関数呼び出しのパラメータです。

Forth では、 関数またはプロシージャに相当するのは「定義」(definition)であり、
パラメータはプログラマから見える共有スタックを使用して定義間で暗黙的に渡されます。  Forth は変数をサポートしていますが、 スタックの存在は、
他のほとんどのプログラミング言語よりも変数が使用される頻度がはるかに低いことを意味します。 テキスト・インタプリタは数値を検出すると、
それをスタックに置きます(プッシュ)。 何種類かのスタックがあり(いくつあるかは実装依存です)、 操作に使用されるスタックは、
実行される操作によって明確に示されます。 すべての整数演算に使用されるスタックは「データ・スタック」と呼ばれ、
これが最も一般的に使用されるスタックであるため、 「データ・スタック」への参照は多くの場合「スタック」と省略されます。

スタックには後入れ先出し(last-in, first-out;LIFO)構成が採用されています。 以下のように打ち込むと:

@example
@kbd{1 2 3@key{RET}}  ok
@end example
@cindex TOS definition
これはテキスト・インタプリタに 3 つの数値を (データ)スタック に配置するように指示します。 スタックの振る舞いはトランプの扱いに例えられます。
トランプの箱から、 (スートは何でもいいですが、) エース(1)のカードと2のカードと3のカードをテーブルの上の山に配ります。
3のカードは山の最後のカード (last-in)であり、 山からカードを 1 枚取ると、 あなたがシャッフルとか何もいじってない限り、 取り出すカードは
3のカードになります(first-out)。 スタックから最初に取り出されるであろう(スタック上の)数値はスタック頂上(スタック・トップ;top of
stack)と呼ばれ、 多くの場合「TOS」と省略されます。

Forth でパラメーターがどのように渡されるかを理解するために、 定義 @code{+} (「プラス」と発音します) の振る舞いを見てみましょう。
あなたは、 この定義が加算を実行することを知っても驚かないでしょう。 より正確には、 これは 2 つの数値を加算して結果を生成します。 さて、 その 2
つの数値はどこから取得されるのでしょうか？ これはスタック頂上から上位 2 つの数値を取り除きます。 その結果はどこに配置されるのでしょうか？
それはスタックです。 あなたは以下のように、 トランプを使って @code{+} の振る舞いを演ずることができます。

@itemize @bullet
@item
テーブル上の山(the steck)カードを 2 枚取り出します
@item
あなたは、 それらをじっと見つめて、 「これら 2 つの数字の合計は何であるか」を自問してください。
@item
答えは 5 であると判明しました
@item
2 枚のカードをシャッフルしてトランプの箱に戻し、 トランプの箱の中から 5のカード を見つけます
@item
テーブル上にある残りのエース(1)のカードの上に 5のカードを置きます。
@end itemize

トランプの箱はないですが、 Forth の実行中は、 定義 @code{.s} を使用して、 スタックに影響を与えることなく、
スタックの現在の状態を表示できます。 以下の様に打ち込みます:

@example
@kbd{clearstacks 1 2 3@key{RET}} ok
@kbd{.s@key{RET}} <3> 1 2 3  ok
@end example

テキスト・インタプリタはワード @code{clearstacks} を検索して実行します。 スタック(データおよび浮動小数点スタック)を整理し、
以前の例の実行によってスタックに残された可能性のあるエントリをすべて削除します。 続けてテキスト・インタプリタは、 3
つの数値をそれぞれ順番にスタックにプッシュします。 最後に、 テキスト・インタプリタはワード @code{.s} を検索して実行します。
@code{.s} を実行すると、「<3>」 (スタック上の項目の合計数) に続いて、スタック上のすべての項目のリストが出力されます。 一番右側の項目が
TOS です。

あなたは今や以下のように打ち込めます:

@example
@kbd{+ .s@key{RET}} <2> 1 5  ok
@end example

@noindent
現在スタックには 2 つの項目があり、 (そのうちの項目の1つである)加算の結果は 5 となっていれば正解です。

あなたが引き続きトランプで遊んでいるなら、 この結果に対して 2 回目の足し算を行ってみましょう。 2 枚のカードを手に取り、 その合計が 6
であることを計算し、手に取った2枚のカードをシャッフルして箱に入れ、 箱から 6のカード を探してテーブルに置きます。 これで、 スタックにはアイテムが
1 つだけになりました。 あなたが 3 回目の足し算を実行しようとするとどうなるでしょうか？ あなたは、 1枚目のカードを手に取り、
2枚目のカードを手に取ろうとします -- ああ! でも 2枚目のカードはありません。 これは「スタック・アンダーフロー」と呼ばれ、エラーとなります。
Forth で同じことを行おうとすると、 多くの場合、 エラーが報告されます(おそらく、 スタック・アンダーフロー(Stack
Underflow)エラー、 または、 無効なメモリアクセス(Invalid Memory Address)エラー)。

スタック・アンダーフローの逆の状況が「スタック・オーバーフロー」です。 これは、 あなたがたが、
スタック用に予約されている有限量のストレージ・スペースがあることを単に受け入れるだけで済みます。 トランプの例えを拡張すると、
沢山の数のトランプのカードがあり、 それらのカードをテーブルに積み上げた場合、 天井にぶつかってしまい、 最終的には別のカードを追加できなくなります。
Gforth を使用すると、 スタックの最大サイズを設定できます。 一般に、 スタック・オーバーフローが発生するのは、 定義にバグがあり、
制御不能にスタック上にデータを生成している場合のみです。

トランプの例えには、 最後にもう 1 つ適用例があります。 トランプを使用してスタックをモデル化した場合、 スタック上のアイテムの最大数は 52
になります(ジョーカーを使用しなかったと仮定して)。 スタック上のアイテムの最大値は13(キング)です。 実際は、 使用できる数値は 1 ～ 13
の正の整数のみ(つまり、 13個の数)です。 (たとえば) 0や27や3.52や-2は使用できません。 そこで、 一部のカードについて考え方を変え、
さまざまな数値に対応できるようにします。 たとえば、ジャックは 0 を表し、 クイーンは -1 を表し、 キングは -2 を表すと見なします。 すると、
表現できる数値の幅は変更されません(合計 13 個の数値のみを表すことができます)が、 -2 から 10 の数値を表す事ができるようになりました。

この例えでは、 制限は 1 つのスタック・エントリが保持できる情報の量であり、 Forth にも同様の制限があります。 Forth では、
スタック・エントリのサイズは「セル」(cell)と呼ばれます。 セルの実際のサイズは実装に依存し、 スタック・エントリが保持できる最大値に影響します。
標準 Forth は少なくとも 16 ビットのセル・サイズを提供し、 ほとんどのデスクトップ・システムは 32 ビットのセル・サイズを使用します。

Forth は型チェックを一切行わないため、 スタック項目を自由に操作したり組み合わせたりできます。 スタック項目を 2
の補数の符号付き整数として扱う便利な方法は、 @code{+} などの標準ワードもやっています。 それゆえ、 以下のように入力できます:

@example
@kbd{-5 12 + .s@key{RET}} <1> 7  ok
@end example

あなたが、 Forth を電卓にするために、 数値や @code{+} のような定義を使用すると、
それが通常の電卓とはかなり異なることがわかるでしょう。 あなたは 2 + 3 = と入力するのではなく、 2 3 +
と入力する必要があります(ここでは、 結果を確認するには @code{.s} を使用する必要があるという事実は無視してください)。
この違いを説明するために使用される用語は、 電卓は「中置記法」(Infix Notation;パラメーターと演算子が混合されている)を使用するのに対し、
Forth は「後置記法」(Postfix Notation;パラメーターと演算子が分かれている)、 またの名を「逆ポーランド記法」(Reverse
Polish Notation)と呼ばれるものを使用します。

後置記法は最初はわかりにくいように見えるかもしれませんが、 いくつかの重要な利点があります:

@itemize @bullet
@item
明白です
@item
より簡潔です
@item
スタックベースのシステムに自然に適合します
@end itemize

これらの主張をさらに詳しく調べるために、 以下の計算について見てみましょう:

@example
6 + 5 * 4 =
4 * 5 + 6 =
@end example

あなたが、算数を勉強中の場合、 または算数が非常に苦手な場合は、 最初の答えは 44、 2 番目の答えは 26 になるでしょう。
あなたが算数に少し詳しい人なら、 乗算は加算よりも優先されるという法則を覚えているでしょう。 そして、 どちらの場合も答えは 26 になるでしょう。
答え 44 だと言った人に、 なぜ答えが 26 かを説明するには、 最初の計算を以下のように書き換えることになるでしょう:

@example
6 + (5 * 4) =
@end example

あなたが、 もし、 乗算より優先して加算を実行したい場合は、 かっこを使用して強制的に加算させる必要があります。

上記 2 つの計算を電卓で計算する場合、 以下のキーストローク・シーケンスを使用して、 入力ミスしない限り、 おそらく正しい答えが得られるでしょう:

@example
6 + 5 = * 4 =
4 * 5 = + 6 =
@end example

Postfix notation is unambiguous because the order that the operators are
applied is always explicit; that also means that parentheses are never
required後置記法では演算子が適用される順序は常に明示的です。 これは、 括弧が決して必要ないことも意味します。
演算子はアクティブです(演算子を引用する行為によって演算操作が実行されます)。 これにより、「=」が必要なくなります。

計算 6 + 5 * 4 は、 以下の 2 つの同等の方法で(後置表記で)書くことができます:

@example
6 5 4 * +
または:
5 4 * 6 +
@end example

この表記法に関して注意すべき重要な点は、 数値の順番は変わらないことです。 10 から 2 を減算する場合は、 @code{10 2 -}
と入力します。

Forth が後置表記を使用する理由は非常に簡単に説明できます。 これにより実装が非常に単純になり、
パラメータを渡すためのメカニズムとしてスタックを使用することが自然な流れになります。 これについての別の考え方としては、 すべての Forth
定義がアクティブであると認識することです。 これらは、 テキスト・インタプリタによって検出されると実行されます。 この結果、 Forth
の構文は何の努力も必要とせずシンプルになります。



@comment ----------------------------------------------
@node Your first definition, How does that work?, Stacks and Postfix notation, Introduction
@section Your first Forth definition
@cindex first definition

これまで私たちが見てきた例はこまごまとしたものでした。 私たちは Forth を大きめの電卓として使用してきました。 また、
これまでに示した各計算は「1 回限り」のものです --
それを繰り返すには、もう一度入力する必要があります@footnote{それは完全には真実ではありません。 キーボードの上矢印キーを押すと、
以前のコマンドにスクロールして戻り、 編集して再入力できます。}。 このセクションでは、 Forth
の語彙(vocabulary)に新しいワードを追加する方法を説明します。

新しいワードを作成する最も簡単な方法は、「コロン定義」を使用することです。 それらがどのように機能するかについて思い悩む前に、
いくつか定義して試してみましょう。 以下の例を入力してみてください。 スペースを正確に反映するように注意してください:

@example
: add-two 2 + . ;
: greet ." Hello and welcome" ;
: demo 5 add-two ;
@end example

@noindent
この例を打ち込んだら、 すぐ試してみましょう:

@example
@kbd{greet@key{RET}} Hello and welcome  ok
@kbd{greet greet@key{RET}} Hello and welcomeHello and welcome  ok
@kbd{4 add-two@key{RET}} 6  ok
@kbd{demo@key{RET}} 7  ok
@kbd{9 greet demo add-two@key{RET}} Hello and welcome7 11  ok
@end example

ここで導入した最初の新しいモノは、 @code{:} と @code{;} というワードのペアです。
これらは、それぞれ新しい定義を開始および終了するために使用されます。  @code{:} の後の最初の単語(word)は、 新しい定義の名前です。

例からわかるように、 定義はすでに定義されているワードから構成されます。 Forth では、 システムの起動時に存在した定義と、
ユーザーが自分で定義した定義とを区別しません。

この例では、 @code{.} (ドット) や、 @code{."} (ドット・クォート)や、 @code{dup} (デュープ)
というワードも紹介しています。 ドットはスタック頂上から数詞を取得して表示します。 これは @code{.s} に似ていますが、
スタック頂上の項目のみを表示する点と破壊的である点が異なります。 実行後、スタック上にその数値は最早ありません。 数値の前はスペース無しで、
後ろには常に 1 つのスペースが表示されます。 ドット・クォートは、 ワードの実行時に出力される文字列(string)を定義します。 文字列には、
@code{"} を除く任意の印刷可能な文字を含めることができます。 @code{"} には特別な機能があります。 これは Forth
ワードではありませんが、 区切り文字として機能します(区切り文字の仕組みについては次のセクションで説明します)。 最後に、 @code{dup}
はスタック頂上の値を複製します。 @code{5 dup .s} と入力して、 @code{dup} がやることを確認してください。

あなたは、 既に、 テキスト・インタプリタが名前を見つけるためにディクショナリを検索することを知っています。 あなたが上記の例の通りにした場合、
@code{add-two} という定義がすでにあるはずです。 それでは、 この定義に対して、 更に新しい定義を入力して変更してみるとしましょう:

@example
@kbd{: add-two dup . ." + 2 = " 2 + . ;@key{RET}} redefined add-two  ok
@end example

Forth は、私たちがすでに存在するワードを定義しようとしていることを認識し、 それを警告するメッセージを出力しました。 さて、 それでは、
新しい定義を試してみましょう:

@example
@kbd{9 add-two@key{RET}} 9 + 2 = 11  ok
@end example

@noindent
ただし、 ここで実際に行ったことは、 特定の名前を付けて新しい定義を作成することだけです。 同一の名前の定義がすでに存在するという事実は、 (Forth
が警告メッセージを出力することを除いて、)新しい定義の作成方法に何の違いもありません。 add-two
の古い定義はいまだ存在します(これが正しいかどうかを確認するには、 @code{demo} をもう一度試してください)。 @code{add-two}
の新しい定義以降に定義するワードは @code{add-two} の新しい定義を利用しますが、 @code{demo} の定義は、 古い定義は
@code{demo} をコンパイルする時点で既に存在していた @code{add-two} の古い定義のバージョンを引き続き使用します。

次のセクションに進む前に、 あなた自身のワードをいくつか定義したり再定義したりしてみましょう。

@comment ----------------------------------------------
@node How does that work?, Forth is written in Forth, Your first definition, Introduction
@section How does that work?
@cindex parsing words

@c That's pretty deep (IMO way too deep) for an introduction. - anton

@c Is it a good idea to talk about the interpretation semantics of a
@c number? We don't have an xt to go along with it. - anton

@c Now that I have eliminated execution semantics, I wonder if it would not
@c be better to keep them (or add run-time semantics), to make it easier to
@c explain what compilation semantics usually does. - anton

@c nac-> I removed the term ``default compilation sematics'' from the
@c introductory chapter. Removing ``execution semantics'' was making
@c everything simpler to explain, then I think the use of this term made
@c everything more complex again. I replaced it with ``default
@c semantics'' (which is used elsewhere in the manual) by which I mean
@c ``a definition that has neither the immediate nor the compile-only
@c flag set''.

@c anton: I have eliminated default semantics (except in one place where it
@c means "default interpretation and compilation semantics"), because it
@c makes no sense in the presence of combined words.  I reverted to
@c "execution semantics" where necessary.

@c nac-> I reworded big chunks of the ``how does that work''
@c section (and, unusually for me, I think I even made it shorter!).  See
@c what you think -- I know I have not addressed your primary concern
@c that it is too heavy-going for an introduction. From what I understood
@c of your course notes it looks as though they might be a good framework. 
@c Things that I've tried to capture here are some things that came as a
@c great revelation here when I first understood them. Also, I like the
@c fact that a very simple code example shows up almost all of the issues
@c that you need to understand to see how Forth works. That's unique and
@c worthwhile to emphasise.

@c anton: I think it's a good idea to present the details, especially those
@c that you found to be a revelation, and probably the tutorial tries to be
@c too superficial and does not get some of the things across that make
@c Forth special.  I do believe that most of the time these things should
@c be discussed at the end of a section or in separate sections instead of
@c in the middle of a section (e.g., the stuff you added in "User-defined
@c defining words" leads in a completely different direction from the rest
@c of the section).

ここで、 前のセクションの @code{add-two} の定義をもう一度見てみましょう。 テキスト・インタプリタの動作方法に関する知識から、
@code{add-two} を定義しようとしたとき、 私達は以下の結果を予期したかもしれません:

@example
@kbd{: add-two 2 + . ;@key{RET}}
*the terminal*:4: Undefined word
: >>>add-two<<< 2 + . ;
@end example

@cindex modifying >IN
しかし、 これが起こらなかった理由は、 @code{:} の動作方法に関係しています。 @code{:} というワードは 2 つの特別な働きをします。
1つ目の特別な機能は、 テキスト・インタプリタが @code{add-two} という文字を認識できないようにすることです。 テキスト・インタプリタは、
@code{>IN} (to-in;トゥーイン)という変数を使用して、 入力行のどこを追跡するかを保持し、 @code{:} というワードに遭遇すると、
他のワードの場合とまったく同じように動作します。 名前ディクショナリでそれを検索し、 その xt を見つけて実行します。  実行される @code{:}
は、 入力バッファーを調べてワード @code{add-two} を見つけ、 @code{>IN} の値をその後ろを指すように進めておきます。 次に、
新しい定義の作成に関連するその他の処理を実行します(名前ディクショナリに @code{add-two} のエントリを作成する等)。 @code{:}
の実行が完了すると、 制御はテキスト・インタプリタに戻ります。 テキスト・インタプリタは、
このトリックにより入力行の一部をスキップしていることに気づきません。

@cindex parsing words
@code{:} のようなワード(@code{>IN} の値を進めて、 テキスト・インタプリタが入力行全体に作用するのを妨げるワード)は、
「構文解析ワード」(parsing words)と呼ばれます。

@cindex @code{state} - effect on the text interpreter
@cindex text interpreter - effect of state
@code{:} が行う 2 つ目の特別な処理は、 @code{state} と呼ばれる変数の値を変更することです。 これは、
テキスト・インタプリタの振る舞いに影響します。 Gforth が起動するとき、 @code{state} の値は 0 であり、
テキスト・インタプリタはインタプリタ状態(@dfn{interpreting})であると言われます。 (@code{:} で始まる)コロン定義中 、
@code{state} は -1 に設定され、テキスト・インタプリタはコンパイル状態(@dfn{compiling})と言われます。

この例では、 テキスト・インタプリタは文字列 ``@code{2 + . ;}''。引き続き同じ方法で文字列を文字シーケンスに分割します。ただし、数値
@code{2} をスタックにプッシュする代わりに、 数値 @code{2} を取得する魔法を @code{add-two}
の定義に組み込み(コンパイル)、 @code{add-two} が「実行」されたときスタックにプッシュされます。 同様に、 @code{+} と
@code{.} の振る舞いも定義にコンパイルされます。

特定の種類のワードはコンパイルされません。 これらのいわゆる「即実行ワード」(immediate word)は、
テキスト・インタプリタがインタプリタ状態であるかコンパイル状態であるかに関係なく、 実行されます(今、 直ちに実行されます)。 @code{;}
というワードは即実行ワードです。 定義にコンパイルされるのではなく、 実行されます。 その効果は、 @code{state} の値を 0
に戻すことを含む、 現在の定義を終了することです。

あなたが @code{add-two} を実行すると、 その定義の外で @code{2 + . @key{RET}}
と入力した場合とまったく同一の「実行時効果」(run-time effect) が生じます。

Forth では、 すべてのワードまたは数値は以下の 2 つの性質を持ちます:

@itemize @bullet
@item
@cindex interpretation semantics
その インタプリタ機能(interpretation semantics)は、
テキスト・インタプリタがインタプリタ状態でどのように動作するかを記述します。 ワードのインタプリタ機能は、 その「実行トークン」(execution
token)(@pxref{Execution token})によって表されます。
@item
@cindex compilation semantics
その コンパイル機能(compilation semantics)は、 テキスト・インタプリタがコンパイル状態でどのように動作するかを記述します。
ワードのコンパイル機能は、 その「コンパイル・トークン」(@pxref{Compilation token})によって表されます。
@end itemize

@noindent
数値は常に決まった方法で処理されます:

@itemize @bullet
@item
その数値が通訳(interpret)される場合、 その振る舞いは、 その数値をスタックにプッシュすることです。
@item
その数値がコンパイルされる場合、 実行時にその数値をプッシュするコードが現在の定義に追加されます。 (言い換えれば、
数値のコンパイル機能(compilation semantics)は、 コンパイルされる定義の実行時まで、
その数値のインタプリタ機能(interpretation semantics)の実行を延期(postpone)します。)
@end itemize

ワードは常にこのような通常の振る舞いをするとは限りませんが、 ほとんどのワードにはデフォルトの機能(default semantics)があり、
以下のように振る舞うことを意味します:

@itemize @bullet
@item
ワードのインタプリタ機能(@dfn{interpretation semantics})は、 何かしら役に立つことを行うことです。
@item
ワードのコンパイル機能(compilation semantics)は、 そのワードのインタプリタ機能(interpretation
semantics)を現在の定義に追加します(よって、 それは実行時に何かしら役に立つことを行います)。
@end itemize

@cindex immediate words
特定のワードの実際の振る舞いは、 ワードの定義時に @code{immediate} や @code{compile-only}
というワードを使用することで制御できます。 これらのワードは、 最後に定義されたワードの名前ディクショナリ・エントリにフラグを設定します。
これらのフラグは、 名前ディクショナリでワードが見つかったときにテキスト・インタプリタによって取得されます。

@dfn{immediate} としてマークされたワードは、 そのインタプリタ機能(interpretation
semantics)と同じコンパイル機能(compilation semantics)を持ちます。 つまり、 以下のように振る舞います:

@itemize @bullet
@item
ワードのインタプリタ機能(@dfn{interpretation semantics})は、 何かしら役に立つことを行うことです。
@item
このワードのコンパイル機能(compilation semantics)は、
何かしら役に立つことを行うことです(実際にはインタプリタ機能と同一のことを行うことです)。 つまり、
このワードのコンパイル機能はコンパイル中に実行されます。
@end itemize

ワードを @dfn{compile-only} としてマークすると、 インタプリタ状態(interpretation
state)でこのワードを検出したときにテキスト・インタプリタが警告を生成することを意味します。 (@code{'} または @code{[']}
を使用して) ワードをティックすると、 警告が生成されます。

@code{compile-only} を使用する必要はありません(多くの実装によって提供されてはいますが、 標準 Forth
の一部でもありません)が、 インタプリタ態(interpret state)で正しく振る舞わないワードに @code{compile-only}
を適用するのは良いエチケットです(そして予期しない副作用が発生する可能性があります)。 たとえば、 定義内で条件ワード @code{IF}
を使用することのみが正当です。 これを忘れて別の場所で使用しようとすると、 (Gforth では) @code{compile-only}
としてマークされているため、 テキスト・インタプリタが有用な警告を生成できます。

以下の例は、 即実行ワードと非即実行ワードの違いを示しています:

@example
: show-state state @@ . ;
: show-state-now show-state ; immediate
: word1 show-state ;
: word2 show-state-now ;
@end example

@code{show-state-now} の定義の後にあるワード @code{immediate} は、そのワードを即実行ワードにします。
これらの定義では、 @code{@@}(「フェッチ」と発音します) という新しいワードが導入されています。
このワードは変数の値を取り出し(フェッチし)、 それをスタックに残します。 したがって、 @code{show-state} の振る舞いは、
@code{state} の現在の値を表す数値を出力することです。

@code{word1} を実行すると、 システムがインタプリタ状態であることを示す数値 0 が出力されます。 テキスト・インタプリタが
@code{word1} の定義をコンパイルしたときに、 コンパイル機能が現在の定義に実行時コードを追加する @code{show-state}
に遭遇しました。 @code{word1} を実行すると、 @code{show-state} のインタプリタ機能(interpretation
semantics)が実行されます。  @code{word1} (つまり @code{show-state}) が実行される時点で、
システムはインタプリタ状態です。

@code{word2} の定義を入力した後に @key{RET} を押すと、 数値 -1 が出力され、 その後に @code{ ok}
が表示されるはずです。 テキスト・インタプリタが @code{word2} の定義をコンパイルすると、 即実行ワードである
@code{show-state-now} が検出されたため、 そのコンパイル機能(compilation
semantics)はインタプリタ機能(interpretation semantics)を実行します。
これは直ちにに実行されます(テキスト・インタプリタが次の文字グループ(この例では @code{;})の処理に移る前に)。 これを実行すると、
@code{word2} の定義途中の @code{state} の値が表示されます。 -1 を出力するので、
システムがその時点でコンパイル状態であることがわかります。 もし あなたが @code{word2} を「実行」しても何も行いません。

@cindex @code{."}, how it works
即実行ワードの話題を離れる前に、 前のセクションの @code{greet} の定義における @code{."} の振る舞いについて検討してみましょう。
このワードは構文解析ワード(parsing word)でもあり、 かつ、 即実行ワードでもあります。  @code{."} とそのテキストの先頭
@code{Hello and welcome} の間にはスペースがありますが、 @code{welcome} の最後の文字と @code{"}
文字の間にはスペースがありません。 これは、@code{."} が Forth ワードであるということです。 テキスト・インタプリタがその Forth
ワード @code{."} を識別できるように、 @code{."} の後ろにスペースが必要です。 @code{"} は Forth ワードではなく、
区切り文字(delimiter)です。 先の例では、 文字列が表示されるときに、 @code{H} の前にも @code{e}
の後ろにもスペースがないことを示しています。 @code{."} は即実行ワードなので、 @code{greet} の定義中に実行されます。
実行されると、 入力行内を前方に走査して区切り文字を探します。 区切り文字が見つかると、 区切り文字の後ろを指すように @code{>IN}
を更新します。 また、 いくつかのマジック・コード、 つまりテキスト文字列を出力する実行時コード xtを @code{greet}
の定義にコンパイルします。 文字列 @code{Hello and welcome} をメモリにコンパイルして、 後で出力できるようにします。 その後、
テキスト・インタプリタが制御を取得すると、 入力ストリーム内で次に検出されるワードは @code{;} であるため、 @code{greet}
の定義を終了します。


@comment ----------------------------------------------
@node Forth is written in Forth, Review - elements of a Forth system, How does that work?, Introduction
@section Forth is written in Forth
@cindex structure of Forth programs

あなたが Forth コンパイラを起動すると、 すでに多数の定義が存在しています。 Forth では、
ボトムアップ・プログラミング手法を使って新しいアプリケーションを開発し、 既存の定義に基づいて定義される新しい定義を作成します。 作成した各定義は、
対話的にテストおよびデバッグできます。

この章の例を試したことがあるなら、 あなたは、それらをおそらく手動で入力したことがあるでしょう。 Gforth を終了すると、
あなたが定義したモノは失われてしまいます。 これを回避するには、 テキスト・エディタを使用して Forth ソース・コードをファイルに入力し、
@code{include} を使用してファイルからコードをロードします(@pxref{Forth source files})。 Forth
のソース・ファイルは、 あたかも手入力したかのように、 テキスト・インタプリタによって処理されます@footnote{実際には、
いくつか微妙な違いがあります -- @ref{The Text Interpreter} }。

Gforth は、 プログラム入力 にテキスト・ファイルを使用する、 伝統的な Forth
の代替手段もサポートしています(@pxref{Blocks})。

ほとんどというほどではないにしても、 多くの Forth コンパイラと共通して、 Gforth のほとんどは実際には Forth で書かれています。
インストール・ディレクトリ@footnote{For example, @file{/usr/local/share/gforth...}}内のすべての
@file{.fs} ファイルは Forth ソース・ファイルであり、 あなたは それらを Forth
プログラミングの例として拝んで学ぶことができます。

Gforth は、 テキスト・インタプリタに入力したすべての行を記録する履歴(history)ファイルを維持します。
このファイルはセッションをまたいで維持され、 コマンドラインの呼び出し機能を提供するために使用されます。 長い定義を手動で入力した場合は、
テキスト・エディターを使用して履歴ファイルから後で再利用するために Forth ソース・ファイルに貼り付けることができます(詳細については
@pxref{Command-line editing})。


@comment ----------------------------------------------
@node Review - elements of a Forth system, Where to go next, Forth is written in Forth, Introduction
@section Review - elements of a Forth system
@cindex elements of a Forth system

この章を要約すると:

@itemize @bullet
@item
Forth プログラムはファクタリングを使用して、 問題を「ワード」または「定義」と呼ばれる小さな断片に分割します。
@item
Forth プログラムの開発は対話型のプロセスです。
@item
入力を受け付け、
通訳(interpret)とコンパイルの両方を制御するメイン・コマンド・ループは、「テキスト・インタプリタ」と呼ばれます(外部インタプリタとも呼ばれます)。
@item
Forth の構文は非常に単純で、 スペースまたは改行文字で区切られた単語(word)と数値で構成されます。 追加の構文は構文解析ワード(parsing
words)によります。
@item
Forth はスタックを使用してワード間でパラメーターを渡します。 その結果、 後置記法が使用されます。
@item
以前に定義されたワードを使用するために、 テキスト・インタプリタは「名前ディクショナリ」でそのワードを探します。
@item
ワードはインタプリタ機能(@dfn{interpretation semantics})とコンパイル機能(@dfn{compilation
semantics})を持っています。
@item
テキスト・インタプリタは、 @code{state} の値を使用して、 探し出したワードのインタプリタ機能(interpretation
semantics)を使用するかコンパイル機能(compilation semantics)を使用するかを選択します。
@item
ワードのインタプリタ機能(interpretation semantics)とコンパイル機能(compilation semantics)の関係は、
そのワードが定義された方法(たとえば、 それが「即実行ワード」(@dfn{immediate} word)であるかどうか)によって異なります。
@item
Forth 定義は、 Forth で実装(「高レベル定義」と呼ばれます)、 または、 その他のいくつかの方法(通常は低レベル言語で、
「低レベル定義」、「コード定義」、「プリミティブ」と呼ばれる事もある)で実装できます。
@item
多くの Forth システムは主に Forth で記述されています。
@end itemize


@comment ----------------------------------------------
@node Where to go next, Exercises, Review - elements of a Forth system, Introduction
@section Where To Go Next
@cindex where to go next

信じられないかもしれませんが、 あなたがここまで読んで(そして理解していれば)、 Forth
システムの内部動作についての基本をほぼすべて知っていることになります。 あなたは今や確実に、 このマニュアルの残りの部分と標準 Forth
ドキュメントを読んで理解し、 Forthの一般的な機能と、 特に Gforth が提供する機能について詳しく学ぶのに十分な知識を持っています。
更に恐るべきことに、 あなたは独自の Forth システムを実装するのにほぼ十分な知識を持っていますが、 独自の Forth
システムを実装するには時期尚早かもしれません。 その前に、 あなたは Gforth でいくつかのプログラムを書いてみたほうがいいでしょう。

Forth には非常に豊富な語彙があるため、 学ぶにも、 どこから手を付ければいいかわからない場合があります。 このセクションでは、
小さいながらも有用なプログラムを作成するのに十分なワードのセットをいくつか提案します。
このドキュメントのワード索引を使用して各ワードについて詳しく学び、 それを試して、 それを使用して簡単な定義を書いてみてください。
まずは以下のワード達を試してみてください:

@itemize @bullet
@item
算術演算: @code{+ - * / /MOD */ ABS INVERT}
@item
比較: @code{MIN MAX =}
@item
論理演算: @code{AND OR XOR NOT}
@item
スタック操作: @code{DUP DROP SWAP OVER}
@item
ループと条件判断: @code{IF ELSE ENDIF ?DO I LOOP}
@item
入出力: @code{. ." EMIT CR KEY}
@item
定義ワード: @code{: ; CREATE}
@item
メモリ割り当てワード: @code{ALLOT ,}
@item
ツール: @code{SEE WORDS .S MARKER}
@end itemize

上記をマスターできたら、 以下に進みましょう:

@itemize @bullet
@item
さらなる 定義ワード いくつか: @code{VARIABLE CONSTANT VALUE TO CREATE DOES>}
@item
メモリ・アクセス: @code{@@ !}
@end itemize

これらをマスターしたら、 あなたは、 このマニュアルのすべてに目を通し、 あなたのプログラムに欠けているものを探し出す必要があります。

@comment ----------------------------------------------
@node Exercises, , Where to go next, Introduction
@section Exercises
@cindex exercises

TODO: すでに完了した内容やマニュアルの他のセクションにリンクされた一連のプログラミング演習を提供したい。 すべての演習に対する回答を、
ディストリビューション内の .fs ファイルで提供するようにしたいです。

@c Get some inspiration from Starting Forth and Kelly&Spies.

@c excercises:
@c 1. take inches and convert to feet and inches.
@c 2. take temperature and convert from fahrenheight to celcius;
@c    may need to care about symmetric vs floored??
@c 3. take input line and do character substitution
@c    to encipher or decipher
@c 4. as above but work on a file for in and out
@c 5. take input line and convert to pig-latin 
@c
@c thing of sets of things to exercise then come up with
@c problems that need those things.


@c ******************************************************************
@node Literals in source code, Words, Introduction, Top
@chapter Literals in source code
@cindex Literals (in source code)

@cindex single-cell numbers, input format
@cindex input format for single-cell numbers
整数値をデータ・スタックにプッシュするために、 あなたはソース・コードに数値を書きます。 たとえば @code{123} です。 数字の連なりの前に
@code{-} を付けると、 負の数値を示すことができます。 たとえば @code{-123} です。
これはコロン定義の内部と外部の両方で機能します。  数値は @code{base} (基数)
の値に従って通訳(interpret)されます(@pxref{Number Conversion})。  「数字」は @code{0} ～
@code{9} 、@code{a} (10進数の10) ～ @code{z} (10進数の35) です。 ただし、
基数(base)より小さい「数字」のみが認識されます。  変換では大文字と小文字が区別されないため、@code{A} と @code{a}
は同じ「数字」になります。

@cindex &-prefix for decimal numbers
@cindex #-prefix for decimal numbers
@cindex %-prefix for binary numbers
@cindex $-prefix for hexadecimal numbers
@cindex 0x-prefix for hexadecimal numbers
以下のプレフィックスを使用すると、 数値の基数(base)を明示的に指定できます:

@itemize @bullet
@item
@code{#} -- 10進数(decimal)
@item
@code{%} -- 2進数(binary)
@item
@code{$} -- 16進数(hexadecimal)
@item
@code{&} -- 10進数(decimal)(非標準)
@item
@code{0x} -- 16進数(hexadecimal), if base<33 (非標準)
@end itemize

基数プレフィックスと符号を含む組み合わせの場合、 標準的な順序では基数プレフィックスを最初に配置します(例: @code{#-123})。 Gforth
は両方の順番をサポートします。

@cindex double-cell numbers, input format
@cindex input format for double-cell numbers
小数点 @code{.} を数値の末尾(または非標準的に、 プレフィックスの前を除く他の場所)に置くと、 2倍長整数double-cell
integer)として扱われます(例: @code{#-123.} または @code{#-.123} (この2つは同一の数値です))。
別のプログラミング言語の経験があるユーザーは、 基数プレフィックスのない、 このような数値(例: @code{-123.}) を見たり書いたりする場合、
その数値が浮動小数点値を表すものと期待する可能性があります。 混乱を早期に解決するために、 Gforth はそのような使用法について警告しています。
警告を回避するには、 常に基数プレフィックスを付けて 2倍長整数(double-cell integer)を記述することをお勧めします(例:
@code{#-123.})

以下にいくつかの例を示します。 なお、 同値の 10 進数が括弧内に示されています:

@code{$-41} (-65), @code{%1001101} (205), @code{%1001.0001} (145 ; 2倍長整数),
@code{#905} (905), @code{$abc} (2478), @code{$ABC} (2478).

@cindex '-prefix for characters/code points
@cindex input format for characters/code points
(文字)コード・ポイントの数値を取得するには、 文字を @code{'} で囲みます (例: @code{'a'})。  末尾の @code{'}
は標準では必須ですが、Gforth では省略できます。  注意: これは非 ASCII 文字でも機能することに注意してください。  多くの用途では、
文字をセルとしてではなく文字列として持つ方が便利です。 文字列の構文については、 以下を参照してください。

@cindex floating-point numbers, input format
@cindex input format for floating-point numbers
Forth の浮動小数点数は、 その指数によって認識されます。  つまり、 @code{1.} は 2倍長整数(double-cell
integer)で、 そして @code{1e0} は浮動小数点数です。 後者は @code{1e} に短縮できます(通常は短縮します)。
仮数部(@code{e} や @code{E} より前の部分)と指数の部分の両方に符号(@code{+} を含む)を含めることができます。
仮数部には少なくとも 1 つの数字が含まれている必要があり、 小数点を含めることができます。 指数は空であってもかまいません。
浮動小数点数は仮数と指数の両方に常に 10 進数の基数を使用し、 基数が 10 進数の場合にのみ認識されます。  例: @code{1e 1e0 1.e
1.e0 +1e+0} (これらは全て同一の数値です)、 @code{+12.E-4}

Gforth 拡張機能 (1.0 以降)では、 浮動小数点数をスケーリングされた表記で書くことができます。 オプションで符号、 その次に 1
つ以上の数字を指定し、その後ろに、 主に SI で定義されたスケーリング記号(別名 メトリック・プレフィックス)または @code{%} のうちの 1
つを使用でき、 その後に、 オプションで更に多くの桁を指定できます。 Gforth が受け入れるスケーリング記号の完全なリストは以下のとおりです:

@itemize @bullet
@item
@code{Q} @code{e30} quetta(クエタ) 
@item
@code{R} @code{e27} ronna(ロナ)  
@item
@code{Y} @code{e24} yotta(ヨタ)  
@item
@code{Z} @code{e21} zetta(ゼタ)  
@item
@code{X} @code{e18} exa(エクサ)(@code{E} じゃ無いので注意) 
@item
@code{P} @code{e15} peta(ペタ)   
@item
@code{T} @code{e12} tera(テラ)   
@item
@code{G} @code{e9} giga(ギガ)   
@item
@code{M} @code{e6} mega(メガ)   
@item
@code{k} @code{e3} kilo(キロ)   
@item
@code{h} @code{e2} hecto(ヘクト)  
@item
@code{d} @code{e-1} deci(デシ)   
@item
@code{%} @code{e-2} percent(パーセント)(@code{c} じゃ無いので注意)(訳注: 一般の centi(センチ)
と違うので注意)
@item
@code{m} @code{e-3} milli(ミリ)  
@item
@code{u} @code{e-6} micro(マイクロ)(@code{μ} じゃ無いので注意)
@item
@code{n} @code{e-9} nano(ナノ)   
@item
@code{p} @code{e-12} pico(ピコ)   
@item
@code{f} @code{e-15} femto(フェムト)  
@item
@code{a} @code{e-18} atto(アト)   
@item
@code{z} @code{e-21} zepto(ゼプト)  
@item
@code{y} @code{e-24} yocto(ヨクト)  
@item
@code{r} @code{e-27} ronto(ロント)  
@item
@code{q} @code{e-30} quecto(クエント) 
@end itemize

Gforth の残りのほとんどとは異なり、 スケーリング・シンボルは大文字と小文字が区別されて扱われます。 スケール表記を使用するということは、
スケール記号の代わりに小数点を使用し、 末尾に指数表記を追加することと同じです。  スケール表記の例: @code{6k5} (6500e),
@code{23%} (0.23e)

@cindex String input format
@cindex input format for strings
文字列を @code{"} で囲んで入力できます(例: @code{"abc"}、@code{"a b"})。 その結果は、データスタック上の、
文字列の開始アドレスと、 バイト(=char)のカウントです。

文字列内の @code{"} は @code{\} でエスケープする必要があります(例: @code{"double-quote->\"<-"})。
さらに、 この文字列構文は、 @code{s\"} でサポートされている制御文字を記述するすべての方法をサポートしています(@pxref{String
and character literals})。 この文字列構文の欠点は、 標準ではないことです。 標準プログラムの場合は、 @code{"…"}
の代わりに @code{s\"} を使用してください。

@cindex environment variable input format
@cindex input format for environment variables
環境変数を取得するには、 最初に @file{rec-env.fs} をロードし、 次に環境変数の前に @code{$} を付けます (例:
@code{$HOME})。 結果は、 上で説明した形式のデータ・スタック上の文字列記述子(string descriptor)になります。  これは
@code{"HOME" getenv} と同等です。つまり、 環境変数は実行時(run-time)に解決されます。

@cindex xt input format
@cindex execution token input format
@cindex input format for execution tokens
@cindex @code{`} prefix of word
ワード名の前に @code{`} を付けることで、 ワードの実行トークン (xt) を取得できます (例: @code{`dup})。
@code{'} または @code{[']} を使うよりも有利な点は、 コロン定義の内側から外側へ、
またはその逆にコードをコピーして貼り付けるときに、 これらを切り替える必要がないことです。  欠点は、 この構文が標準ではないことです。

@cindex nt input format
@cindex nt token input format
@cindex input format for name tokens
@cindex @code{``} prefix of word
ワード名の前に @code{``} を付けることで、 ワードのの名前トークン (nt) を取得できます (例: @code{``dup})。
この構文も非標準です。

@cindex body-relative address input format
@cindex input format for body-relative addresses
ワードの本体アドレスを @code{<} と @code{>} で囲むことで取得できます (例: @code{<spaces>})。 ワード名と末尾の
@code{>} の間に @code{+} と数値を入れることで、
その本体アドレスから正のオフセットのアドレス(通常はそのワードの本体内のアドレス)を取得することもできます(例:
@code{<spaces+$15>}, @code{spaces+-3})。  例えば @code{<spaces+$15>} とか
@code{<spaces+-3>}) とすると、 その本体アドレスに数値を足したのを得るでしょう。 この非標準機能は、 @code{...}
の出力をコピーして貼り付けることを可能にするために存在します(@pxref{Examining data})。

@c !! rec-scope rec-meta rec-to

@c ******************************************************************
@node Words, Error messages, Literals in source code, Top
@chapter Forth Words
@cindex words

@menu
* Notation::
* Case insensitivity::
* Comments::
* Boolean Flags::
* Arithmetic::
* Stack Manipulation::
* Memory::
* Strings and Characters::
* Control Structures::
* Defining Words::
* Interpretation and Compilation Semantics::
* Tokens for Words::
* Compiling words::
* The Text Interpreter::
* The Input Stream::
* Word Lists::
* Environmental Queries::
* Files::
* Blocks::
* Other I/O::
* OS command line arguments::
* Locals::
* Structures::
* Object-oriented Forth::
* Regular Expressions::
* Programming Tools::
* Multitasker::
* C Interface::
* Assembler and Code Words::
* Carnal words::
* Passing Commands to the OS::
* Keeping track of Time::
* Miscellaneous Words::      
@end menu

@node Notation, Case insensitivity, Words, Words
@section Notation
@cindex notation of glossary entries
@cindex format of glossary entries
@cindex glossary notation format
@cindex word glossary entry format

Forth のワードは、 以下にあるように、 Forth テキストのデファクトスタンダード(事実上の標準)となっている表記にて説明されます:

@format
@i{word}     @i{Stack effect}   @i{wordset}   @i{pronunciation}
@end format
@i{Description}

@table @var
@item word
ワード名。

@item Stack effect
@cindex stack effect
スタック効果(stack effect)は、 @code{@i{before} -- @i{after}} という表記で記述されます。
ここで、@i{before} と @i{after} は、 ワード実行前と実行後のスタック・エントリの頂上部を表します。
スタックの残りの部分にはワードは触れません。 スタックの頂上は右端です。 つまり、 スタック・シーケンスはあなたが入力したとおりに書き込まれます。
注意: Gforth は別個の浮動小数点スタックを使用しますが、 統一されたスタック表記法を使用することに注意してください。 また、
リターンスタック効果は「スタック効果」には表示されませんが、 「説明」(Description)に表示されます。 スタック項目の名前は、
項目の型や機能を説明します。 型の説明については、 下記を参照してください。

すべてのワードには、 コンパイル・モードのスタック効果とインタプリタ・モードのスタック効果という 2 つのスタック効果があります。
ほとんどのワードのコンパイル・モードのスタック効果は @i{ -- } です。
ワードのコンパイル・モードのスタック効果がこの標準の振る舞いから逸脱している場合、 またはワードがコンパイル・モードに他の通常でない振る舞いを行う場合、
両方のスタック効果が表示されます。 それ以外の場合、 インタプリタ・モードのスタック効果のみが表示されます。

また、 コード・テンプレートまたはサンプルでは、​​ その時点でのスタックの状態表示するコメントが括弧内にある場合があることにも注意してください。
これらのスタックの状態表示には @code{--} はありません。 なぜなら前・後という状況が無いためです。

@cindex pronounciation of words
@item pronunciation
ワードの発音

@cindex wordset
@cindex environment wordset
@item wordset
ワードセット(wordset)は、 ワードが標準化されたものか、 または環境クエリ文字列であるか、 または Gforth
固有のワードであるかを指定します。 Gforth 固有のワードの場合、 ワードセット名には文字列 @code{gforth} が含まれており、
他のワードセット名は @code{environment} または標準のワードセット(standard word sets)を参照します。

Forth 標準はいくつかのワードセットに分かれています。 理論上、 標準システムはそれらすべてをサポートする必要はありませんが、 実際には、
組み込み用途な超小型のマシン以外の本格的なシステムは、
ほぼすべての標準化されたワードをサポートします(ただし、一部のシステムでは一部のワードセットを明示的にロードする必要があります)。 そのため、
実際のところはワードセットの使用をケチったところでその分移植性が上がる訳ではありません。

Gforth 固有のワードについては、 以下のカテゴリがあります:

@table @code
@item gforth
@item gforth-@i{<version>}
我々はこのワードを Gforth で永続的にサポートするつもりであり、 Gforth @i{<version>} 以降で有効です(おそらくその
@i{<version>} 時点ではサポートされていないワードです)。

@item gforth-experimental
このワードは現在のバージョンで使用できますが、 永続的なワードになるか、 Gforth の将来のリリースで削除されるか分かりません。
あなたのフィードバックをお待ちしています。

@item gforth-internal
このワードは内部用であり、 サポート対象のワードではないため、 Gforth の将来のリリースでは削除される可能性があります。

@item gforth-obsolete
このワードは、 Gforth の将来のリリースでは削除される予定です。
@end table


@item Description
そのワードの振る舞いを説明します。
@end table

@cindex types of stack items
@cindex stack item types
スタック項目の型は、 以下のように、 スタック項目名のはじめの文字が何であるかによって指定されます:

@table @code
@item f
@cindex @code{f}, stack item type
二値フラグ(Boolean flags)。 つまり @code{false} または @code{true}
@item c
@cindex @code{c}, stack item type
Char
@item w
@cindex @code{w}, stack item type
セル。 整数(an integer)やアドレス(an address)も格納可能。
@item n
@cindex @code{n}, stack item type
符号付き整数
@item u
@cindex @code{u}, stack item type
符号なし整数
@item d
@cindex @code{d}, stack item type
符号付き2倍長整数
@item ud
@cindex @code{ud}, stack item type
符号無し2倍長整数
@item r
@cindex @code{r}, stack item type
浮動小数点数(Float)(FP スタック上に置かれる)
@item a-
@cindex @code{a_}, stack item type
セル・アライメント・アドレス
@item c-
@cindex @code{c_}, stack item type
文字(char)アライメント・アドレス(注意: Windows NT では文字(char)は 2 バイトになる場合があることに注意)
@item f-
@cindex @code{f_}, stack item type
浮動小数点数アライメントのアドレス
@item df-
@cindex @code{df_}, stack item type
IEEE倍精度浮動小数点数アライメントのアドレス
@item sf-
@cindex @code{sf_}, stack item type
IEEE単精度浮動小数点数アライメントのアドレス
@item xt
@cindex @code{xt}, stack item type
実行トークン(Execution token)。 セルと同一サイズ
@item wid
@cindex @code{wid}, stack item type
ワード・リストID。セルと同一サイズ
@item ior, wior
@cindex ior type description
@cindex wior type description
セルサイズの入出力結果コード。 Gforth では iors を @code{throw} できます。
@item f83name
@cindex @code{f83name}, stack item type
名前構造体へのポインタ
@item "
@cindex @code{"}, stack item type
(スタック上ではなく、)入力ストリーム内の文字列。 終端文字はデフォルトでは空白(a blank)です。 終端文字が空白でない場合は、
@code{<>} でクォートして表示します。
@end table

@comment ----------------------------------------------
@node Case insensitivity, Comments, Notation, Words
@section Case insensitivity
@cindex case sensitivity
@cindex upper and lower case

Gforth では英大文字小文字を区別しません(case-insensitive)。 大文字、 小文字、 または大文字と小文字の混合を使用して、
定義を入力したり標準のワードを呼び出したりできます(ただし、 こちらも参照ください @pxref{core-idef,
Implementation-defined options, Implementation-defined options})

標準 Forth では、 標準のワードが完全に大文字で入力された場合にのみ実装が認識する必要があります。 したがって、 標準のプログラムでは、
すべての標準ワードに大文字を使用する必要があります。 あなたの定義したワードには大文字と小文字を自由に使用できますが、 標準のプログラムでは、
ワードを定義したときと同じ大文字と小文字で使用する必要があります。

Gforth は、 @code{cs-wordlist} (英大文字小文字を区別する(case-sensitive)ワード・リスト
@pxref{Word Lists}) を通じて英大文字小文字の区別をサポートします。

何人かは Gforth を英大文字小文字を区別する(case-sensitive)ように変換する方法を質問しました。 これは悪い考え(bad
idea)だとは思いますが、 すべてのワードリストを以下のようなテーブルに変更できます:

@example
' table-find forth-wordlist wordlist-map @ !
@end example

注意: このように、 Gforth を英大文字小文字を区別する(case-sensitive)ように変換した場合、 定義済みのワードは、
定義したときと同一の大文字と小文字の組み合わせで入力する必要があることに注意してください。 大文字と小文字は異なります。  この操作を実行する前に、
それらをあなた好みの大文字と小文字の組み合わせに変換するとよいでしょう(その方法については説明しません。 Gforth
を英大文字小文字を区別する(case-sensitive)ように変換することを実行することを検討している場合でも、
すでに定義済みワードのワード名をあなた好みの大文字と小文字の組み合わせに変換するその方法を知っているくらいの Forth
システムの知識があったほうがよいと思います)。

@node Comments, Boolean Flags, Case insensitivity, Words
@section Comments
@cindex comments

Fors は 2 つのスタイルのコメントをサポートしています。 従来の行中コメントである @code{(} と、 その現代的な親戚である、
行末までのコメント @code{\} です。


@findex ( ( @var{ compilation 'ccc<close-paren>' -- ; run-time --   } ) core,file
@cindex @code{(}
@kindex (
@format
@code{(} ( @i{compilation 'ccc<close-paren>' -- ; run-time --  }) core,file ``paren''
@end format
通常は次の @code{)} までがコメントです。 「)」 が見つかるまで、 パース領域内の後続の文字をすべてパースして破棄します。 対話入力中は、
行末はコメント終了文字としても機能します。 ただし、 ファイル入力の場合はそうではありませんので、
「)」区切り文字のパース中にファイルの終わりに遭遇すると、 Gforth は警告を出します。


@findex \ ( @var{ compilation 'ccc<newline>' -- ; run-time --   } ) core-ext,block-ext
@cindex @code{\}
@kindex \
@format
@code{\} ( @i{compilation 'ccc<newline>' -- ; run-time --  }) core-ext,block-ext ``backslash''
@end format
行末までがコメントです。 ブロックからのロード中を除き、 パース領域内の残りの文字をすべてパースして破棄します。 ブロックからのロード中は、
1行64バイトと見なすので、 その 64 バイト行の残りの文字をすべてパースして破棄します。


@findex \G ( @var{ compilation 'ccc<newline>' -- ; run-time --   } ) gforth-0.2
@cindex @code{\G}
@kindex \G
@format
@code{\G} ( @i{compilation 'ccc<newline>' -- ; run-time --  }) gforth-0.2 ``backslash-gee''
@end format
@code{\} と同等ですが、 ドキュメントの定義コメントに注釈(annotate)を付けるためのタグとして使用されます。




@node Boolean Flags, Arithmetic, Comments, Words
@section Boolean Flags
@cindex Boolean flags

@c on and off to Memory? 
@c true and false to "Bitwise operations" or "Numeric comparison"?
ブール値フラグはセル・サイズです。 すべてのビットがクリアされているセルはフラグ @code{false} を表し、
すべてのビットがセットされているセルはフラグ @code{true} を表します。 フラグをチェックするワード (@code{IF} など) は、
セルの任意のビットがセットされているものを @code{true} として扱います。

@findex true ( @var{ -- f   } ) core-ext
@cindex @code{true}
@kindex true
@format
@code{true} ( @i{-- f  }) core-ext ``true''
@end format
定数 -- @i{f} は全てのビットがセットされたセルです。


@findex false ( @var{ -- f   } ) core-ext
@cindex @code{false}
@kindex false
@format
@code{false} ( @i{-- f  }) core-ext ``false''
@end format
定数 -- @i{f} は全てのビットがクリアされたセルです。


@findex on ( @var{ a-addr --   } ) gforth-0.2
@cindex @code{on}
@kindex on
@format
@code{on} ( @i{a-addr --  }) gforth-0.2 ``on''
@end format
指定の @i{a-addr} の変数の値を @code{true} にセットする。


@findex off ( @var{ a-addr --   } ) gforth-0.2
@cindex @code{off}
@kindex off
@format
@code{off} ( @i{a-addr --  }) gforth-0.2 ``off''
@end format
指定の @i{a-addr} の変数の値を @code{false} にセットする。


@findex select ( @var{ u1 u2 f -- u  } ) gforth-1.0
@cindex @code{select}
@kindex select
@format
@code{select} ( @i{u1 u2 f -- u }) gforth-1.0 ``select''
@end format
@i{f} が false なら  @i{u2} を @i{u} として返し、 そうでなければ @i{u1} を @i{u} として返す。


@node Arithmetic, Stack Manipulation, Boolean Flags, Words
@section Arithmetic
@cindex arithmetic words

@cindex division with potentially negative operands
Forth の算術演算はチェックを行いません。 つまり、 加算または乗算での整数のオーバーフローについては問い詰められませんが、
運が良ければゼロによる除算については問い詰められることができるかもしれません。 演算子はオペランドの後に記述されますが、
オペランドは元の順序のままです。 つまり、 中置記法での @code{2-1} は @code{2 1 -} に対応します。 Forth
はさまざまな除算演算子を提供します。 あなたが、 潜在的に負になりうるオペランドを使用して除算を実行する場合、 実装により振る舞いが異なる
@code{/} や @code{/mod} を使用せず、 たとえば、 @code{/f} や @code{/modf} や @code{fm/mod}
を使用します(@pxref{Integer division})。

@menu
* Single precision::
* Double precision::         2倍長整数演算
* Mixed precision::          1倍長整数と2倍長整数の操作
* Integer division::
* Two-stage integer division::
* Bitwise operations::
* Numeric comparison::
* Floating Point::           
@end menu

@node Single precision, Double precision, Arithmetic, Arithmetic
@subsection Single precision
@cindex single precision arithmetic words

@c !! cell undefined

デフォルトでは、 Forth の数値は 1 セルのサイズの1倍長整数です。 扱い方に応じて、 符号付きまたは符号無しにすることができます。
1倍長整数を認識するためにテキスト・インタプリタで使用されるルールについては、 @ref{Number Conversion} を参照してください。

これらのワードは、 すべて符号付きオペランドに対して定義されていますが、 一部のワードは符号無しの数値に対しても機能します: @code{+},
@code{1+}, @code{-}, @code{1-}, @code{*}

@findex + ( @var{ n1 n2 -- n  } ) core
@cindex @code{+}
@kindex +
@format
@code{+} ( @i{n1 n2 -- n }) core ``plus''
@end format

@findex 1+ ( @var{ n1 -- n2  } ) core
@cindex @code{1+}
@kindex 1+
@format
@code{1+} ( @i{n1 -- n2 }) core ``one-plus''
@end format

@findex under+ ( @var{ n1 n2 n3 -- n n2  } ) gforth-0.3
@cindex @code{under+}
@kindex under+
@format
@code{under+} ( @i{n1 n2 n3 -- n n2 }) gforth-0.3 ``under-plus''
@end format
@i{n3} を @i{n1} に足し込む(@i{n} を得る)

@findex - ( @var{ n1 n2 -- n  } ) core
@cindex @code{-}
@kindex -
@format
@code{-} ( @i{n1 n2 -- n }) core ``minus''
@end format

@findex 1- ( @var{ n1 -- n2  } ) core
@cindex @code{1-}
@kindex 1-
@format
@code{1-} ( @i{n1 -- n2 }) core ``one-minus''
@end format

@findex * ( @var{ n1 n2 -- n  } ) core
@cindex @code{*}
@kindex *
@format
@code{*} ( @i{n1 n2 -- n }) core ``star''
@end format

@findex negate ( @var{ n1 -- n2  } ) core
@cindex @code{negate}
@kindex negate
@format
@code{negate} ( @i{n1 -- n2 }) core ``negate''
@end format

@findex abs ( @var{ n -- u  } ) core
@cindex @code{abs}
@kindex abs
@format
@code{abs} ( @i{n -- u }) core ``abs''
@end format

@findex min ( @var{ n1 n2 -- n  } ) core
@cindex @code{min}
@kindex min
@format
@code{min} ( @i{n1 n2 -- n }) core ``min''
@end format

@findex max ( @var{ n1 n2 -- n  } ) core
@cindex @code{max}
@kindex max
@format
@code{max} ( @i{n1 n2 -- n }) core ``max''
@end format

@findex umin ( @var{ u1 u2 -- u  } ) gforth-0.5
@cindex @code{umin}
@kindex umin
@format
@code{umin} ( @i{u1 u2 -- u }) gforth-0.5 ``umin''
@end format

@findex umax ( @var{ u1 u2 -- u  } ) gforth-1.0
@cindex @code{umax}
@kindex umax
@format
@code{umax} ( @i{u1 u2 -- u }) gforth-1.0 ``umax''
@end format


@node Double precision, Mixed precision, Single precision, Arithmetic
@subsection Double precision
@cindex double precision arithmetic words

テキスト・インタプリタが2倍長整を認識するために使用するルールについては、 @ref{Number Conversion} を参照してください。

数値は 2 の補数演算を使用する Gforth で表されるため、符号付き単精度浮動小数点数を (符号付き)
倍精度浮動小数点に変換するには、最上位セル全体で符号拡張が必要です。 倍精度整数はセルのペアで表され、 上位側のセルが TOS にあります。
符号無しの1倍長整数を2倍長整数に変換するのは簡単で、 @code{0} を TOS にプッシュするだけです。 整数値は Gforth では 2
の補数表現を使うため、  符号付き1倍長整数を(符号付き)2倍長整数に変換するには、 上位側セル全体で符号拡張が必要です。 これは @code{s>d}
を使用して実現できます。 このことから分かるとおり、 それが符号無し整数を表しているのか、 符号有り整数を表しているのか分からなければ、
数値を変換できないということです。

これらのワードはすべて符号付きオペランドに対して定義されていますが、 一部のワードは符号無しの数値に対しても機能します:
@code{d+}、@code{d-}

@findex s>d ( @var{ n -- d   } ) core
@cindex @code{s>d}
@kindex s>d
@format
@code{s>d} ( @i{n -- d  }) core ``s-to-d''
@end format

@findex d>s ( @var{ d -- n   } ) double
@cindex @code{d>s}
@kindex d>s
@format
@code{d>s} ( @i{d -- n  }) double ``d-to-s''
@end format

@findex d+ ( @var{ ud1 ud2 -- ud  } ) double
@cindex @code{d+}
@kindex d+
@format
@code{d+} ( @i{ud1 ud2 -- ud }) double ``d-plus''
@end format

@findex d- ( @var{ d1 d2 -- d  } ) double
@cindex @code{d-}
@kindex d-
@format
@code{d-} ( @i{d1 d2 -- d }) double ``d-minus''
@end format

@findex dnegate ( @var{ d1 -- d2  } ) double
@cindex @code{dnegate}
@kindex dnegate
@format
@code{dnegate} ( @i{d1 -- d2 }) double ``d-negate''
@end format

@findex dabs ( @var{ d -- ud   } ) double
@cindex @code{dabs}
@kindex dabs
@format
@code{dabs} ( @i{d -- ud  }) double ``d-abs''
@end format

@findex dmin ( @var{ d1 d2 -- d   } ) double
@cindex @code{dmin}
@kindex dmin
@format
@code{dmin} ( @i{d1 d2 -- d  }) double ``d-min''
@end format

@findex dmax ( @var{ d1 d2 -- d   } ) double
@cindex @code{dmax}
@kindex dmax
@format
@code{dmax} ( @i{d1 d2 -- d  }) double ``d-max''
@end format



@node Mixed precision, Integer division, Double precision, Arithmetic
@subsection Mixed precision
@cindex mixed precision arithmetic words

@findex m+ ( @var{ d1 n -- d2  } ) double
@cindex @code{m+}
@kindex m+
@format
@code{m+} ( @i{d1 n -- d2 }) double ``m-plus''
@end format

@findex m* ( @var{ n1 n2 -- d  } ) core
@cindex @code{m*}
@kindex m*
@format
@code{m*} ( @i{n1 n2 -- d }) core ``m-star''
@end format

@findex um* ( @var{ u1 u2 -- ud  } ) core
@cindex @code{um*}
@kindex um*
@format
@code{um*} ( @i{u1 u2 -- ud }) core ``u-m-star''
@end format


@node Integer division, Two-stage integer division, Mixed precision, Arithmetic
@subsection Integer division
@cindex dividing integers
@cindex modulus
@cindex remainder
@cindex Floating-point unidentified fault
@cindex Division by zero
@cindex Result out of range

以下にあるように、 除算を扱うために相当な数のワードがあることが分かります。 これらの主な違いは、 符号付き除算の処理にあります。
これらのワードはどのようにして符号付き除算に対応するのでしょうか？ (@code{U} プレフィックスが付いたワードでは符号付き除算に対応しません)

@cindex floored division
@cindex symmetric division
商を四捨五入して整数に丸める場合、 負の無限大に向かって丸めるのでしょうか(floored division(床除算)、 接尾辞 @code{F})、
それとも 0 に向かって丸めるのでしょうか(symmetric division、接尾辞 @code{S})。  標準では、
ほとんどの標準ワード(@code{/ mod /mod */ */mod m*/})について、 問題なのは、 各々の実装依存のままであり、
システムごとに異なる選択が行われています。  Gforth では、こ​​れらのワードをfloorとして実装します(Gforth 0.7 以降)。
floored division と symmetric division の違いは、 割られる数と割る数の符号が異なり、 かつ、
割られる数が割る数の倍数で無い場合のみです。 以下の表に組み合わせの結果を示します:

@example
                      floored          symmetric
割られる  割る数      余り 商            余り 商
    10      7           3   1              3   1
   -10      7           4  -2             -3  -1
    10     -7          -4  -2              3  -1
   -10     -7          -3   1             -3   1
@end example

floored と symmetric とが違いを生む一般的なケースは、 様々な符号の被除数(割られる数) n1 が、 同一の正の除数(割る数) n2
で除算される場合です。 同一の正の除数(割る数) n2 で除算される場合、 通常は floored division が必要で、なぜなら、
同一の正の除数(割る数) n2 で除算される場合、 余りは常に正となり、 被除数(割られる数)に応じて符号が変化しないからです。 また、 floored
division では、 n1 が n2 増加すると商は常に 1 増加しますが、 symmetric division では、 -n2<n1<n2
の場合は商は増加しません(この範囲では商は 0 です)。

いずれの場合でも、 floored と symmetric とで違いが生ずる数値を除算する場合は、 どのバリエーションが適切であるかを考えてから、
適切な接尾辞を付けた Gforth ワードか、 標準ワードの @code{fm/mod} または @code{sm/rem}
のいずれかを使用する必要があります。 

1倍長セル同士の除算:

@findex / ( @var{ n1 n2 -- n   } ) core
@cindex @code{/}
@kindex /
@format
@code{/} ( @i{n1 n2 -- n  }) core ``slash''
@end format
n=n1/n2


@findex /s ( @var{ n1 n2 -- n  } ) gforth-1.0
@cindex @code{/s}
@kindex /s
@format
@code{/s} ( @i{n1 n2 -- n }) gforth-1.0 ``slash-s''
@end format

@findex /f ( @var{ n1 n2 -- n  } ) gforth-1.0
@cindex @code{/f}
@kindex /f
@format
@code{/f} ( @i{n1 n2 -- n }) gforth-1.0 ``slash-f''
@end format

@findex u/ ( @var{ u1 u2 -- u  } ) gforth-1.0
@cindex @code{u/}
@kindex u/
@format
@code{u/} ( @i{u1 u2 -- u }) gforth-1.0 ``u-slash''
@end format

@findex mod ( @var{ n1 n2 -- n   } ) core
@cindex @code{mod}
@kindex mod
@format
@code{mod} ( @i{n1 n2 -- n  }) core ``mod''
@end format
n は n1/n2 の余り(modulus)


@findex mods ( @var{ n1 n2 -- n  } ) gforth-1.0
@cindex @code{mods}
@kindex mods
@format
@code{mods} ( @i{n1 n2 -- n }) gforth-1.0 ``mod-s''
@end format

@findex modf ( @var{ n1 n2 -- n  } ) gforth-1.0
@cindex @code{modf}
@kindex modf
@format
@code{modf} ( @i{n1 n2 -- n }) gforth-1.0 ``modf''
@end format

@findex umod ( @var{ u1 u2 -- u  } ) gforth-1.0
@cindex @code{umod}
@kindex umod
@format
@code{umod} ( @i{u1 u2 -- u }) gforth-1.0 ``umod''
@end format

@findex /mod ( @var{ n1 n2 -- n3 n4   } ) core
@cindex @code{/mod}
@kindex /mod
@format
@code{/mod} ( @i{n1 n2 -- n3 n4  }) core ``slash-mod''
@end format
n1/n2 を行い、 n3 が余り(modulus)、 n4 が商です(n1=n2*n4+n3)。


@findex /mods ( @var{ n1 n2 -- n3 n4  } ) gforth-1.0
@cindex @code{/mods}
@kindex /mods
@format
@code{/mods} ( @i{n1 n2 -- n3 n4 }) gforth-1.0 ``slash-mod-s''
@end format
n3 が余り(remainder)、 n4 が商

@findex /modf ( @var{ n1 n2 -- n3 n4  } ) gforth-1.0
@cindex @code{/modf}
@kindex /modf
@format
@code{/modf} ( @i{n1 n2 -- n3 n4 }) gforth-1.0 ``slash-mod-f''
@end format
n3 が余り(modulus)、 n4 が商

@findex u/mod ( @var{ u1 u2 -- u3 u4  } ) gforth-1.0
@cindex @code{u/mod}
@kindex u/mod
@format
@code{u/mod} ( @i{u1 u2 -- u3 u4 }) gforth-1.0 ``u-slash-mod''
@end format
u3 が余り(modulus)、 u4 が商


2倍長セルを1倍長セルで割って1倍長セルの結果を得る; これらのワードは、 一部のアーキテクチャ(AMD64 など)では上記ワードとほぼ同じ速度ですが、
他のアーキテクチャ(さまざまな Aarch64 CPU など)でははるかに遅くなります。

@findex fm/mod ( @var{ d1 n1 -- n2 n3  } ) core
@cindex @code{fm/mod}
@kindex fm/mod
@format
@code{fm/mod} ( @i{d1 n1 -- n2 n3 }) core ``f-m-slash-mod''
@end format
Floored division: @i{d1} = @i{n3}*@i{n1}+@i{n2}, @i{n1}>@i{n2}>=0 or
0>=@i{n2}>@i{n1}.

@findex sm/rem ( @var{ d1 n1 -- n2 n3  } ) core
@cindex @code{sm/rem}
@kindex sm/rem
@format
@code{sm/rem} ( @i{d1 n1 -- n2 n3 }) core ``s-m-slash-rem''
@end format
Symmetric division: @i{d1} = @i{n3}*@i{n1}+@i{n2}, sign(@i{n2})=sign(@i{d1})
or 0.

@findex um/mod ( @var{ ud u1 -- u2 u3  } ) core
@cindex @code{um/mod}
@kindex um/mod
@format
@code{um/mod} ( @i{ud u1 -- u2 u3 }) core ``u-m-slash-mod''
@end format
ud=u3*u1+u2, 0<=u2<u1

@findex du/mod ( @var{ d u -- n u1  } ) gforth-1.0
@cindex @code{du/mod}
@kindex du/mod
@format
@code{du/mod} ( @i{d u -- n u1 }) gforth-1.0 ``du-slash-mod''
@end format
d=n*u+u1, 0<=u1<u; PolyForth スタイルの混合除算

@findex */ ( @var{ ( n1 n2 n3 -- n4   } ) core
@cindex @code{*/}
@kindex */
@format
@code{*/} ( @i{( n1 n2 n3 -- n4  }) core ``star-slash''
@end format
n4=(n1*n2)/n3 中間結果は2倍長


@findex */s ( @var{ n1 n2 n3 -- n4  } ) gforth-1.0
@cindex @code{*/s}
@kindex */s
@format
@code{*/s} ( @i{n1 n2 n3 -- n4 }) gforth-1.0 ``star-slash-s''
@end format
n4=(n1*n2)/n3 中間結果は2倍長

@findex */f ( @var{ n1 n2 n3 -- n4  } ) gforth-1.0
@cindex @code{*/f}
@kindex */f
@format
@code{*/f} ( @i{n1 n2 n3 -- n4 }) gforth-1.0 ``star-slash-f''
@end format
n4=(n1*n2)/n3 中間結果は2倍長

@findex u*/ ( @var{ u1 u2 u3 -- u4  } ) gforth-1.0
@cindex @code{u*/}
@kindex u*/
@format
@code{u*/} ( @i{u1 u2 u3 -- u4 }) gforth-1.0 ``u-star-slash''
@end format
u4=(u1*u2)/u3 中間結果は2倍長

@findex */mod ( @var{ n1 n2 n3 -- n4 n5   } ) core
@cindex @code{*/mod}
@kindex */mod
@format
@code{*/mod} ( @i{n1 n2 n3 -- n4 n5  }) core ``star-slash-mod''
@end format
n1*n2=n3*n5+n4 中間結果(n1*n2)は2倍長、 n4 は剰余、 n5 は商。


@findex */mods ( @var{ n1 n2 n3 -- n4 n5  } ) gforth-1.0
@cindex @code{*/mods}
@kindex */mods
@format
@code{*/mods} ( @i{n1 n2 n3 -- n4 n5 }) gforth-1.0 ``star-slash-mod-s''
@end format
n1*n2=n3*n5+n4, 中間結果(n1*n2)は2倍長、 n4 は余り(remainder)、 n5 は商

@findex */modf ( @var{ n1 n2 n3 -- n4 n5  } ) gforth-1.0
@cindex @code{*/modf}
@kindex */modf
@format
@code{*/modf} ( @i{n1 n2 n3 -- n4 n5 }) gforth-1.0 ``star-slash-mod-f''
@end format
n1*n2=n3*n5+n4 中間結果(n1*n2)は2倍長。 n4 余り(modulus)、n5 は商

@findex u*/mod ( @var{ u1 u2 u3 -- u4 u5  } ) gforth-1.0
@cindex @code{u*/mod}
@kindex u*/mod
@format
@code{u*/mod} ( @i{u1 u2 u3 -- u4 u5 }) gforth-1.0 ``u-star-slash-mod''
@end format
u1*u2=u3*u5+u4 中間結果(u1*u2)は2倍長。


除算結果を2倍長セル(double-cell)で得ます。 以下のワード群は上記のワード群よりもはるかに遅いです。

@findex ud/mod ( @var{ ud1 u2 -- urem udquot   } ) gforth-0.2
@cindex @code{ud/mod}
@kindex ud/mod
@format
@code{ud/mod} ( @i{ud1 u2 -- urem udquot  }) gforth-0.2 ``ud/mod''
@end format
符号無し2倍長 @i{ud1} を @i{u2} で割る。 結果は、符号なし2倍長の商 @i{udquot} と、 1倍長の余り(remainder)
@i{urem} です。


@findex m*/ ( @var{ d1 n2 u3 -- dquot   } ) double
@cindex @code{m*/}
@kindex m*/
@format
@code{m*/} ( @i{d1 n2 u3 -- dquot  }) double ``m-star-slash''
@end format
dquot=(d1*n2)/u3,  中間結果は3倍長です。 ANS Forth では u3 は正の符号付き数値のみです。



環境クエリ(environmental query) @code{floored} を使用すると、 @code{/ mod /mod */ */mod
m*/} が floored division か symmetric division かを確認できます(@pxref{Environmental
Queries})。

@cindex Floating-point unidentified fault (on integer division)
@cindex Division by zero
@cindex Result out of range (on integer division)
整数除算ワードのもう 1 つの側面は、 整数除算ワードのほとんどがオーバーフローする可能性があり、 かつ、
ゼロによる除算が数学的に定義されていないことです。  これらの条件のいずれかに該当した場合に何が起こるかは、
エンジンやハードウェアやオペレーティング・システムによって異なります。 @code{gforth} エンジンは、適切なエラーである -10
(Division by zero;ゼロ除算) または -11 (Result out of range;範囲外の結果) を throw
しようと懸命に試みます、 が、 しかし、 一部のプラットフォームでは -55（浮動小数点未確認エラー;Floating-point
unidentified fault）が throw されます。  @code{gforth-fast} エンジンでは、 不適切な throw
コード(およびエラー・メッセージ)を生成する場合や、 エラーを生成せずに嘘の値のみを生成する場合があります。  つまり、 あなたは、 そのような条件が
throw されることに賭けるべきではありません。 そして、 あなたが迅速なデバッグを行うためには、 @code{gforth} エンジンは
@code{gforth-fast} エンジンよりも多くのエラーをキャッチし、 より正確なエラーを生成します。


@node Two-stage integer division, Bitwise operations, Integer division, Arithmetic
@subsection Two-stage integer division
@cindex dividing many integers with the same divisor
@cindex reciprocal of integer

(Two-stage integer divison;2段階除算)ほとんどのハードウェアでは、 乗算は除算よりも大幅に高速です。 したがって、
多くの数値を同じ除数(割る数)で除算する必要がある場合は、 通常、 除数の逆数を一度求めて、 その逆数を数値に乗算する方が高速です。  整数の場合、
これは技巧的になってしまうため、 Gforth ではこの作業をこのセクションで説明するワード群にパッケージ化しています。

以下の例から始めるとしましょう。 あなたがセルの配列のすべての要素を同じ数値 n で除算したいとします。 これを素直に実装すると以下のようになります:

@example
: array/ ( addr u n -- )
  -rot cells bounds u+do
    i @@ over / i !
  1 cells +loop
  drop ;
@end example

より効率的なバージョンは以下のようになります:

@example
: array/ ( addr u n -- )
  @{: | reci[ staged/-size ] :@}
  reci[ /f-stage1m
  cells bounds u+do
    i @@ reci[ /f-stage2m i !
  1 cells +loop ;
@end example

この例では、 まず、 逆数データを格納するためのサイズ @code{staged/-size} のローカル・バッファー @code{reci[}
を作成します。 次に、 @code{/f-stage1m} は @i{n} の逆数を計算し、 @code{reci[} に格納します。 最後に、
ループ内で @code{/f-stage2m} が @code{reci[} のデータを使用して除算の商を計算します。

これにはいくつかの制限があります。 @code{/f-stage1m} では正の除数のみがサポートされます。  @code{u/-stage1m} には
2 以上の数を使用できます。  サポートされていない除数を使用しようとすると、 エラーが発生します。  floored
第2ステージ・ワードの相互(reciprocal)バッファーは @code{/f-stage1m} で初期化し、
符号な無しの第2ステージ・ワードの相互バッファーは @code{u/-stage1m} で初期化する必要があります。
最初のステージと2番目のステージの間で相互バッファーを変更してはなりません。 基本的に、 これはメモリ・バッファーとして扱うのではなく、
最初のステージでのみ変更可能なものとして扱います。 このルールのポイントは、 Gforth
の将来のバージョンではこのバッファーのエイリアスが考慮されないということです。

これらのワードが以下です:

@findex staged/-size ( @var{ -- u   } ) gforth-1.0
@cindex @code{staged/-size}
@kindex staged/-size
@format
@code{staged/-size} ( @i{-- u  }) gforth-1.0 ``staged-slash-size''
@end format
@code{u/-stage1m} または @code{/f-stage1m} のバッファーのサイズ。


@findex /f-stage1m ( @var{ n addr-reci --   } ) gforth-1.0
@cindex @code{/f-stage1m}
@kindex /f-stage1m
@format
@code{/f-stage1m} ( @i{n addr-reci --  }) gforth-1.0 ``slash-f-stage1m''
@end format
@i{n} の逆数を計算し、 サイズ @code{staged/-size} のバッファー @i{addr-reci} に格納します。  @i{n}<1
の場合、 エラーを出します(throw)。


@findex /f-stage2m ( @var{ n1 a-reci -- nquotient  } ) gforth-1.0
@cindex @code{/f-stage2m}
@kindex /f-stage2m
@format
@code{/f-stage2m} ( @i{n1 a-reci -- nquotient }) gforth-1.0 ``slash-f-stage2m''
@end format
@i{Nquotient} は、@i{n1} を @i{a-reci} で表される除数で除算した結果であり、 @code{/f-stage1m}
によって計算されます。

@findex modf-stage2m ( @var{ n1 a-reci -- umodulus  } ) gforth-1.0
@cindex @code{modf-stage2m}
@kindex modf-stage2m
@format
@code{modf-stage2m} ( @i{n1 a-reci -- umodulus }) gforth-1.0 ``mod-f-stage2m''
@end format
@i{Umodulus} は、 @i{n1} を @i{a-reci} で表される除数で割った余り(remainder)で、
@code{/f-stage1m} によって計算されます。

@findex /modf-stage2m ( @var{ n1 a-reci -- umodulus nquotient  } ) gforth-1.0
@cindex @code{/modf-stage2m}
@kindex /modf-stage2m
@format
@code{/modf-stage2m} ( @i{n1 a-reci -- umodulus nquotient }) gforth-1.0 ``slash-mod-f-stage2m''
@end format
@i{Nquotient} は商で、 @i{umodulus} は @i{n1} を @i{a-reci}
で表される除数で割った余り(remainder)で、 @code{/f-stage1m} によって計算されます。 

@findex u/-stage1m ( @var{ u addr-reci --   } ) gforth-1.0
@cindex @code{u/-stage1m}
@kindex u/-stage1m
@format
@code{u/-stage1m} ( @i{u addr-reci --  }) gforth-1.0 ``u-slash-stage1m''
@end format
@i{u} の逆数を計算し、 サイズ @code{staged/-size} のバッファー @i{addr-reci} に格納します。  @i{u}<2
の場合、 エラーを出します(throw)。


@findex u/-stage2m ( @var{ u1 a-reci -- uquotient  } ) gforth-1.0
@cindex @code{u/-stage2m}
@kindex u/-stage2m
@format
@code{u/-stage2m} ( @i{u1 a-reci -- uquotient }) gforth-1.0 ``u-slash-stage2m''
@end format
@i{Uquotient} は、 @i{u1} を @i{a-reci} で表される除数で除算した結果であり、 @code{u/-stage1m}
によって計算されます。

@findex umod-stage2m ( @var{ u1 a-reci -- umodulus  } ) gforth-1.0
@cindex @code{umod-stage2m}
@kindex umod-stage2m
@format
@code{umod-stage2m} ( @i{u1 a-reci -- umodulus }) gforth-1.0 ``u-mod-stage2m''
@end format
@i{Umodulus} は、 @i{u1} を @i{a-reci}
で表される除数で割った余り(remainder)で、@code{u/-stage1m} によって計算されます。

@findex u/mod-stage2m ( @var{ u1 a-reci -- umodulus uquotient  } ) gforth-1.0
@cindex @code{u/mod-stage2m}
@kindex u/mod-stage2m
@format
@code{u/mod-stage2m} ( @i{u1 a-reci -- umodulus uquotient }) gforth-1.0 ``u-slash-mod-stage2m''
@end format
@i{Uquotient} は商で、 @i{umodulus} は @i{a-reci} で表される除数で @i{u1}
を割った余り(remainder)で、@code{u/-stage1m} によって計算されます。 


Gforth は現在、 段階的対称除算(staged symmetrical division)をサポートしていません。

@code{staged/-divisor @@} を使用すると、 逆数(のアドレス)から除数を復旧(recover)できます:

@findex staged/-divisor ( @var{ addr1 -- addr2   } ) gforth-1.0
@cindex @code{staged/-divisor}
@kindex staged/-divisor
@format
@code{staged/-divisor} ( @i{addr1 -- addr2  }) gforth-1.0 ``staged-slash-divisor''
@end format
@i{Addr1} は逆数のアドレス、 @i{addr2} は逆数の計算元となった除数を含むアドレスです。



これは、Gforth の逆コンパイラ出力を確認するときに役立ちます。 定数による除算は、 多くの場合、
逆数のアドレスとその後に続く第2ステージ・ワードを含むリテラルにコンパイルされます。

これらのワードを使用した場合のパフォーマンスへの影響は、 アーキテクチャ(ハードウェア除算があるかどうか)と、
特定の実装(ハードウェア除算の速さはどれくらいか)に大きく依存しますが、 これらのワードの相対的なパフォーマンスについてのアイデアを提供するために、
以下を示します。 2 つの AMD64 実装でのマイクロ・ベンチマークの反復ごとのサイクルを以下に示します。 @i{norm}
列は通常の除算ワード(例: @code{u/})を示し、stg2 列は対応する stage2 ワード(例:
@code{u/-stage2m})を示します:

@example
intel Skylake       AMD Zen2
norm stg2           norm stg2
41.3 15.8 u/        35.2 21.4 u/
39.8 19.7 umod      36.9 25.8 umod
44.0 25.3 u/mod     43.0 33.9 u/mod
48.7 16.9 /f        36.2 22.5 /f
47.9 20.5 modf      37.9 27.1 modf
53.0 24.6 /modf     45.8 35.4 /modf
    227.2 u/stage1      101.9 u/stage1
    159.8 /fstage1       97.7 /fstage1
@end example


@node Bitwise operations, Numeric comparison, Two-stage integer division, Arithmetic
@subsection Bitwise operations
@cindex bitwise operation words


@findex and ( @var{ w1 w2 -- w  } ) core
@cindex @code{and}
@kindex and
@format
@code{and} ( @i{w1 w2 -- w }) core ``and''
@end format

@findex or ( @var{ w1 w2 -- w  } ) core
@cindex @code{or}
@kindex or
@format
@code{or} ( @i{w1 w2 -- w }) core ``or''
@end format

@findex xor ( @var{ w1 w2 -- w  } ) core
@cindex @code{xor}
@kindex xor
@format
@code{xor} ( @i{w1 w2 -- w }) core ``x-or''
@end format

@findex invert ( @var{ w1 -- w2  } ) core
@cindex @code{invert}
@kindex invert
@format
@code{invert} ( @i{w1 -- w2 }) core ``invert''
@end format

@findex mux ( @var{ u1 u2 u3 -- u  } ) gforth-1.0
@cindex @code{mux}
@kindex mux
@format
@code{mux} ( @i{u1 u2 u3 -- u }) gforth-1.0 ``mux''
@end format
multiplex(多重化): @i{u3} の各ビットについて、 そのビットが 1 の場合は @i{u1} から対応するビットを選択し、
それ以外の場合は @i{u2} から対応するビットを選択します。 たとえば、 @code{%0011 %1100 %1010 mux} は
@code{%0110} となります。

@findex lshift ( @var{ u1 u -- u2  } ) core
@cindex @code{lshift}
@kindex lshift
@format
@code{lshift} ( @i{u1 u -- u2 }) core ``l-shift''
@end format
@i{u1} を @i{u} ビット左シフトします。

@findex rshift ( @var{ u1 u -- u2  } ) core
@cindex @code{rshift}
@kindex rshift
@format
@code{rshift} ( @i{u1 u -- u2 }) core ``r-shift''
@end format
@i{u1} (セル) を @i{u} ビットだけ右にシフトし、 シフトインされたビットを 0 で埋めます(論理/符号無しシフトです)。

@findex arshift ( @var{ n1 u -- n2  } ) gforth-1.0
@cindex @code{arshift}
@kindex arshift
@format
@code{arshift} ( @i{n1 u -- n2 }) gforth-1.0 ``ar-shift''
@end format
@i{n1} (セル) を @i{u} ビット右にシフトし、@i{n1} の符号ビットからシフトインされたビットを埋めます (算術シフト)。

@findex dlshift ( @var{ ud1 u -- ud2  } ) gforth-1.0
@cindex @code{dlshift}
@kindex dlshift
@format
@code{dlshift} ( @i{ud1 u -- ud2 }) gforth-1.0 ``dlshift''
@end format
@i{ud1} (2倍長セル) を @i{u} ビット左にシフトします。

@findex drshift ( @var{ ud1 u -- ud2  } ) gforth-1.0
@cindex @code{drshift}
@kindex drshift
@format
@code{drshift} ( @i{ud1 u -- ud2 }) gforth-1.0 ``drshift''
@end format
@i{ud1} (2倍長セル) を @i{u} ビットだけ右にシフトし、 シフトインされたビットを 0 で埋めます (論理/符号なしシフト)。

@findex darshift ( @var{ d1 u -- d2  } ) gforth-1.0
@cindex @code{darshift}
@kindex darshift
@format
@code{darshift} ( @i{d1 u -- d2 }) gforth-1.0 ``darshift''
@end format
@i{d1} (2倍長セル) を @i{u} ビット右にシフトし、@i{d1} の符号ビットからシフトインされたビットで埋めます (算術シフト)。

@findex 2* ( @var{ n1 -- n2  } ) core
@cindex @code{2*}
@kindex 2*
@format
@code{2*} ( @i{n1 -- n2 }) core ``two-star''
@end format
1 つ左にシフトします。符号なしの数値でも機能します

@findex 2/ ( @var{ n1 -- n2  } ) core
@cindex @code{2/}
@kindex 2/
@format
@code{2/} ( @i{n1 -- n2 }) core ``two-slash''
@end format
1 つ右に算術シフトします。 符号付き数値の場合、 これは 2 による floored division になります(@code{/} は必ずしも
floors ではないことに注意してください)。

@findex d2* ( @var{ d1 -- d2  } ) double
@cindex @code{d2*}
@kindex d2*
@format
@code{d2*} ( @i{d1 -- d2 }) double ``d-two-star''
@end format
2倍長セルを左に 1 シフトします。 符号なしの数値でも機能します

@findex d2/ ( @var{ d1 -- d2  } ) double
@cindex @code{d2/}
@kindex d2/
@format
@code{d2/} ( @i{d1 -- d2 }) double ``d-two-slash''
@end format
1 つ右に算術シフトします。 符号付き数値の場合、これは 2 による floored division になります。

@findex >pow2 ( @var{ u1 -- u2  } ) gforth-1.0
@cindex @code{>pow2}
@kindex >pow2
@format
@code{>pow2} ( @i{u1 -- u2 }) gforth-1.0 ``to-pow2''
@end format
@i{u2} は、@i{u2>=u1} の最小の 2 のべき乗数です。

@findex log2 ( @var{ u -- n  } ) gforth-1.0
@cindex @code{log2}
@kindex log2
@format
@code{log2} ( @i{u -- n }) gforth-1.0 ``log2''
@end format
@i{N} は @i{u} の切り捨て2進対数、 つまり最初に設定されたビットのインデックスです。 @i{u}=0 の場合は @i{n}=-1 です。

@findex pow2? ( @var{ u -- f   } ) gforth-1.0
@cindex @code{pow2?}
@kindex pow2?
@format
@code{pow2?} ( @i{u -- f  }) gforth-1.0 ``pow-two-query''
@end format
@i{f} は、 @i{u} が 2 の累乗の場合、 つまり @i{u} のビットが 1 つだけセットされている場合に true になります。


@findex ctz ( @var{ x -- u   } ) gforth-1.0
@cindex @code{ctz}
@kindex ctz
@format
@code{ctz} ( @i{x -- u  }) gforth-1.0 ``c-t-z''
@end format
x の2進数表現で末尾からのゼロの数を数える



他のほとんどの操作とは異なり、 幅の狭いユニットのローテートと幅の広いユニットのローテートを簡単に合成することはできないため、 1倍長セル幅および
2倍幅のセル幅のローテート操作を使用すると、 結果がセル幅に依存することになります。  公開されたアルゴリズムまたはセル幅に依存しない結果の場合、
通常は固定幅のローテート操作を使用する必要があります。

@findex wrol ( @var{ u1 u -- u2  } ) gforth-1.0
@cindex @code{wrol}
@kindex wrol
@format
@code{wrol} ( @i{u1 u -- u2 }) gforth-1.0 ``wrol''
@end format
@i{u1} の下位側 16 ビットを @i{u} ビットだけ左に回転し、 他のビットを 0 にセットします。

@findex wror ( @var{ u1 u -- u2  } ) gforth-1.0
@cindex @code{wror}
@kindex wror
@format
@code{wror} ( @i{u1 u -- u2 }) gforth-1.0 ``wror''
@end format
@i{u1} の下位側 16 ビットを @i{u} ビットだけ右回転し、 他のビットを 0 にセットします。

@findex lrol ( @var{ u1 u -- u2  } ) gforth-1.0
@cindex @code{lrol}
@kindex lrol
@format
@code{lrol} ( @i{u1 u -- u2 }) gforth-1.0 ``lrol''
@end format
@i{u1} の下位側 32 ビットを @i{u} ビットだけ左に回転し、 他のビットを 0 にセットします。

@findex lror ( @var{ u1 u -- u2  } ) gforth-1.0
@cindex @code{lror}
@kindex lror
@format
@code{lror} ( @i{u1 u -- u2 }) gforth-1.0 ``lror''
@end format
@i{u1} の下位側 32 ビットを @i{u} ビットだけ右回転し、 他のビットを 0 にセットします。

@findex rol ( @var{ u1 u -- u2  } ) gforth-1.0
@cindex @code{rol}
@kindex rol
@format
@code{rol} ( @i{u1 u -- u2 }) gforth-1.0 ``rol''
@end format
@i{u1} のすべてのビットを @i{u} ビットだけ左に回転します。

@findex ror ( @var{ u1 u -- u2  } ) gforth-1.0
@cindex @code{ror}
@kindex ror
@format
@code{ror} ( @i{u1 u -- u2 }) gforth-1.0 ``ror''
@end format
@i{u1} のすべてのビットを @i{u} ビットだけ右回転します。

@findex drol ( @var{ ud1 u -- ud2  } ) gforth-1.0
@cindex @code{drol}
@kindex drol
@format
@code{drol} ( @i{ud1 u -- ud2 }) gforth-1.0 ``drol''
@end format
@i{ud1} (2倍長セル) のすべてのビットを @i{u} ビットだけ左に回転します。

@findex dror ( @var{ ud1 u -- ud2  } ) gforth-1.0
@cindex @code{dror}
@kindex dror
@format
@code{dror} ( @i{ud1 u -- ud2 }) gforth-1.0 ``dror''
@end format
@i{ud1} (2倍長セル) のすべてのビットを @i{u} ビット右に回転します。


@node Numeric comparison, Floating Point, Bitwise operations, Arithmetic
@subsection Numeric comparison
@cindex numeric comparison words

注意: 等しいかどうかを比較するワード(@code{= <> 0= 0<> d= d<> d0= d0<>}) は、
符号付き数値と符号なし数値の両方に対して機能することに注意してください。

@findex < ( @var{ n1 n2 -- f  } ) core
@cindex @code{<}
@kindex <
@format
@code{<} ( @i{n1 n2 -- f }) core ``less-than''
@end format

@findex <= ( @var{ n1 n2 -- f  } ) gforth-0.2
@cindex @code{<=}
@kindex <=
@format
@code{<=} ( @i{n1 n2 -- f }) gforth-0.2 ``less-or-equal''
@end format

@findex <> ( @var{ n1 n2 -- f  } ) core-ext
@cindex @code{<>}
@kindex <>
@format
@code{<>} ( @i{n1 n2 -- f }) core-ext ``not-equals''
@end format

@findex = ( @var{ n1 n2 -- f  } ) core
@cindex @code{=}
@kindex =
@format
@code{=} ( @i{n1 n2 -- f }) core ``equals''
@end format

@findex > ( @var{ n1 n2 -- f  } ) core
@cindex @code{>}
@kindex >
@format
@code{>} ( @i{n1 n2 -- f }) core ``greater-than''
@end format

@findex >= ( @var{ n1 n2 -- f  } ) gforth-0.2
@cindex @code{>=}
@kindex >=
@format
@code{>=} ( @i{n1 n2 -- f }) gforth-0.2 ``greater-or-equal''
@end format


@findex 0< ( @var{ n -- f  } ) core
@cindex @code{0<}
@kindex 0<
@format
@code{0<} ( @i{n -- f }) core ``zero-less-than''
@end format

@findex 0<= ( @var{ n -- f  } ) gforth-0.2
@cindex @code{0<=}
@kindex 0<=
@format
@code{0<=} ( @i{n -- f }) gforth-0.2 ``zero-less-or-equal''
@end format

@findex 0<> ( @var{ n -- f  } ) core-ext
@cindex @code{0<>}
@kindex 0<>
@format
@code{0<>} ( @i{n -- f }) core-ext ``zero-not-equals''
@end format

@findex 0= ( @var{ n -- f  } ) core
@cindex @code{0=}
@kindex 0=
@format
@code{0=} ( @i{n -- f }) core ``zero-equals''
@end format

@findex 0> ( @var{ n -- f  } ) core-ext
@cindex @code{0>}
@kindex 0>
@format
@code{0>} ( @i{n -- f }) core-ext ``zero-greater-than''
@end format

@findex 0>= ( @var{ n -- f  } ) gforth-0.2
@cindex @code{0>=}
@kindex 0>=
@format
@code{0>=} ( @i{n -- f }) gforth-0.2 ``zero-greater-or-equal''
@end format


@findex u< ( @var{ u1 u2 -- f  } ) core
@cindex @code{u<}
@kindex u<
@format
@code{u<} ( @i{u1 u2 -- f }) core ``u-less-than''
@end format

@findex u<= ( @var{ u1 u2 -- f  } ) gforth-0.2
@cindex @code{u<=}
@kindex u<=
@format
@code{u<=} ( @i{u1 u2 -- f }) gforth-0.2 ``u-less-or-equal''
@end format

@c u<> and u= exist but are the same as <> and =
@c doc-u<>
@c doc-u=
@findex u> ( @var{ u1 u2 -- f  } ) core-ext
@cindex @code{u>}
@kindex u>
@format
@code{u>} ( @i{u1 u2 -- f }) core-ext ``u-greater-than''
@end format

@findex u>= ( @var{ u1 u2 -- f  } ) gforth-0.2
@cindex @code{u>=}
@kindex u>=
@format
@code{u>=} ( @i{u1 u2 -- f }) gforth-0.2 ``u-greater-or-equal''
@end format


@findex within ( @var{ u1 u2 u3 -- f  } ) core-ext
@cindex @code{within}
@kindex within
@format
@code{within} ( @i{u1 u2 u3 -- f }) core-ext ``within''
@end format
u2<u3 かつ u1 が [u2,u3) にある(u2 < u3 and  u2 <= u1 < u3 )、 または u2 >= u3 かつ u1 が
[u3,u2) にない( u2 >= u3 and (u1 not in (u3 <= and < u2)。  これは、
符号なしの数値と符号付きの数値に対して機能します(ただし、 混ぜてはいけません)。  このワードについて考えるもう 1 つの方法は、
数値を循環として考えることです(符号なしの数値の場合は @code{max-u} から 0 まで、 符号付きの数値の場合は @code{max-n}
から min-n まで循環します)。ここで、 u2 から u3 までの増加する数値(u3 を除く)の範囲を検討します(u2=u3
の場合は空の範囲を与えます)。 u1 がこの範囲内にある場合、 @code{within} は true を返します。


@findex d< ( @var{ d1 d2 -- f  } ) double
@cindex @code{d<}
@kindex d<
@format
@code{d<} ( @i{d1 d2 -- f }) double ``d-less-than''
@end format

@findex d<= ( @var{ d1 d2 -- f  } ) gforth-0.2
@cindex @code{d<=}
@kindex d<=
@format
@code{d<=} ( @i{d1 d2 -- f }) gforth-0.2 ``d-less-or-equal''
@end format

@findex d<> ( @var{ d1 d2 -- f  } ) gforth-0.2
@cindex @code{d<>}
@kindex d<>
@format
@code{d<>} ( @i{d1 d2 -- f }) gforth-0.2 ``d-not-equals''
@end format

@findex d= ( @var{ d1 d2 -- f  } ) double
@cindex @code{d=}
@kindex d=
@format
@code{d=} ( @i{d1 d2 -- f }) double ``d-equals''
@end format

@findex d> ( @var{ d1 d2 -- f  } ) gforth-0.2
@cindex @code{d>}
@kindex d>
@format
@code{d>} ( @i{d1 d2 -- f }) gforth-0.2 ``d-greater-than''
@end format

@findex d>= ( @var{ d1 d2 -- f  } ) gforth-0.2
@cindex @code{d>=}
@kindex d>=
@format
@code{d>=} ( @i{d1 d2 -- f }) gforth-0.2 ``d-greater-or-equal''
@end format


@findex d0< ( @var{ d -- f  } ) double
@cindex @code{d0<}
@kindex d0<
@format
@code{d0<} ( @i{d -- f }) double ``d-zero-less-than''
@end format

@findex d0<= ( @var{ d -- f  } ) gforth-0.2
@cindex @code{d0<=}
@kindex d0<=
@format
@code{d0<=} ( @i{d -- f }) gforth-0.2 ``d-zero-less-or-equal''
@end format

@findex d0<> ( @var{ d -- f  } ) gforth-0.2
@cindex @code{d0<>}
@kindex d0<>
@format
@code{d0<>} ( @i{d -- f }) gforth-0.2 ``d-zero-not-equals''
@end format

@findex d0= ( @var{ d -- f  } ) double
@cindex @code{d0=}
@kindex d0=
@format
@code{d0=} ( @i{d -- f }) double ``d-zero-equals''
@end format

@findex d0> ( @var{ d -- f  } ) gforth-0.2
@cindex @code{d0>}
@kindex d0>
@format
@code{d0>} ( @i{d -- f }) gforth-0.2 ``d-zero-greater-than''
@end format

@findex d0>= ( @var{ d -- f  } ) gforth-0.2
@cindex @code{d0>=}
@kindex d0>=
@format
@code{d0>=} ( @i{d -- f }) gforth-0.2 ``d-zero-greater-or-equal''
@end format


@findex du< ( @var{ ud1 ud2 -- f  } ) double-ext
@cindex @code{du<}
@kindex du<
@format
@code{du<} ( @i{ud1 ud2 -- f }) double-ext ``d-u-less-than''
@end format

@findex du<= ( @var{ ud1 ud2 -- f  } ) gforth-0.2
@cindex @code{du<=}
@kindex du<=
@format
@code{du<=} ( @i{ud1 ud2 -- f }) gforth-0.2 ``d-u-less-or-equal''
@end format

@c du<> and du= exist but are the same as d<> and d=
@c doc-du<>
@c doc-du=
@findex du> ( @var{ ud1 ud2 -- f  } ) gforth-0.2
@cindex @code{du>}
@kindex du>
@format
@code{du>} ( @i{ud1 ud2 -- f }) gforth-0.2 ``d-u-greater-than''
@end format

@findex du>= ( @var{ ud1 ud2 -- f  } ) gforth-0.2
@cindex @code{du>=}
@kindex du>=
@format
@code{du>=} ( @i{ud1 ud2 -- f }) gforth-0.2 ``d-u-greater-or-equal''
@end format



@node Floating Point, , Numeric comparison, Arithmetic
@subsection Floating Point
@cindex floating point arithmetic words

浮動小数点数を認識するためにテキスト・インタプリタで使用されるルールについては、 @ref{Number Conversion} を参照してください。

Gforth には別個の浮動小数点スタックがありますが、
ドキュメントでは一緒に統一した表記が使用されています@footnote{この一緒にした表記から、 浮動小数点数だけを分離するだけで、
簡単に分離された表記にできます。 例えば: @code{( n r1 ur2 -- r3 )} は @code{( n u -- ) ( F: r1
r2 -- r3 )} になります}。

@cindex floating-point arithmetic, pitfalls
浮動小数点数は、 不注意な人にとっては多くの不快な驚きをもたらします(たとえば、浮動小数点の加算は結合的(associative)ではありません)。
また、 用心深い人にとってもいくつかの不快な驚きさえあります。 自分が何をしているのか理解していない場合、
または得られる結果が完全に偽物であることを気にしない場合を除き、 これらを使用すべきではありません。
浮動小数点数の問題(およびその回避方法)について知りたい場合は、 @cite{David Goldberg,
@uref{https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html,What
Every Computer Scientist Should Know About Floating-Point Arithmetic}, ACM
Computing Surveys 23(1):5@minus{}48, March 1991} から始めると良いでしょう(訳注:
@url{https://docs.oracle.com/cd/E19957-01/806-4847/ncg_goldberg.html}
これが合ってるかどうか不明。一部文字化けあり2024/06現在)。

整数と浮動小数点の間の変換:

@findex s>f ( @var{ n -- r  } ) floating-ext
@cindex @code{s>f}
@kindex s>f
@format
@code{s>f} ( @i{n -- r }) floating-ext ``s-to-f''
@end format

@findex d>f ( @var{ d -- r  } ) floating
@cindex @code{d>f}
@kindex d>f
@format
@code{d>f} ( @i{d -- r }) floating ``d-to-f''
@end format

@findex f>s ( @var{ r -- n  } ) floating-ext
@cindex @code{f>s}
@kindex f>s
@format
@code{f>s} ( @i{r -- n }) floating-ext ``f-to-s''
@end format

@findex f>d ( @var{ r -- d  } ) floating
@cindex @code{f>d}
@kindex f>d
@format
@code{f>d} ( @i{r -- d }) floating ``f-to-d''
@end format


算術演算:

@findex f+ ( @var{ r1 r2 -- r3  } ) floating
@cindex @code{f+}
@kindex f+
@format
@code{f+} ( @i{r1 r2 -- r3 }) floating ``f-plus''
@end format

@findex f- ( @var{ r1 r2 -- r3  } ) floating
@cindex @code{f-}
@kindex f-
@format
@code{f-} ( @i{r1 r2 -- r3 }) floating ``f-minus''
@end format

@findex f* ( @var{ r1 r2 -- r3  } ) floating
@cindex @code{f*}
@kindex f*
@format
@code{f*} ( @i{r1 r2 -- r3 }) floating ``f-star''
@end format

@findex f/ ( @var{ r1 r2 -- r3  } ) floating
@cindex @code{f/}
@kindex f/
@format
@code{f/} ( @i{r1 r2 -- r3 }) floating ``f-slash''
@end format

@findex fnegate ( @var{ r1 -- r2  } ) floating
@cindex @code{fnegate}
@kindex fnegate
@format
@code{fnegate} ( @i{r1 -- r2 }) floating ``f-negate''
@end format

@findex fabs ( @var{ r1 -- r2  } ) floating-ext
@cindex @code{fabs}
@kindex fabs
@format
@code{fabs} ( @i{r1 -- r2 }) floating-ext ``f-abs''
@end format

@findex fcopysign ( @var{ r1 r2 -- r3   } ) gforth-1.0
@cindex @code{fcopysign}
@kindex fcopysign
@format
@code{fcopysign} ( @i{r1 r2 -- r3  }) gforth-1.0 ``fcopysign''
@end format
r3 は r1 から絶対値を取得し r2 から符号を取得します


@findex fmax ( @var{ r1 r2 -- r3  } ) floating
@cindex @code{fmax}
@kindex fmax
@format
@code{fmax} ( @i{r1 r2 -- r3 }) floating ``f-max''
@end format

@findex fmin ( @var{ r1 r2 -- r3  } ) floating
@cindex @code{fmin}
@kindex fmin
@format
@code{fmin} ( @i{r1 r2 -- r3 }) floating ``f-min''
@end format

@findex floor ( @var{ r1 -- r2  } ) floating
@cindex @code{floor}
@kindex floor
@format
@code{floor} ( @i{r1 -- r2 }) floating ``floor''
@end format
次に小さい整数値に向かって丸めます。 つまり、 負の無限大に向かって丸めます。

@findex fround ( @var{ r1 -- r2  } ) floating
@cindex @code{fround}
@kindex fround
@format
@code{fround} ( @i{r1 -- r2 }) floating ``f-round''
@end format
最も近い整数値に丸めます(訳注: 0.5e -- 0, 0.50e -- 0, 0.51e -- 1, 1.5e -- 2, ... ??)

@findex ftrunc ( @var{ r1 -- r2   } ) floating-ext
@cindex @code{ftrunc}
@kindex ftrunc
@format
@code{ftrunc} ( @i{r1 -- r2  }) floating-ext ``f-trunc''
@end format
0 に向かって丸める(正数でも負数でも)


@findex f** ( @var{ r1 r2 -- r3  } ) floating-ext
@cindex @code{f**}
@kindex f**
@format
@code{f**} ( @i{r1 r2 -- r3 }) floating-ext ``f-star-star''
@end format
@i{r3} は @i{r1} の @i{r2} 乗です

@findex fsqrt ( @var{ r1 -- r2  } ) floating-ext
@cindex @code{fsqrt}
@kindex fsqrt
@format
@code{fsqrt} ( @i{r1 -- r2 }) floating-ext ``f-square-root''
@end format

@findex fexp ( @var{ r1 -- r2  } ) floating-ext
@cindex @code{fexp}
@kindex fexp
@format
@code{fexp} ( @i{r1 -- r2 }) floating-ext ``f-e-x-p''
@end format

@findex fexpm1 ( @var{ r1 -- r2  } ) floating-ext
@cindex @code{fexpm1}
@kindex fexpm1
@format
@code{fexpm1} ( @i{r1 -- r2 }) floating-ext ``f-e-x-p-m-one''
@end format
@i{r2}=@i{e}**@i{r1}@minus{}1

@findex fln ( @var{ r1 -- r2  } ) floating-ext
@cindex @code{fln}
@kindex fln
@format
@code{fln} ( @i{r1 -- r2 }) floating-ext ``f-l-n''
@end format

@findex flnp1 ( @var{ r1 -- r2  } ) floating-ext
@cindex @code{flnp1}
@kindex flnp1
@format
@code{flnp1} ( @i{r1 -- r2 }) floating-ext ``f-l-n-p-one''
@end format
@i{r2}=ln(@i{r1}+1)

@findex flog ( @var{ r1 -- r2  } ) floating-ext
@cindex @code{flog}
@kindex flog
@format
@code{flog} ( @i{r1 -- r2 }) floating-ext ``f-log''
@end format
常用対数(decimal logarithm)

@findex falog ( @var{ r1 -- r2  } ) floating-ext
@cindex @code{falog}
@kindex falog
@format
@code{falog} ( @i{r1 -- r2 }) floating-ext ``f-a-log''
@end format
@i{r2}=10**@i{r1}

@findex f2* ( @var{ r1 -- r2   } ) gforth-0.2
@cindex @code{f2*}
@kindex f2*
@format
@code{f2*} ( @i{r1 -- r2  }) gforth-0.2 ``f2*''
@end format
@i{r1} に 2.0e0 を掛けた値


@findex f2/ ( @var{ r1 -- r2   } ) gforth-0.2
@cindex @code{f2/}
@kindex f2/
@format
@code{f2/} ( @i{r1 -- r2  }) gforth-0.2 ``f2/''
@end format
@i{r1} に 0.5e0 を掛けた値


@findex 1/f ( @var{ r1 -- r2   } ) gforth-0.2
@cindex @code{1/f}
@kindex 1/f
@format
@code{1/f} ( @i{r1 -- r2  }) gforth-0.2 ``1/f''
@end format
1.0e0 を @i{r1} で割った値



ベクトル演算:

@findex v* ( @var{ f-addr1 nstride1 f-addr2 nstride2 ucount -- r  } ) gforth-0.5
@cindex @code{v*}
@kindex v*
@format
@code{v*} ( @i{f-addr1 nstride1 f-addr2 nstride2 ucount -- r }) gforth-0.5 ``v-star''
@end format
ドット積(dot-product): r=v1*v2   v1 の最初の要素は f_addr1 にあり、 次の要素は f_addr1+nstride1
というようになります(v2 も同様)。 どちらのベクトルにも ucount の数の要素があります。

@findex faxpy ( @var{ ra f-x nstridex f-y nstridey ucount --  } ) gforth-0.5
@cindex @code{faxpy}
@kindex faxpy
@format
@code{faxpy} ( @i{ra f-x nstridex f-y nstridey ucount -- }) gforth-0.5 ``faxpy''
@end format
vy=ra*vx+vy


@cindex angles in trigonometric operations
@cindex trigonometric operations
浮動小数点演算の角度はラジアン(radians)で指定します(完全な円は 2πラジアンです)。

@findex fsin ( @var{ r1 -- r2  } ) floating-ext
@cindex @code{fsin}
@kindex fsin
@format
@code{fsin} ( @i{r1 -- r2 }) floating-ext ``f-sine''
@end format

@findex fcos ( @var{ r1 -- r2  } ) floating-ext
@cindex @code{fcos}
@kindex fcos
@format
@code{fcos} ( @i{r1 -- r2 }) floating-ext ``f-cos''
@end format

@findex fsincos ( @var{ r1 -- r2 r3  } ) floating-ext
@cindex @code{fsincos}
@kindex fsincos
@format
@code{fsincos} ( @i{r1 -- r2 r3 }) floating-ext ``f-sine-cos''
@end format
@i{r2}=sin(@i{r1}), @i{r3}=cos(@i{r1})

@findex ftan ( @var{ r1 -- r2  } ) floating-ext
@cindex @code{ftan}
@kindex ftan
@format
@code{ftan} ( @i{r1 -- r2 }) floating-ext ``f-tan''
@end format

@findex fasin ( @var{ r1 -- r2  } ) floating-ext
@cindex @code{fasin}
@kindex fasin
@format
@code{fasin} ( @i{r1 -- r2 }) floating-ext ``f-a-sine''
@end format

@findex facos ( @var{ r1 -- r2  } ) floating-ext
@cindex @code{facos}
@kindex facos
@format
@code{facos} ( @i{r1 -- r2 }) floating-ext ``f-a-cos''
@end format

@findex fatan ( @var{ r1 -- r2  } ) floating-ext
@cindex @code{fatan}
@kindex fatan
@format
@code{fatan} ( @i{r1 -- r2 }) floating-ext ``f-a-tan''
@end format

@findex fatan2 ( @var{ r1 r2 -- r3  } ) floating-ext
@cindex @code{fatan2}
@kindex fatan2
@format
@code{fatan2} ( @i{r1 r2 -- r3 }) floating-ext ``f-a-tan-two''
@end format
@i{r1/r2}=tan(@i{r3})  ANS Forth ではそこまで求められてはいないのですが、 おそらくこれが @code{fsincos}
の逆になることを意図していて、 gforth ではそのようになっています。

@findex fsinh ( @var{ r1 -- r2  } ) floating-ext
@cindex @code{fsinh}
@kindex fsinh
@format
@code{fsinh} ( @i{r1 -- r2 }) floating-ext ``f-cinch''
@end format

@findex fcosh ( @var{ r1 -- r2  } ) floating-ext
@cindex @code{fcosh}
@kindex fcosh
@format
@code{fcosh} ( @i{r1 -- r2 }) floating-ext ``f-cosh''
@end format

@findex ftanh ( @var{ r1 -- r2  } ) floating-ext
@cindex @code{ftanh}
@kindex ftanh
@format
@code{ftanh} ( @i{r1 -- r2 }) floating-ext ``f-tan-h''
@end format

@findex fasinh ( @var{ r1 -- r2  } ) floating-ext
@cindex @code{fasinh}
@kindex fasinh
@format
@code{fasinh} ( @i{r1 -- r2 }) floating-ext ``f-a-cinch''
@end format

@findex facosh ( @var{ r1 -- r2  } ) floating-ext
@cindex @code{facosh}
@kindex facosh
@format
@code{facosh} ( @i{r1 -- r2 }) floating-ext ``f-a-cosh''
@end format

@findex fatanh ( @var{ r1 -- r2  } ) floating-ext
@cindex @code{fatanh}
@kindex fatanh
@format
@code{fatanh} ( @i{r1 -- r2 }) floating-ext ``f-a-tan-h''
@end format

@findex pi ( @var{ -- r   } ) gforth-0.2
@cindex @code{pi}
@kindex pi
@format
@code{pi} ( @i{-- r  }) gforth-0.2 ``pi''
@end format
@code{Fconstant}(定数) -- @i{r} は値 pi です(π)。 円の面積と直径の比率。



@cindex equality of floats
@cindex floating-point comparisons
浮動小数点演算に関する特別な問題の 1 つは、 等価性の比較が、 成功するはずなのに失敗することがよくあることです。  このため、 多くの場合、
近似的等価性が好まれます(ただし、 自分が何をしているのかを理解しておく必要があります)。  また、 IEEE NaN
の比較があなたの予想とは異なる場合があることにも注意してください。  比較ワードは以下のとおりです:

@findex f~rel ( @var{ r1 r2 r3 -- flag   } ) gforth-0.5
@cindex @code{f~rel}
@kindex f~rel
@format
@code{f~rel} ( @i{r1 r2 r3 -- flag  }) gforth-0.5 ``f~rel''
@end format
相対誤差を含む近似等価性: |r1-r2|<r3*|r1+r2|


@findex f~abs ( @var{ r1 r2 r3 -- flag   } ) gforth-0.5
@cindex @code{f~abs}
@kindex f~abs
@format
@code{f~abs} ( @i{r1 r2 r3 -- flag  }) gforth-0.5 ``f~abs''
@end format
Approximate equality with absolute error: |r1-r2|<r3.<
絶対誤差を伴う近似等価性: |r1-r2|<r3


@findex f~ ( @var{ r1 r2 r3 -- flag   } ) floating-ext
@cindex @code{f~}
@kindex f~
@format
@code{f~} ( @i{r1 r2 r3 -- flag  }) floating-ext ``f-proximate''
@end format
r1 と r2 が等しいかどうかを比較するための ANS Forth ワードごたまぜ: r3>0 なら @code{f~abs}; r3=0 なら
ビット単位の比較; r3<0 なら @code{fnegate f~rel}


@findex f= ( @var{ r1 r2 -- f  } ) gforth-0.2
@cindex @code{f=}
@kindex f=
@format
@code{f=} ( @i{r1 r2 -- f }) gforth-0.2 ``f-equals''
@end format

@findex f<> ( @var{ r1 r2 -- f  } ) gforth-0.2
@cindex @code{f<>}
@kindex f<>
@format
@code{f<>} ( @i{r1 r2 -- f }) gforth-0.2 ``f-not-equals''
@end format


@findex f< ( @var{ r1 r2 -- f  } ) floating
@cindex @code{f<}
@kindex f<
@format
@code{f<} ( @i{r1 r2 -- f }) floating ``f-less-than''
@end format

@findex f<= ( @var{ r1 r2 -- f  } ) gforth-0.2
@cindex @code{f<=}
@kindex f<=
@format
@code{f<=} ( @i{r1 r2 -- f }) gforth-0.2 ``f-less-or-equal''
@end format

@findex f> ( @var{ r1 r2 -- f  } ) gforth-0.2
@cindex @code{f>}
@kindex f>
@format
@code{f>} ( @i{r1 r2 -- f }) gforth-0.2 ``f-greater-than''
@end format

@findex f>= ( @var{ r1 r2 -- f  } ) gforth-0.2
@cindex @code{f>=}
@kindex f>=
@format
@code{f>=} ( @i{r1 r2 -- f }) gforth-0.2 ``f-greater-or-equal''
@end format


@findex f0< ( @var{ r -- f  } ) floating
@cindex @code{f0<}
@kindex f0<
@format
@code{f0<} ( @i{r -- f }) floating ``f-zero-less-than''
@end format

@findex f0<= ( @var{ r -- f  } ) gforth-0.2
@cindex @code{f0<=}
@kindex f0<=
@format
@code{f0<=} ( @i{r -- f }) gforth-0.2 ``f-zero-less-or-equal''
@end format

@findex f0<> ( @var{ r -- f  } ) gforth-0.2
@cindex @code{f0<>}
@kindex f0<>
@format
@code{f0<>} ( @i{r -- f }) gforth-0.2 ``f-zero-not-equals''
@end format

@findex f0= ( @var{ r -- f  } ) floating
@cindex @code{f0=}
@kindex f0=
@format
@code{f0=} ( @i{r -- f }) floating ``f-zero-equals''
@end format

@findex f0> ( @var{ r -- f  } ) gforth-0.2
@cindex @code{f0>}
@kindex f0>
@format
@code{f0>} ( @i{r -- f }) gforth-0.2 ``f-zero-greater-than''
@end format

@findex f0>= ( @var{ r -- f  } ) gforth-0.2
@cindex @code{f0>=}
@kindex f0>=
@format
@code{f0>=} ( @i{r -- f }) gforth-0.2 ``f-zero-greater-or-equal''
@end format


@cindex floating-point constants
IEEE754 の特別な値は、 たとえばゼロで除算することによって導出できます。
最も一般的なものは、使いやすいように浮動小数点定数として定義されています。

@findex infinity ( @var{ -- r   } ) gforth-1.0
@cindex @code{infinity}
@kindex infinity
@format
@code{infinity} ( @i{-- r  }) gforth-1.0 ``infinity''
@end format
浮動小数点数 (正の)無限大(floating point infinity)


@findex -infinity ( @var{ -- r   } ) gforth-1.0
@cindex @code{-infinity}
@kindex -infinity
@format
@code{-infinity} ( @i{-- r  }) gforth-1.0 ``-infinity''
@end format
浮動小数点数 負の無限大(-infinity)


@findex NaN ( @var{ -- r   } ) gforth-1.0
@cindex @code{NaN}
@kindex NaN
@format
@code{NaN} ( @i{-- r  }) gforth-1.0 ``NaN''
@end format
浮動小数点数 NaN(Not a Number)



@node Stack Manipulation, Memory, Arithmetic, Words
@section Stack Manipulation
@cindex stack manipulation words

@cindex floating-point stack in the standard
Gforth は、 いくつかの個別のスタックを維持します:

@cindex data stack
@cindex parameter stack
@itemize @bullet
@item
データ・スタック(「パラメータ・スタック」とも呼ばれます) -- 文字(characters)と、 セル(cells)と、
アドレス(addresses)と、 2倍長セル(double cells)  用

@cindex floating-point stack
@item
浮動小数点スタック -- 浮動小数点 (FP) 数を保持します。

@cindex return stack
@item
リターン・スタック -- コロン定義およびその他の(FP 以外の)データのリターン・アドレスを保持します。

@cindex locals stack
@item
ローカル・スタック -- ローカル変数を保持します。
@end itemize

@menu
* Data stack::
* Floating point stack::
* Return stack::
* Locals stack::
* Stack pointer manipulation::  
@end menu

@node Data stack, Floating point stack, Stack Manipulation, Stack Manipulation
@subsection Data stack
@cindex data stack manipulation words
@cindex stack manipulations words, data stack


@findex drop ( @var{ w --  } ) core
@cindex @code{drop}
@kindex drop
@format
@code{drop} ( @i{w -- }) core ``drop''
@end format

@findex nip ( @var{ w1 w2 -- w2  } ) core-ext
@cindex @code{nip}
@kindex nip
@format
@code{nip} ( @i{w1 w2 -- w2 }) core-ext ``nip''
@end format

@findex dup ( @var{ w -- w w  } ) core
@cindex @code{dup}
@kindex dup
@format
@code{dup} ( @i{w -- w w }) core ``dupe''
@end format

@findex over ( @var{ w1 w2 -- w1 w2 w1  } ) core
@cindex @code{over}
@kindex over
@format
@code{over} ( @i{w1 w2 -- w1 w2 w1 }) core ``over''
@end format

@findex third ( @var{ w1 w2 w3 -- w1 w2 w3 w1  } ) gforth-1.0
@cindex @code{third}
@kindex third
@format
@code{third} ( @i{w1 w2 w3 -- w1 w2 w3 w1 }) gforth-1.0 ``third''
@end format

@findex fourth ( @var{ w1 w2 w3 w4 -- w1 w2 w3 w4 w1  } ) gforth-1.0
@cindex @code{fourth}
@kindex fourth
@format
@code{fourth} ( @i{w1 w2 w3 w4 -- w1 w2 w3 w4 w1 }) gforth-1.0 ``fourth''
@end format

@findex tuck ( @var{ w1 w2 -- w2 w1 w2  } ) core-ext
@cindex @code{tuck}
@kindex tuck
@format
@code{tuck} ( @i{w1 w2 -- w2 w1 w2 }) core-ext ``tuck''
@end format

@findex swap ( @var{ w1 w2 -- w2 w1  } ) core
@cindex @code{swap}
@kindex swap
@format
@code{swap} ( @i{w1 w2 -- w2 w1 }) core ``swap''
@end format

@findex pick ( @var{ S:... u -- S:... w  } ) core-ext
@cindex @code{pick}
@kindex pick
@format
@code{pick} ( @i{S:... u -- S:... w }) core-ext ``pick''
@end format
実際のスタック効果は @code{ x0 ... xu u -- x0 ... xu x0 } です。

@findex rot ( @var{ w1 w2 w3 -- w2 w3 w1  } ) core
@cindex @code{rot}
@kindex rot
@format
@code{rot} ( @i{w1 w2 w3 -- w2 w3 w1 }) core ``rote''
@end format

@findex -rot ( @var{ w1 w2 w3 -- w3 w1 w2  } ) gforth-0.2
@cindex @code{-rot}
@kindex -rot
@format
@code{-rot} ( @i{w1 w2 w3 -- w3 w1 w2 }) gforth-0.2 ``not-rote''
@end format

@findex ?dup ( @var{ w -- S:... w  } ) core
@cindex @code{?dup}
@kindex ?dup
@format
@code{?dup} ( @i{w -- S:... w }) core ``question-dupe''
@end format
実際のスタック効果は次のとおりです: @code{( w -- 0 | w w )} つまり w がゼロ以外の場合、 @code{dup}
が実行されます。

@findex roll ( @var{ x0 x1 .. xn n -- x1 .. xn x0   } ) core-ext
@cindex @code{roll}
@kindex roll
@format
@code{roll} ( @i{x0 x1 .. xn n -- x1 .. xn x0  }) core-ext ``roll''
@end format

@findex 2drop ( @var{ w1 w2 --  } ) core
@cindex @code{2drop}
@kindex 2drop
@format
@code{2drop} ( @i{w1 w2 -- }) core ``two-drop''
@end format

@findex 2nip ( @var{ w1 w2 w3 w4 -- w3 w4  } ) gforth-0.2
@cindex @code{2nip}
@kindex 2nip
@format
@code{2nip} ( @i{w1 w2 w3 w4 -- w3 w4 }) gforth-0.2 ``two-nip''
@end format

@findex 2dup ( @var{ w1 w2 -- w1 w2 w1 w2  } ) core
@cindex @code{2dup}
@kindex 2dup
@format
@code{2dup} ( @i{w1 w2 -- w1 w2 w1 w2 }) core ``two-dupe''
@end format

@findex 2over ( @var{ w1 w2 w3 w4 -- w1 w2 w3 w4 w1 w2  } ) core
@cindex @code{2over}
@kindex 2over
@format
@code{2over} ( @i{w1 w2 w3 w4 -- w1 w2 w3 w4 w1 w2 }) core ``two-over''
@end format

@findex 2tuck ( @var{ w1 w2 w3 w4 -- w3 w4 w1 w2 w3 w4  } ) gforth-0.2
@cindex @code{2tuck}
@kindex 2tuck
@format
@code{2tuck} ( @i{w1 w2 w3 w4 -- w3 w4 w1 w2 w3 w4 }) gforth-0.2 ``two-tuck''
@end format

@findex 2swap ( @var{ w1 w2 w3 w4 -- w3 w4 w1 w2  } ) core
@cindex @code{2swap}
@kindex 2swap
@format
@code{2swap} ( @i{w1 w2 w3 w4 -- w3 w4 w1 w2 }) core ``two-swap''
@end format

@findex 2rot ( @var{ w1 w2 w3 w4 w5 w6 -- w3 w4 w5 w6 w1 w2  } ) double-ext
@cindex @code{2rot}
@kindex 2rot
@format
@code{2rot} ( @i{w1 w2 w3 w4 w5 w6 -- w3 w4 w5 w6 w1 w2 }) double-ext ``two-rote''
@end format



@node Floating point stack, Return stack, Data stack, Stack Manipulation
@subsection Floating point stack
@cindex floating-point stack manipulation words
@cindex stack manipulation words, floating-point stack

@findex fdrop ( @var{ r --  } ) floating
@cindex @code{fdrop}
@kindex fdrop
@format
@code{fdrop} ( @i{r -- }) floating ``f-drop''
@end format

@findex fnip ( @var{ r1 r2 -- r2  } ) gforth-0.2
@cindex @code{fnip}
@kindex fnip
@format
@code{fnip} ( @i{r1 r2 -- r2 }) gforth-0.2 ``f-nip''
@end format

@findex fdup ( @var{ r -- r r  } ) floating
@cindex @code{fdup}
@kindex fdup
@format
@code{fdup} ( @i{r -- r r }) floating ``f-dupe''
@end format

@findex fover ( @var{ r1 r2 -- r1 r2 r1  } ) floating
@cindex @code{fover}
@kindex fover
@format
@code{fover} ( @i{r1 r2 -- r1 r2 r1 }) floating ``f-over''
@end format

@findex fthird ( @var{ r1 r2 r3 -- r1 r2 r3 r1  } ) gforth-1.0
@cindex @code{fthird}
@kindex fthird
@format
@code{fthird} ( @i{r1 r2 r3 -- r1 r2 r3 r1 }) gforth-1.0 ``fthird''
@end format

@findex ffourth ( @var{ r1 r2 r3 r4 -- r1 r2 r3 r4 r1  } ) gforth-1.0
@cindex @code{ffourth}
@kindex ffourth
@format
@code{ffourth} ( @i{r1 r2 r3 r4 -- r1 r2 r3 r4 r1 }) gforth-1.0 ``ffourth''
@end format

@findex ftuck ( @var{ r1 r2 -- r2 r1 r2  } ) gforth-0.2
@cindex @code{ftuck}
@kindex ftuck
@format
@code{ftuck} ( @i{r1 r2 -- r2 r1 r2 }) gforth-0.2 ``f-tuck''
@end format

@findex fswap ( @var{ r1 r2 -- r2 r1  } ) floating
@cindex @code{fswap}
@kindex fswap
@format
@code{fswap} ( @i{r1 r2 -- r2 r1 }) floating ``f-swap''
@end format

@findex fpick ( @var{ f:... u -- f:... r  } ) gforth-0.4
@cindex @code{fpick}
@kindex fpick
@format
@code{fpick} ( @i{f:... u -- f:... r }) gforth-0.4 ``fpick''
@end format
実際のスタック効果は @code{ r0 ... ru u -- r0 ... ru r0 }

@findex frot ( @var{ r1 r2 r3 -- r2 r3 r1  } ) floating
@cindex @code{frot}
@kindex frot
@format
@code{frot} ( @i{r1 r2 r3 -- r2 r3 r1 }) floating ``f-rote''
@end format

@findex f-rot ( @var{ r1 r2 r3 -- r3 r1 r2  } ) floating
@cindex @code{f-rot}
@kindex f-rot
@format
@code{f-rot} ( @i{r1 r2 r3 -- r3 r1 r2 }) floating ``f-not-rote''
@end format



@node Return stack, Locals stack, Floating point stack, Stack Manipulation
@subsection Return stack
@cindex return stack manipulation words
@cindex stack manipulation words, return stack

@cindex return stack and locals
@cindex locals and return stack
Forth システムは、 リターン・スタックにローカル変数を保持することができます。 通常、 ローカル変数を使用すると、
リターン・スタックを明示的に使用する必要がなくなるため、 これは合理的です。 したがって、 標準に準拠したプログラムを作成する場合で、
ワード内でローカル変数を使用している場合は、
そのワード内でのリターン・スタック操作のことは忘れてください(正確なルールについては標準ドキュメントを参照してください)。

@findex >r ( @var{ w -- R:w  } ) core
@cindex @code{>r}
@kindex >r
@format
@code{>r} ( @i{w -- R:w }) core ``to-r''
@end format

@findex r> ( @var{ R:w -- w  } ) core
@cindex @code{r>}
@kindex r>
@format
@code{r>} ( @i{R:w -- w }) core ``r-from''
@end format

@findex r@@ ( @var{ -- w ; R: w -- w   } ) core
@cindex @code{r@@}
@kindex r@@
@format
@code{r@@} ( @i{-- w ; R: w -- w  }) core ``r-fetch''
@end format

@findex rdrop ( @var{ R:w --  } ) gforth-0.2
@cindex @code{rdrop}
@kindex rdrop
@format
@code{rdrop} ( @i{R:w -- }) gforth-0.2 ``rdrop''
@end format

@findex 2>r ( @var{ w1 w2 -- R:w1 R:w2  } ) core-ext
@cindex @code{2>r}
@kindex 2>r
@format
@code{2>r} ( @i{w1 w2 -- R:w1 R:w2 }) core-ext ``two-to-r''
@end format

@findex 2r> ( @var{ R:w1 R:w2 -- w1 w2  } ) core-ext
@cindex @code{2r>}
@kindex 2r>
@format
@code{2r>} ( @i{R:w1 R:w2 -- w1 w2 }) core-ext ``two-r-from''
@end format

@findex 2r@@ ( @var{ R:w1 R:w2 -- R:w1 R:w2 w1 w2  } ) core-ext
@cindex @code{2r@@}
@kindex 2r@@
@format
@code{2r@@} ( @i{R:w1 R:w2 -- R:w1 R:w2 w1 w2 }) core-ext ``two-r-fetch''
@end format

@findex 2rdrop ( @var{ R:w1 R:w2 --  } ) gforth-0.2
@cindex @code{2rdrop}
@kindex 2rdrop
@format
@code{2rdrop} ( @i{R:w1 R:w2 -- }) gforth-0.2 ``two-r-drop''
@end format

@findex n>r ( @var{ x1 .. xn n -- r:xn..x1 r:n   } ) tools-ext
@cindex @code{n>r}
@kindex n>r
@format
@code{n>r} ( @i{x1 .. xn n -- r:xn..x1 r:n  }) tools-ext ``n-to-r''
@end format

@findex nr> ( @var{ r:xn..x1 r:n -- x1 .. xn n   } ) tools-ext
@cindex @code{nr>}
@kindex nr>
@format
@code{nr>} ( @i{r:xn..x1 r:n -- x1 .. xn n  }) tools-ext ``n-r-from''
@end format


@node Locals stack, Stack pointer manipulation, Return stack, Stack Manipulation
@subsection Locals stack

Gforth で追加のローカル・スタックを使用します。  これは、 その存在理由を含めて @ref{Locals implementation}
にて説明されています。

@node Stack pointer manipulation, , Locals stack, Stack Manipulation
@subsection Stack pointer manipulation
@cindex stack pointer manipulation words

@c removed s0 r0 l0 -- they are obsolete aliases for sp0 rp0 lp0
@findex sp0 ( @var{ -- a-addr   } ) gforth-0.4
@cindex @code{sp0}
@kindex sp0
@format
@code{sp0} ( @i{-- a-addr  }) gforth-0.4 ``sp0''
@end format
ユーザー変数 -- データ・スタック・ポインタの初期値。


@findex sp@@ ( @var{ S:... -- a-addr  } ) gforth-0.2
@cindex @code{sp@@}
@kindex sp@@
@format
@code{sp@@} ( @i{S:... -- a-addr }) gforth-0.2 ``sp-fetch''
@end format

@findex sp! ( @var{ a-addr -- S:...  } ) gforth-0.2
@cindex @code{sp!}
@kindex sp!
@format
@code{sp!} ( @i{a-addr -- S:... }) gforth-0.2 ``sp-store''
@end format

@findex fp0 ( @var{ -- a-addr   } ) gforth-0.4
@cindex @code{fp0}
@kindex fp0
@format
@code{fp0} ( @i{-- a-addr  }) gforth-0.4 ``fp0''
@end format
ユーザー変数 -- 浮動小数点スタック・ポインタの初期値。


@findex fp@@ ( @var{ f:... -- f-addr  } ) gforth-0.2
@cindex @code{fp@@}
@kindex fp@@
@format
@code{fp@@} ( @i{f:... -- f-addr }) gforth-0.2 ``fp-fetch''
@end format

@findex fp! ( @var{ f-addr -- f:...  } ) gforth-0.2
@cindex @code{fp!}
@kindex fp!
@format
@code{fp!} ( @i{f-addr -- f:... }) gforth-0.2 ``fp-store''
@end format

@findex rp0 ( @var{ -- a-addr   } ) gforth-0.4
@cindex @code{rp0}
@kindex rp0
@format
@code{rp0} ( @i{-- a-addr  }) gforth-0.4 ``rp0''
@end format
ユーザー変数 -- リターン・スタック・ポインタの初期値。


@findex rp@@ ( @var{ -- a-addr  } ) gforth-0.2
@cindex @code{rp@@}
@kindex rp@@
@format
@code{rp@@} ( @i{-- a-addr }) gforth-0.2 ``rp-fetch''
@end format

@findex rp! ( @var{ a-addr --  } ) gforth-0.2
@cindex @code{rp!}
@kindex rp!
@format
@code{rp!} ( @i{a-addr -- }) gforth-0.2 ``rp-store''
@end format

@findex lp0 ( @var{ -- a-addr   } ) gforth-0.4
@cindex @code{lp0}
@kindex lp0
@format
@code{lp0} ( @i{-- a-addr  }) gforth-0.4 ``lp0''
@end format
ユーザー変数 -- ローカル・スタック・ポインタの初期値。


@findex lp@@ ( @var{ -- c-addr  } ) gforth-0.2
@cindex @code{lp@@}
@kindex lp@@
@format
@code{lp@@} ( @i{-- c-addr }) gforth-0.2 ``lp-fetch''
@end format
@i{C_addr} は、 ローカル・スタック・ポインタの現在の値です。

@findex lp! ( @var{ c-addr --  } ) gforth-internal
@cindex @code{lp!}
@kindex lp!
@format
@code{lp!} ( @i{c-addr -- }) gforth-internal ``lp-store''
@end format



@node Memory, Strings and Characters, Stack Manipulation, Words
@section Memory
@cindex memory words

@menu
* Memory model::
* Dictionary allocation::
* Heap Allocation::
* Memory Access::
* Special Memory Accesses::
* Address arithmetic::
* Memory Blocks::            
@end menu

標準 Forth のメモリ割り当てワードに加えて
@uref{https://www.complang.tuwien.ac.at/forth/garbage-collection.zip,
ガベージ・コレクター(garbage collector)} もあります。

@node Memory model, Dictionary allocation, Memory, Memory
@subsection Memory model

@c The Standard Forth description is a mess (e.g., is the heap part of
@c the dictionary?), so let's not stick to closely with it.

標準 Forth は、 Forth システムが複数のアドレス空間で構成されているとみなします。 そのうちの「データ空間」(data
space)のみを管理し、 メモリ・ワードでアクセスできます。  メモリには、 スタックと、 コード(コード空間(code
space))と呼ばれる)と、 ヘッダー(名前空間(name space)と呼ばれる)とが含まれ、 それらは必ずしもデータ空間にある必要はありません。
Gforth ではすべてがデータ空間内にありますが、 プリミティブのコードは通常読み取り専用です。

データ空間は、 いくつかの領域に分割されます。 ディクショナリ(dictionary)@footnote{「ディクショナリ」(辞書)という用語は、
従来の辞書と同じように名前を検索するために使用される、 ワード・リストやヘッダーに組み込まれた検索データ構造を指すために使用されることがあります}と、
ヒープと、 システムによって割り当てられた多数のバッファーから成ります。

Gforth は 1 つの大きなアドレス空間を提供し、 その任意のアドレス間でアドレス演算を実行できます。 ただし、
ディクショナリではヘッダーまたはコードがデータと代わる代わる出てくるため(interleaved)、 連続するデータ空間領域は、 標準 Forth
で連続していると記述されているものだけがほとんどです。 しかし、 連続する領域間であっても、
増加するアドレス方向にディクショナリが確実に割り当てられます。
ヒープ内でのメモリ割り当ての順序はプラットフォームに依存します(また、実行ごとに異なる可能性もあります)。


@node Dictionary allocation, Heap Allocation, Memory model, Memory
@subsection Dictionary allocation
@cindex reserving data space
@cindex data space - reserving some

ディクショナリの割り当てはスタック指向の割り当てスキーム(stack-oriented allocation scheme)です。 つまり、 X
の割り当てを解除したい場合は、 X の後に割り当てられたすべての割り当ても解除します。

@cindex contiguous regions in dictionary allocation
以下のワード達を使用した割り当ては連続しており、 アドレスの増加方向に向けて領域が拡張されます。
あらゆる種類のディクショナリ・メモリを割り当てる他のワード(つまり、 @code{:noname} を含む定義ワード)は、
連続領域(contiguous region)を終了し、 新しい領域を開始します。

標準 Forth では、 @code{create} されたワードのみが、 後続の連続領域の開始となるアドレスを生成することが保証されています。
特に、 @code{variable} によって割り当てられたセルが、 後続の @code{allot}
で割り当てられたメモリと連続していることは保証されません。

@code{allot} に負の引数を指定して使用すると、 メモリの割り当てを解除できます(いくつかの制限があります。 @code{allot}
を参照してください)。 大規模な割り当て解除の場合は、 @code{marker} を使用します。


@findex here ( @var{ -- addr   } ) core
@cindex @code{here}
@kindex here
@format
@code{here} ( @i{-- addr  }) core ``here''
@end format
データ空間内の次の空き位置のアドレスを返します。


@findex unused ( @var{ -- u   } ) core-ext
@cindex @code{unused}
@kindex unused
@format
@code{unused} ( @i{-- u  }) core-ext ``unused''
@end format
@code{here} でアドレス指定された領域(以降)に残っている空き領域の量をアドレス単位(address units)で返します。


@findex allot ( @var{ n --   } ) core
@cindex @code{allot}
@kindex allot
@format
@code{allot} ( @i{n --  }) core ``allot''
@end format
初期化せずに、 データ空間に @i{n} アドレス単位を予約します。 @i{n} は符号付きの数値で、 負の @i{n} を渡すとメモリが解放されます。
ANS Forth では、この方法で現在の連続領域からメモリの割り当てを解除することしかできません。  Gforth
では、この方法で名前付きワード以外のあらゆるものを割り当て解除できます。  システムはこの制限をチェックしません。


@findex ->here ( @var{ addr --   } ) gforth-1.0
@cindex @code{->here}
@kindex ->here
@format
@code{->here} ( @i{addr --  }) gforth-1.0 ``to-here''
@end format
@code{here} の値を @i{addr} に変更します。


@findex c, ( @var{ c --   } ) core
@cindex @code{c,}
@kindex c,
@format
@code{c,} ( @i{c --  }) core ``c-comma''
@end format
文字(char)用に1つのデータ空間を予約し、 その空間に @i{c} を格納します。


@findex f, ( @var{ f --   } ) gforth-0.2
@cindex @code{f,}
@kindex f,
@format
@code{f,} ( @i{f --  }) gforth-0.2 ``f,''
@end format
浮動小数点数(floating-point number)用の1つのデータ空間を予約し、 その空間に @i{f} を格納します。


@findex , ( @var{ w --   } ) core
@cindex @code{,}
@kindex ,
@format
@code{,} ( @i{w --  }) core ``comma''
@end format
セル(cell)用の1つのデータ空間を予約し、 その空間に @i{w} を格納します。


@findex 2, ( @var{ w1 w2 --   } ) gforth-0.2
@cindex @code{2,}
@kindex 2,
@format
@code{2,} ( @i{w1 w2 --  }) gforth-0.2 ``2,''
@end format
2つのセル用のデータ空間を予約し、 そこに @i{w1 w2} 格納します。 最初(低位アドレス側)に @i{w2} を格納します。


@findex w, ( @var{ w --   } ) gforth-1.0
@cindex @code{w,}
@kindex w,
@format
@code{w,} ( @i{w --  }) gforth-1.0 ``w-comma''
@end format

@findex l, ( @var{ l --   } ) gforth-1.0
@cindex @code{l,}
@kindex l,
@format
@code{l,} ( @i{l --  }) gforth-1.0 ``l-comma''
@end format

@findex x, ( @var{ x --   } ) gforth-1.0
@cindex @code{x,}
@kindex x,
@format
@code{x,} ( @i{x --  }) gforth-1.0 ``x-comma''
@end format

@findex xd, ( @var{ xd --   } ) gforth-1.0
@cindex @code{xd,}
@kindex xd,
@format
@code{xd,} ( @i{xd --  }) gforth-1.0 ``x-d-comma''
@end format

@findex A, ( @var{ addr --   } ) gforth-0.2
@cindex @code{A,}
@kindex A,
@format
@code{A,} ( @i{addr --  }) gforth-0.2 ``A,''
@end format
1 つのセル用のデータ空間を予約し、 そこに @i{addr} を格納します。  私達のクロス・コンパイラの場合には、
再配置可能なイメージに必要な型情報(type information)を提供します。 ただし、 通常では、 これは @code{,} と同等です。


@findex mem, ( @var{ addr u --   } ) gforth-0.6
@cindex @code{mem,}
@kindex mem,
@format
@code{mem,} ( @i{addr u --  }) gforth-0.6 ``mem,''
@end format

@code{save-mem-dict} ( @i{addr1 u -- addr2 u} ) \ 
訳注:文字列をhereからのディクショナリに書き込み、その(ディクショナリ上の)文字列を返します

メモリ・アクセスはアライメントする必要があります(@pxref{Address arithmetic})。 したがって、
メモリ割り当てもアライメントされるべきです。 つまり、 セルを割り当てる前に、 @code{here} をセル・アライメントする必要があります。
以下のワード達は、 @code{here} が既に指定の型のアライメントに合っている状態で無い場合は合わせます。 基本的に、
既に割り当てたのがその型のサイズの倍数であり、 かつ、 @code{here} が以前にその型のアライメントに対して合うようにしてあった場合にのみ、
その型のアライメントに対して既にすでに合っているということが言えます。

新しくワードを @code{create} した後、@code{here} は 標準 Forth では @code{align} されます(Gforth
では @code{maxalign} されます)。

@findex align ( @var{ --   } ) core
@cindex @code{align}
@kindex align
@format
@code{align} ( @i{--  }) core ``align''
@end format
データ空間ポインタがアライメントできてない場合は、 アライメントするのに十分な空間を予約します。


@findex falign ( @var{ --   } ) floating
@cindex @code{falign}
@kindex falign
@format
@code{falign} ( @i{--  }) floating ``f-align''
@end format
データ空間ポインタが浮動小数点数にアライメントされていない場合は、 アライメントするのに十分な空間を予約します。


@findex sfalign ( @var{ --   } ) floating-ext
@cindex @code{sfalign}
@kindex sfalign
@format
@code{sfalign} ( @i{--  }) floating-ext ``s-f-align''
@end format
データ空間ポインタが単精度浮動小数点数にアライメントされていない場合は、 アライメントするのに十分な空間を予約します。


@findex dfalign ( @var{ --   } ) floating-ext
@cindex @code{dfalign}
@kindex dfalign
@format
@code{dfalign} ( @i{--  }) floating-ext ``d-f-align''
@end format
データ空間ポインタが倍精度浮動小数点数にアライメントされていない場合は、 アライメントするのに十分な空間を予約します。


@findex maxalign ( @var{ --   } ) gforth-0.2
@cindex @code{maxalign}
@kindex maxalign
@format
@code{maxalign} ( @i{--  }) gforth-0.2 ``maxalign''
@end format
すべてのアライメント要件に合わせてデータ空間ポインタをアライメントします。


@findex cfalign ( @var{ --   } ) gforth-0.2
@cindex @code{cfalign}
@kindex cfalign
@format
@code{cfalign} ( @i{--  }) gforth-0.2 ``cfalign''
@end format
データ空間ポインタをコード・フィールドの要件に合わせてアライメントします(つまり、 対応する本体が maxalign された状態になるようにする)。






@node Heap Allocation, Memory Access, Dictionary allocation, Memory
@subsection Heap allocation
@cindex heap allocation
@cindex dynamic allocation of memory
@cindex memory-allocation word set

@cindex contiguous regions and heap allocation
ヒープ割り当ては、 割り当てられたメモリの割り当て解除を任意の順序でサポートします。 ディクショナリの割り当ては影響を受けません(つまり、
連続領域(contiguous region)は終了しません)。 Gforth では、 これらのワードは標準の C ライブラリ呼び出しである
malloc() や free() や realloc() を使用して実装されます。

@code{allocate} または @code{resize} の 1 回の呼び出しによって生成されるメモリ領域は、 内部的に連続しています。
このような領域と他の領域(ヒープから割り当てられた他の領域を含む)との間には連続性はありません。

@findex allocate ( @var{ u -- a_addr wior   } ) memory
@cindex @code{allocate}
@kindex allocate
@format
@code{allocate} ( @i{u -- a_addr wior  }) memory ``allocate''
@end format
連続したデータ空間を @i{u} アドレス単位分割り当てます。 データ空間の初期内容は未定義です。 割り当てが成功した場合、 @i{a-addr}
は割り当てられた領域の開始アドレスで、 @i{wior} は 0 になります。 割り当てが失敗した場合、 @i{a-addr} は未定義で、
@i{wior} ゼロ以外の I/O 結果コードです。


@findex free ( @var{ a_addr -- wior   } ) memory
@cindex @code{free}
@kindex free
@format
@code{free} ( @i{a_addr -- wior  }) memory ``free''
@end format
@i{a-addr} で始まるデータ空間の領域をシステムに返します。  領域は元々 @code{allocate} または @code{resize}
を使用して取得されている必要があります。 操作が成功した場合、 @i{wior} は 0 になります。 操作が失敗した場合、 @i{wior}
はゼロ以外の I/O 結果コードになります。


@findex resize ( @var{ a_addr1 u -- a_addr2 wior   } ) memory
@cindex @code{resize}
@kindex resize
@format
@code{resize} ( @i{a_addr1 u -- a_addr2 wior  }) memory ``resize''
@end format
@i{a-addr1} に割り当てられた領域のサイズを @i{u} アドレス単位に変更します。 但し内容を別の領域に移動する可能性があります。
@i{a-addr2} は、 結果の領域のアドレスです。  操作が成功した場合、 @i{wior} は 0 になります。 操作が失敗した場合、
@i{wior} はゼロ以外の I/O 結果コードになります。 @i{a-addr1} が 0 の場合、 Gforth の (非標準の )
@code{resize} は @i{u} アドレス単位の割り当てを行います。



以下のワード達はメモリ・ブロックを扱うのに役立ちます:

@findex save-mem ( @var{ addr1 u -- addr2 u   } ) gforth-0.2
@cindex @code{save-mem}
@kindex save-mem
@format
@code{save-mem} ( @i{addr1 u -- addr2 u  }) gforth-0.2 ``save-mem''
@end format
指定のメモリ・ブロックをヒープ内で新しく割り当てられた領域にコピーします。


@findex free-mem-var ( @var{ addr --   } ) gforth-experimental
@cindex @code{free-mem-var}
@kindex free-mem-var
@format
@code{free-mem-var} ( @i{addr --  }) gforth-experimental ``free-mem-var''
@end format
addr は、 メモリ範囲のアドレスとサイズを含む 2variable のアドレスです。 これはメモリを解放し、 2variable をクリアします。


@findex extend-mem ( @var{ addr1 u1 u -- addr addr2 u2   } ) gforth-experimental
@cindex @code{extend-mem}
@kindex extend-mem
@format
@code{extend-mem} ( @i{addr1 u1 u -- addr addr2 u2  }) gforth-experimental ``extend-mem''
@end format
u (アドレス単位)によってヒープから割り当てられたメモリ・ブロック addr1 u1 を拡張します。  (おそらく再割り当てされた)開始アドレスは
addr2 で、 その合計長さは u2 で、 拡張部分の開始アドレスは addr です(訳注: 例えば元々長さ10のブロックを5拡張すると( addr1
10 5 -- addr2+10 addr2 10+5))




$tring ワード群は、 メモリ・ブロックの処理にも使用できます。 @xref{＄tring words} (訳注: $tring (ダラー
tring)と String (エス string) とあることに注意)

拡張可能なメモリ・バッファーの場合は、 $trings または以下のワード群を使用できます。  @code{adjust-buffer}
で管理されるバッファーに割り当てられたメモリは縮小できないため、
これまでに確認された最大サイズよりも小さいサイズにバッファーを調整(adjust)するときはヒープ管理のオーバーヘッドは発生しません。

@findex buffer% ( @var{-- u1 u2  } ) gforth-experimental
@cindex @code{buffer%}
@kindex buffer%
@format
@code{buffer%} ( @i{-- u1 u2  }) gforth-experimental ``buffer%''
@end format
@i{u1} は アライメント(alignment)、 @i{u2} は バッファー・デスクリプタのサイズです。


@findex init-buffer ( @var{ addr --   } ) gforth-experimental
@cindex @code{init-buffer}
@kindex init-buffer
@format
@code{init-buffer} ( @i{addr --  }) gforth-experimental ``init-buffer''
@end format

@findex adjust-buffer ( @var{ u addr --   } ) gforth-experimental
@cindex @code{adjust-buffer}
@kindex adjust-buffer
@format
@code{adjust-buffer} ( @i{u addr --  }) gforth-experimental ``adjust-buffer''
@end format
addr の buffer% を長さ u に調整します。 これにより、 割り当てられた領域が拡大する可能性がありますが、
決して縮小されることはありません。



@code{2@@} を使用すると、 このようなバッファーの現在のアドレスと長さを取得できます。

典型的な使い方:

@example
create mybuf  buffer% %size allot  mybuf init-buffer
s" frobnicate" mybuf adjust-buffer  mybuf 2@@ move
mybuf 2@@ type
s" foo"        mybuf adjust-buffer  mybuf 2@@ move
mybuf 2@@ type
@end example


@node Memory Access, Special Memory Accesses, Heap Allocation, Memory
@subsection Memory Access
@cindex memory access words

@findex @@ ( @var{ a-addr -- w  } ) core
@cindex @code{@@}
@kindex @@
@format
@code{@@} ( @i{a-addr -- w }) core ``fetch''
@end format
@i{a_addr} に保存されているセルを @i{w} に取得します。

@findex ! ( @var{ w a-addr --  } ) core
@cindex @code{!}
@kindex !
@format
@code{!} ( @i{w a-addr -- }) core ``store''
@end format
@i{w} を @i{a-addr} のセルに格納します。

@findex +! ( @var{ n a-addr --  } ) core
@cindex @code{+!}
@kindex +!
@format
@code{+!} ( @i{n a-addr -- }) core ``plus-store''
@end format
@i{a-addr} のセルに @i{n} を加算します。

@findex c@@ ( @var{ c-addr -- c  } ) core
@cindex @code{c@@}
@kindex c@@
@format
@code{c@@} ( @i{c-addr -- c }) core ``c-fetch''
@end format
@i{c_addr} に保存されている文字(char) を @i{c} に取得します。

@findex c! ( @var{ c c-addr --  } ) core
@cindex @code{c!}
@kindex c!
@format
@code{c!} ( @i{c c-addr -- }) core ``c-store''
@end format
@i{c} を @i{c-addr} の char に格納します。

@findex 2@@ ( @var{ a-addr -- w1 w2  } ) core
@cindex @code{2@@}
@kindex 2@@
@format
@code{2@@} ( @i{a-addr -- w1 w2 }) core ``two-fetch''
@end format
@i{w2} は @i{a-addr} に格納されているセルの内容、 @i{w1} はその次のセルの内容です。

@findex 2! ( @var{ w1 w2 a-addr --  } ) core
@cindex @code{2!}
@kindex 2!
@format
@code{2!} ( @i{w1 w2 a-addr -- }) core ``two-store''
@end format
@i{w2} を @i{c-addr} のセルに格納し、 @i{w1} をその次のセルに格納します。

@findex f@@ ( @var{ f-addr -- r  } ) floating
@cindex @code{f@@}
@kindex f@@
@format
@code{f@@} ( @i{f-addr -- r }) floating ``f-fetch''
@end format
アドレス @i{f-addr} の浮動小数点数を @i{r} に取得します。

@findex f! ( @var{ r f-addr --  } ) floating
@cindex @code{f!}
@kindex f!
@format
@code{f!} ( @i{r f-addr -- }) floating ``f-store''
@end format
@i{r} をアドレス @i{f-addr} の浮動小数点数として格納します。

@findex sf@@ ( @var{ sf-addr -- r  } ) floating-ext
@cindex @code{sf@@}
@kindex sf@@
@format
@code{sf@@} ( @i{sf-addr -- r }) floating-ext ``s-f-fetch''
@end format
アドレス @i{sf-addr} から 単精度 IEEE 浮動小数点値を @i{r} に取得します。

@findex sf! ( @var{ r sf-addr --  } ) floating-ext
@cindex @code{sf!}
@kindex sf!
@format
@code{sf!} ( @i{r sf-addr -- }) floating-ext ``s-f-store''
@end format
@i{r} を単精度 IEEE 浮動小数点値としてアドレス @i{sf-addr} に格納します。

@findex df@@ ( @var{ df-addr -- r  } ) floating-ext
@cindex @code{df@@}
@kindex df@@
@format
@code{df@@} ( @i{df-addr -- r }) floating-ext ``d-f-fetch''
@end format
アドレス @i{df-addr} からの倍精度 IEEE 浮動小数点値を @i{r} に取得します。

@findex df! ( @var{ r df-addr --  } ) floating-ext
@cindex @code{df!}
@kindex df!
@format
@code{df!} ( @i{r df-addr -- }) floating-ext ``d-f-store''
@end format
@i{r} を 倍精度 IEEE 浮動小数点値としてアドレス @i{df-addr} からに保存します。


@node Special Memory Accesses, Address arithmetic, Memory Access, Memory
@subsection Special Memory Accesses
@cindex byte order
@cindex big-endian
@cindex little-endian
@cindex sign extension
@cindex unaligned memory access

このセクションでは、 他のソフトウェアや他のコンピュータと通信する際に役立つメモリ・アクセスについて説明します。  これは、
アクセスが特定のビット幅であり(Gforth のセル幅とは独立)、 自然な並びでない可能性があり、 通常、 Gforth
が実行されるシステムのネイティブなバイト順序(バイト・オーダー)とは異なる可能性がある特定のバイト順序を持つことを意味します。

私達は以下のプレフィックスを使います:

@table @code
@item c
8ビット(文字;character)
@item w
16ビット
@item l
32ビット
@item x
64 ビットを 1 つのセルとして表現
@item xd
64 ビットを 2 つのセルとして表現
@end table

@code{x} プレフィックスのワードは 32 ビット・システムでは正しく機能しないため、 32
ビット・システムに移植することを目的としたコードの場合は、 @code{xd} プレフィックスのワードを使用する必要があります。  注意:
@code{xd} プレフィックスのワードは 64 ビット・システムでも動作することに注意してください。 64 ビット・システムでは、
上位のセルは単なる 0 (符号なし値の場合)、 または下位のセルの符号拡張です。

以下のメモリ・アクセス・ワード群はすべて、 任意の(非)アライメントされたアドレスで動作します(一部のハードウェアでアライメントが必要な
@code{@@} や @code{!} や @code{f@@} や @code{f!} とは異なります)。

@findex w@@ ( @var{ c-addr -- u  } ) gforth-0.5
@cindex @code{w@@}
@kindex w@@
@format
@code{w@@} ( @i{c-addr -- u }) gforth-0.5 ``w-fetch''
@end format
@i{u} は @i{c_addr} に格納されているゼロ拡張された 16 ビット値(zero-extended 16-bit value)です。

@findex w! ( @var{ w c-addr --  } ) gforth-0.7
@cindex @code{w!}
@kindex w!
@format
@code{w!} ( @i{w c-addr -- }) gforth-0.7 ``w-store''
@end format
@i{w} の下位 16 ビットを @i{c_addr} に格納します。

@findex l@@ ( @var{ c-addr -- u  } ) gforth-0.7
@cindex @code{l@@}
@kindex l@@
@format
@code{l@@} ( @i{c-addr -- u }) gforth-0.7 ``l-fetch''
@end format
@i{u} は、 @i{c_addr} に格納されているゼロ拡張された 32 ビット値(zero-extended 32-bit value)です。

@findex l! ( @var{ w c-addr --  } ) gforth-0.7
@cindex @code{l!}
@kindex l!
@format
@code{l!} ( @i{w c-addr -- }) gforth-0.7 ``l-store''
@end format
@i{w} の下位 32 ビットを @i{c_addr} に格納します。

@findex x@@ ( @var{ c-addr -- u  } ) gforth-1.0
@cindex @code{x@@}
@kindex x@@
@format
@code{x@@} ( @i{c-addr -- u }) gforth-1.0 ``x-fetch''
@end format
@i{u} は、 @i{c_addr} に格納されているゼロ拡張された 64 ビット値です。

@findex x! ( @var{ w c-addr --  } ) gforth-1.0
@cindex @code{x!}
@kindex x!
@format
@code{x!} ( @i{w c-addr -- }) gforth-1.0 ``x-store''
@end format
@i{w} の下位 64 ビットを @i{c_addr} に格納します。

@findex xd@@ ( @var{ c-addr -- ud  } ) gforth-1.0
@cindex @code{xd@@}
@kindex xd@@
@format
@code{xd@@} ( @i{c-addr -- ud }) gforth-1.0 ``x-d-fetch''
@end format
@i{ud} は、 @i{c_addr} に格納されているゼロ拡張された 64 ビット値です。

@findex xd! ( @var{ ud c-addr --  } ) gforth-1.0
@cindex @code{xd!}
@kindex xd!
@format
@code{xd!} ( @i{ud c-addr -- }) gforth-1.0 ``x-d-store''
@end format
@i{ud} の下位 64 ビットを @i{c_addr} に格納します。


特定のバイト順序(byte order)でアクセスする場合は、 取得直後(符号拡張の前)、 または格納の直前にバイト順序調整を行う必要があります。
これらのバイト順調整ワードの結果は常にゼロ拡張(zero-extended)されます。

@findex wbe ( @var{ u1 -- u2   } ) gforth-1.0
@cindex @code{wbe}
@kindex wbe
@format
@code{wbe} ( @i{u1 -- u2  }) gforth-1.0 ``wbe''
@end format
@i{u1} の 16 ビット値をネイティブ・バイト順からビッグ・エンディアンに、
またはビッグ・エンディアンからネイティブ・バイト順に変換します(両方は同一の操作です)


@findex wle ( @var{ u1 -- u2   } ) gforth-1.0
@cindex @code{wle}
@kindex wle
@format
@code{wle} ( @i{u1 -- u2  }) gforth-1.0 ``wle''
@end format
@i{u1} の 16 ビット値をネイティブ・バイト順からリトル・エンディアンに、
またはリトル・エンディアンからネイティブ・バイト順に変換します(両方の操作は同一の操作です)


@findex lbe ( @var{ u1 -- u2   } ) gforth-1.0
@cindex @code{lbe}
@kindex lbe
@format
@code{lbe} ( @i{u1 -- u2  }) gforth-1.0 ``lbe''
@end format
@i{u1} の 32 ビット値をネイティブ・バイト順からビッグ・エンディアンに、
またはビッグ・エンディアンからネイティブ・バイト順に変換します(両方は同一の操作です)


@findex lle ( @var{ u1 -- u2   } ) gforth-1.0
@cindex @code{lle}
@kindex lle
@format
@code{lle} ( @i{u1 -- u2  }) gforth-1.0 ``lle''
@end format
@i{u1} の 32 ビット値をネイティブ・バイト順からリトル・エンディアンに、
またはリトル・エンディアンからネイティブ・バイト順に変換します(両方は同一の操作です)


@findex xbe ( @var{ u1 -- u2   } ) gforth-1.0
@cindex @code{xbe}
@kindex xbe
@format
@code{xbe} ( @i{u1 -- u2  }) gforth-1.0 ``xbe''
@end format
@i{u1} の 64 ビット値をネイティブ・バイト順からビッグ・エンディアンに、
またはビッグ・エンディアンからネイティブ・バイト順に変換します(両方は同一の操作です)


@findex xle ( @var{ u1 -- u2   } ) gforth-1.0
@cindex @code{xle}
@kindex xle
@format
@code{xle} ( @i{u1 -- u2  }) gforth-1.0 ``xle''
@end format
@i{u1} の 64 ビット値をネイティブ・バイト順からリトル・エンディアンに、
またはリトル・エンディアンからネイティブ・バイト順に変換します(両方は同一の操作です)


@findex xdbe ( @var{ ud1 -- ud2   } ) gforth-1.0
@cindex @code{xdbe}
@kindex xdbe
@format
@code{xdbe} ( @i{ud1 -- ud2  }) gforth-1.0 ``xdbe''
@end format
@i{ud1} の 64 ビット値をネイティブ・バイト順からビッグ・エンディアンに、
またはビッグ・エンディアンからネイティブ・バイト順に変換します(両方は同一の操作です)


@findex xdle ( @var{ ud1 -- ud2   } ) gforth-1.0
@cindex @code{xdle}
@kindex xdle
@format
@code{xdle} ( @i{ud1 -- ud2  }) gforth-1.0 ``xdle''
@end format
@i{ud1} の 64 ビット値をネイティブ・バイト順からリトル・エンディアンに、
またはリトル・エンディアンからネイティブ・バイト順に変換します(両方は同一の操作です)



特定のバイト順序での符号付きでの取得の場合、 符号なし取得とバイト順序修正の後に符号拡張ワードを実行する必要があります:

@findex c>s ( @var{ x -- n  } ) gforth-1.0
@cindex @code{c>s}
@kindex c>s
@format
@code{c>s} ( @i{x -- n }) gforth-1.0 ``c-to-s''
@end format
@i{x} の 8 ビット値をセル @i{n} に符号拡張します。

@findex w>s ( @var{ x -- n  } ) gforth-1.0
@cindex @code{w>s}
@kindex w>s
@format
@code{w>s} ( @i{x -- n }) gforth-1.0 ``w-to-s''
@end format
@i{x} の 16 ビット値をセル @i{n} に符号拡張します。

@findex l>s ( @var{ x -- n  } ) gforth-1.0
@cindex @code{l>s}
@kindex l>s
@format
@code{l>s} ( @i{x -- n }) gforth-1.0 ``l-to-s''
@end format
@i{x} の 32 ビット値をセル @i{n} に符号拡張します。

@findex x>s ( @var{ x -- n   } ) gforth-1.0
@cindex @code{x>s}
@kindex x>s
@format
@code{x>s} ( @i{x -- n  }) gforth-1.0 ``x>s''
@end format
@i{x} の 64 ビット値をセル @i{n} に符号拡張します。


@findex xd>s ( @var{ xd -- d   } ) gforth-1.0
@cindex @code{xd>s}
@kindex xd>s
@format
@code{xd>s} ( @i{xd -- d  }) gforth-1.0 ``xd>s''
@end format
@var{xd} の 64 ビット値を 2倍長セル @var{d} に符号拡張します。



これら全般を、 以下のような流れで使います:

@example
w@@ wbe w>s   \ 16ビット 非アライメント 符号付き ビッグ・エンディアン を取得し、
>r lle r> l!  \ 32-bit 非アライメント リトル・エンディアン として 格納
@end example

@node Address arithmetic, Memory Blocks, Special Memory Accesses, Memory
@subsection Address arithmetic
@cindex address arithmetic words

アドレス演算は、 配列やレコード(@pxref{Structures})やオブジェクト(@pxref{Object-oriented
Forth})のようなデータ構造を構築可能な基礎基盤です。

@cindex address unit
@cindex au (address unit)
標準 Forth では、 データ型のサイズは規定されていません。 代わりに、 サイズを計算したりアドレス演算を行うための多数のワードが提供されます。
アドレス演算はアドレス単位(au;Address Unit, aus;Address UnitS)で実行されます。 ほとんどのシステムでは、
1アドレス単位は 1 バイトです。 注意: 1 つの文字に複数 au が含まれる可能性があるため、 @code{chars}
は何もしない(noop)訳ではないことに注意してください(noop であるプラットフォームでは、 @code{chars} は何もコンパイルしません)。

基本的なアドレス算術ワードは @code{+} と @code{-} です。 たとえば、 セルのアドレスがわかっている場合、 @code{1 cells
+} を実行すると、 次のセルのアドレスがわかります。

@cindex alignment of addresses for types
標準 Forth では、 特定の型のアドレスをアライメントするためのワードも定義されています。 多くのコンピュータでは、
特定のデータ型へのアクセスは特定のアドレスでのみ行われる必要があります。 たとえば、 セルは 4 で割り切れるアドレスでのみアクセスできます。
マシンが非アライメント・アクセスを許可する場合でも、 通常はアライメント・アクセスの方が高速に実行できます。 

パフォーマンス重視で行く場合: 通常、 アライメント操作はデータ構造の定義中にのみ必要であり、
(より頻繁な)データ構造へのアクセス中には必要ありません。

標準 Forth では、 文字のアドレス・アライメント用ワードは定義されていません。 Forth-2012
では、すべてのアドレスが文字単位でアライメントされています(all addresses are character-aligned)

@cindex @code{CREATE} and alignment
標準 Forth は、 @code{CREATE} されたワードによって返されるアドレスがセル・アライメントされていることを保証します。
さらに、Gforth は、 こ​​れらのアドレスがあらゆる目的に合わせてアライメント済みであることを保証します(addresses are
aligned for all purposes)。

注意: 標準の Forth ワード @code{char} はアドレス演算とは何の関係もないことに注意してください。


@findex chars ( @var{ n1 -- n2   } ) core
@cindex @code{chars}
@kindex chars
@format
@code{chars} ( @i{n1 -- n2  }) core ``chars''
@end format
@i{n1} 文字(char)が何アドレス単位になるかを @i{n2} に返します。


@findex char+ ( @var{ c-addr1 -- c-addr2  } ) core
@cindex @code{char+}
@kindex char+
@format
@code{char+} ( @i{c-addr1 -- c-addr2 }) core ``char-plus''
@end format
@code{1 chars +}.

@findex char- ( @var{ c-addr1 -- c-addr2   } ) gforth-0.7
@cindex @code{char-}
@kindex char-
@format
@code{char-} ( @i{c-addr1 -- c-addr2  }) gforth-0.7 ``char-minus''
@end format

@findex cells ( @var{ n1 -- n2  } ) core
@cindex @code{cells}
@kindex cells
@format
@code{cells} ( @i{n1 -- n2 }) core ``cells''
@end format
 @i{n1} 個のセルのアドレス単位の数を @i{n2} に取得します。

@findex cell+ ( @var{ a-addr1 -- a-addr2  } ) core
@cindex @code{cell+}
@kindex cell+
@format
@code{cell+} ( @i{a-addr1 -- a-addr2 }) core ``cell-plus''
@end format
@code{1 cells +}

@findex cell- ( @var{ a-addr1 -- a-addr2  } ) core
@cindex @code{cell-}
@kindex cell-
@format
@code{cell-} ( @i{a-addr1 -- a-addr2 }) core ``cell-minus''
@end format
@code{1 cells -}

@findex cell/ ( @var{ n1 -- n2  } ) gforth-1.0
@cindex @code{cell/}
@kindex cell/
@format
@code{cell/} ( @i{n1 -- n2 }) gforth-1.0 ``cell-divide''
@end format
@i{n1} 個のアドレス単位の幅の中に入れられるセルの数が @i{n2} です

@findex cell ( @var{ -- u   } ) gforth-0.2
@cindex @code{cell}
@kindex cell
@format
@code{cell} ( @i{-- u  }) gforth-0.2 ``cell''
@end format
定数 -- @code{1 cells}


@findex aligned ( @var{ c-addr -- a-addr  } ) core
@cindex @code{aligned}
@kindex aligned
@format
@code{aligned} ( @i{c-addr -- a-addr }) core ``aligned''
@end format
 @i{a-addr} は、 @i{c-addr} 以上の最初にアライメントされたアドレスです。

@findex floats ( @var{ n1 -- n2  } ) floating
@cindex @code{floats}
@kindex floats
@format
@code{floats} ( @i{n1 -- n2 }) floating ``floats''
@end format
@i{n2} は @i{n1} 個の浮動小数点数(float)のアドレスユニットの数です。

@findex float+ ( @var{ f-addr1 -- f-addr2  } ) floating
@cindex @code{float+}
@kindex float+
@format
@code{float+} ( @i{f-addr1 -- f-addr2 }) floating ``float-plus''
@end format
@code{1 floats +}.

@findex float ( @var{ -- u   } ) gforth-0.3
@cindex @code{float}
@kindex float
@format
@code{float} ( @i{-- u  }) gforth-0.3 ``float''
@end format
定数 -- 浮動小数点数に対応するアドレスユニットの数。


@findex float/ ( @var{ n1 -- n2  } ) gforth-1.0
@cindex @code{float/}
@kindex float/
@format
@code{float/} ( @i{n1 -- n2 }) gforth-1.0 ``float-divide''
@end format

@findex faligned ( @var{ c-addr -- f-addr  } ) floating
@cindex @code{faligned}
@kindex faligned
@format
@code{faligned} ( @i{c-addr -- f-addr }) floating ``f-aligned''
@end format
 @i{f-addr} は、@i{c-addr} 以上の、 浮動小数点数にアライメントされた最初のアドレスです。

@findex sfloats ( @var{ n1 -- n2  } ) floating-ext
@cindex @code{sfloats}
@kindex sfloats
@format
@code{sfloats} ( @i{n1 -- n2 }) floating-ext ``s-floats''
@end format
@i{n2} は、 @i{n1} 個の単精度 IEEE 浮動小数点数のアドレス単位の数です。

@findex sfloat+ ( @var{ sf-addr1 -- sf-addr2   } ) floating-ext
@cindex @code{sfloat+}
@kindex sfloat+
@format
@code{sfloat+} ( @i{sf-addr1 -- sf-addr2  }) floating-ext ``s-float-plus''
@end format
@code{1 sfloats +}.


@findex sfloat/ ( @var{ n1 -- n2  } ) gforth-1.0
@cindex @code{sfloat/}
@kindex sfloat/
@format
@code{sfloat/} ( @i{n1 -- n2 }) gforth-1.0 ``dfloat-divide''
@end format

@findex sfaligned ( @var{ c-addr -- sf-addr  } ) floating-ext
@cindex @code{sfaligned}
@kindex sfaligned
@format
@code{sfaligned} ( @i{c-addr -- sf-addr }) floating-ext ``s-f-aligned''
@end format
@i{sf-addr} は、 @i{c-addr} 以上の、 最初の単精度浮動小数点数アライメント・アドレスです。

@findex dfloats ( @var{ n1 -- n2  } ) floating-ext
@cindex @code{dfloats}
@kindex dfloats
@format
@code{dfloats} ( @i{n1 -- n2 }) floating-ext ``d-floats''
@end format
@i{n2} は、 @i{n1} 個の倍精度 IEEE 浮動小数点数のアドレス単位の数です。

@findex dfloat+ ( @var{ df-addr1 -- df-addr2   } ) floating-ext
@cindex @code{dfloat+}
@kindex dfloat+
@format
@code{dfloat+} ( @i{df-addr1 -- df-addr2  }) floating-ext ``d-float-plus''
@end format
@code{1 dfloats +}.


@findex dfloat/ ( @var{ n1 -- n2  } ) gforth-1.0
@cindex @code{dfloat/}
@kindex dfloat/
@format
@code{dfloat/} ( @i{n1 -- n2 }) gforth-1.0 ``sfloat-divide''
@end format

@findex dfaligned ( @var{ c-addr -- df-addr  } ) floating-ext
@cindex @code{dfaligned}
@kindex dfaligned
@format
@code{dfaligned} ( @i{c-addr -- df-addr }) floating-ext ``d-f-aligned''
@end format
@i{df-addr} は、 @i{c-addr} 以上の、 最初の倍精度浮動小数点数アライメント・アドレスです。

@findex maxaligned ( @var{ addr1 -- addr2   } ) gforth-0.2
@cindex @code{maxaligned}
@kindex maxaligned
@format
@code{maxaligned} ( @i{addr1 -- addr2  }) gforth-0.2 ``maxaligned''
@end format
@i{addr2} は、 すべてのアライメント制限を満たす @i{addr1} 以上の最初のアドレスです。


@findex cfaligned ( @var{ addr1 -- addr2   } ) gforth-0.2
@cindex @code{cfaligned}
@kindex cfaligned
@format
@code{cfaligned} ( @i{addr1 -- addr2  }) gforth-0.2 ``cfaligned''
@end format
@i{addr2} は、 @i{addr1} 以上の最初のアドレスで、 コード・フィールド用にアライメントされています(つまり、
対応する本体(body)が maxalign されるようにします)。


@findex *aligned ( @var{ addr1 n -- addr2   } ) gforth-1.0
@cindex @code{*aligned}
@kindex *aligned
@format
@code{*aligned} ( @i{addr1 n -- addr2  }) gforth-1.0 ``*aligned''
@end format
@var{addr1} 以上で、 @var{n} でアライメントされた(@var{n} で割り切れる)アドレスを @var{addr2} に返します。


@findex *align ( @var{ n --   } ) gforth-1.0
@cindex @code{*align}
@kindex *align
@format
@code{*align} ( @i{n --  }) gforth-1.0 ``*align''
@end format
@code{here} を @var{n} で割り切れるアドレスにアライメントします。


@findex waligned ( @var{ addr -- addr'   } ) gforth-1.0
@cindex @code{waligned}
@kindex waligned
@format
@code{waligned} ( @i{addr -- addr'  }) gforth-1.0 ``waligned''
@end format
@i{Addr'} は、 @i{addr} 以上、かつ、次の偶数アドレスです。


@findex walign ( @var{ --   } ) gforth-1.0
@cindex @code{walign}
@kindex walign
@format
@code{walign} ( @i{--  }) gforth-1.0 ``walign''
@end format
@code{here} を 偶数アドレスにアライメントします。


@findex laligned ( @var{ addr -- addr'   } ) gforth-1.0
@cindex @code{laligned}
@kindex laligned
@format
@code{laligned} ( @i{addr -- addr'  }) gforth-1.0 ``laligned''
@end format
@i{Addr'} は、 @i{addr} 以上、 かつ、 4 で割り切れるアドレスです。


@findex lalign ( @var{ --   } ) gforth-1.0
@cindex @code{lalign}
@kindex lalign
@format
@code{lalign} ( @i{--  }) gforth-1.0 ``lalign''
@end format
@code{here} を 4 で割り切れるアドレスにアライメントします。


@findex xaligned ( @var{ addr -- addr'   } ) gforth-1.0
@cindex @code{xaligned}
@kindex xaligned
@format
@code{xaligned} ( @i{addr -- addr'  }) gforth-1.0 ``xaligned''
@end format
@i{Addr'} を @i{addr} 以上、 かつ、 8 で割り切れるアドレスにします。


@findex xalign ( @var{ --   } ) gforth-1.0
@cindex @code{xalign}
@kindex xalign
@format
@code{xalign} ( @i{--  }) gforth-1.0 ``xalign''
@end format
@code{here} を 8 で割り切れるアドレスにアライメントします。



環境クエリ @code{address-unit-bits} (@pxref{Environmental Queries}) と、 以下のワード群は、
バイトアドレスを持たないマシン(non-byte-addressed machines)に移植可能なソフトウェアを作成したい人に役立つかもしれません。

@findex /w ( @var{ -- u   } ) gforth-0.7
@cindex @code{/w}
@kindex /w
@format
@code{/w} ( @i{-- u  }) gforth-0.7 ``slash-w''
@end format
16ビット値に必要なアドレス単位


@findex /l ( @var{ -- u   } ) gforth-0.7
@cindex @code{/l}
@kindex /l
@format
@code{/l} ( @i{-- u  }) gforth-0.7 ``slash-l''
@end format
32ビット値に必要なアドレス単位


@findex /x ( @var{ -- u   } ) gforth-1.0
@cindex @code{/x}
@kindex /x
@format
@code{/x} ( @i{-- u  }) gforth-1.0 ``slash-x''
@end format
64ビット値に必要なアドレス単位



@node Memory Blocks, , Address arithmetic, Memory
@subsection Memory Blocks
@cindex memory block words
@cindex character strings - moving and copying

メモリ・ブロックは多くの場合、 文字の連なり(character strings)を表します。 文字の連なりをメモリに保存する方法については、
@ref{String representations} を参照してください。  他の連なり処理ワード(string-processing
words)については、 @ref{Displaying characters and strings} を参照してください。

これらのワードのいくつかは、 アドレス単位ブロック(address unit blocks)で機能します。  その場合、
文字の連なり(character strings)を扱う際には通常、 ワードの前に @code{CHARS} を挿入する必要があります。
ほとんどのワードは文字ブロック(character blocks)で機能し、 文字アライメント・アドレス(char-aligned
address)を期待します。

重複するメモリ領域間で文字達をコピーする場合は、 @code{move} を使用します。  @code{cmove} と @code{cmove>}
は、 適切に実装された @code{move} よりも遅くなる傾向があります。

@findex move ( @var{ c-from c-to ucount --  } ) core
@cindex @code{move}
@kindex move
@format
@code{move} ( @i{c-from c-to ucount -- }) core ``move''
@end format
@i{c-from} アドレスにある @i{ucount} 個のcharの内容を @i{c-to} アドレスにコピーします。 @code{move}
は、 2 つの領域が重なっている場合でも正しく機能します。

@findex cmove ( @var{ c-from c-to u --  } ) string
@cindex @code{cmove}
@kindex cmove
@format
@code{cmove} ( @i{c-from c-to u -- }) string ``c-move''
@end format
データ空間で @i{c-from} アドレスから @i{ucount} 個のcharの内容を @i{c-to} アドレスにコピーします。コピーは、  1
@code{char} ずつコピーしながら下位アドレスから上位アドレス方向へ進めます。 つまり、 重複領域の場合、 @i{c-to} <=
@i{c-from} であれば安全です。

@findex cmove> ( @var{ c-from c-to u --  } ) string
@cindex @code{cmove>}
@kindex cmove>
@format
@code{cmove>} ( @i{c-from c-to u -- }) string ``c-move-up''
@end format
データ空間で @i{c-from} アドレスから @i{ucount} 個のcharの内容を @i{c-to} アドレスにコピーします。 コピーは、 1
@code{char} ずつコピーし上位アドレスから下位アドレス方向に進みます。 つまり、 重複領域の場合、 @i{c-to} >=
@i{c-from} であれば安全です。

@findex fill ( @var{ c-addr u c --  } ) core
@cindex @code{fill}
@kindex fill
@format
@code{fill} ( @i{c-addr u c -- }) core ``fill''
@end format
@i{c} を @i{c-addr} から @i{u} 個char単位で格納します。

@findex erase ( @var{ addr u --   } ) core-ext
@cindex @code{erase}
@kindex erase
@format
@code{erase} ( @i{addr u --  }) core-ext ``erase''
@end format
@i{addr} から始まる @i{u} aus のすべてのビットをクリアします。


@findex blank ( @var{ c-addr u --   } ) string
@cindex @code{blank}
@kindex blank
@format
@code{blank} ( @i{c-addr u --  }) string ``blank''
@end format
スペース文字を @i{c-addr} アドレスから @i{u} 個char単位で格納します。


@findex insert ( @var{ string length buffer size --   } ) gforth-0.7
@cindex @code{insert}
@kindex insert
@format
@code{insert} ( @i{string length buffer size --  }) gforth-0.7 ``insert''
@end format
バッファーの先頭に文字列を挿入します。 残りのバイトは後ろにずらされます(訳注: sizeを超えた分は捨てられます)。


@findex delete ( @var{ buffer size u --   } ) gforth-0.7
@cindex @code{delete}
@kindex delete
@format
@code{delete} ( @i{buffer size u --  }) gforth-0.7 ``delete''
@end format
最初の @var{u} バイトをバッファーから削除し、 その分前にずらして、 残りの最後のバイトを空白(0x20)で埋めます。


@findex compare ( @var{ c-addr1 u1 c-addr2 u2 -- n  } ) string
@cindex @code{compare}
@kindex compare
@format
@code{compare} ( @i{c-addr1 u1 c-addr2 u2 -- n }) string ``compare''
@end format
連なり(string)内のバイトの値に基づいて、 2
つの連なり(strings)を(英語の)辞書順(lexicographically)に比較します(つまり、 英大文字と小文字が区別され、
ロケール固有の照合順序は無視されます)。 2つが等しい場合、 @i{n} は 0 です。 最初の連なり(string)が小さい場合、 @i{n} は
-1 です。 最初の連なり(string)が大きい場合、 @i{n} は 1 です。

@findex pad ( @var{ -- c-addr   } ) core-ext
@cindex @code{pad}
@kindex pad
@format
@code{pad} ( @i{-- c-addr  }) core-ext ``pad''
@end format
@var{c-addr} は、 一時的なデータ・ストレージとして使用できる一時領域のアドレスです。 少なくとも 84 文字分の空間が使用可能です。



@comment TODO examples

@node Strings and Characters, Control Structures, Memory, Words
@section Strings and Characters

@menu
* Characters::
* String representations::
* String and character literals::
* String words::
* ＄tring words::
* Counted string words::     
@end menu

@node Characters, String representations, Strings and Characters, Strings and Characters
@subsection Characters
@cindex Characters - chars/bytes vs. extended characters
@cindex character encoding

Forth は、 @code{c@@} などのワードで使用される char (別名バイト)をサポートします。 これらは ASCII
文字を表すために使用できます。

Forth は、 複数のバイト(つまり、 複数の char)のシーケンスで表現できる拡張文字(extended
characters)もサポートしています。  一般的な文字エンコーディングは、 ユニコードの UTF-8 表現です。

一般に、 ほとんどのプログラム・コードは拡張文字(extended characters)について心配する必要はありません。
連なり(string)表現では、 当該バイトが拡張文字の一部であるか、 それ自体が1つの文字であるかは問題ではありません。 拡張文字が char
のシーケンスとして転送される場合、 (@code{emit} のような) char を消費するワードも機能します。 Forth は未だ、
拡張文字を処理するためのワード群を提供しています(@pxref{Xchars and Unicode})。

ユニコード用語では、 char @i{コード・ユニット}、 拡張文字は @i{コード・ポイント} です。  Unicode
@i{抽象文字}(abstract character) はコード・ポイントのシーケンスとしで構成されますが、 (他のプログラミング言語と同様、 )
Forth  には抽象文字個々のデータ型はないことに注意してください。 もちろん、 これらは連なり(string)として表すことができます。

スタック上の char および Xchar には通常の整数ワードを使用できますが、 Gforth にはスタック上の char
を処理するためのワードもいくつかあります:

@findex toupper ( @var{ c1 -- c2  } ) gforth-0.2
@cindex @code{toupper}
@kindex toupper
@format
@code{toupper} ( @i{c1 -- c2 }) gforth-0.2 ``toupper''
@end format
@i{c1} が小文字の ASCII 文字である場合、 @i{c2} は同等の大文字です。 それ以外の場合、 @i{c2} と @i{c1}
は同じです。


@node String representations, String and character literals, Characters, Strings and Characters
@subsection String representations
@cindex strings - see character strings
@cindex character strings - representations
@cindex counted strings

Forth は通常、 文字列(strings)をスタック上のセルのペア @i{c-addr u} として表します。  @i{u}
はバイト単位の文字列の長さ(別名 文字数)、 @i{c-addr} は文字列の最初のバイトのアドレスです。  コード・ポイントは、
文字列内の複数の文字(char)のシーケンスによって表される場合があることに注意してください(また、 ユニコード の「抽象文字」(abstract
character)は複数のコード・ポイントで構成される場合があります)。 @xref{String words}

もう一つの文字列表現が、 @code{$} を含む文字列ライブラリ・ワード群で使用されます。 それらは、
変数などに配置できるセルサイズの文字列ハンドル(cell-sized string handle)のアドレスを通じてスタック上の文字列を表します。
@xref{＄tring words}

旧来からの文字列表現は「カウンタ付き文字列」(counted strings)で、 スタック上では @i{c-addr} と表現されます。
@i{c-addr} によって指定される char には、 文字列の文字数 @i{n} が含まれており、 その文字列はメモリ内の後続の @i{n}
char アドレスを占有します。 カウントされる文字列の長さは 255 バイトに制限されます。  カウンタ付き文字列は、 必要なスタック項目が 1
つだけであるため魅力的に見えるかもしれませんが、 この制限があるため、 特にワードの入力パラメータとしては使用しないことをお勧めします。
@xref{Counted string words}

@node String and character literals, String words, String representations, Strings and Characters
@subsection String and Character literals
@cindex character literals
@cindex string literals
@cindex literals for characters and strings

文字列リテラル(string literal)を記述する至高の方法は、 @code{"@i{STRING}"} と記述することです。
@code{s\"} の場合と同じく、 バックスラッシュによるエスケープ(\-escapes)を使用できます。 ただし、
この方法は標準ではないため(non-standard)、 移植性を高めるためには以下のいずれかのワードを使用することをお勧めします:

@findex s\" ( @var{ compilation 'ccc"' -- ; run-time -- c-addr u   } ) core-ext,file-ext
@cindex @code{s\"}
@kindex s\"
@format
@code{s\"} ( @i{compilation 'ccc"' -- ; run-time -- c-addr u  }) core-ext,file-ext ``s-backslash-quote''
@end format
これは @code{s"} と似ていますが、
C言語のようなバックスラッシュ・エスケープ・シーケンス(\-escape-sequences)を次のように変換します: @code{\a} BEL
(ビープ音)、 @code{\b} BS 、 @code{\e} ESC (not in C99)、 @code{\f} FF 、 @code{\n}
改行(newline)、 @code{\r} CR 、 @code{\t} HT 、@code{\v} VT 、@code{\"} " 、
@code{\\} \ 、 @code{\}[0-7]@{1,3@} 8進数(非標準)、 @code{\x}[0-9a-f]@{0,2@}
16進指定char値(標準は2桁のみ)、 @code{\u}[0-9a-f]@{4@}
ユニコード・コードポイント(サロゲート・ペア自動マージ;auto-merges surrogate pairs)、
@code{\U}[0-9a-f]@{8@} 拡張ユニコード・コード・ポイント。 @code{\} は他の文字よりも前に予約されています。 @* 注意:
@code{\x}XX は生のバイトを生成することに注意してください。 一方、 @code{\u}XXXX と @code{\U}XXXXXXXX は、
現在のエンコーディングのコード・ポイントを生成します。 たとえば、 UTF-8 エンコーディングを使用し、 @"a (コード・ポイント
U+00E4)をエンコードしたい場合は、 次のように指定できます: 文字 @"a 自体を記述するか、 @code{\xc3\xa4}
(このコード・ポイントの UTF-8 バイト) または @code{\u00e4} または @code{\U000000e4} を記述します。 @*
注意: C言語とは異なり、 @code{\n} はホストOS に適した改行シーケンスを生成します。 これは複数の文字で構成される場合があります。
つまり、 @code{"\n"} は @code{newline} と同等です。


@findex S" ( @var{ compilation 'ccc"' -- ; run-time -- c-addr u   } ) core,file
@cindex @code{S"}
@kindex S"
@format
@code{S"} ( @i{compilation 'ccc"' -- ; run-time -- c-addr u  }) core,file ``s-quote''
@end format
コンパイル・モードコードは  @code{"} (二重引用符) を区切り文字として文字列 @i{ccc} をパースします。 その実行時コードは、 長さ
@i{u} と 文字列の開始アドレス @i{c-addr} を返します。 インタプリタ時: 同様に文字列をパースし、 @i{c-addr} と
@i{u} 返します。 Gforth では文字列(string)を @code{allocate} します。
結果として生じるメモリ・リークは通常は問題ではありません。 例外は、 @code{S"} を含む文字列を作成し、 その文字列を
@code{evaluate} する場合です。 その場合、 リークはインタプリトされたファイルのサイズに制限されないため、 文字列を
@code{free} することもできます。 Forth-2012 では、それぞれ 80 文字のバッファーが 2 つしか保証されないため、
標準プログラムでは、 文字列は 2 つ前の @code{s"} までしか存続していない想定する必要があります。



同様に、 @code{'@i{C}'} を使用すると、 文字 @i{C} のコード @i{xc} を取得できます。 この方法は Forth-2012
から標準化されています。 これを取得する古い方法は、 以下のいずれかのワードを使用することです:

@findex char ( @var{ '<spaces>ccc' -- c   } ) core,xchar-ext
@cindex @code{char}
@kindex char
@format
@code{char} ( @i{'<spaces>ccc' -- c  }) core,xchar-ext ``char''
@end format
先頭のスペース達をスキップします。 文字列 @i{ccc} をパースし、 @i{ccc} の最初の文字の文字コード @i{c}
を返します(訳注:ASCII以外の文字コードもいけるっぽい(LANG=ja_JP.UTF-8) char あ hex . decimal 3042
ok)


@findex [char] ( @var{ compilation '<spaces>ccc' -- ; run-time -- c   } ) core,xchar-ext
@cindex @code{[char]}
@kindex [char]
@format
@code{[char]} ( @i{compilation '<spaces>ccc' -- ; run-time -- c  }) core,xchar-ext ``bracket-char''
@end format
コンパイル状態: 先頭のスペース達をスキップします。 文字列 @i{ccc} をパースします。 その実行時コード: @i{ccc}
の最初の文字の文字コード @i{c} を返します。 このワードのインタプリタ機能(interpretation semantics)は未定義です。



通常は、 コロン定義の外側で @code{char} 使用するか、 コロン定義の内側で @code{[char]} を使用するか、 単にその両方で
@code{'@i{C}'} を使用するかです。

注意: 例えば、

@example
"C" type
@end example

@noindent
の方が下記よりも(わずかに)効率的です

@example
'C' xemit
@end example

@noindent
なぜなら、 後者はコード・ポイントをバイトのシーケンスに変換し、 それらを個別に @code{emit} するからです。 同様に、
一般的な文字達を扱う場合は、 通常、 コード・ポイントではなく文字列として表す方が効率的です。

@code{S"} または @code{'@i{C}'} では生成できない、 一般的に使用される文字や文字列を生成するために以下のワード群があります:

@findex newline ( @var{ -- c-addr u  } ) gforth-0.5
@cindex @code{newline}
@kindex newline
@format
@code{newline} ( @i{-- c-addr u }) gforth-0.5 ``newline''
@end format
ホストOSの改行シーケンスを含む文字列(訳注: 文字コードを返す訳では無いことに注意。 文字列の内容は LF だったり CRLF だったりする)

@findex bl ( @var{ -- c-char   } ) core
@cindex @code{bl}
@kindex bl
@format
@code{bl} ( @i{-- c-char  }) core ``b-l''
@end format
@i{c-char} は空白(space)の文字コード値です。


@findex #tab ( @var{ -- c   } ) gforth-0.2
@cindex @code{#tab}
@kindex #tab
@format
@code{#tab} ( @i{-- c  }) gforth-0.2 ``number-tab''
@end format

@findex #lf ( @var{ -- c   } ) gforth-0.2
@cindex @code{#lf}
@kindex #lf
@format
@code{#lf} ( @i{-- c  }) gforth-0.2 ``number-l-f''
@end format

@findex #cr ( @var{ -- c   } ) gforth-0.2
@cindex @code{#cr}
@kindex #cr
@format
@code{#cr} ( @i{-- c  }) gforth-0.2 ``number-c-r''
@end format

@findex #ff ( @var{ -- c   } ) gforth-0.2
@cindex @code{#ff}
@kindex #ff
@format
@code{#ff} ( @i{-- c  }) gforth-0.2 ``number-f-f''
@end format

@findex #bs ( @var{ -- c   } ) gforth-0.2
@cindex @code{#bs}
@kindex #bs
@format
@code{#bs} ( @i{-- c  }) gforth-0.2 ``number-b-s''
@end format

@findex #del ( @var{ -- c   } ) gforth-0.2
@cindex @code{#del}
@kindex #del
@format
@code{#del} ( @i{-- c  }) gforth-0.2 ``number-del''
@end format

@findex #bell ( @var{ -- c   } ) gforth-0.2
@cindex @code{#bell}
@kindex #bell
@format
@code{#bell} ( @i{-- c  }) gforth-0.2 ``number-bell''
@end format

@findex #esc ( @var{ -- c   } ) gforth-0.5
@cindex @code{#esc}
@kindex #esc
@format
@code{#esc} ( @i{-- c  }) gforth-0.5 ``number-esc''
@end format

@findex #eof ( @var{ -- c   } ) gforth-0.7
@cindex @code{#eof}
@kindex #eof
@format
@code{#eof} ( @i{-- c  }) gforth-0.7 ``number-e-o-f''
@end format
実際には EOT (ASCII コード 4 別名 @code{^D})



@node String words, ＄tring words, String and character literals, Strings and Characters
@subsection String words

メモリ・ブロックに使用されるワードは文字列(string)にも役立つため、 文字列(string)の移動やコピーや比較や検索を行うワードについては、
@ref{Memory Blocks} を参照してください。 文字や文字列を表示するワードについては、 see @ref{Displaying
characters and strings} を参照してください。

以下のワード群は、 既に存在している文字列(strings)に対して機能します:

@findex str= ( @var{ c-addr1 u1 c-addr2 u2 -- f   } ) gforth-0.6
@cindex @code{str=}
@kindex str=
@format
@code{str=} ( @i{c-addr1 u1 c-addr2 u2 -- f  }) gforth-0.6 ``str-equals''
@end format

@findex str< ( @var{ c-addr1 u1 c-addr2 u2 -- f   } ) gforth-0.6
@cindex @code{str<}
@kindex str<
@format
@code{str<} ( @i{c-addr1 u1 c-addr2 u2 -- f  }) gforth-0.6 ``str-less-than''
@end format

@findex string-prefix? ( @var{ c-addr1 u1 c-addr2 u2 -- f   } ) gforth-0.6
@cindex @code{string-prefix?}
@kindex string-prefix?
@format
@code{string-prefix?} ( @i{c-addr1 u1 c-addr2 u2 -- f  }) gforth-0.6 ``string-prefix-question''
@end format
@var{c-addr2 u2} が @var{c-addr1 u1} の接頭辞部分と合致しますか？


@findex string-suffix? ( @var{ c-addr1 u1 c-addr2 u2 -- f   } ) gforth-1.0
@cindex @code{string-suffix?}
@kindex string-suffix?
@format
@code{string-suffix?} ( @i{c-addr1 u1 c-addr2 u2 -- f  }) gforth-1.0 ``string-suffix-question''
@end format
@var{c-addr2 u2} が @var{c-addr1 u1} の接尾辞部分と合致しますか？


@findex search ( @var{ c-addr1 u1 c-addr2 u2 -- c-addr3 u3 flag   } ) string
@cindex @code{search}
@kindex search
@format
@code{search} ( @i{c-addr1 u1 c-addr2 u2 -- c-addr3 u3 flag  }) string ``search''
@end format
文字列 @i{c-addr1, u1} の中で、 文字列 @i{c-addr2, u2} を検索します。  @i{flag} が true の場合:
見つかったアドレスを @i{c-addr3} に、 文字列 @i{c-addr2, u2} を含むそれ以降の文字数を @i{u3} に返します(訳注:
s" GNU gforth マニュアル" s" ニュア" search drop ." [" type ." ]" [ニュアル] ok )。
@i{flag} が false の場合: 一致するものが見つかりませんでした。 @i{c-addr3, u3} は @i{c-addr1, u1}
と同じです。


@findex scan ( @var{ c-addr1 u1 c -- c-addr2 u2  } ) gforth-0.2
@cindex @code{scan}
@kindex scan
@format
@code{scan} ( @i{c-addr1 u1 c -- c-addr2 u2 }) gforth-0.2 ``scan''
@end format
c に等しくないすべての文字をスキップします。 結果は c で始まる(c-addr2 u2)か空(empty; c-addr2+u2, 0)です。
@code{Scan} はシングルバイト文字(ASCII)に限定されます。 マルチバイト文字を検索するには、 @code{search} を使用します。

@findex scan-back ( @var{ c-addr u1 c -- c-addr u2   } ) gforth-0.7
@cindex @code{scan-back}
@kindex scan-back
@format
@code{scan-back} ( @i{c-addr u1 c -- c-addr u2  }) gforth-0.7 ``scan-back''
@end format

@findex skip ( @var{ c-addr1 u1 c -- c-addr2 u2  } ) gforth-0.2
@cindex @code{skip}
@kindex skip
@format
@code{skip} ( @i{c-addr1 u1 c -- c-addr2 u2 }) gforth-0.2 ``skip''
@end format
c に等しいすべての文字をスキップします。  結果は最初の非 C 文字で始まる(アドレス、長さ)か、 空(文字列の長さ0)になります。
@code{skip} はシングルバイト文字(ASCII)に限定されます。

@findex -trailing ( @var{ c_addr u1 -- c_addr u2   } ) string
@cindex @code{-trailing}
@kindex -trailing
@format
@code{-trailing} ( @i{c_addr u1 -- c_addr u2  }) string ``dash-trailing''
@end format
@i{c-addr, u1} で指定された文字列の末尾をトリムします(末尾のスペースをすべて削除します)。 @i{u2} は変更後の文字列の長さです。


@findex /string ( @var{ c-addr1 u1 n -- c-addr2 u2  } ) string
@cindex @code{/string}
@kindex /string
@format
@code{/string} ( @i{c-addr1 u1 n -- c-addr2 u2 }) string ``slash-string''
@end format
@i{c-addr1, u1} で指定された文字列の先頭から @i{n} 文字削除します(訳注: c-addr1+n, u1-n するだけっぽい…)。

@findex safe/string ( @var{ c-addr1 u1 n -- c-addr2 u2  } ) gforth-1.0
@cindex @code{safe/string}
@kindex safe/string
@format
@code{safe/string} ( @i{c-addr1 u1 n -- c-addr2 u2 }) gforth-1.0 ``safe-slash-string''
@end format
@i{c-addr1, u1} で指定された文字列の先頭から @i{n} 文字を削除します。 @code{/string}
とは異なり、@code{safe/string} は少なくとも 0 文字、 最大で @i{u1} 文字を削除します。

@findex cstring>sstring ( @var{ c-addr -- c-addr u   } ) gforth-0.2
@cindex @code{cstring>sstring}
@kindex cstring>sstring
@format
@code{cstring>sstring} ( @i{c-addr -- c-addr u  }) gforth-0.2 ``cstring-to-sstring''
@end format
@i{C-addr} はゼロで終わる文字列の開始アドレス、 @i{u} はその長さです。



以下のワード群は、 ASCII 文字については大文字と小文字を区別せずに比較しますが、 (ワードリストの検索のような)非 ASCII
文字については大文字と小文字を区別します 。

@findex capscompare ( @var{ c-addr1 u1 c-addr2 u2 -- n  } ) gforth-0.7
@cindex @code{capscompare}
@kindex capscompare
@format
@code{capscompare} ( @i{c-addr1 u1 c-addr2 u2 -- n }) gforth-0.7 ``capscompare''
@end format
文字列内のバイトの値に基づいて、 2 つの文字列(string)を辞書順(lexicographically)に比較します。ただし、 ASCII
文字は大文字と小文字を区別せずに比較し、 非 ASCII 文字は大文字と小文字を区別して、 かつ、 ロケール固有の照合順序を使用せずに比較します。
それらが等しい場合 @i{n} は 0 です。 最初の文字列が小さい場合 @i{n} は -1 です。 最初の文字列が大きい場合@i{n} は 1
です。 

@findex capsstring-prefix? ( @var{ c-addr1 u1 c-addr2 u2 -- f   } ) gforth-1.0
@cindex @code{capsstring-prefix?}
@kindex capsstring-prefix?
@format
@code{capsstring-prefix?} ( @i{c-addr1 u1 c-addr2 u2 -- f  }) gforth-1.0 ``capsstring-prefix?''
@end format
@code{string-prefix?} と似ていますが、 ASCII 文字の大文字と小文字は区別されません: @var{c-addr2 u2} は
@var{c-addr1 u1} の接頭辞か？


@findex capssearch ( @var{ c-addr1 u1 c-addr2 u2 -- c-addr3 u3 flag   } ) gforth-1.0
@cindex @code{capssearch}
@kindex capssearch
@format
@code{capssearch} ( @i{c-addr1 u1 c-addr2 u2 -- c-addr3 u3 flag  }) gforth-1.0 ``capssearch''
@end format
@code{search} と似ていますが、 ASCII 文字の大文字と小文字は区別されません: @i{c-addr1 u1} 内で
@i{c-addr2 u2} を検索します。 見つかった場合 @i{flag} は true になります。



以下のワード群は、 ヒープに文字列(string)を作成、 またはヒープの文字列(string)を拡張します。

@findex s+ ( @var{ c-addr1 u1 c-addr2 u2 -- c-addr u   } ) gforth-0.7
@cindex @code{s+}
@kindex s+
@format
@code{s+} ( @i{c-addr1 u1 c-addr2 u2 -- c-addr u  }) gforth-0.7 ``s-plus''
@end format
@i{c-addr u} は、@i{c-addr1 u1} (最初) と @i{c-addr2 u2} (2 番目) を連結したのを含む、 新しく
@code{allocate} された文字列です。


@findex append ( @var{ c-addr1 u1 c-addr2 u2 -- c-addr u   } ) gforth-0.7
@cindex @code{append}
@kindex append
@format
@code{append} ( @i{c-addr1 u1 c-addr2 u2 -- c-addr u  }) gforth-0.7 ``append''
@end format
@i{C-addr u} は、@i{c-addr1 u1} (最初) と @i{c-addr2 u2} (2 番目) を連結したものです。
@i{c-addr1 u1} は @code{allocate} された文字列であり、 @i{u}
文字の領域に対応するために(可能なら)サイズ変更(resize)して @i{c-addr2 u2}
の文字列を追加(append)します(サイズ変更できなくて、新しいアドレスに移動する可能性があります)。


@findex >string-execute ( @var{ ... xt -- ... addr u   } ) gforth-1.0
@cindex @code{>string-execute}
@kindex >string-execute
@format
@code{>string-execute} ( @i{... xt -- ... addr u  }) gforth-1.0 ``>string-execute''
@end format
xt を実行(execute)すると、 標準出力 (@code{type} や @code{emit} やそれらを使用するすべてのもの)
を文字列にリダイレクトします。 結果の文字列は addr u で、これは割り当てられた(@code{allocate})メモリ内にあります。
この文字列を開放(@code{free})するのは、 @code{>string-execute} の呼び出し元の責任です。



以下のようにして、@code{>string-execute} を使用して @code{s+} を定義できます:

: s+ ( c-addr1 u1 c-addr2 u2 -- c-addr u )  [: 2swap type type ;]
>string-execute ;

2 つの文字列だけを連結する場合、 @code{>string-execute} は効率的ではありませんが、 多くの文字列を連結する場合は、
@code{>string-execute} の方が効率的です。

@node ＄tring words, Counted string words, String words, Strings and Characters
@subsection ＄tring words
@cindex string words with $

以下の文字列ライブラリは、 文字列を通常のセル・サイズの変数(文字列ハンドル;string handle)に格納します。  これらのハンドルには、
ヒープに割り当てられたセル・カウント文字列(cell-counted
string;カウンタがセルサイズであるカウンタ付き文字列)へのポインタが含まれています。 この文字列ライブラリは bigFORTH 由来です。

内容への恒久的な参照は 1 つだけ(ハンドル内の参照)しかないため、 未解決の参照を恐れることなく文字列を再配置または削除できます。 これには、
プログラマが、 例えば @code{$@@} 等によって生成された参照を一時的な目的でのみ使用する必要があります。 つまり、 これらの一時的な参照は、
戻り値として渡されたり、 グローバル・メモリに格納されたりすることはなく、 ハンドルを変更する可能性のあるワードは、
これらの一時的な参照が存在する間は呼び出されません。

このライブラリを補完するものとしてセルペア表現(cell-pair representation)があります。 文字列変数に対して $tring
ワードを使用しますが、 これは c-addr u 表現では面倒です。  セルペア表現は、 文字列を変更しないで処理(検査など)するために使用します。

@findex $! ( @var{ addr1 u $addr --   } ) gforth-0.7
@cindex @code{$!}
@kindex $!
@format
@code{$!} ( @i{addr1 u $addr --  }) gforth-0.7 ``string-store''
@end format
文字列 @i{addr1 u} を、 新しく割り当てられた文字列バッファーに格納し、 その文字列バッファーのアドレスを @i{$addr}
に格納します。 必要に応じて以前のバッファーを解放します。


@findex $@@ ( @var{ $addr -- addr2 u   } ) gforth-0.7
@cindex @code{$@@}
@kindex $@@
@format
@code{$@@} ( @i{$addr -- addr2 u  }) gforth-0.7 ``string-fetch''
@end format
格納された文字列のアドレスと長さを返します。


@findex $@@len ( @var{ $addr -- u   } ) gforth-0.7
@cindex @code{$@@len}
@kindex $@@len
@format
@code{$@@len} ( @i{$addr -- u  }) gforth-0.7 ``string-fetch-len''
@end format
格納されている文字列の長さを返します。


@findex $!len ( @var{ u $addr --   } ) gforth-0.7
@cindex @code{$!len}
@kindex $!len
@format
@code{$!len} ( @i{u $addr --  }) gforth-0.7 ``string-store-len''
@end format
格納されている文字列(string)領域の長さを変更します(足し算ではない。 長さを直にいじる)  それゆえ、メモリ領域を変更し、
アドレスとカウンタ・セルも調整(adjust)する必要があります(訳注: 元の長さより長くした場合、 領域を拡張するだけで初期化はしない。
そこにはゴミが入っているので自分で初期化する必要がある)


@findex $+!len ( @var{ u $addr -- addr   } ) gforth-1.0
@cindex @code{$+!len}
@kindex $+!len
@format
@code{$+!len} ( @i{u $addr -- addr  }) gforth-1.0 ``string-plus-store-len''
@end format
$addr によって参照されるメモリ領域の最後に u バイト用の空間を確保します(追加。確保するだけで初期化はしない。 $addr
の「長さ」に追加もする)。 addr は、 確保した空間の最初のアドレスです。


@findex $del ( @var{ addr off u --   } ) gforth-0.7
@cindex @code{$del}
@kindex $del
@format
@code{$del} ( @i{addr off u --  }) gforth-0.7 ``string-del''
@end format
文字列のオフセット位置 @var{off} から @var{u} バイト削除します。


@findex $ins ( @var{ addr1 u $addr off --   } ) gforth-0.7
@cindex @code{$ins}
@kindex $ins
@format
@code{$ins} ( @i{addr1 u $addr off --  }) gforth-0.7 ``string-ins''
@end format
オフセット位置 @var{off} に文字列を挿入します。


@findex $+! ( @var{ addr1 u $addr --   } ) gforth-0.7
@cindex @code{$+!}
@kindex $+!
@format
@code{$+!} ( @i{addr1 u $addr --  }) gforth-0.7 ``string-plus-store''
@end format
文字列(addr1 u)を別の文字列($addr)に追加します。


@findex c$+! ( @var{ char $addr --   } ) gforth-1.0
@cindex @code{c$+!}
@kindex c$+!
@format
@code{c$+!} ( @i{char $addr --  }) gforth-1.0 ``c-string-plus-store''
@end format
文字列に文字を追加します。


@findex $free ( @var{ $addr --   } ) gforth-1.0
@cindex @code{$free}
@kindex $free
@format
@code{$free} ( @i{$addr --  }) gforth-1.0 ``string-free''
@end format
$addr が指す文字列を解放し、  $addr のポインタを 0 にします( $@@ すると 0 0 を返す)


@findex $init ( @var{ $addr --   } ) gforth-1.0
@cindex @code{$init}
@kindex $init
@format
@code{$init} ( @i{$addr --  }) gforth-1.0 ``string-init''
@end format
以前に何があったかに関係なく、そこに空の文字列を保存します(訳注: ポインタを 0 にする訳ではなくて、 ポインタの指す先に長さゼロの文字列がある)


@findex $split ( @var{ addr u char -- addr1 u1 addr2 u2   } ) gforth-0.7
@cindex @code{$split}
@kindex $split
@format
@code{$split} ( @i{addr u char -- addr1 u1 addr2 u2  }) gforth-0.7 ``string-split''
@end format
文字列中で最初に現れる char を区切り文字として文字列を 2 つに分割します(例: HTML クエリの引数の '?')(訳注: 区切り文字 char
自体は分割後の文字列に含まれない)


@findex $iter ( @var{ .. $addr char xt -- ..   } ) gforth-0.7
@cindex @code{$iter}
@kindex $iter
@format
@code{$iter} ( @i{.. $addr char xt -- ..  }) gforth-0.7 ``string-iter''
@end format
区切り文字 char で切り出した部分文字列(addr u)ごとに xt を呼び出します。 xt は (addr u -- ) でなければなりません。
これにより、 例えば '&' で区切られた引数を簡単に分解できます(訳注: : my-type  ( addr u -- )  ." [" type
." ]" ;   variable title s" GNU gforth manual" title $!   title $@ my-type
[GNU gforth manual]   title bl ' my-type $iter [GNU][gforth][manual] ok)。


@findex $over ( @var{ addr u $addr off --   } ) gforth-1.0
@cindex @code{$over}
@kindex $over
@format
@code{$over} ( @i{addr u $addr off --  }) gforth-1.0 ``string-over''
@end format
$addr の文字列のオフセット位置 off から文字列(addr u)で上書きします。


@findex $exec ( @var{ xt addr --   } ) gforth-1.0
@cindex @code{$exec}
@kindex $exec
@format
@code{$exec} ( @i{xt addr --  }) gforth-1.0 ``string-exec''
@end format
実行トークン xt を実行し、 その標準出力(TYPE や EMIT やそれらを使用するすべてのもの)を addr が指す文字列の末尾に「追加」します。 


@findex $tmp ( @var{ xt -- addr u   } ) gforth-1.0
@cindex @code{$tmp}
@kindex $tmp
@format
@code{$tmp} ( @i{xt -- addr u  }) gforth-1.0 ``string-t-m-p''
@end format
ワードの出力から一時的な文字列を生成します


@findex $. ( @var{ addr --   } ) gforth-1.0
@cindex @code{$.}
@kindex $.
@format
@code{$.} ( @i{addr --  }) gforth-1.0 ``string-dot''
@end format
文字列を出力する、 ショートカット( $@ TYPE → $. )


@findex $slurp ( @var{ fid addr --   } ) gforth-1.0
@cindex @code{$slurp}
@kindex $slurp
@format
@code{$slurp} ( @i{fid addr --  }) gforth-1.0 ``string-slurp''
@end format
(slurp;音を立ててすする)ファイル @i{fid} を最後まで読み取り(ファイルのクローズは行いません)、 読み取ったデータを @i{addr}
の指す文字列に入れます。


@findex $slurp-file ( @var{ c-addr u addr --   } ) gforth-1.0
@cindex @code{$slurp-file}
@kindex $slurp-file
@format
@code{$slurp-file} ( @i{c-addr u addr --  }) gforth-1.0 ``string-slurp-file''
@end format
@i{c-addr u} という名前のファイル内のすべてのデータを @i{addr} の文字列に入力します。


@findex $+slurp ( @var{ fid addr --   } ) gforth-1.0
@cindex @code{$+slurp}
@kindex $+slurp
@format
@code{$+slurp} ( @i{fid addr --  }) gforth-1.0 ``string-plus-slurp''
@end format
ファイル @i{fid} を最後まで読み取り(但しクローズはしません)、 読み取ったデータを @i{addr} の文字列に「追加」します。


@findex $+slurp-file ( @var{ c-addr u addr --   } ) gforth-1.0
@cindex @code{$+slurp-file}
@kindex $+slurp-file
@format
@code{$+slurp-file} ( @i{c-addr u addr --  }) gforth-1.0 ``string-plus+slurp-file''
@end format
@i{c-addr u} という名前のファイル内のすべてのデータを @i{addr} の文字列に「追加」します。


@findex $[] ( @var{ u $[]addr -- addr'   } ) gforth-1.0
@cindex @code{$[]}
@kindex $[]
@format
@code{$[]} ( @i{u $[]addr -- addr'  }) gforth-1.0 ``string-array''
@end format
@i{addr'} は、 文字列配列 @i{$[]addr} の @i{u} 番目の要素のアドレスです。  配列のサイズは必要に応じて変更されます。


@findex $[]! ( @var{ c-addr u n $[]addr --   } ) gforth-1.0
@cindex @code{$[]!}
@kindex $[]!
@format
@code{$[]!} ( @i{c-addr u n $[]addr --  }) gforth-1.0 ``string-array-store''
@end format
文字列 @i{c-addr u} を文字列配列 @i{$[]addr} のインデックス @i{n} に格納します。
必要に応じて配列のサイズが変更されます。


@findex $[]+! ( @var{ c-addr u n $[]addr --   } ) gforth-1.0
@cindex @code{$[]+!}
@kindex $[]+!
@format
@code{$[]+!} ( @i{c-addr u n $[]addr --  }) gforth-1.0 ``string-array-plus-store''
@end format
文字列 @i{c-addr u} をインデックス @i{n} の文字列に「追加」します。  必要に応じて配列のサイズが変更されます。  これを
@code{$+[]!} と混同しないでください。


@findex $+[]! ( @var{ c-addr u $[]addr --   } ) gforth-1.0
@cindex @code{$+[]!}
@kindex $+[]!
@format
@code{$+[]!} ( @i{c-addr u $[]addr --  }) gforth-1.0 ``string-append-array''
@end format
文字列 @i{c-addr u} を文字列配列 @i{$[]addr} の新しい最後の要素として保存します(つまり要素が1つ増える)。
必要に応じて配列のサイズが変更されます。


@findex $[]@@ ( @var{ n $[]addr -- addr u   } ) gforth-1.0
@cindex @code{$[]@@}
@kindex $[]@@
@format
@code{$[]@@} ( @i{n $[]addr -- addr u  }) gforth-1.0 ``string-array-fetch''
@end format
配列インデックス @i{n} から文字列を取得します --- 空の場合はゼロ文字列( 0 0 )を返し、
誤って配列が成長しないようにします(訳注:要素はあるけど空文字列(長さ0)の場合と、範囲外の要素を指した場合の区別は付かないので注意)


@findex $[]# ( @var{ addr -- len   } ) gforth-1.0
@cindex @code{$[]#}
@kindex $[]#
@format
@code{$[]#} ( @i{addr -- len  }) gforth-1.0 ``string-array-num''
@end format
配列内の要素の数を返します


@findex $[]map ( @var{ addr xt --   } ) gforth-1.0
@cindex @code{$[]map}
@kindex $[]map
@format
@code{$[]map} ( @i{addr xt --  }) gforth-1.0 ``string-array-map''
@end format
文字列配列 @var{addr} のすべての要素に対して 実行トークン @var{xt} を実行します。  xt は @var{( addr u --
)} で、一度に 1 つの文字列を取得します


@findex $[]slurp ( @var{ fid addr --   } ) gforth-1.0
@cindex @code{$[]slurp}
@kindex $[]slurp
@format
@code{$[]slurp} ( @i{fid addr --  }) gforth-1.0 ``string-array-slurp''
@end format
ファイル @var{fid} の内容を 1 行ずつ文字列配列 @var{addr} に入れます


@findex $[]slurp-file ( @var{ addr u $addr --   } ) gforth-1.0
@cindex @code{$[]slurp-file}
@kindex $[]slurp-file
@format
@code{$[]slurp-file} ( @i{addr u $addr --  }) gforth-1.0 ``string-array-slurp-file''
@end format
名前付きファイル @var{addr u} を 1 行ずつ文字列配列 @var{$addr} に入れます。


@findex $[]. ( @var{ addr --   } ) gforth-1.0
@cindex @code{$[].}
@kindex $[].
@format
@code{$[].} ( @i{addr --  }) gforth-1.0 ``string-array-dot''
@end format
すべての配列エントリを出力します


@findex $[]free ( @var{ addr --   } ) gforth-1.0
@cindex @code{$[]free}
@kindex $[]free
@format
@code{$[]free} ( @i{addr --  }) gforth-1.0 ``string-array-free''
@end format
addr は沢山のセルカウント文字列(string)へのアドレス達を含む、 セル・カウント文字列(string)へのアドレスで、 $[]free
はこれらの文字列を解放、 つまり、 この配列を開放し、 addr の値を 0 にセットします。


@findex $save ( @var{ $addr --   } ) gforth-1.0
@cindex @code{$save}
@kindex $save
@format
@code{$save} ( @i{$addr --  }) gforth-1.0 ``string-save''
@end format
savesys のディクショナリに文字列(string)をプッシュします


@findex $[]save ( @var{ addr --   } ) gforth-1.0
@cindex @code{$[]save}
@kindex $[]save
@format
@code{$[]save} ( @i{addr --  }) gforth-1.0 ``string-array-save''
@end format
文字列配列を savesys のディクショナリにプッシュ


@findex $boot ( @var{ $addr --   } ) gforth-1.0
@cindex @code{$boot}
@kindex $boot
@format
@code{$boot} ( @i{$addr --  }) gforth-1.0 ``string-boot''
@end format
ディクショナリから文字列を新しく割り当てたメモリに取り込みます。 その後、 ディクショナリのその文字列の領域を(0で)クリアします(長さはそのまま)。


@findex $[]boot ( @var{ addr --   } ) gforth-1.0
@cindex @code{$[]boot}
@kindex $[]boot
@format
@code{$[]boot} ( @i{addr --  }) gforth-1.0 ``string-array-boot''
@end format
ディクショナリから、 文字列配列を割り当てられたメモリに取得します


@findex $saved ( @var{ addr --   } ) gforth-1.0
@cindex @code{$saved}
@kindex $saved
@format
@code{$saved} ( @i{addr --  }) gforth-1.0 ``string-saved''
@end format
アドレスを ブート済み(booted)/保存済み(saved) としてマークする


@findex $[]saved ( @var{ addr --   } ) gforth-1.0
@cindex @code{$[]saved}
@kindex $[]saved
@format
@code{$[]saved} ( @i{addr --  }) gforth-1.0 ``string-array-saved''
@end format
アドレスを ブート済み(booted)/保存済み(saved) としてマークする


@findex $Variable ( @var{ --   } ) gforth-1.0
@cindex @code{$Variable}
@kindex $Variable
@format
@code{$Variable} ( @i{--  }) gforth-1.0 ``string-variable''
@end format
savesystem 全体にわたって保存される文字列変数。


@findex $[]Variable ( @var{ --   } ) gforth-1.0
@cindex @code{$[]Variable}
@kindex $[]Variable
@format
@code{$[]Variable} ( @i{--  }) gforth-1.0 ``string-array-variable''
@end format
savesystem 全体にわたって保存される文字列変数。




@node Counted string words, , ＄tring words, Strings and Characters
@subsection Counted string words

カウンタ付文字列(counted string)は、 指定のアドレスのバイトとして長さを格納し、 その後に文字列のバイトが続きます。
可能な長さは厳しく制限されており、 入力文字列を破壊せずにその場で部分文字列を作成することはできません。 したがって、
カウンタ付文字列を使用しないことをお勧めします。 それでも、 カウンタ付文字列を処理する必要がある場合、 以下のようなワード群があります:

@findex count ( @var{ c-addr1 -- c-addr2 u  } ) core
@cindex @code{count}
@kindex count
@format
@code{count} ( @i{c-addr1 -- c-addr2 u }) core ``count''
@end format
@i{c-addr2} は最初の文字で、 @i{u} は @i{c-addr1} のカウンタ付文字列の、 長さです。


以下のワードは、 (@code{s"} とは異なり) 有用なインタプリタ機能(interpretation semantics)がなく、
(@code{[char]} とは異なり) 対応するインタプリタ用コードがないため、 コロン定義内でのみ使用する必要があります(コロン定義がある場合):

@findex C" ( @var{ compilation "ccc<quote>" -- ; run-time  -- c-addr   } ) core-ext
@cindex @code{C"}
@kindex C"
@format
@code{C"} ( @i{compilation "ccc<quote>" -- ; run-time  -- c-addr  }) core-ext ``c-quote''
@end format
コンパイル状態: @code{"} (二重引用符) を区切り文字として文字列 @i{ccc} をパースします。 その実行時コードは、
指定のカウンタ付文字列 @i{ccc} のアドレスを @i{c-addr} として返します。 インタプリタ機能は未定義です。



( gforth-obsolete ) @code{place} ( @i{c-addr1 u c-addr2 --}) \ @var{c-addr2}
に長さ @var{u} のカウンタ付き文字列を作成し、 文字列 @var{c-addr1 u} をその場所にコピーします。
@findex string, ( @var{ c-addr u --   } ) gforth-0.2
@cindex @code{string,}
@kindex string,
@format
@code{string,} ( @i{c-addr u --  }) gforth-0.2 ``string,''
@end format
文字列をカウンタ付き文字列として(here以降の)データ空間に書き込みます。



@node Control Structures, Defining Words, Strings and Characters, Words
@section Control Structures
@cindex control structures

Forth の制御構造は、 コロン定義内のみで、 対話的(interpretively)に使用することはできません@footnote{正確には、
インタプリタ機能(interpretation semantics)(@pxref{Interpretation and Compilation
Semantics})を持っていません}。 私たちもこのような制限を好まないので、 多くのスキームが提案されてはいますが、
これを回避する満足のいく方法はまだ見つかっていません。

@menu
* Selection::                IF ... ELSE ... ENDIF
* Simple Loops::             BEGIN ...
* Counted Loops::            DO
* BEGIN loops with multiple exits::
* General control structures with CASE::
* Arbitrary control structures::
* Calls and returns::
* Exception Handling::       
@end menu

@node Selection, Simple Loops, Control Structures, Control Structures
@subsection Selection
@cindex selection control structures
@cindex control structures for selection

@cindex @code{IF} control structure
@example
@i{flag}
IF
  @i{code}
ENDIF
@end example
@noindent

@i{flag} がゼロ以外の場合(@code{IF} などに関する限り、 任意のビットが設定されたセルは true 扱いです)、 @i{code}
が実行されます。

@example
@i{flag}
IF
  @i{code1}
ELSE
  @i{code2}
ENDIF
@end example

@var{flag} が true の場合は @i{code1} が実行され、 それ以外の場合は @i{code2} が実行されます。

@code{ENDIF} の代わりに @code{THEN} を使用できます。 実際 @code{THEN} は標準です、 がしかし、
@code{ENDIF} は非常に人気があるものの、 標準ではありません。 私達は @code{ENDIF} の使用をお勧めします。 なぜなら、
他の言語を知っている人にとっても混乱が少ないためです(また、 @code{ENDIF} に対しては、 これらの人々の Forth
に対する否定的な偏見が強化される傾向が見られません)。 なお、 @code{THEN} のみを提供するシステムに @code{ENDIF}
を追加するのは以下のように簡単です:
@example
: ENDIF   POSTPONE then ; immediate
@end example

[@cite{Webster's New Encyclopedic Dictionary} によると、@dfn{then (副詞)}
には以下の意味があります:
@quotation
... 2b: 順番に次の後に続く ... 3d: 必然的な結果として (if you were there, then you saw them)
@end quotation
Forth の @code{THEN} は 2b の意味を持ちますが、 Pascal や他の多くのプログラミング言語の @code{THEN} は 3d
の意味を持ちます。]

Gforth には @code{?DUP-IF} および @code{?DUP-0=-IF} というワードも用意されているため、 @code{?dup}
の使用を避けることができます。これらの代替手段を使用することは、 @code{?dup} を使用するよりも効率的です。 @code{ENDIF} や
@code{?DUP-IF} や @code{?DUP-0=-IF} の標準 Forth での定義は、@file{compat/control.fs}
で提供されます。

@cindex @code{CASE} control structure
@example
@i{x}
CASE
  @i{x1} OF @i{code1} ENDOF
  @i{x2} OF @i{code2} ENDOF
  @dots{}
  ( x ) @i{default-code} ( x )
ENDCASE ( )
@end example

@i{xi} が @i{x} に等しいなら、 最初の @i{codei} を実行します。 @i{x1} 〜 @i{xn} のいずれも一致しない場合は、
オプションの @i{default-code} が実行されます。 オプションのデフォルト・ケースは、 最後の @code{ENDOF}
の後にコードを記述するだけで追加できます。 スタック頂上にある @i{x} を使用することはできますが、 それを消費してはなりません。  値 @i{x}
は、 この構造によって(一致する @code{OF} によって、 または一致する OF がない場合は @code{ENDCASE} によって)
消費されます。  例:

@example
: num-name ( n -- c-addr u )
 case
   0 of s" zero " endof
   1 of s" one "  endof
   2 of s" two "  endof
   \ default case:
   s" other number" 
   rot \ get n on top so ENDCASE can drop it
 endcase ;
@end example

(非標準の) @code{?of} を使用して、 @code{case} を 3 つ以上の選択肢の一般的な選択構造として使用することもできます。
@code{?Of} はフラグを受け取ります。  例:

@example
: sgn ( n1 -- n2 )
    \ sign function
    case
	dup 0< ?of drop -1 endof
	dup 0> ?of drop 1 endof
	dup \ n1=0 -> n2=0; dup an item, to be consumed by ENDCASE
    endcase ;
@end example

@progstyle コードを理解しやすくするには、
選択構造を介したすべての経路で同一の方法でスタックを変更(消費およびプッシュされるスタック項目の数と型)するようにする必要があります。

@node Simple Loops, Counted Loops, Selection, Control Structures
@subsection Simple Loops
@cindex simple loops
@cindex loops without count

@cindex @code{WHILE} loop
@example
BEGIN
  @i{code1}
  @i{flag}
WHILE
  @i{code2}
REPEAT
@end example

@i{code1} が実行され、 @i{flag} が計算されます。 @i{flag} が true の場合、 @i{code2} が実行され、
@i{BEGIN} からループが再開されます。  @i{flag} が false の場合、 @code{REPEAT} の後へ実行が続行されます。

@cindex @code{UNTIL} loop
@example
BEGIN
  @i{code}
  @i{flag}
UNTIL
@end example

@i{code} が実行されます。 @code{flag} が false の場合、 @i{BEGIN} からループが再開されます。

@progstyle コードを理解しやすくするために、 ループの完全な反復(complete
iteration)によってスタック上の項目の数と型が変更されるべきではありません。

@cindex endless loop
@cindex loops, endless
@example
BEGIN
  @i{code}
AGAIN
@end example

これは無限ループです。


@node Counted Loops, BEGIN loops with multiple exits, Simple Loops, Control Structures
@subsection Counted Loops
@cindex counted loops
@cindex loops, counted
@cindex @code{DO} loops

基本のカウント・ループ:
@example
@i{limit} @i{start} ?DO
  @i{body}
LOOP
@end example

これは、 @i{start} から始まり @i{limit} まで(@i{limit} 自身は除く)、 各整数値に対して 1 回の反復を実行します。
カウンタ、 つまりインデックスには、 @code{i} を使用してアクセスできます。 たとえば、 以下のループをご覧ください:
@example
10 0 ?DO
  i .
LOOP
@end example
@noindent
出力: @code{0 1 2 3 4 5 6 7 8 9}

最も内側のループのインデックスには @code{i} を使用してアクセスでき、 その一つ外側のループのインデックスには @code{j}
を使用してアクセスでき、 さらにもう一つ外側のループのインデックスには @code{k} を使用してアクセスできます。

@code{i'} を使用すると最も内側のループの limit にアクセスでき、 @code{delta-i} を使用すると @code{i'} -
@code{i} にアクセスできます。

@example
: foo 7 5 ?do cr i . i' . delta-i . loop ; 
@end example

出力:

@example
5 7 2 
6 7 1
@end example

ループ制御データはリターン・スタックに保持されるため、 リターン・スタックへのアクセスとカウント・ループ・ワードの混在にはいくつかの制限があります。
特に、ループの外側のリターン・スタックに値を置いた場合、 ループ内で値を読み取る事はできません@footnote{ええ、まぁ、
移植可能な方法ではできません、 ぐらいな}。 ループ内のリターン・スタックに値を置く場合は、 ループの終了前、
およびループのインデックスにアクセスする前に値を削除する必要があります。

カウント・ループにはいくつかのバリエーションがあります:

@itemize @bullet
@item
@code{LEAVE} は、 最も内側のカウント・ループを直ちに抜け出します。 それが関係する @code{LOOP} または @code{NEXT}
の後へ実行は移ります。 例:

@example
10 0 ?DO  i DUP . 3 = IF LEAVE THEN LOOP
@end example
出力: @code{0 1 2 3}


@item
@code{UNLOOP} は、 例えば @code{EXIT} などを介しての異常なループ終了の準備を行います。 @code{UNLOOP} は、
@code{EXIT} がリターン・アドレスに到達できるように、 リターン・スタックからループ制御パラメーターを削除します(訳注: 1重ループなので
unloop 1つ。2重ループなら unloop 2つ)。 例:

@example
: demo 10 0 ?DO i DUP . 3 = IF UNLOOP EXIT THEN LOOP ." Done" ;
@end example
出力: @code{0 1 2 3}


@item
@i{start} が @i{limit} より大きい場合でも、 @code{?DO}
はループを開始します(ラップアラウンド演算(処理可能な範囲をの最後に達した後に最初に戻る事)によって両者が等しくなるまで @code{LOOP}
を反復します)。 通常、 この振る舞いは望ましくないものです。 したがって、 Gforth は (@code{?DO} の代替として、)
@code{+DO} と @code{U+DO} を提供します。 これらは、 @i{start} が @i{limit}
より大きい場合にはループを開始しません。 @code{+DO} は符号付きループ・パラメータ用で、 @code{U+DO}
は符号なしループ・パラメータ用です。

@item
@code{?DO} は @code{DO} に置き換えることはできます。 @code{DO} は、 ループ・パラメータ に関係なく、
常にループに入ります。 あなたが、 どの場合にもループに入ることを知っている場合でも @code{DO} は使用しないでください。
このような知恵はプログラムを保守していく中で無効になる傾向があり、 それゆえ @code{DO} が問題を引き起こすことになります。

@item
@code{LOOP} は @code{@i{n} +LOOP} に置き換えることができます。 これにより、インデックスが 1 ではなく @i{n}
によって更新されます。 @i{limit-1} と @i{limit} の間の境界を越えると、 ループは終了します。 例:

@example
4 0 +DO  i .  2 +LOOP
@end example
@noindent
出力: @code{0 2}

@example
4 1 +DO  i .  2 +LOOP
@end example
@noindent
出力: @code{1 3}

@item
@cindex negative increment for counted loops
@cindex counted loops with negative increment
@i{n} が負数の場合、 @code{@i{n} +LOOP} の動作は奇妙です:

@example
-1 0 ?DO  i .  -1 +LOOP
@end example
@noindent
出力: @code{0 -1}

@example
0 0 ?DO  i .  -1 +LOOP
@end example
出力: なし。

私たちは @code{?DO} と @code{+LOOP} を組み合わせないことをお勧めします。  Gfors はいくつかの代替手段を提供します:

@code{I}=limit の反復を含める @code{-1 +LOOP} の振る舞いが必要な場合、 @code{-[DO} または
@code{U-[DO}] でループを開始します(ここで、 @code{[} は、 包含範囲の数学的表記法(例: [1,n]
からインスピレーションを得ています):

@example
-1 0 -[DO  i .  -1 +LOOP
@end example

出力: @code{0 -1}.

@example
0 0 -[DO  i .  -1 +LOOP
@end example

出力: @code{0}

@example
0 -1 -[DO  i .  -1 +LOOP
@end example

出力: なし。

limit を除外したい場合、 代わりに @code{1 -LOOP} (または一般的には @code{@i{u} -LOOP})を使用し、
@code{?DO} または @code{-DO } または @code{U-DO} でループを開始します。 @code{-LOOP}
は、@i{limit+1} と @i{limit} の間の境界を越えたときにループを終了します。  例:

@example
-2 0 -DO  i .  1 -LOOP
@end example
@noindent
出力: @code{0 -1}

@example
-1 0 -DO  i .  1 -LOOP
@end example
@noindent
出力: @code{0}

@example
0 0 -DO  i .  1 -LOOP
@end example
@noindent
出力: なし。

残念ながら、 @code{+DO}, @code{U+DO}, @code{-DO}, @code{U-DO}, @code{-LOOP} は 標準
Forth では定義されていません。 ただし、 標準のワードのみを使用するこれらのワードの実装が @file{compat/loops.fs}
にて提供されています。

@item
@cindex iterate over array
@cindex array, iterating over
よくある作業は、 配列の要素を前方または後方に反復処理することです。  要素のアドレスに対して反復処理することには 2 つの利点があります。
配列の開始アドレスを保持する必要がなくなり、 データ・スタックの負荷が軽減されます。 また、 反復ごとにアドレス計算を実行する必要がなくなります。
欠点は、 通常の配列表現 @i{addr u要素} または @i{addr uバイト} から始めて、 start アドレスと limit
アドレスを生成するために何らかの処理が必要なことです。  Gforth には、@i{addr ubytes} 表現からそこに到達するために
@code{bounds} があるため、セル配列 @code{v} を介した前方ループを以下のように記述できます:

@example
create v 1 , 3 , 7 ,
: foo v 3 cells bounds U+DO i @ . cell +LOOP ;
foo
@end example

これは @code{1 3 7} を出力します。  逆方向にたどるための入力の前処理はより複雑であるため、 Gforth はそれを行う
@code{MEM-DO} … @code{LOOP} 形式のループ構造を提供します。 これは @i{addr uバイト}
表現の配列と要素サイズを受け取り、 要素のアドレスを逆順に反復処理します。

@example
create v 1 , 3 , 7 ,
: foo1 v 3 cell array>mem MEM-DO i @ . LOOP ;
foo1
@end example

これは @code{7 3 1} を出力します。@code{ARRAY>MEM} は @i{addr uelems uelemsize} を
@code{MEM-DO} が期待する @i{addr ubytes uelemsize} に変換します(ubytes は uelems *
uelmsize です)。  このループは @code{MEM-DO} 通過後に@i{uelemsize} ずつ減算される、 @code{LOOP}
と対になるループとなります。

Gforth は、 完全を期すために @code{MEM+DO} も追加します。  @code{MEM-DO} と同一のパラメータを受け取りますが、
配列を順(forwards)に処理します:

@example
create v 1 , 3 , 7 ,
: foo2 v 3 cell array>mem MEM+DO i @ . LOOP ;
foo2
@end example

出力: @code{1 3 7}

@item
@cindex @code{FOR} loops
別のカウント・ループ:
@example
@i{n}
FOR
  @i{body}
NEXT
@end example
これは、 @code{?DO} ループを適切に最適化するのが面倒な、 ネイティブ・コード・コンパイラ作成者達が好むループです。 このループ構造は標準
Forth では定義されていません。  Gforth では、 このループは @i{n+1} 回繰り返します。 @code{i} は、 @i{n}
で始まり 0 で終わる値を生成します。 他の Forth システムは、@code{FOR} ループをサポートしている場合でも、
振る舞いが異なる場合があります。 この問題を回避するには、 @code{FOR} ループを使用しないようにしてください。

@end itemize

カウント・ループ・ワード群:

@findex ?DO ( @var{ compilation -- do-sys ; run-time w1 w2 -- | loop-sys   } ) core-ext
@cindex @code{?DO}
@kindex ?DO
@format
@code{?DO} ( @i{compilation -- do-sys ; run-time w1 w2 -- | loop-sys  }) core-ext ``question-do''
@end format
@xref{Counted Loops}.


@findex +DO ( @var{ compilation -- do-sys ; run-time n1 n2 -- | loop-sys   } ) gforth-0.2
@cindex @code{+DO}
@kindex +DO
@format
@code{+DO} ( @i{compilation -- do-sys ; run-time n1 n2 -- | loop-sys  }) gforth-0.2 ``plus-do''
@end format
@xref{Counted Loops}.


@findex U+DO ( @var{ compilation -- do-sys ; run-time u1 u2 -- | loop-sys   } ) gforth-0.2
@cindex @code{U+DO}
@kindex U+DO
@format
@code{U+DO} ( @i{compilation -- do-sys ; run-time u1 u2 -- | loop-sys  }) gforth-0.2 ``u-plus-do''
@end format
@xref{Counted Loops}.


@findex bounds ( @var{ addr u -- addr+u addr  } ) gforth-0.2
@cindex @code{bounds}
@kindex bounds
@format
@code{bounds} ( @i{addr u -- addr+u addr }) gforth-0.2 ``bounds''
@end format
開始アドレス @i{addr} と長さ @i{u} で表されるメモリ・ブロックを指定すると、 @code{u+do} または @code{?do}
の終了アドレス @i{addr+u} と開始アドレス @i{addr} を正しい順序で生成します。

@findex -[do ( @var{ compilation -- do-sys ; run-time n1 n2 -- | loop-sys   } ) gforth-experimental
@cindex @code{-[do}
@kindex -[do
@format
@code{-[do} ( @i{compilation -- do-sys ; run-time n1 n2 -- | loop-sys  }) gforth-experimental ``minus-bracket-do''
@end format
負の方向へカウントされるループを開始します。 @i{n2}<@i{n1} の場合、 ループをスキップします。 このようなカウント・ループは、
増分が負である @code{+loop} と対になります。 @code{I}>=@i{n1} である限り実行されます。


@findex u-[do ( @var{ compilation -- do-sys ; run-time u1 u2 -- | loop-sys   } ) gforth-experimental
@cindex @code{u-[do}
@kindex u-[do
@format
@code{u-[do} ( @i{compilation -- do-sys ; run-time u1 u2 -- | loop-sys  }) gforth-experimental ``u-minus-bracket-do''
@end format
負の方向へカウントするループを開始します。 @i{u2}<@i{u1} の場合、ループをスキップします。 このようなカウント・ループは、 増分が負の
@code{+loop} と対になります。  @code{I}>=@i{u1} である限り実行されます。


@findex -DO ( @var{ compilation -- do-sys ; run-time n1 n2 -- | loop-sys   } ) gforth-0.2
@cindex @code{-DO}
@kindex -DO
@format
@code{-DO} ( @i{compilation -- do-sys ; run-time n1 n2 -- | loop-sys  }) gforth-0.2 ``minus-do''
@end format
@xref{Counted Loops}.


@findex U-DO ( @var{ compilation -- do-sys ; run-time u1 u2 -- | loop-sys   } ) gforth-0.2
@cindex @code{U-DO}
@kindex U-DO
@format
@code{U-DO} ( @i{compilation -- do-sys ; run-time u1 u2 -- | loop-sys  }) gforth-0.2 ``u-minus-do''
@end format
@xref{Counted Loops}.


@code{array>mem} ( @i{uelements uelemsize -- ubytes uelemsize}) \ ubytes は
uelements * uelementsize です
@findex mem+do ( @var{ compilation -- w xt do-sys; run-time addr ubytes +nstride --   } ) gforth-experimental
@cindex @code{mem+do}
@kindex mem+do
@format
@code{mem+do} ( @i{compilation -- w xt do-sys; run-time addr ubytes +nstride --  }) gforth-experimental ``mem-plus-do''
@end format
@code{I} を @i{addr} から開始し、 @code{I}<@i{addr}+@i{ubytes} である限り、 @i{nstride}
幅のステップでメモリ内をアドレスが増える方向にカウント・アップするカウント・ループを開始します。 @i{loop} と対にする必要があります。


@findex mem-do ( @var{ compilation -- w xt do-sys; run-time addr ubytes +nstride --   } ) gforth-experimental
@cindex @code{mem-do}
@kindex mem-do
@format
@code{mem-do} ( @i{compilation -- w xt do-sys; run-time addr ubytes +nstride --  }) gforth-experimental ``mem-minus-do''
@end format
@code{I} を @i{addr}+@i{ubytes}-@i{ustride} として開始し、 @code{I}>=@i{addr} である間
-@i{nstride} 幅のステップでメモリをアドレス下位方向(backward)にステップするカウント・ループを開始します。 @i{loop}
と対にしなければなりません。


@findex DO ( @var{ compilation -- do-sys ; run-time w1 w2 -- loop-sys   } ) core
@cindex @code{DO}
@kindex DO
@format
@code{DO} ( @i{compilation -- do-sys ; run-time w1 w2 -- loop-sys  }) core ``DO''
@end format
@xref{Counted Loops}.


@findex FOR ( @var{ compilation -- do-sys ; run-time u -- loop-sys   } ) gforth-0.2
@cindex @code{FOR}
@kindex FOR
@format
@code{FOR} ( @i{compilation -- do-sys ; run-time u -- loop-sys  }) gforth-0.2 ``FOR''
@end format
@xref{Counted Loops}.


@findex LOOP ( @var{ compilation do-sys -- ; run-time loop-sys1 -- | loop-sys2   } ) core
@cindex @code{LOOP}
@kindex LOOP
@format
@code{LOOP} ( @i{compilation do-sys -- ; run-time loop-sys1 -- | loop-sys2  }) core ``LOOP''
@end format
@xref{Counted Loops}.


@findex +LOOP ( @var{ compilation do-sys -- ; run-time loop-sys1 n -- | loop-sys2   } ) core
@cindex @code{+LOOP}
@kindex +LOOP
@format
@code{+LOOP} ( @i{compilation do-sys -- ; run-time loop-sys1 n -- | loop-sys2  }) core ``plus-loop''
@end format
@xref{Counted Loops}.


@findex -LOOP ( @var{ compilation do-sys -- ; run-time loop-sys1 u -- | loop-sys2   } ) gforth-0.2
@cindex @code{-LOOP}
@kindex -LOOP
@format
@code{-LOOP} ( @i{compilation do-sys -- ; run-time loop-sys1 u -- | loop-sys2  }) gforth-0.2 ``minus-loop''
@end format
@xref{Counted Loops}.


@findex NEXT ( @var{ compilation do-sys -- ; run-time loop-sys1 -- | loop-sys2   } ) gforth-0.2
@cindex @code{NEXT}
@kindex NEXT
@format
@code{NEXT} ( @i{compilation do-sys -- ; run-time loop-sys1 -- | loop-sys2  }) gforth-0.2 ``NEXT''
@end format
@xref{Counted Loops}.


@findex i ( @var{ R:n -- R:n n  } ) core
@cindex @code{i}
@kindex i
@format
@code{i} ( @i{R:n -- R:n n }) core ``i''
@end format
@i{n} は、最も内側のカウント・ループのインデックスです。

@findex j ( @var{ R:n R:w1 R:w2 -- n R:n R:w1 R:w2  } ) core
@cindex @code{j}
@kindex j
@format
@code{j} ( @i{R:n R:w1 R:w2 -- n R:n R:w1 R:w2 }) core ``j''
@end format
@i{n} は、 最も内側から数えて 2 番目のカウント・ループのインデックスです。

@findex k ( @var{ R:n R:w1 R:w2 R:w3 R:w4 -- n R:n R:w1 R:w2 R:w3 R:w4  } ) gforth-0.3
@cindex @code{k}
@kindex k
@format
@code{k} ( @i{R:n R:w1 R:w2 R:w3 R:w4 -- n R:n R:w1 R:w2 R:w3 R:w4 }) gforth-0.3 ``k''
@end format
@i{n} は、 最も内側から数えて3番目のカウント・ループのインデックスです。

@findex i' ( @var{ R:w R:w2 -- R:w R:w2 w  } ) gforth-0.2
@cindex @code{i'}
@kindex i'
@format
@code{i'} ( @i{R:w R:w2 -- R:w R:w2 w }) gforth-0.2 ``i-tick''
@end format
最も内側のカウント・ループの limit

@findex delta-i ( @var{ r:ulimit r:u -- r:ulimit r:u u2  } ) gforth-1.0
@cindex @code{delta-i}
@kindex delta-i
@format
@code{delta-i} ( @i{r:ulimit r:u -- r:ulimit r:u u2 }) gforth-1.0 ``delta-i''
@end format
@i{u2}=@code{I'}-@code{I} (limit とインデックスの差)

@findex LEAVE ( @var{ compilation -- ; run-time loop-sys --   } ) core
@cindex @code{LEAVE}
@kindex LEAVE
@format
@code{LEAVE} ( @i{compilation -- ; run-time loop-sys --  }) core ``LEAVE'' @*\ 訳注: @code{LEAVE} は、 最も内側のカウンタ付きループを抜け出します。@*\       それが関係する @code{LOOP} または @code{NEXT} の直後から実行を続行します。
@end format
@xref{Counted Loops}.


@findex ?LEAVE ( @var{ compilation -- ; run-time f | f loop-sys --   } ) gforth-0.2
@cindex @code{?LEAVE}
@kindex ?LEAVE
@format
@code{?LEAVE} ( @i{compilation -- ; run-time f | f loop-sys --  }) gforth-0.2 ``question-leave'' @*\訳注: @i{f} が true なら @var{leave} します。
@end format
@xref{Counted Loops}.


@findex unloop ( @var{ R:w1 R:w2 --  } ) core
@cindex @code{unloop}
@kindex unloop
@format
@code{unloop} ( @i{R:w1 R:w2 -- }) core ``unloop''
@end format

@findex DONE ( @var{ compilation do-sys -- ; run-time --   } ) gforth-0.2
@cindex @code{DONE}
@kindex DONE
@format
@code{DONE} ( @i{compilation do-sys -- ; run-time --  }) gforth-0.2 ``DONE''
@end format
do-sys までのすべての LEAVE を解決します(訳注: loop, +loop , next 等の中で内部的に呼び出されます)。




標準では、 @i{do-sys} で @code{CS-PICK} や @code{CS-ROLL} を使用することは許可されていません。
@code{MEM+DO} と @code{MEM-DO} によって生成される do-sys を除いて、 Gforth では
@code{CS-PICK} や @code{CS-ROLL} の使用を許可しますが、 すべての @code{?DO} などに対して、
定義を介した任意の経路上に @code{UNLOOP} が正確に 1 つだけ存在すること(@code{LOOP} などの失敗経路上で
@code{UNLOOP} コンパイルするなど)を確認するのはあなたの仕事です。 また、 すべての @code{LEAVE} が（ループ終了ワードの 1
つまたは @code{DONE} を使用して)解決されていることを確認する必要があります。

@node BEGIN loops with multiple exits, General control structures with CASE, Counted Loops, Control Structures
@subsection @code{Begin} loops with multiple exits
@cindex Multiple exits from @code{begin}

カウント・ループの場合、 複数箇所で @code{leave} を使用できます。  @code{begin} ループの場合は、 以下の選択肢があります:

ループ内で @code{exit} を使用(複数記述できます)すると、 ループだけでなくコロン定義全体からも去ります。 例:

@example
: foo
  begin
    condition1 while
      condition2 if
        exit-code2 exit then
      condition3 if
        exit-code3 exit then
    ...
  repeat
  exit-code1 ;
@end example
  
このアプローチの欠点は、 ループ後に共通コードが必要な場合、 共通コードを含む別のワードで @code{foo} を包むか、 または、 それぞれの
exit-code から共通コードを呼び出す必要があることです。

もう 1 つのアプローチは、 @code{begin} ループ内で複数の @code{while} を使用することです。  追加の
@code{while} ごとにループの後ろに @code{then} を追加する必要があります。  例:

@example
begin
  condition1 while
    condition2 while
      condition3 while
again then then then
@end example

ここでは、 ループの最後に @code{again} を使用して、 各 @code{while} に @code{then} を用意しました。
@code{repeat} は @code{then} を 1 つ減らしますが、 それ以外の場合は同じ動作になります。
これが機能する理由の説明については、 @xref{Arbitrary control structures} をご覧下さい。

後で共通のコードを使用することはできますが、 上で示したように、 異なる出口(exit)に対して異なる exit-code を使用することはできません。
以下のようにすると、 これらの異なる exit-code を使用できます:

@example
begin
  condition1 while
    condition2 while
      condition3 while
again then exit-code3
else exit-code2 then
else exit-code1 then
@end example

exit-code は終了条件から比較的離れているため、 これを理解するのは比較的困難です(このような制御構造に慣れていないことも理由にはなりません)。

@node General control structures with CASE, Arbitrary control structures, BEGIN loops with multiple exits, Control Structures
@subsection General control structures with @code{case}
@cindex @code{case} as generalized control structure
@cindex general control structures (@code{case})

Gforth は、 拡張 @code{case} を提供することで、 上で説明した複数出口ループの問題を解決する追加のオプションを提供します。 この拡張
@code{case} の移植可能な実装は @file{compat/caseext.fs} にあります。

この拡張には 3 つの追加ワードがあります。  1 つ目は @code{?of} で、 @code{case}
内で(単なる同等性のテストではなく、)一般的なテストが可能です。 例:

@example
: sgn ( n -- -1|0|1 )
  ( n ) case
    dup 0 < ?of drop -1 endof
    dup 0 > ?of drop 1  endof
    \ otherwise leave the 0 on the stack
  0 endcase ;
@end example

注意: @code{endcase} は値(a value)を drop することに注意してください。 これは @code{of}
ではほとんどうまいこと機能しますが、 @code{?of} ではたいていうまいこといかないので、 今回も @code{endcase} で drop
するための値として 0 をスタック置きます。  ここでは、 @code{sgn} に渡される n は、 いずれの @code{?of}
もトリガーしない場合返り値の 0 そのものになります。

2 番目の追加ワードは @code{next-case} で、 これにより @code{case} をループに変えることができます。
出口が3つのループは以下のようになります:

@example
case
  condition1 ?of exit-code1 endof
  condition2 ?of exit-code2 endof
  condition3 ?of exit-code3 endof
  ...
next-case
common code afterwards
@end example

ご覧のとおり、 これにより、 先程議論したバリエーションの両方の問題が解決されます(@pxref{BEGIN loops with multiple
exits})。 注意: @code{endcase} とは異なり、 @code{next-case} は値をドロップしないことに注意してください。
@footnote{@code{next-case} は、 他の @code{case} ワード群とは異なり、
名前にハイフン(@code{-})が含まれています。 VFX Forth には値をドロップする @code{nextcase}
があるので、これと区別するためです。}

最後の追加ワードは @code{contof} です。 これは @code{endof} の代わりに使用され、
ループを終了する代わりに次の反復を開始します。 これは、 ダイクストラのガード付きコマンド 繰り返し: @i{do} と同様の方法で使用できます。 例:

@example
: gcd ( n1 n2 -- n )
    case
        2dup > ?of tuck - contof
        2dup < ?of over - contof
    endcase ;
@end example

ここで、 2 つの @code{?of} はループを継続する異なる方法を持っています。 どちらの @code{?of} もトリガーされない場合、 2
つの数値は等しく、gcd(最大公約数) になります。  @code{Endcase} はそれらの 1 つを削除し、もう 1 つは n として残します。

これらのワードを組み合わせることもできます。  以下は、 @code{endcase} を除く、 各 @code{case} ワードをそれぞれ 1
回使用する例です:

@example
: collatz ( u -- )
    \ print the 3n+1 sequence starting at u until we reach 1
    case
        dup .
        1 of endof
        dup 1 and ?of 3 * 1+ contof
        2/
    next-case ;
@end example

この例では、 シーケンスの現在の値をスタックに保持します。  1 の場合、 @code{of} がトリガーされ、 値が削除され、 @code{case}
構造から去ります。 奇数の場合、 @code{?of} がトリガーされ、 3n+1 が計算され、 @code{contof} で次の反復が開始されます。
それ以外の場合、 数値が偶数の場合は 2 で除算され、 @code{next-case} でループが再開されます。

@node Arbitrary control structures, Calls and returns, General control structures with CASE, Control Structures
@subsection Arbitrary control structures
@cindex control structures, user-defined

@cindex control-flow stack
標準 Forth は、 ネストされない方法での制御構造の使用を許可・サポートします。 まだ完成されてない制御構造に関する情報は、
制御フロー・スタック(control-flow stack)に保存されます。 このスタックは Forth のデータ・スタック上に実装でき、 Gforth
はそうしました。

@cindex @code{orig}, control-flow stack item
@cindex @code{dest}, control-flow stack item
@i{orig} エントリは未解決の前方分岐を表し、 @i{dest} エントリは後方分岐ターゲットを表します。 いくつかのワードは、
可能なあらゆる制御構造を構築するための基礎となります(呼び出しやコルーチンやバックトラッキングのような、 ストレージを必要とする制御構造を除く)。


@findex IF ( @var{ compilation -- orig ; run-time f --   } ) core
@cindex @code{IF}
@kindex IF
@format
@code{IF} ( @i{compilation -- orig ; run-time f --  }) core ``IF''
@end format
実行時(run-time)、 @i{f}=0 の場合、 (コンパイル時に) @i{orig} を消費する @code{THEN} (または
@code{ELSE}) の後から実行が続行されます。 それ以外の場合は、 @code{IF} の直後に続きます(@pxref{Selection})。


@findex AHEAD ( @var{ compilation -- orig ; run-time --   } ) tools-ext
@cindex @code{AHEAD}
@kindex AHEAD
@format
@code{AHEAD} ( @i{compilation -- orig ; run-time --  }) tools-ext ``AHEAD''
@end format
実行時、 (コンパイル時に) @i{orig} を消費する @code{THEN} の後から実行が続行されます(訳注: つまり、 単純に
@code{THEN} へジャンプする)。


@findex THEN ( @var{ compilation orig -- ; run-time --   } ) core
@cindex @code{THEN}
@kindex THEN
@format
@code{THEN} ( @i{compilation orig -- ; run-time --  }) core ``THEN''
@end format
(コンパイル時に) @i{orig} をプッシュした @code{IF} または @code{AHEAD} または @code{ELSE} または
@code{WHILE} は、 @code{THEN} の直後にジャンプします(@pxref{Selection})。


@findex BEGIN ( @var{ compilation -- dest ; run-time --   } ) core
@cindex @code{BEGIN}
@kindex BEGIN
@format
@code{BEGIN} ( @i{compilation -- dest ; run-time --  }) core ``BEGIN''
@end format
(コンパイル時に) @i{dest} を消費する @code{UNTIL} または @code{AGAIN} または @code{REPEAT} は、
@code{BEGIN} の直後へジャンプします(@pxref{Simple Loops})。


@findex UNTIL ( @var{ compilation dest -- ; run-time f --   } ) core
@cindex @code{UNTIL}
@kindex UNTIL
@format
@code{UNTIL} ( @i{compilation dest -- ; run-time f --  }) core ``UNTIL''
@end format
実行時、 @i{f}=0 の場合、 (コンパイル時に) @i{dest} をプッシュした @code{BEGIN} の直後から実行が続行されます。
それ以外の場合は、 @code{UNTIL}の直後から実行が続行されます(@pxref{Simple Loops})。


@findex AGAIN ( @var{ compilation dest -- ; run-time --   } ) core-ext
@cindex @code{AGAIN}
@kindex AGAIN
@format
@code{AGAIN} ( @i{compilation dest -- ; run-time --  }) core-ext ``AGAIN''
@end format
実行時、 (コンパイル時に) @i{dest} をプッシュした @code{BEGIN} の直後から実行が続行されます(@pxref{Simple
Loops})。


@findex CS-PICK ( @var{ orig0/dest0 orig1/dest1 ... origu/destu u -- ... orig0/dest0   } ) tools-ext
@cindex @code{CS-PICK}
@kindex CS-PICK
@format
@code{CS-PICK} ( @i{orig0/dest0 orig1/dest1 ... origu/destu u -- ... orig0/dest0  }) tools-ext ``c-s-pick''
@end format

@findex CS-ROLL ( @var{ destu/origu .. dest0/orig0 u -- .. dest0/orig0 destu/origu   } ) tools-ext
@cindex @code{CS-ROLL}
@kindex CS-ROLL
@format
@code{CS-ROLL} ( @i{destu/origu .. dest0/orig0 u -- .. dest0/orig0 destu/origu  }) tools-ext ``c-s-roll''
@end format

@findex CS-DROP ( @var{ dest --   } ) gforth-1.0
@cindex @code{CS-DROP}
@kindex CS-DROP
@format
@code{CS-DROP} ( @i{dest --  }) gforth-1.0 ``CS-DROP''
@end format


標準ワードの @code{CS-PICK} や @code{CS-ROLL} を使用すると、 移植可能な方法で制御フロー・スタックを操作できます。
これら無しだと制御フロー・エントリが占めるスタック項目の数を知る必要があります(多くのシステムは 1 つのセルを使用します。 Gforth では現在 4
つを使用しますが、 これは将来変更される可能性があります)。

@i{orig} は 1 回だけ解決する必要があるため、 @code{CS-PICK} は @i{dest} を pick することしかできず、 かつ、
@code{CS-DROP} は @i{dest} を drop することしかできません。

一部の標準の制御構造ワードは、 以下のワード群から構築されます:


@findex ELSE ( @var{ compilation orig1 -- orig2 ; run-time --   } ) core
@cindex @code{ELSE}
@kindex ELSE
@format
@code{ELSE} ( @i{compilation orig1 -- orig2 ; run-time --  }) core ``ELSE''
@end format
実行時、 (コンパイル時に) @i{orig} を消費する @code{THEN} の直後から実行が続行されます。 @i{orig1} をプッシュした
@code{IF} または @code{AHEAD} または @code{ELSE} または @code{WHILE} は、 @code{ELSE}
の直後にジャンプします(@pxref{Selection})。


@findex WHILE ( @var{ compilation dest -- orig dest ; run-time f --   } ) core
@cindex @code{WHILE}
@kindex WHILE
@format
@code{WHILE} ( @i{compilation dest -- orig dest ; run-time f --  }) core ``WHILE''
@end format
実行時、 @i{f}=0 の場合、 (コンパイル時の) @i{orig} を消費する @code{REPEAT} (または @code{THEN}
または @code{ELSE}) の直後から実行が継続されます。 それ以外の場合は、 @code{WHILE}
の直後から実行されます(@pxref{Simple Loops})。


@findex REPEAT ( @var{ compilation orig dest -- ; run-time --   } ) core
@cindex @code{REPEAT}
@kindex REPEAT
@format
@code{REPEAT} ( @i{compilation orig dest -- ; run-time --  }) core ``REPEAT''
@end format
実行時、 (コンパイル時に) @i{dest} をプッシュした @code{BEGIN} の直後から実行が続行されます。 @i{orig}
をプッシュした @code{WHILE} または @code{IF} または @code{AHEAD} または @code{ELSE} は、
@code{REPEAT} の直後にジャンプします(@pxref{Simple Loops})。




@noindent
Gforth は、さらにいくつかの制御構造ワードを追加します:


@findex ENDIF ( @var{ compilation orig -- ; run-time --   } ) gforth-0.2
@cindex @code{ENDIF}
@kindex ENDIF
@format
@code{ENDIF} ( @i{compilation orig -- ; run-time --  }) gforth-0.2 ``ENDIF''
@end format
@code{THEN} と同一です。


@findex ?dup-IF ( @var{ compilation -- orig ; run-time n -- n|   } ) gforth-0.2
@cindex @code{?dup-IF}
@kindex ?dup-IF
@format
@code{?dup-IF} ( @i{compilation -- orig ; run-time n -- n|  }) gforth-0.2 ``question-dupe-if''
@end format
これは、スタック・チェッカー(stack checker)などのツールでより適切に処理できるため、 イディオム「@code{?DUP
IF}」の代替として推奨されます。 しかも、 @code{?DUP IF} より速いです。


@findex ?DUP-0=-IF ( @var{ compilation -- orig ; run-time n -- n|   } ) gforth-0.2
@cindex @code{?DUP-0=-IF}
@kindex ?DUP-0=-IF
@format
@code{?DUP-0=-IF} ( @i{compilation -- orig ; run-time n -- n|  }) gforth-0.2 ``question-dupe-zero-equals-if''
@end format


@noindent
制御構造ワードのもう一つのグループ:


@findex case ( @var{ compilation  -- case-sys ; run-time  --   } ) core-ext
@cindex @code{case}
@kindex case
@format
@code{case} ( @i{compilation  -- case-sys ; run-time  --  }) core-ext ``case''
@end format
@code{case} 構造の開始。


@findex endcase ( @var{ compilation case-sys -- ; run-time x --   } ) core-ext
@cindex @code{endcase}
@kindex endcase
@format
@code{endcase} ( @i{compilation case-sys -- ; run-time x --  }) core-ext ``end-case''
@end format
@code{case} 構造を終わらせます。 x を drop して、@code{endcase} の後ろへ進みます。  x の drop は、
元の(@code{of} のみの)@code{case} 構造では便利ですが、 他の場合(特に @code{?of} を使用する場合)では(drop
する為の) x を明示的に指定する必要がある場合があります。


@findex next-case ( @var{ compilation case-sys -- ; run-time --   } ) gforth-1.0
@cindex @code{next-case}
@kindex next-case
@format
@code{next-case} ( @i{compilation case-sys -- ; run-time --  }) gforth-1.0 ``next-case''
@end format
一致する @code{case} にジャンプして、 @code{case} ループを再開します。 @code{endcase} とは異なり、
@code{next-case} はセルを drop しないことに注意してください。


@findex of ( @var{ compilation  -- of-sys ; run-time x1 x2 -- |x1   } ) core-ext
@cindex @code{of}
@kindex of
@format
@code{of} ( @i{compilation  -- of-sys ; run-time x1 x2 -- |x1  }) core-ext ``of''
@end format
x1=x2 の場合は続行します(両方を drop します)。 それ以外の場合は、 x1 をスタック上に残し、 @code{endof} または
@code{contof} の後ろにジャンプします。


@findex ?of ( @var{ compilation  -- of-sys ; run-time  f --   } ) gforth-1.0
@cindex @code{?of}
@kindex ?of
@format
@code{?of} ( @i{compilation  -- of-sys ; run-time  f --  }) gforth-1.0 ``question-of''
@end format
f が true の場合は続行します。 それ以外の場合は、 @code{endof} または @code{contof} の後ろにジャンプします。


@findex endof ( @var{ compilation case-sys1 of-sys -- case-sys2 ; run-time  --   } ) core-ext
@cindex @code{endof}
@kindex endof
@format
@code{endof} ( @i{compilation case-sys1 of-sys -- case-sys2 ; run-time  --  }) core-ext ``end-of''
@end format
@code{endcase}/@code{next-case} の後ろにジャンプして、 囲んでいる @code{case}
構造を終了(exit)します。


@findex contof ( @var{ compilation case-sys1 of-sys -- case-sys2 ; run-time  --   } ) gforth-1.0
@cindex @code{contof}
@kindex contof
@format
@code{contof} ( @i{compilation case-sys1 of-sys -- case-sys2 ; run-time  --  }) gforth-1.0 ``cont-of''
@end format
囲んでいる @code{case} にジャンプして、 @code{case} ループを再開します。



内部的には、 @i{of-sys} は @code{orig} で、 @i{case-sys} はセルとスタック深さ情報と、0 個以上の
@code{orig} と、 @code{dest} です。

@subsubsection Programming Style
@cindex control structures programming style
@cindex programming style, arbitrary control structures

読みやすさを確保するために、 任意の制御構造を直接作成せず、 必要な制御構造に対して新しい制御構造ワードを定義し、
プログラム内でこれらのワードを使用することをお勧めします。たとえば、 以下のように書く代わりに:

@example
BEGIN
  ...
IF [ 1 CS-ROLL ]
  ...
AGAIN THEN
@end example

@noindent
以下のように制御構造のワードを定義することをお勧めします。 例:

@example
: WHILE ( DEST -- ORIG DEST )
 POSTPONE IF
 1 CS-ROLL ; immediate

: REPEAT ( orig dest -- )
 POSTPONE AGAIN
 POSTPONE THEN ; immediate
@end example

@noindent
そして、 次に、 これらを使用して制御構造を作成します:

@example
BEGIN
  ...
WHILE
  ...
REPEAT
@end example

このほうがずっと読みやすいですよね。 もちろん、 @code{REPEAT} と @code{WHILE} は定義済みなので、
この例を見て改めて定義する必要はありません。

@node Calls and returns, Exception Handling, Arbitrary control structures, Control Structures
@subsection Calls and returns
@cindex calling a definition
@cindex returning from a definition

@cindex recursive definitions
呼び出す定義の名前を記述するだけで定義を呼び出すことができます。 通常、 定義はそれ自身の定義中は表示されません。 直接再帰的な定義を記述したい場合は、
@code{recursive} を使用して現在の定義を見えるようにする(使えるようにする)か、 @code{recurse}
を使用して現在の定義を直接呼び出すことができます。


@findex recursive ( @var{ compilation -- ; run-time --   } ) gforth-0.2
@cindex @code{recursive}
@kindex recursive
@format
@code{recursive} ( @i{compilation -- ; run-time --  }) gforth-0.2 ``recursive''
@end format
現在の定義中の定義をその定義内で呼び出せるように(表示できるように)し、 それ自体を再帰的に呼び出せるようにします。


@findex recurse ( @var{ ... -- ...   } ) core
@cindex @code{recurse}
@kindex recurse
@format
@code{recurse} ( @i{... -- ...  }) core ``recurse''
@end format
現在の定義の別名(alias)。



@noindent
これらのワードの使用例については @xref{Recursion Tutorial} を参照してください。

@progstyle 著者は、@code{recurse} よりも @code{recursive} を使用することを好みます。
名前で定義を呼び出す方が、 やや難解な @code{recurse} よりも説明的であるためです(名前が適切に選択されていれば)。
たとえば、クイックソートの実装では、「今、再帰呼び出しを行う」(now do a recursive
call)と読むよりも、「今、パーティションをソートする」(now sort the
partitions)と読む(そして考える)方がはるかに優れています。

相互再帰(mutual recursion)の場合は、 以下のように @code{defer} ワードを使用します:

@example
Defer foo

: bar ( ... -- ... )
 ... foo ... ;

:noname ( ... -- ... )
 ... bar ... ;
IS foo
@end example

defer された ワードについては、 @ref{Deferred Words} で詳しく説明します。

定義の終わりに達するか、 @code{EXIT} に遭遇すると、 現在の定義は呼び出し元の定義に制御を返します。

@findex EXIT ( @var{ compilation -- ; run-time nest-sys --   } ) core
@cindex @code{EXIT}
@kindex EXIT
@format
@code{EXIT} ( @i{compilation -- ; run-time nest-sys --  }) core ``EXIT''
@end format
呼び出し元の定義に戻る(return): 通常、 定義から速やかに戻るのを強制する方法として使用されます。 @code{EXIT} する前に、
リターン・スタックをクリーンアップし、 未処理の @code{?DO}...@code{LOOP} を @code{UNLOOP} する必要があります。
ローカル変数(local)が無い場合に @code{exit} のように動作するティック可能なワード(tickable word)には
@code{;s} を使用します。


@findex ?EXIT ( @var{ --   } ) gforth-0.2
@cindex @code{?EXIT}
@kindex ?EXIT
@format
@code{?EXIT} ( @i{--  }) gforth-0.2 ``?EXIT''
@end format
@i{f} が true の場合、 呼び出し元の定義に戻ります(return)。


@findex ;s ( @var{ R:w --  } ) gforth-0.2
@cindex @code{;s}
@kindex ;s
@format
@code{;s} ( @i{R:w -- }) gforth-0.2 ``semis''
@end format
@code{EXIT} によってコンパイルされたプリミティブ。



@node Exception Handling, , Calls and returns, Control Structures
@subsection Exception Handling
@cindex exceptions

@c quit is a very bad idea for error handling, 
@c because it does not translate into a THROW
@c it also does not belong into this chapter

ワードが処理できないエラー状態を検出した場合、 例外を投げる(@code{throw})ことができます。 最も単純なケースでは、
これによりプログラムが終了し、適切なエラーが報告されます。

@findex throw ( @var{ y1 .. ym nerror -- y1 .. ym / z1 .. zn error   } ) exception
@cindex @code{throw}
@kindex throw
@format
@code{throw} ( @i{y1 .. ym nerror -- y1 .. ym / z1 .. zn error  }) exception ``throw''
@end format
@i{nerror} が 0 の場合は、 それを drop して続行します。 それ以外の場合は、 動的に囲んでいる次の例外ハンドラー(next
dynamically enclosing exception handler)に制御を移し、 それに応じてスタックをリセットし、 @i{nerror}
をプッシュします。


@findex fast-throw ( @var{ ... wball -- ... wball  } ) gforth-experimental
@cindex @code{fast-throw}
@kindex fast-throw
@format
@code{fast-throw} ( @i{... wball -- ... wball }) gforth-experimental ``fast-throw''
@end format
軽量の @code{throw} バリエーション: ゼロ以外のみに使用され、 バックトレースを保存したり、 欠落している @code{catch}
を扱ったりしません。


@code{throw} は、スタック上のセル・サイズのエラー番号数値を消費します。 標準 Forth
には事前定義されたエラー番号がいくつかあります(@file{errors.fs} 参照)。  Gforth (および他のほとんどのシステム)では、
さまざまなワードによって生成された ior をエラー番号として使用できます(たとえば、 @code{allocate} の一般的な使用法は
@code{allocate throw} です)。  Gforth は、 (適切なエラー報告付きで)独自のエラー番号を定義するための
@code{Exception} というワードも提供します。 このワードの標準 Forth バージョン(ただしエラー・メッセージなし) は
@code{compat/excel.fs} で入手できます。  最後に、 あなた独自のエラー番号(-4095 〜 0
の範囲以外の任意の番号)を使用できますが、 表示されるのは適切なエラー・メッセージではなく、数字のみです。  たとえば、
以下のことを試してみてください:

@example
-10 throw                    \ 標準で定義済
-267 throw                   \ システムで定義済
s" my error" exception throw \ ユーザー定義
7 throw                      \ 思いつくままの任意の番号
@end example

@findex exception ( @var{ addr u -- n   } ) gforth-0.2
@cindex @code{exception}
@kindex exception
@format
@code{exception} ( @i{addr u -- n  }) gforth-0.2 ``exception''
@end format
@var{n} は、 -4095 〜 -256 の範囲内で以前に使用されていなかった @code{throw} 値です。
@code{Exception} を連続して呼び出すと、 連続して減少する数値が返されます。 Gforth は文字列 @var{addr u}
をエラー・メッセージとして使用します(訳注: 同じエラーメッセージを使いまわすには、 s" hoge err msg" exception
constant hoge-error hoge-error ! などとして得られた hoge-error を使いまわす。 hoge-error
throw 等する)



エラー番号を文字列に変換するためのワード(通常は POSIX の @code{strerror} をモデルにしたもの)がある場合もあります。
以下のワードを使用すると、 これらの文字列を Gforth のエラー処理に取り込むことができます:

@findex exceptions ( @var{ xt n1 -- n2   } ) gforth-1.0
@cindex @code{exceptions}
@kindex exceptions
@format
@code{exceptions} ( @i{xt n1 -- n2  }) gforth-1.0 ``exceptions''
@end format
throw時: @i{xt} @code{( +n -- c-addr u )} は、 0<=@i{n}<@i{n1}
の範囲のローカルのエラー・コードをエラー・メッセージに変換します。  @code{Exceptions} は、 n2-n1<n3<=n2 の範囲で
@i{n1} 個(0 〜 n1)のエラー・コードを予約します。 n2 に、 対応する Gforth エラー・コード(ローカルのエラー番号 0 に対応。
つまり、 0<=@i{n}<@i{n1} の範囲のローカルのエラー・コードに 対応する Gforth エラー・コードは n2 <= n3 <
n2+n1)を返します。 (後の時点で)その範囲に対応した Gforth エラー・コード @i{n3} が throw されると、 @i{n2-n3}
がプッシュされ(つまりローカルのエラー番号に変換した値をプッシュし)、 @i{xt} が実行されて、 @i{xt}
がエラー・メッセージを生成します(訳注: minos2/pulse-audio.fs 等で確認。 xt にC-interface ワードをセットし、
外部Cライブラリのエラー・メッセージを gforth 内から表示するのに使っているようだ)



たとえば、 C言語ライブラリの @code{errno} エラー (および @code{strerror} を使用した変換) がまだ Gforth
で直接サポートされていないとした場合、 以下のようにして @code{strerror} を gforth と結び付けることができます:

@example
' strerror 1536 exceptions constant errno-base
: errno-ior ( -- n )
\ n は errno の値に対応する Gforth ior を求めなければならないので、
\ ここでerrno 範囲と Gforth ior の範囲の間で変換する必要があります。
\ ERRNO は Gforth ワードではないため、
\ それにアクセスするには C インターフェイスを使用する必要があります。
  errno errno-base over - swap 0<> and ;
@end example

C言語の関数(C言語インターフェイス(C interface)を使用)を呼び出し、 その戻り値がエラーが発生したことを示している場合、
@code{errno-ior throw} を実行して、適切なエラー・メッセージ (``Permission denied''
など)を含む例外を生成できます。

フラグが true の場合、 特定の @i{err#} でエラーを投げる(@code{THROW})一般的な慣用句は以下のとおりです:

@example
@code{( flag ) 0<> @i{err#} and throw}
@end example

あなたのプログラムで、 例外をキャッチする例外ハンドラーを提供できます。  例外ハンドラーを使用すると、 問題を修正したり、
一部のデータ構造をクリーンアップして例外を次の例外ハンドラーに投げたり(throw)することができます。  @code{throw}
は動的に最も内側の例外ハンドラー(the dynamically innermost exception
handler)にジャンプすることに注意してください。 システムの例外ハンドラーは最も外側にあり、
エラーを出力してコマンド・ラインの通訳(interpretation)を再開するだけです(または、 バッチ・モード(つまり、
シェル・コマンド・ラインの処理中)では Gforth を終了します)。

例外をキャッチする標準 Forth での方法は @code{catch} です:

@findex catch ( @var{ x1 .. xn xt -- y1 .. ym 0 / z1 .. zn error   } ) exception
@cindex @code{catch}
@kindex catch
@format
@code{catch} ( @i{x1 .. xn xt -- y1 .. ym 0 / z1 .. zn error  }) exception ``catch''
@end format
@i{xt} を実行します。  実行から正常に戻った場合、 @code{catch} はスタックに 0 をプッシュします。  @code{throw}
を介して実行が戻った場合、 すべてのスタックは @code{catch} へ入る時点の深さにリセットされ、 TOS (@i{xt} の位置) は
throw コードに置き換えられます。


@findex nothrow ( @var{ --   } ) gforth-0.7
@cindex @code{nothrow}
@kindex nothrow
@format
@code{nothrow} ( @i{--  }) gforth-0.7 ``nothrow''
@end format
再 throw しない @code{catch} または @code{endtry} の後ろでこれ (または標準のシーケンス @code{[']
false catch 2drop}) を使用します。 これにより、 次の @code{throw} でバックトレースが確実に記録されます。



例外ハンドラーの最も一般的な使用法は、 エラーが発生したときに状態をクリーンアップすることです。  例：

@example
base @@ >r hex \ actually the HEX should be inside foo to protect
              \ against exceptions between HEX and CATCH
['] foo catch ( nerror|0 )
r> base !
( nerror|0 ) throw \ pass it on
@end example

@code{myerror} というエラー番号を処理するための @code{catch} の使用は以下のようになります:

@example
['] foo catch
CASE
  myerror OF ... ( do something about it ) nothrow ENDOF
  dup throw \ default: pass other errors on, do nothing on non-errors
ENDCASE
@end example

コードを別のワードでくるむ要があるのは面倒な場合が多いため、 Gforth では代替構文を提供しています:

@example
TRY
  @i{code1}
  IFERROR
    @i{code2}
  THEN
  @i{code3}
ENDTRY
@end example

これは、 @i{code1} を実行しします。 @i{code1} が正常に完了すると、 @i{code3} の実行へ続きます。   @i{code1}
または、 @code{endtry} より前で例外があった場合、 スタックは @code{try} 時の深さにリセットされ、 throw
された値をデータ・スタックにプッシュし、 @i{code2} の実行に続き、 そして、 最終的に @i{code3} に到達します。

@findex try ( @var{ compilation  -- orig ; run-time  -- R:sys1   } ) gforth-0.5
@cindex @code{try}
@kindex try
@format
@code{try} ( @i{compilation  -- orig ; run-time  -- R:sys1  }) gforth-0.5 ``try''
@end format
例外キャッチ領域の開始


@findex endtry ( @var{ compilation  -- ; run-time  R:sys1 --   } ) gforth-0.5
@cindex @code{endtry}
@kindex endtry
@format
@code{endtry} ( @i{compilation  -- ; run-time  R:sys1 --  }) gforth-0.5 ``endtry''
@end format
例外キャッチ領域の終わり


@findex iferror ( @var{ compilation  orig1 -- orig2 ; run-time  --   } ) gforth-0.7
@cindex @code{iferror}
@kindex iferror
@format
@code{iferror} ( @i{compilation  orig1 -- orig2 ; run-time  --  }) gforth-0.7 ``iferror''
@end format
例外処理コードを開始します(@code{try} と @code{endtry} の間に例外がある場合に実行されます)。 この部分は
@code{then} で終了する必要があります。



@i{code2} が必要ない場合は、 @code{iferror then} の代わりに @code{restore} を記述できます:

@example
TRY
  @i{code1}
RESTORE
  @i{code3}
ENDTRY
@end example

@cindex unwind-protect
先程の例をこの構文で身綺麗にしてみます:

@example
base @@ @{ oldbase @}
TRY
  hex foo \ now the hex is placed correctly
  0       \ value for throw
RESTORE
  oldbase base !
ENDTRY
throw
@end example

このバリエーションの追加の利点は、 @code{restore} と @code{endtry} の間の例外(たとえば、 ユーザーが
@kbd{Ctrl-C} を押すことによる例外)でも、 @code{restore} の直後へコードの実行が移ることです。 ゆえに、
いかなる状況であっても base は復元されます。

ただし、 このコード自体が例外を引き起こさないようにする必要があります。 そうしないと、 @code{iferror}/@code{restore}
コードがループします。  さらに、 @code{iferror}/@code{restore} コードで必要なスタックの内容が @code{try} と
@code{endtry} の間のあらゆる場所に存在することも確認する必要があります。 この例では、 これは @code{try}
の前にデータをローカル変数(local)に置くことによって実現されます(リターン・スタック上の例外フレーム(@i{sys1})が邪魔なのでリターン・スタックは使用できません)。

この種の使用法は、 Lisp の @code{unwind-protect} と同様のものです。

@cindex @code{recover} (old Gforth versions)
もし、あなたが、 この例外再開始(exception-restarting)の振る舞いを望まない場合は、 以下のようにしてください:

@example
TRY
  @i{code1}
ENDTRY-IFERROR
  @i{code2}
THEN
@end example

@i{code1} に例外がある場合は @i{code2} が実行され、 それ以外の場合は @code{then} の後ろ (または
@code{else} 分岐の可能性あり) から実行が続行されます。 これはバージョン 0.7 より前の Gforth では以下の構成要素に該当します

@example
TRY
  @i{code1}
RECOVER
  @i{code2}
ENDTRY
@end example

つまり、 この @code{recover} を使用しているコードを直に @code{try ... entry-iferror ... then}
へと置き換えることができます。 ただし、 その置き換え作業中に他の @code{try}
バリエーションのいずれかを使用した方が良いかどうかも検討することをお勧めします。

移行を容易にするために、 Gforth は 2 つの互換性ファイルを提供します:  1つ目は @file{endtry-iferror.fs} で、
古いシステム用に @code{try ... endtry-iferror ... then} 構文を提供します(ただし、 @code{iferror}
または @code{restore} は提供しません)。 2つ目の @file{recover-endtry.fs} は、 新しいシステム上で古い構文の
@code{try ... recover ... endtry} 構文を提供するので、 古いプログラムを実行するための一時しのぎとして使用できます。
どちらのファイルもどのシステムでも動作します(システムが、 実装する構文を既に定義済みの場合は何も行わないだけです)。 そのため、
古いシステムと新しいシステムを混在させて使用している場合でも、 これらのファイルのいずれかを無条件に @code{require} することができます。

@findex restore ( @var{ compilation  orig1 -- ; run-time  --   } ) gforth-0.7
@cindex @code{restore}
@kindex restore
@format
@code{restore} ( @i{compilation  orig1 -- ; run-time  --  }) gforth-0.7 ``restore''
@end format
コードの復元(restore)を開始します。 これは、 例外がある場合と無い場合に行われます。


@findex endtry-iferror ( @var{ compilation  orig1 -- orig2 ; run-time  R:sys1 --   } ) gforth-0.7
@cindex @code{endtry-iferror}
@kindex endtry-iferror
@format
@code{endtry-iferror} ( @i{compilation  orig1 -- orig2 ; run-time  R:sys1 --  }) gforth-0.7 ``endtry-iferror''
@end format
例外キャッチ領域を終了し、 その領域外で例外処理コードを開始します(@code{try} と @code{endtry-iferror}
の間に例外がある場合に実行されます)。  この部分は @code{then} (または @code{else}...@code{then})
で終了する必要があります。



ここで、 エラー処理の例を以下に示します:

@example
TRY
  foo
ENDTRY-IFERROR
  CASE
    myerror OF ... ( do something about it ) nothrow ENDOF
    throw \ pass other errors on
  ENDCASE
THEN
@end example

@progstyle いつものように、 エラーを渡すための @code{throw} の後、 または @code{ENDTRY}
の後のいずれか(または、@code{catch} を使用する場合は、エラーを処理するための選択構造の終了後)で、
スタックの深さが静的に明白であることを保証する必要があります。

@code{throw} の代替は 2 つあります: @code{Abort"} は条件付きでエラー・メッセージを提供できます。
@code{Abort} は「中止」(Abort)エラーを生成するだけです。

これらのワードの問題は、 例外ハンドラーが、 異なる @code{abort"} を区別できないことです。 例外ハンドラーにとってはそれらは
@code{-2 throw} のように見えるだけです(標準のプログラムではエラー・メッセージにアクセスできません)。 同様に、
@code{abort} は例外ハンドラーに対して @code{-1 throw} のように見えます。

@findex ABORT" ( @var{ compilation 'ccc"' -- ; run-time f --   } ) core,exception-ext
@cindex @code{ABORT"}
@kindex ABORT"
@format
@code{ABORT"} ( @i{compilation 'ccc"' -- ; run-time f --  }) core,exception-ext ``abort-quote''
@end format
@i{f} のいずれかのビットがゼロ以外の場合、 @code{-2 throw} の機能を実行し、 例外スタック上例外フレームがない場合は文字列
@i{ccc} を表示します。


@findex abort ( @var{ ?? -- ??   } ) core,exception-ext
@cindex @code{abort}
@kindex abort
@format
@code{abort} ( @i{?? -- ??  }) core,exception-ext ``abort''
@end format
@code{-1 throw}.



実行を中止する必要があるほど深刻でない問題の場合は、 警告を表示するだけで済みます。  変数 @code{warnings} を使用すると、
表示される警告の数を調整できます。

@findex WARNING" ( @var{ compilation 'ccc"' -- ; run-time f --   } ) gforth-1.0
@cindex @code{WARNING"}
@kindex WARNING"
@format
@code{WARNING"} ( @i{compilation 'ccc"' -- ; run-time f --  }) gforth-1.0 ``WARNING"''
@end format
@i{f} がゼロ以外の場合、 警告メッセージとして文字列 @i{ccc} を表示します。


@findex warnings ( @var{ -- addr   } ) gforth-0.2
@cindex @code{warnings}
@kindex warnings
@format
@code{warnings} ( @i{-- addr  }) gforth-0.2 ``warnings''
@end format
以下の警告レベルをセットしてください
@table @code
@item 0
警告オフ
@item -1
通常警告オン
@item -2
初心者警告オン
@item -3
偏執狂的警告オン
@item -4
全ての警告をエラーとして扱います(初心者警告を含む)
@end table



@c -------------------------------------------------------------
@node Defining Words, Interpretation and Compilation Semantics, Control Structures, Words
@section Defining Words
@cindex defining words

定義ワード(defining word)は、 ディクショナリに新しいエントリを作成することによって Forth を拡張するために使用されます。

@menu
* CREATE::
* Variables::                Variables and user variables
* Constants::
* Values::                   Initialised variables
* Varues::
* Colon Definitions::
* Anonymous Definitions::    名前無しのワード定義
* Quotations::
* Supplying names::          定義ワードの名前を文字列として渡す
* User-defined Defining Words::
* Deferred Words::           前方参照の許容
* Forward::                  自動解決される前方参照
* Aliases::                  
@end menu

@node CREATE, Variables, Defining Words, Defining Words
@subsection @code{CREATE}
@cindex simple defining words
@cindex defining words, simple

定義ワードは、 ディクショナリに新しいエントリを作成するために使用されます。 最も単純な定義ワードは @code{CREATE} です。
@code{CREATE} は以下のように使用します:

@example
CREATE new-word1
@end example

@code{CREATE} はパース・ワード(parsing word)です。
つまり、入力ストリームから引数(argument)を受け取ります(この例では @code{new-word1} です)。 @code{CREATE} は
@code{new-word1} のディクショナリ・エントリを作成します。  @code{new-word1} が実行される時は、
アドレスがスタックに残されるだけです。 そのアドレスは、 @code{new-word1}
が定義された時点のデータ空間ポインタ(@code{HERE})の値を表します。したがって、 @code{CREATE}
は名前をメモリ領域のアドレスに関連付ける方法です。

@findex Create ( @var{ "name" --   } ) core
@cindex @code{Create}
@kindex Create
@format
@code{Create} ( @i{"name" --  }) core ``Create''
@end format


注意: 標準 Forth は、 @code{create} に対してのみ、 そのボディ部分がディクショナリのデータ空間(つまり、 @code{here}
や @code{allot} などが機能する空間。 @pxref{Dictionary
allocation})にあることを保証することに注意してください。  また、 標準 Forth では、 @code{does>} で変更できるのは
@code{create} で作成されたワードのみで(@pxref{User-defined Defining Words})、 標準 Forth の
@code{>body} は @code{create} されたワードにのみ適用できます。

この new-word1 の例を拡張して、 データ空間にメモリを少々確保すると、 最終的には @i{variable} のような代物になります。
これを行う 2 つの異なる方法を以下に示します:

@example
CREATE new-word2 1 cells allot  \ 1 セル予約 - 初期値未定義
CREATE new-word3 4 ,            \ 1 セル予約 かつ (4で)初期化
@end example

これらの変数は、 以下のように @code{@@} (「フェッチ」(fetch;取り出す)) と @code{!}
(「ストア」(store;格納する)) を使用して検査(examine)および変更(modify)できます:

@example
new-word2 @@ .      \ get address, fetch from it and display
1234 new-word2 !   \ new value, get address, store to it
@end example

@cindex arrays
同様のメカニズムを使用して配列を作成できます。 たとえば、 80 文字のテキスト入力バッファーです:

@example
CREATE text-buf 80 chars allot

text-buf 0 chars + c@@ \ the 1st character (offset 0)
text-buf 3 chars + c@@ \ the 4th character (offset 3)
@end example

メモリに適切な領域を割り当てることで、 思いつく限りの複雑なデータ構造を構築できます。 これについてさらに詳しく説明し、 それを容易にする Gforth
ツールについて知りたい場合は、 @xref{Structures} を参照ください。


@node Variables, Constants, CREATE, Defining Words
@subsection Variables
@cindex variables

前のセクションでは、 一連のコマンドを使用して変数を生成する方法を説明しました。 最終的な改良として、
(次のセクションの主題を先取りして)そのコード・シーケンス全体を定義ワードでまとめることができ、 新しい変数の作成が容易になります:

@example
: myvariableX ( "name" -- a-addr ) CREATE 1 cells allot ;
: myvariable0 ( "name" -- a-addr ) CREATE 0 , ;

myvariableX foo \ variable foo starts off with an unknown value
myvariable0 joe \ whilst joe is initialised to 0

45 3 * foo !   \ set foo to 135
1234 joe !     \ set joe to 1234
3 joe +!       \ increment joe by 3.. to 1237
@end example

当然のことながら、 Forth にはすでに @code{Variable} の定義があるため、 @code{myvariable}
を定義する必要はありません。 標準 Forth は、 @code{Variable} が作成時に初期化されることを保証しません(つまり、
@code{myvariableX} のように振る舞う可能性があります)。 対照的に、Gforth の @code{Variable} は変数を 0
に初期化します(つまり、 @code{myvariable0} とまったく同じように振る舞います)。 Forth は、
2倍長変数と浮動小数点変数に対して、 それぞれ @code{2Variable} と @code{fvariable} も提供します。
これらは、Gforth ではそれぞれ 0. と 0e に初期化されます。 @code{Variable} を使用してブール値を保存する場合、
@code{on} と @code{off} を使用してその状態を切り替えることができます。

@findex Variable ( @var{ "name" --   } ) core
@cindex @code{Variable}
@kindex Variable
@format
@code{Variable} ( @i{"name" --  }) core ``Variable''
@end format
@i{name} を定義し、 @i{addr} で始まるセルを予約します。  @i{name} 実行時: @code{( -- addr )}


@findex AVariable ( @var{ "name" --   } ) gforth-0.2
@cindex @code{AVariable}
@kindex AVariable
@format
@code{AVariable} ( @i{"name" --  }) gforth-0.2 ``AVariable''
@end format
@code{variable} と同様に機能しますが、
(クロス・コンパイルされたコードで使用される場合)その変数に格納されているセルがアドレスであることをクロス・コンパイラーに伝えます。


@findex 2Variable ( @var{ "name" --   } ) double
@cindex @code{2Variable}
@kindex 2Variable
@format
@code{2Variable} ( @i{"name" --  }) double ``two-variable''
@end format

@findex fvariable ( @var{ "name" --   } ) floating
@cindex @code{fvariable}
@kindex fvariable
@format
@code{fvariable} ( @i{"name" --  }) floating ``f-variable''
@end format


最後に、 任意の長さのバッファーは以下のようになります

@findex buffer: ( @var{ u "name" --   } ) core-ext
@cindex @code{buffer:}
@kindex buffer:
@format
@code{buffer:} ( @i{u "name" --  }) core-ext ``buffer-colon''
@end format
@i{name} を定義し、@i{addr} から始まる @i{u} バイトを予約します。  @i{name} 実行時: @code{( -- addr
)}  なお、 Gforth は予約したバイトを 0 に初期化しますが、 標準では保証されません。



@comment TODO is that stuff about user variables strictly correct? Is it
@comment just terminal tasks that have user variables?
@comment should document tasker.fs (with some examples) elsewhere
@comment in this manual, then expand on user space and user variables.

@node Constants, Values, Variables, Defining Words
@subsection Constants
@cindex constants

@code{constant} を使用すると、 固定値を宣言し、 名前でそれを参照できます。 例:

@example
12 Constant INCHES-PER-FOOT
3E+08 fconstant SPEED-O-LIGHT
@end example

@code{Variable} は読み取りと書き込みの両方ができるため、 その実行時の振る舞いは、 現在の値を操作できるアドレスを提供することです。
それとは対照的に、 @code{Constant} の値は一度宣言すると変更できないため、 アドレスを指定する必要はありません@footnote{まあ、
多くの場合、 それは可能ではありますが、 標準的な移植可能な方法では変更できません。 @code{Value} を使用する方が安全です
(続きを読んでください)まあ、多くの場合変更できますが、標準的な移植可能な方法では変更できません。 @code{Value} (続きを読んでください)}
-- 定数の値を直接返す方が効率的です。 そして正にそのとおりになります。 つまり、
定数の実行時の効果は、その値をスタックの頂上に置くことです((@code{Constant} を実装する方法の1つは @ref{User-defined
Defining Words} で見つけることができます)。

Forth は、それぞれ2倍長定数と浮動小数点定数を定義するための @code{2Constant} と @code{fconstant}
も提供します。

@findex Constant ( @var{ w "name" --   } ) core
@cindex @code{Constant}
@kindex Constant
@format
@code{Constant} ( @i{w "name" --  }) core ``Constant''
@end format
定数 @i{name} を値 @i{w} で定義します。
 
@i{name} 実行時: @i{-- w}


@findex AConstant ( @var{ addr "name" --   } ) gforth-0.2
@cindex @code{AConstant}
@kindex AConstant
@format
@code{AConstant} ( @i{addr "name" --  }) gforth-0.2 ``AConstant''
@end format
@code{constant} と似ていますが、 アドレスのための定数を定義します(これはクロス・コンパイラーでのみ違いが生じます)。


@findex 2Constant ( @var{ w1 w2 "name" --   } ) double
@cindex @code{2Constant}
@kindex 2Constant
@format
@code{2Constant} ( @i{w1 w2 "name" --  }) double ``two-constant''
@end format

@findex fconstant ( @var{ r "name" --   } ) floating
@cindex @code{fconstant}
@kindex fconstant
@format
@code{fconstant} ( @i{r "name" --  }) floating ``f-constant''
@end format


@c that's too deep, and it's not necessarily true for all ANS Forths. - anton
@c nac-> How could that not be true in an ANS Forth? You can't define a
@c constant, use it and then delete the definition of the constant..

@c anton->An ANS Forth system can compile a constant to a literal; On
@c decompilation you would see only the number, just as if it had been used
@c in the first place.  The word will stay, of course, but it will only be
@c used by the text interpreter (no run-time duties, except when it is 
@c POSTPONEd or somesuch).

@c nac:
@c I agree that it's rather deep, but IMO it is an important difference
@c relative to other programming languages.. often it's annoying: it
@c certainly changes my programming style relative to C.

@c anton: In what way?

Forth の定数は、他のプログラミング言語の定数とは異なる振る舞いをします。 他の言語では、 定数(アセンブラの EQU や C の #define
など)はコンパイル時にのみ存在します。 実行プログラム(executable program)では、 定数は即値(absolute
number)に変換されているため、 シンボリック・デバッガを使用しない限り、 その数値がどのような抽象的なものを表しているかを知ることは不可能です。
Forth では、 定数はヘッダー空間にエントリを持ち、 それを使用するコードが定義された後もそこに残ります。 実際、 実行時に機能する義務があるため、
それをディクショナリに残しておく必要があります。 例:

@example
12 Constant INCHES-PER-FOOT
: FEET-TO-INCHES ( n1 -- n2 ) INCHES-PER-FOOT * ;
@end example

@cindex in-lining of constants
ここで、 @code{FEET-TO-INCHES} が実行されると、 定数 @code{INCHES-PER-FOOT} に関連付けられた xt
が実行されます。 @code{see} を使用して @code{FEET-TO-INCHES} の定義を逆コンパイルすると、
@code{INCHES-PER-FOOT} を呼び出していることがわかります。 一部の Forth
コンパイラは、定数を使用する場所にインライン展開(in-lining)することによって定数を最適化しようとします。 以下のようにして Gforth
に定数をインライン化するように強制できます:

@example
: FEET-TO-INCHES ( n1 -- n2 ) [ INCHES-PER-FOOT ] LITERAL * ;
@end example

ここで、 @code{see} を使用して @code{FEET-TO-INCHES} の このバージョンを逆コンパイルすると、
@code{INCHES-PER-FOOT} が存在しないことがわかります。 これがどのように機能するかを理解するには、
@ref{Interpret/Compile states} と @ref{Literals} を読んでください。

この方法で定数をインライン化すると、 実行時間がわずかに改善される可能性があり、 定数がコンパイル時にのみ参照されるようにすることができます。 ただし、
定数の定義はまだディクショナリに残っています。 一部の Forth コンパイラは、 一時的なワード(transient words)を保持する 2
番目のディクショナリを制御するメカニズムを提供し、 メモリ領域を回復するために後でこの 2 番目のディクショナリを削除できるようしています。 ただし、
これを行う標準の方法はありません。


@node Values, Varues, Constants, Defining Words
@subsection Values
@cindex values

@code{Value} は @code{Constant} のように動作しますが、 変更することができます。 @code{TO}
は、@code{Values} を変更するパース・ワード(parsing word)です。 (標準 Forth ではなく) Gforth では、
@code{>body} を使用しても @code{value} にアクセス(および変更)できます。

ここで幾つか例を示します:

@example
12 Value APPLES     \ APPLES を初期値 12 で定義
34 TO APPLES        \ APPLES の値を変更。 TO はパース・ワード
1 ' APPLES >body +! \ APPLES をインクリメント。 非標準の使い方
APPLES              \ スタック頂上に 35 を置く(はず)
@end example

@findex Value ( @var{ w "name" --   } ) core-ext
@cindex @code{Value}
@kindex Value
@format
@code{Value} ( @i{w "name" --  }) core-ext ``Value''
@end format
@i{name} を初期値 @i{w} で定義します。 この値は @code{to @i{name}} または @code{->@i{name}}
で変更できます(訳注: -> と name の間に空白を開けない。 ->name とする。 ワードではなく、
テキスト・インタプリタの認識器(recognizer)機能によるもの)。
 
@i{name} 実行時: @i{-- w2}


@findex AValue ( @var{ w "name" --   } ) gforth-0.6
@cindex @code{AValue}
@kindex AValue
@format
@code{AValue} ( @i{w "name" --  }) gforth-0.6 ``AValue''
@end format
@code{value} と似ていますが、 アドレスの為の値を定義します(これはクロス・コンパイラーでのみ違いが生じます)。


@findex 2Value ( @var{ d "name" --   } ) double-ext
@cindex @code{2Value}
@kindex 2Value
@format
@code{2Value} ( @i{d "name" --  }) double-ext ``two-value''
@end format

@findex fvalue ( @var{ r "name" --   } ) floating-ext
@cindex @code{fvalue}
@kindex fvalue
@format
@code{fvalue} ( @i{r "name" --  }) floating-ext ``f-value''
@end format
実行時: @code{( -- r1 )} な @i{name} を定義します。 ここで @i{r} は初期値です。 値は @code{to
@i{name}} または @code{->@i{name}} で変更できます。


@findex TO ( @var{ value "name" --   } ) core-ext
@cindex @code{TO}
@kindex TO
@format
@code{TO} ( @i{value "name" --  }) core-ext ``TO''
@end format
@var{name} の値を @var{value} に変更します


@findex +TO ( @var{ value "name" --   } ) gforth-1.0
@cindex @code{+TO}
@kindex +TO
@format
@code{+TO} ( @i{value "name" --  }) gforth-1.0 ``+TO''
@end format
@var{name} の値に @var{value} を足し込みます



@node Varues, Colon Definitions, Values, Defining Words
@subsection Varues
@cindex varues

(訳注: vaLue ではなくて vaRue) value のようなワードでアドレスを取得したい場合があります。 これにはいくつかの欠点があるため、
Gforth では、 これについて明示的に指定し、 @code{varue}を使用して名前を宣言するように求めます(variable と value
の特性を組み合わせたものであるため、 そのように名付けられました)。

@findex Varue ( @var{ w "name" --   } ) gforth-1.0
@cindex @code{Varue}
@kindex Varue
@format
@code{Varue} ( @i{w "name" --  }) gforth-1.0 ``Varue''
@end format
@code{value} と似ていますが、 @code{addr @i{name}} で得たアドレスで値にアクセスすることもできます。 将来的には、
varues の効率が values よりも低くなる可能性があります。


@findex 2varue ( @var{ x1 x2 "name" --   } ) gforth-1.0
@cindex @code{2varue}
@kindex 2varue
@format
@code{2varue} ( @i{x1 x2 "name" --  }) gforth-1.0 ``2varue''
@end format
@code{2value} と似ていますが、 @code{addr @i{name}} で得たアドレスで値にアクセスすることもできます。
将来的には、2varues は 2values よりも効率が低くなる可能性があります。


@findex fvarue ( @var{ r "name" --   } ) gforth-1.0
@cindex @code{fvarue}
@kindex fvarue
@format
@code{fvarue} ( @i{r "name" --  }) gforth-1.0 ``fvarue''
@end format
@code{fvalue} と似ていますが、 @code{addr @i{name}} で得たアドレスで値にアクセスすることもできます。
将来的には、fvarues は fvalues よりも効率が低くなる可能性があります。


@findex addr ( @var{ "name" -- addr   } ) gforth-1.0
@cindex @code{addr}
@kindex addr
@format
@code{addr} ( @i{"name" -- addr  }) gforth-1.0 ``addr''
@end format
varue @var{name} または 2varue @var{name} または fvarue @var{name} のアドレスを提供します。
または @code{wa: ca: da: fa: xta:} のいずれかで定義されたローカル変数 @i{name} のアドレスを提供します。



@node Colon Definitions, Anonymous Definitions, Varues, Defining Words
@subsection Colon Definitions
@cindex colon definitions

@example
: name ( ... -- ... )
    word1 word2 word3 ;
@end example

@noindent
@code{name} というワードを作成し、 実行時に @code{word1 word2 word3} を実行します。 @code{name} は
定義(コロン定義)(@dfn{(colon) definition}) です。

上記の説明はやや表面的です。 コロン定義の簡単な例については、 @ref{Your first definition} を参照してください。
関連する問題の一部についての詳細な説明については、 @xref{Interpretation and Compilation Semantics}
を参照してください。

@findex : ( @var{ "name" -- colon-sys   } ) core
@cindex @code{:}
@format
@code{:} ( @i{"name" -- colon-sys  }) core ``colon''
@end format

@findex ; ( @var{ compilation colon-sys -- ; run-time nest-sys --   } ) core
@cindex @code{;}
@kindex ;
@format
@code{;} ( @i{compilation colon-sys -- ; run-time nest-sys --  }) core ``semicolon''
@end format


最終的には自動インライン化を実行する予定ですが、 今のところは以下のようにしてインライン化を実行できます

@findex inline: ( @var{ "name" -- inline:-sys   } ) gforth-experimental
@cindex @code{inline:}
@kindex inline:
@format
@code{inline:} ( @i{"name" -- inline:-sys  }) gforth-experimental ``inline-colon''
@end format
インライン・コロン定義を開始します。  @code{inline:} と @code{;inline} の間のコードは、
インライン化するコードを(実行するのではなく)コンパイルする必要がありますが、 結果の定義 @i{name} は、
インライン化されたコードを実行するコロン定義です。  コンパイルするコードはスタック効果が@code{( -- )}
(スタックの深さが変わらない)である必要があることに注意してください。 さもないと、 Gforth が @i{name}
のコロン定義を作成しようとしたときにエラーが発生します。


@findex ;inline ( @var{ inline:-sys --   } ) gforth-experimental
@cindex @code{;inline}
@kindex ;inline
@format
@code{;inline} ( @i{inline:-sys --  }) gforth-experimental ``semi-inline''
@end format
@code{inline:} で始まるインライン定義を終了します



例として、 インライン化されたワードを定義し、 以下のようにして使います

@example
inline: my2dup ( a b -- a b a b )
    ]] over over [[ ;inline

#1. my2dup d. d.
: foo my2dup ;
#1. foo d. d.
see foo
@end example

インライン・ワードはマクロ(@pxref{Macros})に関連しています。 マクロとの違いは、マクロには即時コンパイル機能(immediate
compilation semantics)があるのに対し、 @code{inline:}
で定義されたワードにはデフォルトのコンパイル機能(compilation semantics)があることです。 つまり、
通常はコロン定義内でのみマクロを使用しますが、 @code{inline:}
ワードは対話的(interpretively)にも使用できることを意味します。 しかしそれは、 @code{inline:}
ワードとしては実行できないいくつかのことをマクロでは実行できることも意味します。 例:

@example
\ Doesn't work:
\   inline: endif ]] then [[ ;inline
\ Instead, write a macro:
: endif ]] then [[ ; immediate
@end example

逆に、 非即時コロン定義(non-immediate colon definitions)として問題ないワードについては、
非即時コロン定義として定義するか、 (最大限のパフォーマンスが必要な場合) @code{inline:} ワードとして定義します。
それらをマクロとして定義しないでください。 対話的(interpretively)に適切に使用できなくなります:

@example
: another2dup ]] over over [[ ; immediate
\ Doesn't work:
\   #1. another2dup d. d.
@end example

なぜ @code{inline:} と @code{;inline} の間にコンパイル・コードを書かなければならないのか疑問に思われるかもしれません。
これは、 上記の @code{my2dup} のようなインライン・ワードの実装が以下のように動作するためです:

@example
: compile-my2dup ( xt -- )
    drop ]] over over [[ ;

: my2dup [ 0 compile-my2dup ] ;
' compile-my2dup set-optimizer
@end example

@code{DROP} や @code{0} があるのは、 @code{compile-my2dup} が @code{my2dup} ための
@code{compile,} の実装であり、 @code{compile,} は xt を期待する為です(@pxref{User-defined
compile-comma})。

@node Anonymous Definitions, Quotations, Colon Definitions, Defining Words
@subsection Anonymous Definitions
@cindex colon definitions
@cindex defining words without name

しばしば匿名のワード(@dfn{anonymous word})を定義したい場合があります。 つまり、 名前無しのワードです。
これは以下のようにします:

@findex :noname ( @var{ -- xt colon-sys   } ) core-ext
@cindex @code{:noname}
@format
@code{:noname} ( @i{-- xt colon-sys  }) core-ext ``colon-no-name''
@end format


これにより、 終わりの @code{;} の後にワードの実行トークンがスタックに残ります。 以下は、 defer された ワード(deferred
word)が匿名コロン定義(anonymous colon definition)の @code{xt} で初期化される例です:

@example
Defer deferred
:noname ( ... -- ... )
  ... ;
IS deferred
@end example

@noindent
Gforth は、 2 つの別々のワードを使用して、 これを行う別の方法を提供します:

@findex noname ( @var{ --   } ) gforth-0.2
@cindex @code{noname}
@kindex noname
@format
@code{noname} ( @i{--  }) gforth-0.2 ``noname''
@end format
次に定義するワードは匿名になります。
その定義するワードは(@code{noname}がいじる訳ではなくて)入力ストリームからのをそのままを使います(The defining word
will leave the input stream alone)。 その定義したワードの xt は @code{latestxt} で取得します。


@cindex execution token of last defined word
@findex latestxt ( @var{ -- xt   } ) gforth-0.6
@cindex @code{latestxt}
@kindex latestxt
@format
@code{latestxt} ( @i{-- xt  }) gforth-0.6 ``latestxt''
@end format
@i{xt} は、 最後に定義されたワードの実行トークンです。



@noindent
先の例を、 @code{noname} と @code{latestxt} を使用して書き直すことができます:

@example
Defer deferred
noname : ( ... -- ... )
  ... ;
latestxt IS deferred
@end example

@noindent
@code{noname} は、 @code{:} だけでなく、 あらゆる定義ワードで機能します。

@code{latestxt} は、 最後のワードが @code{noname} として定義されていない場合にも機能します。  ただし、
複合ワード(combined words)には機能しません。  また、 これは、
定義のヘッダーが構築されるやいなや有効になる便利なプロパティでもあります。 したがって、 以下のようにすると:

@example
latestxt . : foo [ latestxt . ] ; ' foo .
@end example

@noindent
これは3つの数値を出力: 後ろの2つは同一の数値です。


@node Quotations, Supplying names, Anonymous Definitions, Defining Words
@subsection Quotations
@cindex quotations
@cindex nested colon definitions
@cindex colon definitions, nesting

引用(quotation)は、 別のコロン定義内の匿名コロン定義です。  引用(quotation)は、 @code{catch} や
@code{outfile-execute} など、 実行トークンを消費するワードを扱うときに便利です。  例えば、 以下の
@code{outfile-execute} (@pxref{Redirection}) の使用例を考えてみましょう:

@example
: some-warning ( n -- )
    cr ." warning# " . ;

: print-some-warning ( n -- )
    ['] some-warning stderr outfile-execute ;
@end example

上記のように、 @code{some-warning} をヘルパー・ワードとして定義し、 その xt を outfile-execute
に渡すことができます。 その代わりに、 引用(quotation)を使用して @code{print-some-warning}
内でそのようなワードを匿名で定義できます:

@example
: print-some-warning ( n -- )
  [: cr ." warning# " . ;] stderr outfile-execute ;
@end example

引用(quotation)は @code{[:} と @code{;]} で囲まれています。  それは実行時に実行トークンを生成します。

@findex [: ( @var{ compile-time: -- quotation-sys flag colon-sys   } ) gforth-1.0
@cindex @code{[:}
@kindex [:
@format
@code{[:} ( @i{compile-time: -- quotation-sys flag colon-sys  }) gforth-1.0 ``bracket-colon''
@end format
引用(quotation)を開始します


@findex ;] ( @var{ compile-time: quotation-sys -- ; run-time: -- xt   } ) gforth-1.0
@cindex @code{;]}
@kindex ;]
@format
@code{;]} ( @i{compile-time: quotation-sys -- ; run-time: -- xt  }) gforth-1.0 ``semi-bracket''
@end format
引用(quotation)を終了します




@node Supplying names, User-defined Defining Words, Quotations, Defining Words
@subsection Supplying the name of a defined word
@cindex names for defined words
@cindex defining words, name given in a string

デフォルトでは、 定義ワードは入力ストリームから定義されるワードの名前を取得します。 しばしば文字列から名前を指定したい場合があります。
これは以下のようにして行うことができます:

@findex nextname ( @var{ c-addr u --   } ) gforth-0.2
@cindex @code{nextname}
@kindex nextname
@format
@code{nextname} ( @i{c-addr u --  }) gforth-0.2 ``nextname''
@end format
次に定義されるワードの名前は @var{c-addr u} になります。 定義中のワードは入力ストリームからそのままで @code{nextname}
がいじることはありません。



例:

@example
s" foo" nextname create
@end example

@noindent
これは以下と同等です:

@example
create foo
@end example

@noindent
@code{nextname} は、 あらゆる定義ワードで機能します。


@node User-defined Defining Words, Deferred Words, Supplying names, Defining Words
@subsection User-defined Defining Words
@cindex user-defined defining words
@cindex defining words, user-defined
@cindex defining defining words

既存の定義ワードに基づいて新しい定義ワードを定義できますが、 @code{:} と
@code{create}...@code{does>}/@code{set-does>} は特に柔軟です。 一方、 たとえば、
@code{constant} の子供達は全て単なる定数です。

@menu
* User-defined defining words with colon definitions::
* User-defined defining words using CREATE::
* CREATE..DOES> applications::
* CREATE..DOES> details::
* Advanced does> usage example::
* User-defined TO and DEFER@@::
* User-defined compile-comma::
* Creating from a prototype::
* Making a word current::
* Const-does>::              
@end menu

@node User-defined defining words with colon definitions, User-defined defining words using CREATE, User-defined Defining Words, User-defined Defining Words
@subsubsection User-defined defining words with colon definitions

既存の定義ワードを定義時(defining-time)コードで取り囲み、 その取り囲んだ一連のコードをコロン定義に入れることで、
新しい定義ワードを作成できます。 

@c anton: This example is very complex and leads in a quite different
@c direction from the CREATE-DOES> stuff that follows.  It should probably
@c be done elsewhere, or as a subsubsection of this subsection (or as a
@c subsection of Defining Words)

たとえば、 定義の @i{xt} を指定してコロン定義に関する統計を収集するワード @code{stats} があり、
アプリケーション内のすべてのコロン定義で @code{stats} を呼び出す必要があるとします。 これには、 以下のように @code{:}
の新しいバージョンを定義して使用できます:

@example
: stats
  ( xt -- ) DUP ." (Gathering statistics for " . ." )"
  ... ;  \ other code

: my: : latestxt postpone literal ['] stats compile, ;

my: foo + - ;
@end example

@code{my:} を使用して @code{foo} を定義する場合、 以下のステップが実行されます:

@itemize @bullet
@item
@code{my:} が実行されます。
@item
定義内の @code{:} (@code{my:} と @code{latestxt} の間にあるもの) が実行され、 @code{:} として、
いつもと同じことを行います。 名前を得るために入力ストリームをパースし、 名前 @code{foo} のディクショナリ・ヘッダーを構築し、
@code{state} をインタプリタ状態からコンパイル状態に切り替えます。
@item
@code{latestxt} というワードが実行されます。 定義中のワード(@code{foo})の @i{xt} をスタックに置きます。
@item
@code{postpone literal} によって生成されたコードが実行されます。 これにより、 スタック上の値(@code{foo} の
@i{xt})が @code{foo} のコード領域にリテラルとしてコンパイルされます。
@item
コード @code{['] stats} は、 @code{my:} の定義時に、 リテラルを @code{my:} の定義内にコンパイルします(訳注:
そして、 @code{my:} の実行時は @code{stats} の @i{xt} をスタックに積みます)。 そして、
@code{compile,} が実行されると、 @code{foo} のコード領域に、 上記に続けて @code{stats} の @i{xt}
をコンパイルします@footnote{厳密に言えば、 @code{compile,} が @i{xt}
をコード領域内の何かに変換するために使用するメカニズムは実装に依存します。 スレッド実装は実行トークンを直接吐き出す場合がありますが、
別の実装はネイティブ・コード・シーケンスを吐き出す場合があります}。
@item
この時点で、 @code{my:} の実行が完了し、 制御がテキスト・インタプリタに戻ります。 テキスト・インタプリタはコンパイル状態にあるため、
後続のテキスト @code{+ -} は @code{foo} の定義にコンパイルされ、 いつものように @code{;} によって定義が終了します。
@end itemize

@code{see} を使用すると、 @code{my:} を使用して定義されたワードを逆コンパイルし、 それが通常の @code{:}
定義とどのように異なるかを確認できます。 例:

@example
: bar + - ;  \ like foo but using : rather than my:
see bar
: bar
  + - ;
see foo
: foo
  `foo stats + - ;
@end example

@code{`foo} は @code{['] foo} を記述する別の方法です。



@node User-defined defining words using CREATE, CREATE..DOES> applications, User-defined defining words with colon definitions, User-defined Defining Words
@subsubsection User-defined defining words using create
@cindex @code{CREATE} ... @code{DOES>}

定義ワードで定義されたワードを、 標準の定義ワードで定義されたワードとは異なる振る舞いにしたい場合は、 以下のように定義ワードを記述できます:

@example
: def-word ( "name" -- )
    CREATE @i{code1}
DOES> ( ... -- ... )
    @i{code2} ;

def-word name
@end example

@cindex child words
このコード断片は 定義ワード(@dfn{defining word}) @code{def-word} を定義し、 そして、 それを実行します。
@code{def-word} が実行されると、 新しいワード @code{name} が @code{CREATE} され、コード @i{code1}
が実行されます。 コード @i{code2} は現時点では実行されません。 @code{name} というワードは、 @code{def-word}
の子供(@dfn{child})と呼ばれることもあります。

@code{name} を実行すると、 @code{name} の本体のアドレスがデータ・スタックに置かれ、 @i{code2}
が実行されます(@code{name} の本体のアドレスは、 @code{CREATE} の直後に @code{HERE} が返すアドレス、 つまり、
@code{create} されたワードがデフォルトで返すアドレスです)。

@code{def-word} を使用して、 同様に動作する一連の子ワード達を定義できます。 つまり、 これらはすべて @i{code2}
によって決定される共通の実行時の振る舞いを持っています。 通常、 @i{code1} シーケンスは、 子ワードの本体にデータ領域を構築します。
データの構造は @code{def-word} のすべての子に共通ですが、 データ値は各子ワードに固有で、 そして、 プライベートです。
子ワードが実行されると、 そのプライベート・データ領域のアドレスが TOS 上のパラメータとして渡され、 @i{code2}
によって使用および操作されます@footnote{このデータ領域への読み取りと書き込みは両方とも正当です。}。

定義ワードを構成する 2 つのコード断片は、 完全に別々の 2 つの時点で動作(実行)されます:

@itemize @bullet
@item
@i{定義時} 、定義ワードが @i{code1} を実行して子ワードを生成します
@item
@i{子の実行時}、 子ワードが呼び出されると、 子ワード固有のプライベートなパラメータ達(データ)を使って、 @i{code2} が実行されます。
@end itemize

@code{def-word} と @code{name} の振る舞いを理解するもう 1 つの方法は、 以下のように定義することです:
@example
: def-word1 ( "name" -- )
    CREATE @i{code1} ;

: action1 ( ... -- ... )
    @i{code2} ;

def-word1 name1
@end example

@noindent
この場合、 @code{name1 action1} を使用することは、 @code{name} を使用することと同じです。

@cindex @code{CREATE} ... @code{SET-DOES>}
@code{def-word} を記述するもう 1 つの方法が引用(@pxref{Quotations})です:

@example
: def-word ( "name" -- ; name execution: ... -- ... )
    create @i{code1}
    [: @i{code2} ;] set-does> ;
@end example

Gforth  は実際は @code{does>} を使用してコードを後者のコードと同等のコードにコンパイルします。  @code{set-does>}
アプローチの利点は、 その背後に他のコードを配置でき、 回避策を必要とせずに制御構造内でそれを使用できることです。  欠点は、 Gforth
固有であることです。

典型的な例は、 以下のようにして @code{CONSTANT} を定義できることです:

@example
: CONSTANT ( w "name" -- )
    CREATE ,
DOES> ( -- w )
    @@ ;
@end example

@noindent
または同等の

@example
: CONSTANT ( w "name" -- ; name execution: -- w )
    create ,
    ['] @@ set-does> ;
@end example

@comment There is a beautiful description of how this works and what
@comment it does in the Forthwrite 100th edition.. as well as an elegant
@comment commentary on the Counting Fruits problem.

@code{5 CONSTANT five} を使用して定数を作成すると、 一連の定義時アクションが実行されます。 最初に新しいワード
@code{five} が作成され、 次に @code{,} を使用して @code{five} の本体に値 5 が配置されます。
@code{five} が実行されると、 その本体のアドレスがスタックに置かれ、 @code{@@} は値 5 を取得します。 ワード
@code{five} にはそれ自体のコードはありません。 ワード @code{five} には、 データ・フィールドと、 引用(quotation)
の xt または @code{@@} の xt が含まれるだけです。

このセクションの最後の例は、 @code{CREATE} されたワードで予約されている空間はデータ空間であるため、
標準プログラムによる読み取りと書き込みの両方が可能であることを思い出していただくことを目的としています@footnote{研究課題: この例は
@code{Value} と @code{TO} をあなた独自に実装するための出発点として使って見ましょう。 もし、 あなたが行き詰まった場合は、
@code{'} と @code{[']} の振る舞いを調べてください。}:

@example
: foo ( "name" -- )
    CREATE -1 ,
DOES> ( -- )
    @@ . ;

foo first-word
foo second-word

123 ' first-word >BODY !
@end example

@code{first-word} が @code{CREATE} されたワードであった場合、
単純にそれを実行してデータ・フィールドのアドレスを取得できます。 ただし、 @code{DOES>} アクションを持つように定義されているため、
その実行機能(execution semantics)は、 それらの @code{DOES>} アクションを実行することになります。
データ・フィールドのアドレスを取得するには、 @code{'} を使用して xt を取得し、 次に @code{>BODY} を使用して xt
をデータ・フィールドのアドレスに変換する必要があります。  @code{first-word} を実行すると、 @code{123} が表示されます。
@code{second-word} を実行すると、@code{-1} が表示されます。

@cindex stack effect of @code{DOES>}-parts
@cindex @code{DOES>}-parts, stack effect
上記の例では、 @code{DOES>} の後のスタック・コメントは、  @code{DOES>} に続くコードのスタック効果ではなく、
定義されたワードのスタック効果を指定しています(@code{DOES>}  に続くコードは、 本体のアドレスがスタックの先頭にある事を期待しています。
これはスタック・コメントには反映されません)。 これは著者が使用し、 推奨している規則です(ただし、
スタック効果の指定にローカル変数宣言を使うのと少々衝突する)。


@node CREATE..DOES> applications, CREATE..DOES> details, User-defined defining words using CREATE, User-defined Defining Words
@subsubsection Applications of @code{CREATE..DOES>}
@cindex @code{CREATE} ... @code{DOES>}, applications

あなたは、 この機能をどのように使用するのか不思議に思うかもしれません。 いくつかの使用パターンを以下に示します:

@cindex factoring similar colon definitions
とあるコードのフレーズが複数回出現し、 その意味を同一視できる場合は、 それをコロン定義としてくくり出します。 類似のコロン定義が見つかった場合は、
@code{CREATE..DOES>} を使用してそれらをファクタリングできます。 たとえば、 アセンブラは通常、
非常によく似たいくつかのワードを定義します:
@example
: ori, ( reg-target reg-source n -- )
    0 asm-reg-reg-imm ;
: andi, ( reg-target reg-source n -- )
    1 asm-reg-reg-imm ;
@end example

@noindent
これは以下のようにファクタリングできます:
@example
: reg-reg-imm ( op-code -- )
    CREATE ,
DOES> ( reg-target reg-source n -- )
    @@ asm-reg-reg-imm ;

0 reg-reg-imm ori,
1 reg-reg-imm andi,
@end example

@cindex currying
@code{CREATE..DOES>} の別の観点は、
これをワードのパラメータの一部を提供する素朴な方法(関数型言語コミュニティではカリー化(@dfn{currying})として知られています)とみなすことです。
たとえば、 @code{+} には 2 つのパラメータが必要ですが、そのうち 1 つのパラメータを固定した @code{+}
のバージョンを作成するには、 以下のようにします:

@example
: curry+ ( n1 "name" -- )
    CREATE ,
DOES> ( n2 -- n1+n2 )
    @@ + ;

 3 curry+ 3+
-2 curry+ 2-
@end example


@node CREATE..DOES> details, Advanced does> usage example, CREATE..DOES> applications, User-defined Defining Words
@subsubsection The gory details of @code{CREATE..DOES>}
@cindex @code{CREATE} ... @code{DOES>}, details

@findex DOES> ( @var{ compilation colon-sys1 -- colon-sys2   } ) core
@cindex @code{DOES>}
@kindex DOES>
@format
@code{DOES>} ( @i{compilation colon-sys1 -- colon-sys2  }) core ``does''
@end format


@cindex @code{DOES>} in a separate definition
以下は、 一つの定義内で @code{CREATE} と @code{DOES>} の両方を使用する必要がないことを意味します。
@code{DOES>} 部分を別の定義に置くことができます。 これにより、 たとえば、 さまざまな @code{DOES>}
部分から選択するようにすることができます:
@example
: does1 
DOES> ( ... -- ... )
    code1 ;

: does2
DOES> ( ... -- ... )
    code2 ;

: def-word ( ... -- ... )
    create ...
    IF
       does1
    ELSE
       does2
    ENDIF ;
@end example

この例では、 @code{does1} と @code{does2} のどちらを使用するかの選択は、 子ワードが @code{CREATE}
される定義時に行われます。

注意: 定義を終了する @code{does>} の性質により、 追加の定義 @code{does1} と @code{does2}
を導入する必要があることに注意してください。  @code{set-does>} を使用するとこれを回避できます:

@example
: def-word ( ... -- ... )
    create ...
    IF
       [: code1 ;] set-does>
    ELSE
       [: code2 ;] set-does>
    ENDIF ;
@end example

@cindex @code{DOES>} in interpretation state
標準のプログラムでは、 最後のワードが @code{CREATE} で定義されている場合にのみ @code{DOES>} 部分を適用できます。
Gforth では、 @code{DOES>} 部分は、 いかなる場合でも定義された最後のワードの振る舞いをオーバーライドします。
標準のプログラムでは、 @code{DOES>} はコロン定義でのみ使用できます。 Gforth では、 一種のワンショット・モードとして、
インタプリタ状態で使用することもできます。 例:
@example
CREATE name ( ... -- ... )
  @i{initialization}
DOES>
  @i{code} ;
@end example

@noindent
これは、 以下の標準のと同等です:
@example
:noname
DOES>
    @i{code} ;
CREATE name EXECUTE ( ... -- ... )
    @i{initialization}
@end example

Gforth は対話時に打ち込んだコード内での引用(quotations)もサポートしており、 引用は現在の定義を保存および復元するため、
上記の例を以下のように記述することもできます:

@example
CREATE name ( ... -- ... )
  @i{initialization}
[: @i{code} ;] set-does>
@end example

@findex set-does> ( @var{ xt --   } ) gforth-1.0
@cindex @code{set-does>}
@kindex set-does>
@format
@code{set-does>} ( @i{xt --  }) gforth-1.0 ``set-does>''
@end format
現在のワードを変更して、 本体アドレスをプッシュしてから @i{xt} を実行します。  それに応じて @code{compile,}
の実装も変更します。  より効率的な実装が必要な場合、 この後で @code{set-optimizer} を呼び出します。


@findex >body ( @var{ xt -- a_addr   } ) core
@cindex @code{>body}
@kindex >body
@format
@code{>body} ( @i{xt -- a_addr  }) core ``to-body''
@end format
@i{xt} で表されるワードの本体(body)のアドレス(ワードのデータ・フィールドのアドレス)を取得します。



@node Advanced does> usage example, User-defined TO and DEFER@@, CREATE..DOES> details, User-defined Defining Words
@subsubsection Advanced does> usage example

MIPS 逆アセンブラ(@file{arch/mips/disasm.fs})には、
非常に反復的なスキームに従って逆アセンブルするための多くのワードが含まれています(訳注: very repetetive scheme;
repetitiveのスペルミスっぽい):

@example
:noname @var{disasm-operands} s" @var{inst-name}" type ;
@var{entry-num} cells @var{table} + !
@end example

もちろん、 これは共通点をくくり出して以下のような定義を可能にするというアイデアを刺激します:

@example
@var{disasm-operands} @var{entry-num} @var{table} define-inst @var{inst-name}
@end example

通常、 パラメータ @var{disasm-operands} と @var{table} は相関しています。 さらに、
著者が逆アセンブラを作成する前に、 以下のような命令を定義するコードがすでに存在していました:

@example
@var{entry-num} @var{inst-format} @var{inst-name}
@end example

このコードは assembler 由来で、 @file{arch/mips/insts.fs} にあります。

したがって、 実行時に上記のスキームを実行する @var{inst-format} ワードを定義する必要がありました。 著者は、
まず最初に、ランタイム・コード生成を使用することを選択しました:

@example
: @var{inst-format} ( entry-num "name" -- ; compiled code: addr w -- )
  :noname Postpone @var{disasm-operands}
  name Postpone sliteral Postpone type Postpone ;
  swap cells @var{table} + ! ;
@end example

注意: これにより、 上記のスキームの他に 2 つのパラメータが提供されることに注意してください。

別の方法として、 @code{create}/@code{does>} を使用してこれを記述することもできます:

@example
: @var{inst-format} ( entry-num "name" -- )
  here name string, ( entry-num c-addr ) \ parse and save "name"
  noname create , ( entry-num )
  latestxt swap cells @var{table} + !
does> ( addr w -- )
  \ disassemble instruction w at addr
  @@ >r 
  @var{disasm-operands}
  r> count type ;
@end example

どういうわけか、 最初の解決策の方が簡単です。 その主な理由は、 @code{string,} やその友達を使用するよりも、
@code{sliteral} を使用した方が、 文字列を定義時から使用時へシフトするのが簡単だからです。

私はこのスキームに従ってたくさんのワードを書き、 すぐにそれらの共通点を取り出すことを考えました。  これは 2 レベルの定義ワード、
つまり通常の定義ワードを定義するワードを使用していることに注意してください。

今回は、 @code{postpone} とそのファミリーが関与する解決策はより困難に思えたので(研究課題として試してみましょう)、
@code{create}/@code{does>} というワードを使用することにしました。 私はすでにそれを行っていたので、 下位レベルにも
@code{create}/@code{does>} を使用しました(研究課題として @code{postpone} などを使用してみましょう)。
その結果、 以下の定義が得られました:

@example
: define-format ( disasm-xt table-xt -- )
    \ 逆アセンブルに disasm-xt を使用する命令フォーマットを定義し、
    \ 定義された命令を
    \ 表(table) table-xt に入れます
    create 2,
does> ( u "inst" -- )
    \ 命令 inst を逆アセンブルする匿名ワードを定義し、
    \ それを u 番目のエントリとして table-xt に入れます
    2@@ swap here name string, ( u table-xt disasm-xt c-addr ) \ remember string
    noname create 2,      \ define anonymous word
    execute latestxt swap ! \ enter xt of defined word into table-xt
does> ( addr w -- )
    \ disassemble instruction w at addr
    2@@ >r ( addr w disasm-xt R: c-addr )
    execute ( R: c-addr ) \ disassemble operands
    r> count type ; \ print name 
@end example

注意: ここでのテーブルは(上記とは対照的に) @code{cells +} を単独で実行することに注意してください (そのため、xt
を渡す必要があります)。  このワードは以下のように使用されます:

@example
' @var{disasm-operands} ' @var{table} define-format @var{inst-format}
@end example

上に示したように、 定義された命令フォーマットは以下のように使用されます:

@example
@var{entry-num} @var{inst-format} @var{inst-name}
@end example

カリー化に関しては、 この種の 2 レベルの定義ワードは 3 段階でパラメータを提供します。 最初に @var{disasm-operands} と
@var{table}、 次に @var{entry-num} と @var{inst-name }、最後に @code{addr w} つまり、
逆アセンブル対象の命令です。  

もちろん、 これは @file{insts.fs} で使用されるすべての命令フォーマット名に完全に適合するわけではないため、
パラメータを正しい形式に条件付けるいくつかのラッパーを定義する必要がありました。

あなたが、 このセクションを理解するのが難しい場合でも、 心配する必要はありません。  まず、 これは複雑であり、
理解するのに時間がかかります(おそらく多少いじくりまわすことも必要です)。 2 番目に、 これは私が Forth の 17 年間で書いた最初の 2
レベルの @code{create}/@code{does>} ワードです。 また、 最初に @file{insts.fs} がなかった場合は、 1
レベルの定義ワードのみを使用することを選択した可能性があります(定義ワードを使用するときにパラメータをいくつか繰り返します)。 したがって、
これを理解する必要はありませんが、 あなたの Forth についての理解が深まるかもしれません。



@node User-defined TO and DEFER@@, User-defined compile-comma, Advanced does> usage example, User-defined Defining Words
@subsubsection User-defined @code{to} and @code{defer@@}

Gforth の value にはいくつかの操作子(operators)があります。 @code{to} (@code{is} はエイリアスであり、
@code{defer!} は入力ストリーム内の名前の代わりに xt を受け取ります)や @code{+to} や @code{addr} や
@code{action-of} (@code{defer@@} は入力ストリーム内の名前の代わりに xt を受け取ります)です。

Gforth を使用すると、 ワードの @code{(to)} アクションを変更できます。

@findex (to) ( @var{ val operation xt --   } ) gforth-1.0
@cindex @code{(to)}
@kindex (to)
@format
@code{(to)} ( @i{val operation xt --  }) gforth-1.0 ``paren-to''
@end format
@i{name} という名前の、 ワードに似ている value の @i{xt} です。 @i{name} に @i{val} を保存します。
@i{operation} は、 @code{to} と @code{+to} と @code{addr} と @code{action-of}
から選択します。


@findex to-table: ( @var{ "name" "xt1" .. "xtn" --   } ) gforth-experimental
@cindex @code{to-table:}
@kindex to-table:
@format
@code{to-table:} ( @i{"name" "xt1" .. "xtn" --  }) gforth-experimental ``to-table-colon''
@end format
@code{TO} や @code{+TO} や @code{ADDR} や @code{ACTION-OF} のエントリを含むテーブルを作成します。
@code{n/a} を使用して、 サポートされていない操作をマークします。


@findex to-method: ( @var{ xt table "name" --   } ) gforth-experimental
@cindex @code{to-method:}
@kindex to-method:
@format
@code{to-method:} ( @i{xt table "name" --  }) gforth-experimental ``to-method-colon''
@end format
to-method を作成します。 ここで、@var{xt} はフィールドにアクセスするためのアドレスを計算し、 @var{table}
にはそれに格納する操作子(operators)が含まれます。


@findex set-to ( @var{ to-xt --   } ) gforth-1.0
@cindex @code{set-to}
@kindex set-to
@format
@code{set-to} ( @i{to-xt --  }) gforth-1.0 ``set-to''
@end format
現在のワードの @code{(to) ( val xt -- )} メソッドの実装を @i{to-xt} に設定します。


@findex n/a ( @var{ --   } ) gforth-experimental
@cindex @code{n/a}
@kindex n/a
@format
@code{n/a} ( @i{--  }) gforth-experimental ``not-available''
@end format
このワードをチック(tick)することはできますが、 インタプリタ時およびコンパイル時に ``Operation not supported''
(操作はサポートされていません)という例外が投げられます(throw)。  サポートされていないメソッドなどにこれを使用します。



@code{(to)} は @code{to} 内で使用されるワードです。 実行時(run-time)に値を保存します。  @code{(to)}
メソッドの一般的なスタック効果は @code{( val Operation xt -- )} です。 ここで、 @i{xt}
は格納されているワードを示し、 @i{operation} は @code{to} 風の操作の実際のバリエーションを示します。  @i{val}
はそこに格納されている (適切な型の) 値です。

@code{to-table:} を使用して @code{to} メソッドを実装し、
タイプ固有の操作テーブルを作成し(テーブルの最後にある指定されていないスロットは @code{n/a} で埋められます)、
@code{to-method:} を、 value の @i{xt} からそのデータ・フィールドを取得する操作と組み合わせて使用​​します(通常、
ディクショナリ内の値の場合は @code{>body} ですが、 value-style データは構造体またはユーザー領域に存在することもできます)。

たとえば、 以下のように @code{fvalue} を実装できます:

@example
to-table: f!-table f! f+!
' >body f!-table to-method: fvalue-to

: fvalue ( r "name" -- ; name: -- r )
  create f,
  ['] f@@ set-does>
  ['] fvalue-to set-to ;

5e fvalue foo
: bar foo 1e f+ to foo ;
see bar
@end example

@node User-defined compile-comma, Creating from a prototype, User-defined TO and DEFER@@, User-defined Defining Words
@subsubsection User-defined @code{compile,}

以下を使用して、 とあるワードのための @code{compile,} の実装を変更することもできます

@findex set-optimizer ( @var{ xt --   } ) gforth-1.0
@cindex @code{set-optimizer}
@kindex set-optimizer
@format
@code{set-optimizer} ( @i{xt --  }) gforth-1.0 ``set-optimizer''
@end format
@code{compile,} で @i{xt} execute するように現在のワードを変更します(@code{compile,}
に渡されたものと同じスタック内容を使用)。 注意: @code{compile,} は @code{execute}
とスタック内容が一致している必要があるため、 @code{set-optimizer} は同じ振る舞いの、
より効率的な実装をインストールする場合にのみ使用しなければならないことに注意してください。


@findex opt: ( @var{ compilation -- colon-sys2 ; run-time -- nest-sys   } ) gforth-1.0
@cindex @code{opt:}
@kindex opt:
@format
@code{opt:} ( @i{compilation -- colon-sys2 ; run-time -- nest-sys  }) gforth-1.0 ``opt:''
@end format
名前無しのコロン定義を開始します。 完了すると、 このコロン定義は(@code{opt:} の前の)最新のワードの @code{compile,}
の実装になります。



注意: 結果として得られる @code{compile,} は、 依然として @code{postpone literal postpone
execute} と同等である必要があることに注意してください。 そのため、 @code{set-optimizer} は、
振る舞いを変更するためではなく、 効率化のために役立てるものです。  しかし、 あなたが自分の足を撃つことを妨げるものは何もありません。  あなたが
@code{set-optimizer} を使用したときの結果と、 最初に以下を定義して使用を無効にしたときに得られる結果を比較することで、
@code{set-optimizer} の使用が正しいかどうかを確認できます。

@example
: set-optimizer drop ;
@end example

@code{set-optimizer} の使用例として、 上記の @code{CONSTANT} の定義の 1 つを以下のように拡張できます。

@example
: CONSTANT ( n "name" -- ; name: -- n )
  create ,
  ['] @@ set-does>
  [: >body @@ postpone literal ;] set-optimizer
;
@end example

唯一の変更は、 @code{set-optimizer} 行の追加です。 あなたが定数を定義してコンパイルすると、 以下のようになります:

@example
5 constant five
: foo five ;
@end example

@code{foo} 内のコンパイル済み @code{five} は、 @code{five} の一般的な呼び出しではなく、 literal 5
とコンパイルされるようになりました。  引用(quotation)には、 @code{compile,} と同じスタック効果があり、 それは
@code{( xt -- )} です。  渡された xt は @code{compile,} されたワード、 つまりこの例では @code{five}
に属します。 この例では、 まず xt が本体アドレスに変換され、 次にその場所の値 5 が取り出され、 その値が @code{postpone
literal} でコンパイルされます(@pxref{Literals})。

この @code{set-optimizer} の使用は、 ユーザーが、 例えば @code{6 ' five >body !}
などして定数の値を変更しないことを前提としています。  @code{five} は @code{create} で定義されていますが、 これは
@code{CONSTANT} の実装の詳細であり、 それを文書化しない場合、 ユーザーはそれに依存してはなりません。  また、
本体(body)が変更されないことを前提とした方法で @code{set-optimizer} を使用する場合、 (ここで行われているように)
@code{create} が使用されていることを文書化してはなりません。 逆に、 それを文書化する場合は、 本体の変更を処理できるように
@code{compile,} 実装を記述する必要があります。

もう一つの例は、 前述の @code{fvalue} の例をさらに最適化したものです:

@example
: compile-fvalue-to ( xt-value-to -- )
  drop ]] >body f! [[ ;
  
: fvalue-to ( r xt -- )
  >body f! ;
' compile-fvalue-to set-optimizer

: fvalue ( r "name" -- ; name: -- r )
  create f,
  ['] f@@ set-does>
  [: >body ]] literal f@@ [[ ;] set-optimizer
  ['] fvalue-to set-to ;

5e fvalue foo
: bar foo 1e f+ to foo ;
see bar
@end example

@code{bar} のコードを以前の定義のコードと比較します。  ここでは、 fvalue を読み取るコード(@code{fvalue} の
@code{set-optimizer} より)と、 fvalue を書き込むコード(@code{fvalue-to} に適用された
@code{set-optimizer} より)の両方の最適化が見られます。 fvalue は(定数とは異なり)変化する可能性があるため、
(@code{fvalue} 内部の)読み取り部分が、 アドレスと、 実行時に実行される @code{f@@} をコンパイルします。

@c !! reference the appropriate sections that explain these
@c optimizations
@code{fvalue-to} の場合、 @code{compile,} の実装は基本的に、 @code{fvalue}
によってインラインで実行されるコードをコンパイルするだけです。 @code{to} のコンパイル機能(compilation
semantics)は、アドレスをリテラルとしてコンパイルしてから、 @code{(to)} の実装(つまり、
@code{fvalue-to})をコンパイルします。 この処理では、 @code{>body} が最適化されて削除されます。

実際には、 Gforth の @code{fvalue} は、 たとえば @code{+TO} をサポートするなど、
いくつかの追加の工夫が含まれています。

注意: @code{set-optimizer} の呼び出しは、 @code{set-does>} (または @code{does>}
の呼び出しの後に実行する必要があることに注意してください。 なぜなら、 @code{set-does>} は @code{compile,}
の実装それ自体を上書きするからです。

@code{fvalue-to} の例でわかるように、 @code{set-optimizer} を @code{constant} や
@code{fvalue} のような定義ワード内ではなく、 個々のワードに適用することもできます。  この場合、 オプティマイザに渡されるワードの xt
は通常は不要であり、 @code{compile-fvalue-to} のように @code{drop} されます。

エンジン @code{gforth-itc} は @code{compile,} に @code{,} を使用するので、 そこでは
@code{set-optimizer} は効果ありません。


@node Creating from a prototype, Making a word current, User-defined compile-comma, User-defined Defining Words
@subsubsection Creating from a prototype

上記では、 最初に @code{create} を使用してワードを定義し、 それから @code{set-does>} や @code{set-to}
や @code{set-optimizer} などで変更する方法を示しました。

別の方法として、 以下のワード群を使用してプロトタイプを作成し、そのプロトタイプから新しいワードを作成します。
この種のコピーでは本体(body)部分は網羅されないため、 明示的に割り当てて初期化する必要があります。  上記の @code{fvalue}
を例に取ると、 代わりに以下のように定義できます:

@example
create fvalue-prototype ( -- r )
['] f@@ set-does>
[: >body ]] literal f@@ [[ ;] set-optimizer
['] fvalue-to set-to

: fvalue ( r "name" -- ; name: -- r )
  ``fvalue-prototype create-from f, reveal ;
@end example

このアプローチの利点は、まず @code{create} ヘッダー・メソッド達を複製し、 それらを変更し、 最終的に重複排除する必要がないため、
@code{fvalue} ワード群の作成が高速化されることだ。 ただし、 この利点は、
この定義ワードで作成されるワードの数が膨大な場合にのみ意味があります。

@findex create-from ( @var{ nt "name" --   } ) gforth-1.0
@cindex @code{create-from}
@kindex create-from
@format
@code{create-from} ( @i{nt "name" --  }) gforth-1.0 ``create-from''
@end format
指定の @i{nt} のように振る舞うが、 ボディが空のワード @i{name} を作成します。  @i{nt} は名前付きワードの nt
でなければなりません。  結果として得られるヘッダーはまだ非公開状態です(訳注: not yet
reveal;ワードリスト未登録なので普通は呼び出せない)。  @code{set-} ワード群を使用せずに @code{create-from}
でワードを作成すると、 @code{set-} ワード群または @code{immediate} または @code{does>}
を使用してワードを作成するよりも高速になります。  @code{noname} で @code{create-from} を使用できます。


@findex reveal ( @var{ --   } ) gforth-0.2
@cindex @code{reveal}
@kindex reveal
@format
@code{reveal} ( @i{--  }) gforth-0.2 ``reveal''
@end format
(reveal;明らかにする、暴露する)ヘッダー定義時の現在のワード・リスト(wordlist current)に現在のワードを入れます。



@code{noname} を定義ワードとともに使用しても、 パフォーマンス上の利点は得られません。  したがって、 以下もいっしょに使います

@findex noname-from ( @var{ xt --   } ) gforth-1.0
@cindex @code{noname-from}
@kindex noname-from
@format
@code{noname-from} ( @i{xt --  }) gforth-1.0 ``noname-from''
@end format
指定の @i{xt} のように動作するが、 本体が空の名前のないワードを作成します。  @i{xt} は、 名前のないワードの xt
でなければなりません。



以下に使用例を示します:

@example
``fvalue-prototype noname create-from
latestnt constant noname-fvalue-prototype

: noname-fvalue ( r -- xt ; xt execution: -- r )
  noname-fvalue-prototype noname-from f,
  latestxt ;
@end example


@node Making a word current, Const-does>, Creating from a prototype, User-defined Defining Words
@subsubsection Making a word current
@cindex Modifying a word defined earlier

@code{immediate} や @code{set-optimizer} など、
上記の多くのワードは、「現在の」(current)ワードまたは「一番最近定義された」(most recently defined)ワードを変更します。
しばしば以前のワードを変更したい場合があると思います。  その場合は以下のようにして行うことができます

@findex make-latest ( @var{ nt --   } ) gforth-1.0
@cindex @code{make-latest}
@kindex make-latest
@format
@code{make-latest} ( @i{nt --  }) gforth-1.0 ``make-latest''
@end format
@i{nt} を最新の定義にし、 @code{immediate} および @code{set-*} 操作で操作できるようにします。  nt
によって参照されるワードを既に使用している(特にコンパイル済みの)場合、 そのワードの振る舞いを変更しないでください(その実装だけを変更してください)。
さもないと、 Gforth エンジンやバージョン間で一貫性のない驚くべき振る舞いの組み合わせが発生する可能性があります。




@node Const-does>, , Making a word current, User-defined Defining Words
@subsubsection @code{Const-does>}

@code{create}...@code{does>} は、 定義時から実行時に幾つかの値を転送(transfer)するためによく使用されます。
Gforth は、 このために以下を用意しています

@findex const-does> ( @var{ run-time: w*uw r*ur uw ur "name" --   } ) gforth-obsolete
@cindex @code{const-does>}
@kindex const-does>
@format
@code{const-does>} ( @i{run-time: w*uw r*ur uw ur "name" --  }) gforth-obsolete ``const-does''
@end format
定義時: @var{name} を定義して返ります。
 
@var{name} 実行時: @var{w*uw r*ur} をプッシュし、 @code{const-does>} に続くコードを実行します。



このワードの一般的な使用例は以下のとおりです:

@example
: curry+ ( n1 "name" -- )
1 0 CONST-DOES> ( n2 -- n1+n2 )
    + ;

3 curry+ 3+
@end example

ここで @code{1 0} は、 1 つのセルと 0 の浮動小数点が定義時から実行時に転送されることを意味します。

@code{const-does>} を使用する利点は以下のとおりです:

@itemize

@item
値の保存と取得を扱う必要がなくなります。 つまり、 プログラムの書き込みと読み取りがより容易になります。

@item
@code{does>} を使用する場合は、 最適化できない @code{@@} を導入する必要があります(なぜなら
@code{>body}...@code{!} を使用してデータを変更できるため)。 @code{const-does>} はこの問題を回避します。

@end itemize

@code{const-does>} の標準 Forth 実装は @file{compat/const-does.fs} で利用できます。


@node Deferred Words, Forward, User-defined Defining Words, Defining Words
@subsection Deferred Words
@cindex deferred words

定義ワード @code{defer} (訳注: (期限を定めない)延期)を使用すると、 その振る舞いを定義せずに名前でワードを定義できます。
その振る舞いの定義は延期(defer)されます。 これが役立つ 2 つの状況を以下に示します:

@itemize @bullet
@item
ワードの振る舞いを後で変更できるようにし、 振る舞いが変更されたときにそのワードへの全てのプリコンパイルされた参照も変更できるようにしたい場合。
@item
相互再帰(mutual recursion)の場合。 @xref{Calls and returns}
@end itemize

以下の例では、 @code{foo} は常に @code{greet} の「@code{Good breakfast}」を出力するバージョンを呼び出し、
@code{bar} は常に@code{greet} の「@code{Hello}」を出力するバージョンを呼び出します。
ソースコードを並べ替えて再コンパイルすることなく、 @code{foo} で新しいバージョンを使用できるようにする方法はありません。

@example
: greet ." Good morning" ;
: foo ... greet ... ;
: greet ." Hello" ;
: bar ... greet ... ;
@end example

この問題は、 @code{greet} を @code{defer} された ワードとして定義することで解決できます。 @code{defer} された
ワードの振る舞いは、 @code{IS} を使用して以前に定義されたワードの xt と関連付けることによって、 いつでも定義および再定義できます。
上記の例は以下のようになります:

@example
Defer greet ( -- )
: foo ... greet ... ;
: bar ... greet ... ;
: greet1 ( -- ) ." Good morning" ;
: greet2 ( -- ) ." Hello" ;
' greet2 IS greet  \ make greet behave like greet2
@end example

@progstyle すべての defer された ワードに対してスタック・コメントを記述し、 かつ、 そのスタック効果に一致する XT のみを
defer されたワードに入れる必要があります。 そうしないと、  defer されたワードを使用するのは非常に困難です。

defer された ワードを使用すると、 @ref{User-defined Defining Words}
の統計収集の例(statistics-gathering example)を改善できます。 アプリケーションのソース・コードを編集してすべての
@code{:} を @code{my:} に変更するのではなく、 以下のようにします:

@example
: real: : ;     \ retain access to the original
defer :         \ redefine as a deferred word
' my: IS :      \ use special version of :
\
\ load application here
\
' real: IS :    \ go back to the original
@end example


注意すべき点の 1 つは、 @code{IS} には特別なコンパイル機能(compilation semantics)があり、 (@code{TO}
のように)コンパイル時に名前をパースするということです:

@example
: set-greet ( xt -- )
  IS greet ;

' greet1 set-greet
@end example

@code{IS} が適合しない状況では、 代わりに @code{defer!} を使用してください。

defer された ワードは、 xt から実行機能(execution semantics)のみを継承できます(xt
が表現できるのはそれだけであるためです -- これについての詳しい説明は @pxref{Tokens for Words} 参照)。
デフォルトでは、この実行機能(execution semantics)から派生したデフォルトのインタプリタ機能(interpretation
semantics)とコンパイル機能(compilation semantics)を持ちます。  ただし、 defer された
ワードのインタプリタ機能とコンパイル機能は、 通常の方法で変更できます。

@example
: bar .... ; immediate
Defer fred immediate
Defer jim

' bar IS jim  \ jim has default semantics
' bar IS fred \ fred is immediate
@end example

@findex Defer ( @var{ "name" --   } ) core-ext
@cindex @code{Defer}
@kindex Defer
@format
@code{Defer} ( @i{"name" --  }) core-ext ``Defer''
@end format
defer された ワード @i{name} を定義します。 その実行機能(execution semantics)は @code{defer!}
または @code{is} で設定できます(最初に @i{name} を実行する前に設定する必要があります)。


@findex defer! ( @var{ xt xt-deferred --   } ) core-ext
@cindex @code{defer!}
@kindex defer!
@format
@code{defer!} ( @i{xt xt-deferred --  }) core-ext ``defer-store''
@end format
xt (@var{xt-deferred}) で表される defer された ワードに実行のための @var{xt} を設定します。


@findex IS ( @var{ xt "name" --   } ) core-ext
@cindex @code{IS}
@kindex IS
@format
@code{IS} ( @i{xt "name" --  }) core-ext ``IS''
@end format
@code{defer} された ワード @var{name} に実行のための @var{xt} を設定します。


@findex defer@@ ( @var{ xt-deferred -- xt   } ) core-ext
@cindex @code{defer@@}
@kindex defer@@
@format
@code{defer@@} ( @i{xt-deferred -- xt  }) core-ext ``new-defer-fetch''
@end format
@i{xt} は、 defer された ワード @i{xt-deferred} に現在関連付けられているワードを表します。


@findex action-of ( @var{ interpretation "name" -- xt; compilation "name" -- ; run-time -- xt   } ) core-ext
@cindex @code{action-of}
@kindex action-of
@format
@code{action-of} ( @i{interpretation "name" -- xt; compilation "name" -- ; run-time -- xt  }) core-ext ``action-of''
@end format
@i{Xt} は、 現在 @i{name} に割り当てられている XT です。



@c Use @code{words-deferred} to see a list of deferred words.

Forth-94 では、 これら Forth-2012 のワードの定義は、@file{compat/defer.fs} で提供されます。  さらに、
Gforth は以下を提供します:

@findex defers ( @var{ compilation "name" -- ; run-time ... -- ...   } ) gforth-0.2
@cindex @code{defers}
@kindex defers
@format
@code{defers} ( @i{compilation "name" -- ; run-time ... -- ...  }) gforth-0.2 ``defers''
@end format
defer された ワード @i{name} の現在の内容を現在の定義にコンパイルします。  つまり、 これにより、 @i{name} が defer
されなかったかのように静的結び付け(static binding)が生成されます。


@findex wrap-xt ( @var{ xt1 xt2 xt: xt3 -- ...   } ) gforth-1.0
@cindex @code{wrap-xt}
@kindex wrap-xt
@format
@code{wrap-xt} ( @i{xt1 xt2 xt: xt3 -- ...  }) gforth-1.0 ``wrap-xt''
@end format
defer された ワード xt2 の現在の xt-current をどこかに退避して xt1 に設定した上で、 xt3 を実行し、 xt3 実行後、
退避した xt-current を defer されたワード xt2 に戻します(訳注: xt3 の内部のどこかで defer されたワード xt2
を使っているとして、 xt2 の実行機能を一時的に xt1 に設定してから xt3 を実行し、 実行後に xt2 の実行機能を元に戻しておく。
元に戻すのは try ... restore ... endtry で囲まれた部分なので xt3 実行中にエラーがあっても確実に復旧される。
詳しくはソースコード見て下さい。 なお、  xt: は xt3 を deferフレーバーに設定する)


@findex preserve ( @var{ "name" --   } ) gforth-1.0
@cindex @code{preserve}
@kindex preserve
@format
@code{preserve} ( @i{"name" --  }) gforth-1.0 ``preserve''
@end format
指定の defer された ワード @i{name} で、 現在設定されている実行機能 @i{xt} を、 その場で @code{is} や
@code{defer!} したかのようなコードに変換します(訳注: 上記例より、 ' greet2 is greet  :
preserve-greet2 preserve greet ; → greet1 is greet  ok  → greet Good morning
ok → preserve-greet2  ok → greet Hello ok ; see preserve-greet2 → :
preserve-greet2  `greet2 `greet ! ; ok)




@node Forward, Aliases, Deferred Words, Defining Words
@subsection Forward

@code{forward.fs} 内の定義ワード @code{forward} を使用すると、 前方参照(forward
references)を作成できます。 これは自動的に解決され、 @code{Defer}
の間接化(indirection)のような追加コストは発生しません。  ただし、 これらの forward 定義はコロン定義に対してのみ機能します。

@findex forward ( @var{ "name" --   } ) gforth-1.0
@cindex @code{forward}
@kindex forward
@format
@code{forward} ( @i{"name" --  }) gforth-1.0 ``forward''
@end format
コロン定義への前方参照(forward reference)を定義します。
同一のワードリスト内(wordlist)で同一の名前のコロン定義を定義すると、 前方参照が解決されます。  @code{.unresolved}
を使用して、 未解決の forward があるかどうかを確認します。


@findex .unresolved ( @var{ --   } ) gforth-1.0
@cindex @code{.unresolved}
@kindex .unresolved
@format
@code{.unresolved} ( @i{--  }) gforth-1.0 ``.unresolved''
@end format
未解決の前方参照(forward references)をすべて出力します



@node Aliases, , Forward, Defining Words
@subsection Aliases
@cindex aliases
@cindex synonyms

定義ワード @code{synonym} を使用すると、 他のワードと同一の振る舞いをするワードを名前で定義できます。 これが役立つ 2
つの状況を以下に示します:

@itemize @bullet
@item
別のワードリストからワードの定義にアクセスしたい場合(この例については、 Gforth ソースの @code{root}
ワードリストの定義を参照してください)。
@item
あなたが同義語(synonym)を作成したい場合。 2つの名前どちらでも認識できる定義(たとえば、 @code{THEN} と @code{ENDIF}
は同義語(synonyms)です)。
@end itemize

@findex Synonym ( @var{ "name" "oldname" --   } ) tools-ext
@cindex @code{Synonym}
@kindex Synonym
@format
@code{Synonym} ( @i{"name" "oldname" --  }) tools-ext ``Synonym''
@end format
@i{oldname} と同一に振る舞うように @i{name} を定義します。 つまり、 同一のインタプリタ機能(interpretation
semantics)と、 同一のコンパイル機能(compilation semantics)と、 同一の @code{to}/@code{defer!}
や @code{defer@@} 機能を持ちます。



Gforth は、 コンパイル機能、 または @code{to}/@code{defer!} や @code{defer@@} 機能を親から継承しない、
非標準の @code{alias} も提供します。 あなたは後で、 例えば @code{immediate}
などを使用してコンパイル機能などを変更できます。

@findex Alias ( @var{ xt "name" --   } ) gforth-0.2
@cindex @code{Alias}
@kindex Alias
@format
@code{Alias} ( @i{xt "name" --  }) gforth-0.2 ``Alias''
@end format
@i{name} を @i{xt} を実行するワードとして定義します。  defer された ワードとは異なり、
エイリアス(aliase)にはコンパイル時に間接的なオーバーヘッドがありません。



Example:

@example
: foo ... ; immediate

' foo Alias bar1           \ bar1 is not an immediate word
' foo Alias bar2 immediate \ bar2 is an immediate word
synonym bar3 foo           \ bar3 is an immediate word
@end example

synonyms(同義語)とaliases(別名)はどちらも元の nt とは異なる nt を持ちますが、 それをチック(tick)すると(または
@code{name>interpret} を使用すると)、 元の xt と同じ xt が生成されます(@pxref{Tokens for
Words})。

@node Interpretation and Compilation Semantics, Tokens for Words, Defining Words, Words
@section Interpretation and Compilation Semantics
@cindex semantics, interpretation and compilation

@c !! state and ' are used without explanation
@c example for immediate/compile-only? or is the tutorial enough

@cindex interpretation semantics
(名前付き)ワード(word)のインタプリタ機能(@dfn{interpretation semantics})は、
テキスト・インタプリタがインタプリタ状態でワードに遭遇したときに行うことです。 これは他の文脈でも表れます。 たとえば、 @code{'
@i{word}} によって返される実行トークンは、 @i{word} のインタプリタ機能(@dfn{interpretation
semantics})を識別します(つまり、 @code{' @i{word} execute} は、 @code{@i{word}}
のインタプリタ状態でのテキスト通訳(interpretation)と同等です)。

@cindex compilation semantics
(名前付き)ワード(word)のコンパイル機能(@dfn{compilation semantics})は、
テキスト・インタプリタがコンパイル状態でワードに遭遇したときに行うことです。 これは他の文脈でも表れます。 たとえば、 @code{POSTPONE
@i{word}} は、 @i{word} のコンパイル機能(compilation
semantics)コンパイルします@footnote{標準の用語では、 「現在の定義に追加する」と言います}。

ほとんどのワードにはデフォルトのコンパイル機能(compilation semantics)があります。 つまり実行機能(execution
semantics)(スタック効果 @code{( -- )})をコンパイルします。  ただし、多くのワードが他のコンパイル機能(compilation
semantics)を持っていて、 その個々のワードについては文書化されています(スタック効果を含む)。

@cindex execution semantics
標準では、 実行機能(@dfn{execution semantics})についても述べています。 標準では、
両方が定義されている場合はインタプリタ機能(interpretation semantics)と異なることはありませんが、 一方が定義されていない、
または、 両方とも定義されていない場合もあります。  Gforth ではインタプリタ機能(interpretation
semantics)と実行機能(execution semantics)には違いがないため、 これらの用語は同じ意味で使用されます。

Gforth (1.0 以降)では、 すべてのワードに インタプリタ機能/実行機能 が定義されています。
標準でインタプリタ機能も実行機能も定義されていない多くのワード(@code{if} など)については、 Gforth の インタプリタ機能/実行機能
がコンパイル機能を実行します。

標準では、 実行機能はデフォルトでインタプリタ機能とコンパイル機能を定義するために使用されます。
デフォルトでは、ワードのインタプリタ機能はその実行機能を @code{execute} し、 ワードのコンパイル機能はその実行機能を
@code{compile,} します@footnote{標準の用語でいうと、 デフォルトのインタプリタ機能はその実行機能です。
デフォルトのコンパイル機能は、 その実行機能を現在の定義の実行機能に追加します}。

名前無しワード(@pxref{Anonymous Definitions})は、 テキスト・インタプリタまたはチック(tick)または
@code{postpone} では検出できません。 このようなワードはその xt (@pxref{Tokens for Words})
によって表され、 この xt が @code{execute} されたときは、 その実行機能が呼び出されます。

@comment TODO expand, make it co-operate with new sections on text interpreter.

@cindex immediate words
@cindex compile-only words
あなたは、 最後に定義されたワードの機能(semantics)を変更できます:


@findex immediate ( @var{ --   } ) core
@cindex @code{immediate}
@kindex immediate
@format
@code{immediate} ( @i{--  }) core ``immediate''
@end format
ワードのコンパイル機能を、 その実行機能を実行するように設定します。


@findex compile-only ( @var{ --   } ) gforth-0.2
@cindex @code{compile-only}
@kindex compile-only
@format
@code{compile-only} ( @i{--  }) gforth-0.2 ``compile-only''
@end format
最後の定義をコンパイル専用としてマークします。 その結果、 テキスト・インタプリタと @code{'} は、
そのようなワードに遭遇すると警告を発します。


@findex restrict ( @var{ --   } ) gforth-0.2
@cindex @code{restrict}
@kindex restrict
@format
@code{restrict} ( @i{--  }) gforth-0.2 ``restrict''
@end format
@code{compile-only} の同義語(synonym)



慣習により、 デフォルト以外のコンパイル機能を持つワード(即実行ワードなど)は、多くの場合、
名前が括弧(brackets;角括弧)で囲まれています(例: @code{[']} @pxref{Execution token})。

注意: compile-only のワードにチック(tick)(@code{'})を付けると、警告(``<word> is
compile-only'')が表示されることに注意してください。

@menu
* Combined words::           
@end menu


@node Combined words, , Interpretation and Compilation Semantics, Interpretation and Compilation Semantics
@subsection Combined Words
@cindex combined words

Gforth を使用すると、 複合ワード(@dfn{combined words})、 つまりインタプリタ機能(interpretation
semantics)とコンパイル機能(compilation semantics)を任意に組み合わせたワードを定義できます。

@findex interpret/compile: ( @var{ interp-xt comp-xt "name" --   } ) gforth-0.2
@cindex @code{interpret/compile:}
@kindex interpret/compile:
@format
@code{interpret/compile:} ( @i{interp-xt comp-xt "name" --  }) gforth-0.2 ``interpret/compile:''
@end format


この機能は、 @code{TO} と @code{S"} を実装するために導入されました。 このようなワードは、
たとえ小さなかわいいものであっても定義しないことをお勧めします。 なぜなら、 ワードによっては、
いくつかの文脈でワードの両方の部分を理解するのが困難になるからです。 たとえば、 あなたがコンパイル部分の実行トークンを取得したいとすると、 代わりに、
2つのワードを定義します。 1つはインタプリタ機能部分を具体化するもで、 もう一つはコンパイル機能部分を具体化するものです。 それら完成したら、
あなたのユーザーの便宜のために @code{interpret/compile:} を使用して、 それらを組み合わせた複合ワード(combined
word)を定義できます。

この機能を使用して、 ワードのデフォルトのコンパイル機能(compilation semantics)の最適化実装を提供してみるとしましょう。
たとえば、 以下のように定義します:
@example
:noname
   foo bar ;
:noname
   POSTPONE foo POSTPONE bar ;
interpret/compile: opti-foobar
@end example

@noindent
上記は以下の最適化バージョンです:

@example
: foobar
    foo bar ;
@end example

残念ながら、 これは @code{[compile]} では正しく動きません。 なぜなら、 @code{[compile]} では、 すべての
@code{interpret/compile:} ワードのコンパイル機能がデフォルトでは無いと想定しているためです。 つまり、
@code{[compile] opti-foobar} はコンパイル機能をコンパイルしますが、 @code{[compile] foobar}
はインタプリタ機能をコンパイルします。

@cindex state-smart words (are a bad idea)
@anchor{state-smartness}
@dfn{state-smart} ワードを使用して、@code{interpret/compile:}
によって提供される機能をエミュレートしようとする人もいます(実行途中に @code{STATE} をチェックする場合、 ワードは state-smart
になります)。 たとえば、@code{foobar} を以下のようにコーディングしようとします:

@example
: foobar
  STATE @@
  IF ( compilation state )
    POSTPONE foo POSTPONE bar
  ELSE
    foo bar
  ENDIF ; immediate
@end example

これは @code{foobar} がテキスト・インタプリタによってのみ処理される場合には機能しますが、 他のコンテキスト(@code{'} や
@code{POSTPONE} など)では機能しません。 たとえば、 @code{' foobar} は、 元の @code{foobar}
のインタプリタ機能ではなく、 state-smart ワードの実行トークンを生成します。 この実行トークンを(@code{EXECUTE} で直接、
または @code{COMPILE,} で間接的に)コンパイル状態において実行(execute)すると、 結果は期待したものになりません(つまり、
@code{foo bar} は実行されません)。 state-smart ワードは良くないアイディアです。 対策は、
こんなの書かない事！です@footnote{このトピックに関する議論の詳細は M. Anton Ertl,
@cite{@uref{https://www.complang.tuwien.ac.at/papers/ertl98.ps.gz,@code{State}-smartness---Why
it is Evil and How to Exorcise it}}, EuroForth '98. をご覧ください。}。

@c -------------------------------------------------------------
@node Tokens for Words, Compiling words, Interpretation and Compilation Semantics, Words
@section Tokens for Words
@cindex tokens for words

このセクションでは、 ワードを表すトークンの作成とその使用について説明します。

@menu
* Execution token::          実行/インタプリタ 
                               機能(execution/interpretation semantics)
* Name token::               名前付きワード
* Compilation token::        コンパイル機能(compilation semantics)
@end menu

@node Execution token, Name token, Tokens for Words, Tokens for Words
@subsection Execution token

@cindex xt
@cindex execution token
実行トークン(@dfn{execution token})(@i{xt})はワードの振る舞いを表します。  @code{execute} を使用して
xt で表される振る舞いを呼び出すことができ、 そして、 @code{compile,} (@pxref{Macros})
を使用してそれを現在の定義にコンパイルできます。 その他の使用法としては、 defer された ワード(@pxref{Deferred Words})
があります。

特に、 ワードのインタプリタ機能(interpretation semantics)(別名 実行機能(execution
semantics))を表す「実行トークン」(execution token)があります@footnote{標準 Forth には、
インタプリタ機能(interpretation semantics)が未定義のワード(例: @code{r@@})や、
定義された実行機能(execution semantics)が無いワード(例: @code{s"})や、 およびそのどちらも持たないワード(例:
@code{if})があります。 ただし、 インタプリタ機能(interpretation semantics)と実行機能(execution
semantics)の両方が定義されている場合、 それらは同一でであるため、 それらを同一のものとして扱います}。

@cindex prefix @code{`}
@cindex @code{`} prefix
名前付きワード @i{x} の場合、
@code{`@i{x}}(訳注:アポストロフィではなくてバックスラッシュ)を使用してその実行トークンを取得できます:

@example
5 `. ( n xt )
execute ( )      \ execute the xt (i.e., ".")
: foo `. execute ;
5 foo
@end example

@cindex tick (')
しかしながら、 @code{`} プレフィックスは Gforth 拡張であるため、 以下の標準 Forth のワードを使用する方が好ましいです:

@findex ' ( @var{ "name" -- xt   } ) core
@cindex @code{'}
@kindex '
@format
@code{'} ( @i{"name" -- xt  }) core ``tick''
@end format
@i{xt} は @i{name} のインタプリタ機能(interpretation semantics)を表します。
ワードにインタプリタ機能が無い場合、 @code{-14 throw} を実行します。


@findex ['] ( @var{ compilation. "name" -- ; run-time. -- xt   } ) core
@cindex @code{[']}
@kindex [']
@format
@code{[']} ( @i{compilation. "name" -- ; run-time. -- xt  }) core ``bracket-tick''
@end format
@i{xt} は @i{name} のインタプリタ機能(interpretation semantics)を表します。
ワードにインタプリタ機能が無い場合、 @code{-14 throw} を実行します。



これらはパース・ワード(parsing words)であるため(なお、 @code{`@i{x}}
は認識器(recognizer)によってリテラルとして扱われます)、
通訳(interpret)されたりコンパイルされたコードの振る舞いが直感的ではない場合があります:

@example
5 ' .   ( n xt ) 
execute ( -- )      \ execute the xt of .
\ 以下は意図したとおりに動きません:
\ : foo ' . ;
\ 5 foo execute
\ その代わりに以下のようにします:
: foo ['] . ;
5 foo execute    \ execute the xt of .
\ コロン定義内で ' を使った場合:
: bar ' execute ;
5 bar .          \ execute the xt of .
\ 訳注: 一見普段と変わらないように見えるが、
\       テキスト・インタプリタが . を実行するのではなく、
\       bar が その後ろのワードの xt を execute している。
\       よって bar の後ろを省略すると下記のようにエラーとなる
5 bar 
*the terminal*:10:6: error: Attempt to use zero-length string as a name
5 bar>>><<<
@end example

@code{'} は実行時にパースするため、 @code{bar} のようにコロン定義に置くと、
コロン定義内の次のワードを消費せずに実行時に次のワードが消費されます。  @code{`@i{x}} と書かずにリテラル xt
をコロン定義に入れたい場合は、 @code{['] @i{x}} と書きます。

Gforth の @code{`@i{x}} や @code{'} や @code{[']} は、 compile-only
ワードで使用すると警告(warn)します。 そのような使用法が、 異なる Forth システム間で移植できない可能性があるためです。

ワードの immediate のバリエーションを定義することで、 この警告(warning)と移植性の問題を回避できます。 例:

@example
: if postpone if ; immediate
: test [ ' if execute ] ." test" then ;
@end example

結果として得られる実行トークンが @code{execute} されたときは、 @code{if} のコンパイル機能(compilation
semantics)を実行します。

xt を取得するもう一つ方法は、 @code{:noname} または @code{latestxt} です(@pxref{Anonymous
Definitions})。  匿名のワードの場合、 @code{:noname} または @code{latestxt} により、
そのワードが持つ唯一の振る舞い(実行機能(execution semantics)) の xt が得られますが、 名前付きワードの定義の後ろで
@code{latestxt} を使用して、 その xt を取得することもできます。

@example
:noname ." hello" ;
execute
@end example

xt は 1 つのセルを占有し、 他のセルと同様に操作できます。

標準 Forth では、 xt は単なる抽象データ型です(つまり、 xt を生成または消費する操作によって定義されます)。 (Gforth 1.0
以降の)具体的な実装は、 ワードの本体アドレス(昔は PFA だった)です。 Gforth 0.7 以前では、 xt
はコード・フィールド・アドレス(CFA は PFA の 2 セル前)として実装されていました。

@findex execute ( @var{ xt --  } ) core
@cindex @code{execute}
@kindex execute
@format
@code{execute} ( @i{xt -- }) core ``execute''
@end format
実行トークン @i{xt} によって表される機能(semantics)を実行します。

@findex execute-exit ( @var{ compilation -- ; run-time xt nest-sys --   } ) gforth-1.0
@cindex @code{execute-exit}
@kindex execute-exit
@format
@code{execute-exit} ( @i{compilation -- ; run-time xt nest-sys --  }) gforth-1.0 ``execute-exit''
@end format
@code{xt} を実行し、 末尾呼び出し最適化法(tail-call-optimized way)で現在の定義から戻ります。 戻りアドレス
@code{nest-sys} とローカル変数(local)は、 @code{xt} を execute
する前に割り当て解除(deallocate)されます。


@findex perform ( @var{ a-addr --  } ) gforth-0.2
@cindex @code{perform}
@kindex perform
@format
@code{perform} ( @i{a-addr -- }) gforth-0.2 ``perform''
@end format
@code{@@ execute}.


@code{Noop} は、 しばしば実行トークンのプレースホルダーとして使用されます:

@findex noop ( @var{ --  } ) gforth-0.2
@cindex @code{noop}
@kindex noop
@format
@code{noop} ( @i{-- }) gforth-0.2 ``noop''
@end format



@node Name token, Compilation token, Execution token, Tokens for Words
@subsection Name token

@cindex name token
@cindex nt (name token)
Gforth は、名前付きワードを「名前トークン」@dfn{name token}(@i{nt})で表します。 名前トークンは、 引数または、
以下のワードの結果として発生するセル・サイズの抽象データ型です。

Gforth 1.0 以降、 ほとんどのワードの nt の具体的な実装は、 xt と同一アドレスです(これは xt のための基本 nt (primary
nt)です)。  ただし、 synonym と、 aliase と、 @code{interpret/compile:} で定義されたワードは、
別のワードから xt を取得しますが、 (xt とは異なり)依然として自分独自の nt を持ちます。  したがって、 Gforth 1.0
固有のコードを作成する準備ができている場合でも、 xt と nt を同一の意味で使用することはできません。 @code{>name}
を使用してこれら自分独自の nt を持つワードの xt から代替 nt を取得することはできません。

@code{``@i{x}} (Gforth 1.0 以降) または、 以下を使用して、 ワード @i{x} の nt を取得します

@findex find-name ( @var{ c-addr u -- nt | 0   } ) gforth-0.2
@cindex @code{find-name}
@kindex find-name
@format
@code{find-name} ( @i{c-addr u -- nt | 0  }) gforth-0.2 ``find-name''
@end format
現在の検索順序スタック(the search order)で名前 @i{c-addr u} を見つけます。 @i{nt} が見つかった場合はそれを返し、
それ以外の場合は 0 を返します。


@findex find-name-in ( @var{ c-addr u wid -- nt | 0   } ) gforth-1.0
@cindex @code{find-name-in}
@kindex find-name-in
@format
@code{find-name-in} ( @i{c-addr u wid -- nt | 0  }) gforth-1.0 ``find-name-in''
@end format
@i{wid} で識別されるワードリストで、 @i{c-addr u} の文字列で指定された定義を検索します。  @i{nt}
が見つかった場合はそれを返し、 それ以外の場合は 0 を返します。


@findex latest ( @var{ -- nt   } ) gforth-0.6
@cindex @code{latest}
@kindex latest
@format
@code{latest} ( @i{-- nt  }) gforth-0.6 ``latest''
@end format
@var{nt} は、 最後に定義されたワードの名前トークンです。 最後のワードに名前がない場合は 0 です。


@findex latestnt ( @var{ -- nt   } ) gforth-1.0
@cindex @code{latestnt}
@kindex latestnt
@format
@code{latestnt} ( @i{-- nt  }) gforth-1.0 ``latestnt''
@end format
@i{nt} は、 最後に定義されたワードの名前トークンです(訳注: 名前が無い場合でも nt を返す。 その nt を name>string
すると、 長さ 0 の文字列(addr u) を返す)


@findex >name ( @var{ xt -- nt|0   } ) gforth-0.2
@cindex @code{>name}
@kindex >name
@format
@code{>name} ( @i{xt -- nt|0  }) gforth-0.2 ``to-name''
@end format
@i{xt} で表されるワードの基本名前トークン(primary name token) @i{nt} を取得します。  @i{xt} が ぢつは xt
でない場合(非 xt を xt と誤認する可能性が低いヒューリスティック・チェックを使用)、 または基本 nt (primary
nt)が名前無しワードである場合は 0 を返します。  Gforth 1.0 の時点では、 すべての xt に基本 nt がありますが、
他の名前付きワードも同一のインタプリタ機能(interpretation sematics) xt を持つ可能性があります。


@findex xt>name ( @var{ xt -- nt   } ) gforth-1.0
@cindex @code{xt>name}
@kindex xt>name
@format
@code{xt>name} ( @i{xt -- nt  }) gforth-1.0 ``xt-to-name''
@end format
xt の基本 nt (primary nt)を生成します。  @i{xt} が、 ぢつは xt でない場合、 @i{nt} は nt
であるとは保証されません。



以下を使用すると、 ワードリスト内のすべての nt を取得できます

@findex traverse-wordlist ( @var{ ... xt wid -- ...   } ) tools-ext
@cindex @code{traverse-wordlist}
@kindex traverse-wordlist
@format
@code{traverse-wordlist} ( @i{... xt wid -- ...  }) tools-ext ``traverse-wordlist''
@end format
@i{f} が false になるかワードリストがなくなるまで、 ワードリスト @i{wid} 内のワード @i{nt} ごとに @i{xt} (
... nt -- f ... ) を 1 回実行します。  @i{xt} はスタックその下側を自由に使用できます(訳注: つまり TOS に f
さえ返せばスタックに何が積まれても(積まれなくても)気にしない)



nt を使用すると、 ワードのインタプリタ機能(interpretation semantics)とコンパイル機能(compilation
semantics)や、 その名前や、 ワードリスト内の次のワードのワード、 にアクセスできます:

@findex name>interpret ( @var{ nt -- xt   } ) tools-ext
@cindex @code{name>interpret}
@kindex name>interpret
@format
@code{name>interpret} ( @i{nt -- xt  }) tools-ext ``name-to-interpret''
@end format
@i{xt} はワード @i{nt} のインタプリタ機能(interpretation semantics)を表します。


@findex name>compile ( @var{ nt -- w xt   } ) tools-ext
@cindex @code{name>compile}
@kindex name>compile
@format
@code{name>compile} ( @i{nt -- w xt  }) tools-ext ``name-to-compile''
@end format
@i{w xt} はワード @i{nt} のコンパイル・トークン(compilation token)です(訳注: コンパイル・トークン CT は
2セル構成)。


@findex name>string ( @var{ nt -- addr u   } ) tools-ext
@cindex @code{name>string}
@kindex name>string
@format
@code{name>string} ( @i{nt -- addr u  }) tools-ext ``name-to-string''
@end format
@i{addr count} は、 @i{nt} で表されるワードの名前です。


@findex id. ( @var{ nt --   } ) gforth-0.6
@cindex @code{id.}
@kindex id.
@format
@code{id.} ( @i{nt --  }) gforth-0.6 ``i-d-dot''
@end format
@var{nt} で表されるワードの名前を出力します。


@findex .id ( @var{ nt --   } ) gforth-0.6
@cindex @code{.id}
@kindex .id
@format
@code{.id} ( @i{nt --  }) gforth-0.6 ``dot-i-d''
@end format
@code{id.} の F83 での名前です。


@findex name>link ( @var{ nt1 -- nt2 / 0   } ) gforth-1.0
@cindex @code{name>link}
@kindex name>link
@format
@code{name>link} ( @i{nt1 -- nt2 / 0  }) gforth-1.0 ``name-to-link''
@end format
ワード @i{nt1} の場合、 同じワードリスト内の1つ前のワード @i{nt2} を返します。 前のワードがない場合は 0 を返します。



名前なしワードは通常、 インタプリタ機能(interpretation compilation)も無く、 コンパイル機能(compilation
semantics)も無く、 名前も無く、 単語リストにもありません。  しかし、Gforth (1.0 以降) ではすべてのワードは等しいため、
名前無しのワードにも nt があります(ただし、 ワードリストには含まれません)。  その nt は @code{latestnt} で取得でき、 nt
を消費する上記のワード群はこれらの nt に対して適切な処理を行います。

使用例として、 以下のコードは、デフォルト以外のコンパイル機能(compilation semantics)を持つ
@code{forth-wordlist} 内のすべてのワードをリストします:

@example
: ndcs-words ( wid -- )
  [: dup name>compile ['] compile, <> if over id. then 2drop true ;]
  swap traverse-wordlist ;

forth-wordlist ndcs-words
@end example

@c which
@c holds for Gforth.  There are a few standard ways for a Forth system to
@c deviate from this assumption (although it's more likely that a system
@c that deviates gets it wrong and is non-standard).
このコードは、 コンパイル・トークンの xt 部分が @code{compile,} の xt である場合、
ワードがデフォルトのコンパイル機能(compilation semantics)を持っていると仮定しています。


@cindex name field address
@cindex NFA
いにしえの Forth システムの nt に最も近いのはネーム・フィールド・アドレス(NFA)ですが、 Gforth とは顕著な違いがあります。
いにしえの Forth システムでは、 各ワードに一意の NFAとLFAとCFAとPFA(または、LFAとNFAとCFAとPFAの順)があり、
あるワードから次のワードへと進むためのワードがありました。 これとは対照的に、 Gforth では、 いくつかの nt が
@code{name>interpret} xt からは同一の xt を取得できます。
名前トークンによって識別される構造体にリンク・フィールドがありますが、 通常、 検索にはこれらの構造体の外部にあるハッシュ・テーブルが使用されます。
Gforth の名前はセル幅のカウントおよびフラグ・フィールド(cell-wide count-and-flags field)がありますが、 nt
はそのカウント・フィールドへのアドレスとしては実装されていません。


@node Compilation token, , Name token, Tokens for Words
@subsection Compilation token

@cindex compilation token
@cindex ct (compilation token)
名前付きワードのコンパイル機能(compilation semantics)は、 2 つのセル @i{w xt}
で構成されるコンパイル・トークン(@dfn{compilation token})によって表されます。 一番上のセル @i{xt} は実行トークンです。
コンパイル・トークンによって表されるコンパイル機能は、 @code{execute} で実行できます。 これは、 コンパイル・トークン全体を消費し、
コンパイル・トークンが表すコンパイル機能(compilation semantics)によって決定される追加のスタック効果を伴います。  

現時点では、 コンパイル・トークンの @i{w} 部分は実行トークンで、 @i{xt} 部分は @code{execute} または
@code{compile,} のいずれかを表します@footnote{これは、 ワードのコンパイル機能(compilation
semantics)に依存します。 ワードにデフォルトのコンパイル機能(compilation semantics)がある場合、 @i{xt} は
@code{compile,} を表します。 それ以外の場合(たとえば、 即実行ワードの場合)、 @i{xt} は @code{execute}
を表します}。 ただし、 必要な場合を除き、 この知識に頼らないでください。  Gforth の将来のバージョンでは、
普通でない(unusual)なコンパイル・トークン(リテラルのコンパイル機能を表すコンパイル・トークンなど)が導入される可能性があります。

たとえば、 @code{if} のコンパイル・ークンは、 @code{name>compile} を使用した標準的な方法(例: @code{`if
name>compile})で取得できますが、 コンパイル・トークンを取得するためのパース・ワードもあります:

@findex [COMP'] ( @var{ compilation "name" -- ; run-time -- w xt   } ) gforth-0.2
@cindex @code{[COMP']}
@kindex [COMP']
@format
@code{[COMP']} ( @i{compilation "name" -- ; run-time -- w xt  }) gforth-0.2 ``bracket-comp-tick''
@end format
コンパイル・トークン @i{w xt} は、 @i{name} のコンパイル機能(compilation semantics)を表します。


@findex COMP' ( @var{ "name" -- w xt   } ) gforth-0.2
@cindex @code{COMP'}
@kindex COMP'
@format
@code{COMP'} ( @i{"name" -- w xt  }) gforth-0.2 ``comp-tick''
@end format
コンパイル・トークン @i{w xt} は、 @i{name} のコンパイル機能(compilation semantics)を表します。



@code{execute} を使用して、 コンパイル・トークンによって表されるコンパイル機能(compilation
semantics)を実行できます。  @code{postpone,} を使用してコンパイル機能(compilation
semantics)をコンパイルできます。 つまり、 @code{``@i{x} name>compile postpone,} は
@code{postpone @i{x}} と同等です。

@findex postpone, ( @var{ w xt --   } ) gforth-0.2
@cindex @code{postpone,}
@kindex postpone,
@format
@code{postpone,} ( @i{w xt --  }) gforth-0.2 ``postpone-comma''
@end format
コンパイル・トークン @i{w xt} で表されるコンパイル機能(compilation semantics)をコンパイルします。



@c ----------------------------------------------------------
@node Compiling words, The Text Interpreter, Tokens for Words, Words
@section Compiling words
@cindex compiling words
@cindex macros

他のほとんどの言語とは異なり、 Forth にはコンパイルと実行時(run-time)の間に厳密な境界がありません。  たとえば、
ワードの定義中(または @code{constant} のようなワードの定義によって使用されるデータのための計算)に任意のコードを実行できます。
さらに、 @code{immediate} (@pxref{Interpretation and Compilation Semantics}) や
@code{[}...@code{]} (下記参照)を使用すると、 コロン定義のコンパイル中に任意のコードを実行できます(例外:
ディクショナリ空間で割り当てしてはいけません)。

@menu
* Literals::                 データ値をコンパイルします
* Macros::                   Compiling words
@end menu

@node Literals, Macros, Compiling words, Compiling words
@subsection Literals
@cindex Literals

最も単純で最も頻繁に使用される例は、 コンパイル中にリテラルを計算することです。  たとえば、 以下の定義は、 文字列の配列を 1 行に 1
つの文字列で出力します:

@example
: .strings ( addr u -- ) \ gforth
    2* cells bounds U+DO
        cr i 2@@ type
    2 cells +LOOP ;  
@end example

Gforth のような愚かで低能なコンパイラを使用すると、 ループ反復ごとに @code{2 cells} が計算されます。  あなたは、
この値をコンパイル時に一度だけ計算し、 定義にコンパイルできます。 以下のようにします:

@example
: .strings ( addr u -- ) \ gforth
    2* cells bounds U+DO
        cr i 2@@ type
    [ 2 cells ] literal +LOOP ;  
@end example

@code{[} は、 テキスト・インタープリタをインタプリタ状態に切り替えます(この例を対話的に入力し、 @code{[} と @code{]}
の間に改行を挿入すると、 @code{ok} プロンプトが表示されます)。 @code{2 cells}
のインタプリタ機能(interpretation semantics)を実行します。 ここでは数値を計算します。  @code{]} は、
テキスト・インタプリタをコンパイル状態に戻します。  次に、 この数値を現在のワードにコンパイルする @code{Literal}
のコンパイル機能(compilation semantics)を実行します。 @code{see .strings}
を使用してワードを逆コンパイルすると、 コンパイルされたコードへの影響を確認できます。

この方法で @code{2* cells} を @code{[ 2 cells ] literal *}  に最適化することもできます。

@findex [ ( @var{ --   } ) core
@cindex @code{[}
@kindex [
@format
@code{[} ( @i{--  }) core ``left-bracket''
@end format
インタプリタ状態にします。 即実行ワードです。


@findex ] ( @var{ --   } ) core
@cindex @code{]}
@kindex ]
@format
@code{]} ( @i{--  }) core ``right-bracket''
@end format
コンパイル状態にします。


@findex Literal ( @var{ compilation n -- ; run-time -- n   } ) core
@cindex @code{Literal}
@kindex Literal
@format
@code{Literal} ( @i{compilation n -- ; run-time -- n  }) core ``Literal''
@end format
コンパイル機能(compilation semantics): 実行機能(run-time semantics)をコンパイルします。
実行機能(run-time semantics): @i{n} をスタックにプッシュします。 インタプリタ機能(interpretation
semantics): 未定義です。


@findex ALiteral ( @var{ compilation addr -- ; run-time -- addr   } ) gforth-0.2
@cindex @code{ALiteral}
@kindex ALiteral
@format
@code{ALiteral} ( @i{compilation addr -- ; run-time -- addr  }) gforth-0.2 ``ALiteral''
@end format
@code{literal} と同様に機能しますが、
(クロス・コンパイルされたコードで使用される場合、)リテラルがアドレスであることをクロス・コンパイラーに伝えます。


@findex ]L ( @var{ compilation: n -- ; run-time: -- n   } ) gforth-0.5
@cindex @code{]L}
@kindex ]L
@format
@code{]L} ( @i{compilation: n -- ; run-time: -- n  }) gforth-0.5 ``]L''
@end format
@code{] literal} と同等。



単一セル以外のデータ型をリテラルとしてコンパイルするためのワードもあります:

@findex 2Literal ( @var{ compilation w1 w2 -- ; run-time  -- w1 w2   } ) double
@cindex @code{2Literal}
@kindex 2Literal
@format
@code{2Literal} ( @i{compilation w1 w2 -- ; run-time  -- w1 w2  }) double ``two-literal''
@end format
実行時に @i{w1 w2} がスタックに配置されるように、 適切なコードをコンパイルします。 インタプリタ機能(interpretation
semantics)は未定義です。


@findex FLiteral ( @var{ compilation r -- ; run-time -- r   } ) floating
@cindex @code{FLiteral}
@kindex FLiteral
@format
@code{FLiteral} ( @i{compilation r -- ; run-time -- r  }) floating ``f-literal''
@end format
実行時に @i{r} が(浮動小数点)スタックに配置されるように、 適切なコードをコンパイルします。 インタプリタ機能(interpretation
semantics)は未定義です。


@findex SLiteral ( @var{ Compilation c-addr1 u ; run-time -- c-addr2 u   } ) string
@cindex @code{SLiteral}
@kindex SLiteral
@format
@code{SLiteral} ( @i{Compilation c-addr1 u ; run-time -- c-addr2 u  }) string ``SLiteral''
@end format
コンパイル時: @i{c-addr1}, @i{u} で指定された文字列を現在の定義にコンパイルします。 実行時: 文字列のアドレスと長さを記述する
@i{c-addr2 u} を返します。



@cindex colon-sys, passing data across @code{:}
@cindex @code{:}, passing data across
データ・スタック上のコロン定義の外側から内側にデータを渡したいと思うかもしれません。  @code{:} がコロン colon-sys をプッシュし、
colon-sys より下のモノのにアクセスできなくなるため、 これは機能しません。  たとえば、 以下は機能しません:

@example
5 : foo literal ; \ error: "unstructured"
@end example

代わりに、 変数など、 他の方法で値を渡す必要があります:

@example
variable temp
5 temp !
: foo [ temp @@ ] literal ;
@end example


@node Macros, , Literals, Compiling words
@subsection Macros
@cindex Macros
@cindex compiling compilation semantics

@code{Literal} とその仲間たちは、 データ値を現在の定義にコンパイルします。
他のワードを現在の定義にコンパイルするワードを記述することもできます。 例えば:

@example
: compile-+ ( -- ) \ compiled code: ( n1 n2 -- n )
  POSTPONE + ;

: foo ( n1 n2 -- n )
  [ compile-+ ] ;
1 2 foo .
@end example

これは @code{: foo + ;} と同等です(確認するには @code{see foo} としてください)。
この例では何が起こっているのでしょうか? @code{Postpone} は、 @code{+} のコンパイル機能(compilation
semantics)を @code{compile-+} にコンパイルします。 その後、 テキスト・インタプリタは @code{compile-+}
を実行し、 + のコンパイル機能(compilation semantics)を実行します。 これにより、@code{+}
(の実行機能(execution semantics)) が @code{foo} にコンパイルされます@footnote{最近の RFI の回答では、
ワードのコンパイルはコンパイル状態でのみ実行する必要があるとしているため、 この例はすべての標準システムで動作することは保証されませんが、
ちゃんとした(decent)システムであれば動作します}。

@findex postpone ( @var{ "name" --   } ) core
@cindex @code{postpone}
@kindex postpone
@format
@code{postpone} ( @i{"name" --  }) core ``postpone''
@end format
@i{name} の コンパイル機能(compilation semantics)をコンパイルする。



@code{compile-+} のようなコンパイル・ワード(compiling
words)のコンパイルは通常即実行ワード(または即実行同様)であるため、 それらを実行するためにインタプリタ状態に切り替える必要はありません。
最後の例をそれに応じて変更すると、 以下のようになります:

@example
: [compile-+] ( compilation: --; interpretation: -- )
  \ compiled code: ( n1 n2 -- n )
  POSTPONE + ; immediate

: foo ( n1 n2 -- n )
  [compile-+] ;
1 2 foo .
@end example

場合によっては、 複数のワードを POSTPONE する必要があることに気づくでしょう。 このような各ワードの前に POSTPONE
を置くのは面倒なので、 Gforth ではより便利な構文 @code{]] ... [[} を提供しています。  これにより、
@code{[compile-+]} を以下のように記述できるようになります:

@example
: [compile-+] ( compilation: --; interpretation: -- )
  ]] + [[ ; immediate
@end example

@findex ]] ( @var{ --   } ) gforth-0.6
@cindex @code{]]}
@kindex ]]
@format
@code{]]} ( @i{--  }) gforth-0.6 ``right-bracket-bracket''
@end format
postpone 状態に切り替え: すべてのワードと認識器(recognizers)は、 その前に @code{postpone}
があるかのように処理されます。  @code{[[} が認識されると、 postpone 状態は終了します。



角括弧の珍しい方向はその機能を示しています。 @code{]} が即時実行(インタプリタ状態)からコンパイルに切り替えるのと同じように、
@code{]]} はコンパイルから postpone 状態(つまり、 コンパイル機能のコンパイル)に切り替えます。  逆に、 @code{[[} は
postpone 状態からコンパイル状態に切り替えます。 これは、 コンパイル状態から即時実行(インタプリタ状態)に切り替える @code{[}
に似ています。

@code{]] }...@code{ [[} の本当の利点は、 POSTPONE するワードがたくさんある場合に明らかになります。  たとえば、
ワード @code{compile-map-array} (@pxref{Advanced macros Tutorial}) は、
以下のようにさらに短く書くことができます:

@example
: compile-map-array ( compilation: xt -- ; run-time: ... addr u -- ... )
\ at run-time, execute xt ( ... x -- ... ) for each element of the
\ array beginning at addr and containing u elements
  @{: xt: xt :@}
  ]] cells over + swap ?do
    i @@ xt 1 cells +loop [[ ;

: sum-array ( addr u -- n )
  0 [ ' + compile-map-array ] ;
@end example

@code{see sum-array} すると、 以下のコードが表示されます:

@example
: sum-array
  #0 over + swap ?do
    i @ + #8 +LOOP
;
@end example

@code{]]}...@code{[[} に加えて、 この例では他の機能もいくつかお披露目しています:

@itemize

@item
(@code{xt:} を指定する) defer フレーバーのローカル変数 @code{xt} を使用しています。
@code{]]}...@code{[[} 内でローカル変数 xt に遭遇すると、 ローカル変数 xt を @code{compile,} します。

@item
@code{]]}...@code{[[} 内でリテラル @code{1} を使用します。  これにより、 @code{1} が postpone
(延期)されます。 つまり、 @code{compile-map-array} の実行時にコンパイルされます。

@item
@code{compile-map-array} が実行されると、 @code{1 cells} がコンパイルされ、 Gforth
の定数折りたたみによって @code{#8} に最適化(optimize)されます。

@end itemize

注意: @code{s\"} などのワードのパースは postpone 指定時にはパースされないため、 @code{]]}...@code{[[}
内ではパースされないことに注意してください。 @code{s\" mystring\n"} の代わりに、 文字列認識器(string
recognizer)を使用して、 @code{]]}...@code{[[} 内で動作する @code{"mystring\n"}
で記述することができます。これは @code{]]}...@code{[[} 内で機能します。 同様に、 パース・ワード @code{[']}
についても、  @code{`} で始まる認識器(recognizer)表記で記述することができます。

ただし、 あなたが @code{s\"} を使用したい場合(または、 認識器(recognizer)置換がないパース・ワードがある場合)、
以下のようにコンパイル状態に切り替えることで実行できます:

@example
]] ... [[ s\" mystring\n" ]] 2literal ... [[
@end example

標準 Forth での @code{]]} と、 その仲間の定義は、 @file{compat/macros.fs} で提供されます。

即時コンパイル・ワード(immediate compiling words)は、 他の言語(特に Lisp)のマクロに似ています。
C言語などのマクロとの重要な違いは以下のとおりです:

@itemize @bullet

@item
マクロの定義と処理には、 別個の前処理用の言語や処理器ではなく、 同一の言語を使用します。

@item
したがって、 Forth の全機能をマクロ定義で利用できます。 たとえば、 任意の複雑な計算を実行したり、
条件付きまたはループで異なるコードを生成したりできます (例: @pxref{Advanced macros Tutorial})。  この能力は、
パーサ・ジェネレータや、 その他のコード生成ソフトウェアを作成するときに非常に役立ちます。

@item
@code{postpone} などを使用して定義されたマクロは、 文字列よりも高いレベルで言語を扱います。 名前との結び付け(name
binding)はマクロ定義時に行われるため、 C言語のマクロで発生する可能性のある名前の衝突の落とし穴を回避できます。 もちろん、 Forth
は自由主義の言語(liberal language)であり、 以下のようなテキスト解釈マクロ(text-interpreted
macros)を使用して自分自身を攻撃することもできます

@example
: [compile-+] s" +" evaluate ; immediate
@end example

マクロ使用時に名前を結びつける(bind)だけでなく、 @code{evaluate} を使用すると、 あなたの定義は
@code{state}-smart (@pxref{state-smartness}) になります。
@end itemize

マクロで数値をワードにコンパイルすることが必要な場合があります。  これを行うためのワードは @code{literal} ですが、
@code{postpone} する必要があるため、 @code{literal} のコンパイル機能(compilation
semantics)はマクロがコンパイルされる時ではなくマクロの実行時に効果を発揮します:

@example
: [compile-5] ( -- ) \ compiled code: ( -- n )
  5 POSTPONE literal ; immediate

: foo [compile-5] ;
foo .
@end example

マクロにパラメータを渡して、 マクロを現在の定義にコンパイルする必要がある場合があります。  パラメータが数値の場合は、 @code{postpone
literal} を使用できます(他の値の場合も同様)。

コンパイルされるワードを渡したい場合、 通常の方法は、実行トークンと @code{compile,} を渡すことです:

@example
: twice1 ( xt -- ) \ compiled code: ... -- ...
  dup compile, compile, ;

: 2+ ( n1 -- n2 )
  [ ' 1+ twice1 ] ;
@end example

@findex compile, ( @var{ xt --   } ) core-ext
@cindex @code{compile,}
@kindex compile,
@format
@code{compile,} ( @i{xt --  }) core-ext ``compile-comma''
@end format
@i{xt} で表される機能(semantics)を現在の定義に追加します。 結果のコード断片が実行されると、 @i{xt} が
@code{execute} されたのと同一の振る舞いをします。



Gforth で利用可能な代替方法では、 コンパイル機能をパラメータ(compilation semantics)として渡すことができる、
コンパイル・トークンを使用します(@pxref{Compilation token})。 以下は、 上記と同じ例にこの方法を使ったものです:

@example
: twice ( ... ct -- ... ) \ compiled code: ... -- ...
  2dup 2>r execute 2r> execute ;

: 2+ ( n1 -- n2 )
  [ comp' 1+ twice ] ;
@end example

この例では、 @code{2>r} と @code{2r>} により、 実行(execute)されるコンパイル機能(compilation
semantics)がデータ・スタックに影響を与える場合でも、 @code{twice} が確実に機能するようにします(訳注: 2dup ( ct ct
) 2>r ( ct r:ct ) execute ( ?? r:ct ) 2r> ( ?? ct ) execute ( ??? ) 。 最初の
execute でデータ・スタックのTOSがどうなろうとも、 2つ目の execute のために ct を tos に与えるため。 ct は
2セル単位なので、 2dupで複製、 2>r ... 2r> で ct を1つ退避となる)

これらのワードを使用して完全な定義を定義することもできます。 これは、 @code{does>}
を使用する代わりの方法を提供します(@pxref{User-defined Defining Words})。  たとえば以下の代わりに

@example
: curry+ ( n1 "name" -- )
    CREATE ,
DOES> ( n2 -- n1+n2 )
    @@ + ;
@end example

以下のように定義することができます

@example
: curry+ ( n1 "name" -- )
  \ name execution: ( n2 -- n1+n2 )
  >r : r> POSTPONE literal POSTPONE + POSTPONE ; ;

-3 curry+ 3-
see 3-
@end example

n1 にアクセスするために @code{>r : r>} というシーケンスが必要です。 なぜなら、 @code{:} はデータ・スタックに
colon-sys をプッシュし、 それより下にある全てのモノにアクセスできなくなるためです。

ワードを定義するこの方法は、 @code{does>} を使用するよりも便利な場合もあれば、 そうでない場合もあります(@pxref{Advanced
does> usage example})。  この方式の利点の 1 つは、 コンパイラは、  @code{literal}
でコンパイルされた値が固定されているのに対して、 @code{create} されたワードに関連付けられたデータは変更可能なことを認識しているため、
より適切に最適化できることです。

@findex [compile] ( @var{ compilation "name" -- ; run-time ? -- ?   } ) core-ext
@cindex @code{[compile]}
@kindex [compile]
@format
@code{[compile]} ( @i{compilation "name" -- ; run-time ? -- ?  }) core-ext ``bracket-compile''
@end format
古いワード(lLegacy word)です。  代わりに @code{postpone} を使用してください。  @i{name}
がデフォルト以外のコンパイル機能(compilation semantics)を持つ場合は、 @code{postpone} と同様に機能します。
@i{name} がデフォルトのコンパイル機能を持つ(つまり、 通常のワードである)場合、 @code{[compile] @i{name}}
をコンパイルすることは、 @i{name} をコンパイルすることと同じです(つまり、 この場合 @code{[compile]} は冗長です)。



@c ----------------------------------------------------------
@node The Text Interpreter, The Input Stream, Compiling words, Words
@section The Text Interpreter
@cindex interpreter - outer
@cindex text interpreter
@cindex outer interpreter

@c Should we really describe all these ugly details?  IMO the text
@c interpreter should be much cleaner, but that may not be possible within
@c ANS Forth. - anton
@c nac-> I wanted to explain how it works to show how you can exploit
@c it in your own programs. When I was writing a cross-compiler, figuring out
@c some of these gory details was very helpful to me. None of the textbooks
@c I've seen cover it, and the most modern Forth textbook -- Forth Inc's,
@c seems to positively avoid going into too much detail for some of
@c the internals.

@c anton: ok.  I wonder, though, if this is the right place; for some stuff
@c it is; for the ugly details, I would prefer another place.  I wonder
@c whether we should have a chapter before "Words" that describes some
@c basic concepts referred to in words, and a chapter after "Words" that
@c describes implementation details.

テキスト・インタプリタ(text interpreter)は、 現在の入力デバイスからの入力を処理する無限ループです。
インタプリタの実装上でコンパイルされた Forth コードを実行する内部インタプリタ(inner
interpreter)(@pxref{Engine})とは対照的に、 これは外部インタプリタ(outer
interpreter)とも呼ばれます@footnote{このセクションは @ref{Introducing the Text Interpreter}
の拡大バージョンです}。

@cindex interpret state
@cindex compile state
テキスト・インタプリタは、 インタプリタ状態(@dfn{interpret state}) と コンパイル状態(@dfn{compile
state})の 2 つの状態のいずれかで動作します。 現在の状態は、 それにふさわしい名前の変数である @code{state}
によって定義されます。

このセクションでは、 テキスト・インタプリタがインタプリタ状態にあるときに、
ユーザー入力デバイス(キーボード)からの入力処理についてどのように振る舞うかについて説明することから始めます。 これは Forth
システムが動き始めた時のモードです。

@cindex input buffer
@cindex terminal input buffer
テキスト・インタプリタは、 入力バッファー(@dfn{input
buffer})@footnote{テキスト・インタプリタがキーボードからの入力を処理している時、
このメモリ領域はターミナル入力バッファー(@dfn{terminal input buffer} (TIB))と呼ばれ、 (既に廃止されていますが)
ワード @code{TIB} および ワード @code{#TIB} によってアドレス指定されます}と呼ばれるメモリ領域で動作します。 この領域には、
@key{RET} キーを押したときにキーボードからの入力が保存され、 入力バッファーの先頭から開始して、
先頭の空白文字達(デリミタ(@dfn{delimiters})と呼ばれる)をスキップし、 空白文字、
またはバッファーの終わりに達するまで文字列(空白以外の文字のシーケンス)をパースします。 文字列をパースした後、 以下の2つの試行を行います:

@cindex dictionary
@itemize @bullet
@item
定義のディクショナリ(@dfn{dictionary})内でその文字列を検索します。 その文字列が見つかった場合、 その文字列は、
とある定義(@dfn{definition})(ワード(@dfn{word})とも呼ばれる)を指し示していて、 そして、 ディクショナリ検索機能は、
テキスト・インタプリタがそのワードのインタプリタ機能(@dfn{interpretation
semantics})を実行できるようにするための情報を返します。 ほとんどの場合、 これは、 単にそのワードが execute
されることを意味します。
@item
文字列がディクショナリに見つからない場合、 テキスト・インタプリタは @ref{Number Conversion} で説明されているルールを使用して、
文字列を数値として処理しようと試みます。 文字列が現在の基数で有効な数値を表す場合、 その数値はパラメータ・スタック(整数の場合はデータ・スタック、
浮動小数点数の場合は浮動小数点スタック)にプッシュされます。
@end itemize

上記両方の試行が失敗した場合、 テキスト・インタプリタは入力バッファーの残りを破棄し、 そして、 エラー・メッセージを発行して、そして、
さらなる入力を待ちます。 いずれかの試行が成功すると、 テキスト・インタプリタは入力バッファー全体が処理されるまでパース処理を繰り返し、
全体が処理された時点でステータス・メッセージ ``@code{ ok}'' を出力し、 そして、 さらなる入力を待ちます。

@c anton: this should be in the input stream subsection (or below it)

@cindex parse area
テキスト・インタプリタは、 @code{>IN} (``to-in''(トゥーイン)と発音します)と呼ばれる変数を更新することにより、
入力バッファー内の位置を追跡します。  @code{>IN} の値は 0 で始まり、 入力バッファーの先頭からのオフセットが 0 であることを示します。
オフセット @code{>IN @@} から入力バッファーの末尾までの領域は、 パース領域(@dfn{parse
area})と呼ばれます@footnote{言い換えると、 テキスト・インタプリタは、 パース領域が空になるまで、
パース領域からの文字列をパースすることによって、 入力バッファーの内容を処理します}。 以下の例は、
テキスト・インタプリタが入力バッファーをパースする際に @code{>IN} がどのように変化するかを示しています:

@example
: remaining source >in @@ /string
  cr ." ->" type ." <-" ; immediate 

1 2 3 remaining + remaining . 

: foo 1 2 3 remaining swap remaining ;
@end example

@noindent
これらの結果はそれぞれ以下のようになります:

@example
->+ remaining .<-
->.<-5  ok

->swap remaining ;-<
->;<-  ok
@end example

@cindex parsing words
@code{>IN} の値は、 テキスト・インタプリタによって実行される入力バッファー内のワードによって変更することもできます。  これは、
ワードがテキスト・インタプリタをだまして、 入力バッファーの一節をスキップしたり@footnote{これがワードのパースの仕組みです}、 一節を 2
回パースしたりすることができることを意味します。 例:

@example
: lat ." <<foo>>" ;
: flat ." <<bar>>" >IN DUP @@ 3 - SWAP ! ;
@end example

@noindent
@code{flat} が実行されると、 以下の出力が生成されます@footnote{研究課題: @code{3} を @code{4}
に置き換えたらどうなるでしょうか？}(訳注:ユーザーが flat と打ち込と、 入力バッファーには flat があり、 ワード flat
の実行が初まったときは >IN は flatの t の次を指している。 そこから 3 戻ると >IN が 指すのは flat の l で、
そこからテキスト・インタプリタがパースを再開すると、 テキスト・インタプリタに見えるのは lat である。 よって lat が実行されて <<foo>>
が出力される):

@example
<<bar>><<foo>>
@end example

この手法を使用すると、 ワードのパースにおける相互運用性の問題(interoperability problems)の一部を回避できます。 もちろん、
ワードのパースは可能な限り避けた方が良いです。

@noindent
テキスト・インタプリタの振る舞いに関する 2 つの重要な注意事項:

@itemize @bullet
@item
入力バッファーからの追加の文字達をパースする前に、 各入力文字列の処理を完了させます。
@item
入力バッファーを読み取り専用領域(region)として扱います(そして、 コードも同様に読み取り専用でなければなりません)。
@end itemize

@noindent
テキスト・インタプリタがコンパイル状態にある場合、 その振る舞いは以下のように変化します:

@itemize @bullet
@item
パースされた文字列がディクショナリ内で見つかった場合、 テキスト・インタプリタはそのワードのコンパイル機能(@dfn{compilation
semantics})を実行します。 ほとんどの場合、これは単にそのワードの実行機能(execution
semantics)が現在の定義に追加されることを意味します。
@item
数値が検出されると、 パラメータ・スタックにプッシュされるのではなく、 現在の定義に(リテラルとして)コンパイルされます。
@item
エラーが発生した場合、 @code{state} が変更され、 テキスト・インタプリタはインタプリタ状態に戻ります。
@item
キーボードから行が入力されるたびに、 Gforth は `` @code{ok}'' ではなく ``@code{ compiled}'' を出力します。
@end itemize

@cindex text interpreter - input sources
テキスト・インタプリタがキーボード以外の入力デバイスを使用している場合、 その振る舞いは以下のように変化します:

@itemize @bullet
@item
パース領域が空の場合、 テキスト・インタプリタは入力ソースから入力バッファーを再充填(refill)しようと試みます。 入力ソースを使い尽くすと、
入力ソースは以前の入力ソースに戻ります。
@item
パース領域が空になるたびに ``@code{ ok}'' や ``@code{ compiled}'' メッセージは出力されません。
@item
エラーが発生した場合、 入力ソースはユーザー入力デバイスに戻されます。
@end itemize

これについて詳しくは、 @ref{Input Sources} をご覧ください。

@findex >in ( @var{ -- addr   } ) core
@cindex @code{>in}
@kindex >in
@format
@code{>in} ( @i{-- addr  }) core ``to-in''
@end format
@code{uvar} 変数 -- @i{a-addr} は、 入力バッファーの先頭からパース領域の先頭までの char
オフセットを格納するセルへのアドレスです。


@findex source ( @var{ -- addr u   } ) core
@cindex @code{source}
@kindex source
@format
@code{source} ( @i{-- addr u  }) core ``source''
@end format
現在の入力バッファーのアドレス @i{addr} と長さ @i{u} を返します



@findex tib ( @var{ -- addr   } ) core-ext-obsolescent
@cindex @code{tib}
@kindex tib
@format
@code{tib} ( @i{-- addr  }) core-ext-obsolescent ``t-i-b''
@end format

@findex #tib ( @var{ -- addr   } ) core-ext-obsolescent
@cindex @code{#tib}
@kindex #tib
@format
@code{#tib} ( @i{-- addr  }) core-ext-obsolescent ``number-t-i-b''
@end format
@code{uvar} 変数 -- @i{a-addr} は、 端末の入力バッファー内の文字数を含むセルのアドレスです。
時代遅れ(OBSOLESCENT): @code{source} はこのワードの機能を置き換えます。



@findex interpret ( @var{ ... -- ...   } ) gforth-0.2
@cindex @code{interpret}
@kindex interpret
@format
@code{interpret} ( @i{... -- ...  }) gforth-0.2 ``interpret''
@end format


@menu
* Input Sources::
* Number Conversion::
* Interpret/Compile states::
* Interpreter Directives::
* Recognizers::
* Text Interpreter Hooks::   
@end menu

@node Input Sources, Number Conversion, The Text Interpreter, The Text Interpreter
@subsection Input Sources
@cindex input sources
@cindex text interpreter - input sources

デフォルトでは、 テキスト・インタプリタは、 Forth の起動時にユーザー入力デバイス(キーボード)からの入力を処理します。
テキスト・インタプリタは、 以下のいずれかの入力ソースからの入力を処理できます:

@itemize @bullet
@item
ユーザー入力デバイス -- つまり、キーボード。
@item
ファイル。 @ref{Forth source files} で説明されているワードを使用。
@item
ブロック。 @ref{Blocks} で説明されているワードを使用。
@item
テキスト文字列。 @code{evaluate} 使用。
@end itemize

プログラムは、 @code{source-id} と @code{blk} の値から現在の入力デバイスを識別できます。


@findex source-id ( @var{ -- 0 | -1 | fileid   } ) core-ext,file
@cindex @code{source-id}
@kindex source-id
@format
@code{source-id} ( @i{-- 0 | -1 | fileid  }) core-ext,file ``source-i-d''
@end format
戻り値: 0 (入力ソースはユーザー入力デバイス)または、 -1 (入力ソースは @code{evaluate} によって処理されている文字列)または、
@i{fileid} (入力ソースは @i{fileid} で指定されたファイル)です。


@findex blk ( @var{ -- addr   } ) block
@cindex @code{blk}
@kindex blk
@format
@code{blk} ( @i{-- addr  }) block ``b-l-k''
@end format
@code{uvar} 変数 -- このセルには現在のブロック番号(現在の入力ソースがブロックでない場合は 0)が格納されています。



@findex save-input ( @var{ -- x1 .. xn n   } ) core-ext
@cindex @code{save-input}
@kindex save-input
@format
@code{save-input} ( @i{-- x1 .. xn n  }) core-ext ``save-input''
@end format
@i{n} 個のエントリ @i{xn 〜 x1} は、 @code{restore-input} で使用できるプラットフォーム依存の方法で、
入力ソース仕様(input source specification)の現在の状態を記述します。


@findex restore-input ( @var{ x1 .. xn n -- flag   } ) core-ext
@cindex @code{restore-input}
@kindex restore-input
@format
@code{restore-input} ( @i{x1 .. xn n -- flag  }) core-ext ``restore-input''
@end format
入力ソース仕様(input source specification)を @i{n} 個のエントリ @i{xn 〜 x1}
で記述された状態に復元しようとします。 復元が失敗した場合は @i{flag} が true になります。 新しい入力プログラムを使用した Gforth
では、 再度 throw するために使用できるフラグがある場合にのみ失敗します。 異なるアクティブな入力ストリーム間で保存および復元することも可能です。
注意: 入力ストリームを閉じる場合は、 開いたときとは逆の順序で行う必要がありますが、 その間はすべて許可されます。



@findex evaluate ( @var{ ... addr u -- ...   } ) core,block
@cindex @code{evaluate}
@kindex evaluate
@format
@code{evaluate} ( @i{... addr u -- ...  }) core,block ``evaluate''
@end format
現在の入力ソース仕様(input source specification)を保存します。 そして、 @code{-1} を
@code{source-id} に保存し、 かつ、 @code{0} を @code{blk} に保存します。 それから、 @code{>IN} を
@code{0} に設定し、 文字列 @i{c-addr u} を入力ソースおよび入力バッファーにし、 通訳(interpret)します。
そしてパース領域が空になったら、 入力ソース仕様を復元します。


@findex query ( @var{ --   } ) core-ext-obsolescent
@cindex @code{query}
@kindex query
@format
@code{query} ( @i{--  }) core-ext-obsolescent ``query''
@end format
ユーザー入力デバイスを入力ソースにします。 入力を端末入力バッファー(Terminal Input Buffer)で受け取ります。 @code{>IN}
をゼロに設定します。 時代遅れ(OBSOLESCENT): @code{accept} で置き換えられました。





@node Number Conversion, Interpret/Compile states, Input Sources, The Text Interpreter
@subsection Number Conversion
@cindex number conversion

テキスト・インタプリタが数値入力をどのように変換するかの概要は @ref{Literals in source code} にあります。
このセクションでは、 関連するいくつかのワードについて説明します。

デフォルトでは、 整数変換に使用される基数は変数 @code{base} の内容によって与えられます。 注意: 予期しない @code{base}
の値によって多くの混乱が生じる可能性があることに注意してください。  @code{base} を変更する場合、 必ず古い値を保存し、
後で復元してください。 さらに良いのは、これを自動的に実行する @code{base-execute} を使用することです。  一般に、
@code{base} を 10 進数のままにし、 一般的な 10 進数以外の基数については @ref{Literals in source code}
で説明されている接頭辞を使用することをお勧めします。

@findex base-execute ( @var{ i*x xt u -- j*x   } ) gforth-0.7
@cindex @code{base-execute}
@kindex base-execute
@format
@code{base-execute} ( @i{i*x xt u -- j*x  }) gforth-0.7 ``base-execute''
@end format
@code{BASE} の内容を @i{u} にして @i{xt} を実行し、 その後元の @code{BASE} を復元します。


@findex base ( @var{ -- a-addr   } ) core
@cindex @code{base}
@kindex base
@format
@code{base} ( @i{-- a-addr  }) core ``base''
@end format
@code{User} 変数 -- @i{a-addr} は、 入出力時の数値変換にデフォルトで使用される基数を格納するセルへのアドレスです。
@code{base} に保存せず、 代わりに @code{base-execute} を使用してください。


@findex hex ( @var{ --   } ) core-ext
@cindex @code{hex}
@kindex hex
@format
@code{hex} ( @i{--  }) core-ext ``hex''
@end format
@code{base} を &16 (16 進数) に設定します。  @code{hex} を使用せず、 代わりに
@code{base-execute} を使用してください。


@findex decimal ( @var{ --   } ) core
@cindex @code{decimal}
@kindex decimal
@format
@code{decimal} ( @i{--  }) core ``decimal''
@end format
@code{base} を &10 (10 進数) に設定します。  @code{10 進数} を使用せず、 代わりに
@code{base-execute} を使用してください。


@findex dpl ( @var{ -- a-addr   } ) gforth-0.2
@cindex @code{dpl}
@kindex dpl
@format
@code{dpl} ( @i{-- a-addr  }) gforth-0.2 ``Decimal-PLace''
@end format
@code{User} 変数 -- @i{a-addr} は、 最新の数値変換における小数点の位置を格納するセルのアドレスです。  -1
に初期化されます。 小数点を含まない数値を変換すると、 @code{dpl} は -1 になります。 @code{2.} の変換後は 0
が保持されます。 234123.9 の変換後は 1 が保持されます。



@cindex number conversion - traps for the unwary
@noindent
数値変換は、 不注意な人にとっては多くの罠があります:

@itemize @bullet
@item
コード・シーケンス @code{base @@ .} を使用して現在の基数を測定することはできません。 これは現在の基数では常に 10 と表示されます。
代わりに、 @code{base @@ dec.} なととしてください。
@item
@code{bin} というワードがありますが、 これは基数を設定するものではありません(@pxref{General files})。
@item
標準 Forth では、 2倍長整数の @code{.} が文字列の最後の文字である必要があります。  Gforth では @code{.}
をどこにでも置くことができます。
@item
数値変換プロセスではオーバーフローはチェックされません。
@end itemize

@ref{Line input and conversion} で説明されているワードを使用して、 プログラムに数値を読み込むことができます。

@node Interpret/Compile states, Interpreter Directives, Number Conversion, The Text Interpreter
@subsection Interpret/Compile states
@cindex Interpret/Compile states

標準のプログラムでは @code{state} を明示的に変更することは許可されていません。 ただし、@code{[} と @code{]}
というワードを使用して、 @code{state} を暗黙的に変更できます。 @code{[} が実行されると、 @code{state}
がインタプリタ状態に切り替わり、 テキスト・インタプリタが通訳(interpret)を開始します。  @code{]} が実行されると、
@code{state} がコンパイル状態に切り替わり、 テキスト・インタプリタはコンパイルを開始します。
これらのワードの最も一般的な使用法は、コロン定義内でインタプリタ状態に切り替えたり、 元の状態に戻したりすることです。 この手法は、
リテラルのコンパイル(@pxref{Literals} の例参照)または条件付きコンパイル(例: @pxref{Interpreter
Directives} の例を参照)に使用できます。


@c This is a bad example: It's non-standard, and it's not necessary.
@c However, I can't think of a good example for switching into compile
@c state when there is no current word (@code{state}-smart words are not a
@c good reason).  So maybe we should use an example for switching into
@c interpret @code{state} in a colon def. - anton
@c nac-> I agree. I started out by putting in the example, then realised
@c that it was non-ANS, so wrote more words around it. I hope this
@c re-written version is acceptable to you. I do want to keep the example
@c as it is helpful for showing what is and what is not portable, particularly
@c where it outlaws a style in common use.

@c anton: it's more important to show what's portable.  After we have done
@c that, we can also show what's not.  In any case, I have written a
@c section Compiling Words which also deals with [ ].

@c  !! The following example does not work in Gforth 0.5.9 or later.

@c  @code{[} and @code{]} also give you the ability to switch into compile
@c  state and back, but we cannot think of any useful Standard application
@c  for this ability. Pre-ANS Forth textbooks have examples like this:

@c  @example
@c  : AA ." this is A" ;
@c  : BB ." this is B" ;
@c  : CC ." this is C" ;

@c  create table ] aa bb cc [

@c  : go ( n -- ) \ n is offset into table.. 0 for 1st entry
@c    cells table + @@ execute ;
@c  @end example

@c  This example builds a jump table; @code{0 go} will display ``@code{this
@c  is A}''. Using @code{[} and @code{]} in this example is equivalent to
@c  defining @code{table} like this:

@c  @example
@c  create table ' aa COMPILE, ' bb COMPILE, ' cc COMPILE,
@c  @end example

@c  The problem with this code is that the definition of @code{table} is not
@c  portable -- it @i{compile}s execution tokens into code space. Whilst it
@c  @i{may} work on systems where code space and data space co-incide, the
@c  Standard only allows data space to be assigned for a @code{CREATE}d
@c  word. In addition, the Standard only allows @code{@@} to access data
@c  space, whilst this example is using it to access code space. The only
@c  portable, Standard way to build this table is to build it in data space,
@c  like this:

@c  @example
@c  create table ' aa , ' bb , ' cc ,
@c  @end example

@c  doc-state


@node Interpreter Directives, Recognizers, Interpret/Compile states, The Text Interpreter
@subsection Interpreter Directives
@cindex interpreter directives
@cindex conditional compilation

以下のワード群は通常、 インタプリタ状態で使用されます。 通常は、 ソース・ファイルのどの部分がテキスト・インタプリタによって処理されるかを制御します。
これらは、 標準 Forth のワードには少数しかありませんが、 Gforth では、
非即実行バージョンがコンパイル状態でのみ使用できるという事実を補うために、
豊富な即実行制御構造ワードのセットでこれらを補っています(@pxref{Control Structures})。 一般的な使用法は以下のとおりです:

@example
[undefined] \G [if]
  : \G ... ; immediate
[endif]
@end example

これは、 システムが @code{\G} を定義していない場合は、 幾つかの置き換えプログラムをコンパイルします(機能が制限される可能性があります)。


@findex [IF] ( @var{ flag --   } ) tools-ext
@cindex @code{[IF]}
@kindex [IF]
@format
@code{[IF]} ( @i{flag --  }) tools-ext ``bracket-if''
@end format
flag が @code{TRUE} の場合は何もしません(したがって、 後続のワードは通常どおり実行されます)。 flag が
@code{FALSE} の場合、 対になる @code{[ELSE]} または @code{[THEN]} がパースされて破棄されるまで、
@code{[IF]}..  @code{[ELSE]}.. @code{[THEN]} や @code{[IF]}.. @code{[THEN]}
の入れ子になったモノを含むパース領域(入力バッファー/パース領域 は、 必要に応じて @code{REFILL}
を使用して再充填します)からワードをパースして破棄します。 即実行ワードです。


@findex [ELSE] ( @var{ --   } ) tools-ext
@cindex @code{[ELSE]}
@kindex [ELSE]
@format
@code{[ELSE]} ( @i{--  }) tools-ext ``bracket-else''
@end format
対になる @code{[THEN]} がパースされて破棄されるまで、 @code{[IF]}..
@code{[ELSE]}.. @code{[THEN]} や @code{[IF]}.. @code{[THEN]}
の入れ子になったモノを含むパース領域(入力バッファー/パース領域 は、 必要に応じて @code{REFILL}
を使用して再充填します)からワードをパースして破棄します。 @code{FALSE} の場合、@code{[IF]} は @code{[ELSE]}
をパースして破棄し、後続のワードは通常どおり実行されたままになります。 即実行ワードです。


@findex [THEN] ( @var{ --   } ) tools-ext
@cindex @code{[THEN]}
@kindex [THEN]
@format
@code{[THEN]} ( @i{--  }) tools-ext ``bracket-then''
@end format
何もしない。 パースして破棄する他のワードのマーカーとして使用されます。 即実行ワードです。


@findex [ENDIF] ( @var{ --   } ) gforth-0.2
@cindex @code{[ENDIF]}
@kindex [ENDIF]
@format
@code{[ENDIF]} ( @i{--  }) gforth-0.2 ``bracket-end-if''
@end format
何もしません。 @code{[THEN]} の同義語(synonym)です。



@findex [defined] ( @var{ "<spaces>name" -- flag   } ) tools-ext
@cindex @code{[defined]}
@kindex [defined]
@format
@code{[defined]} ( @i{"<spaces>name" -- flag  }) tools-ext ``bracket-defined''
@end format
現在の検索順序スタック(the search order)で名前が見つかった場合は true を返します


@findex [undefined] ( @var{ "<spaces>name" -- flag   } ) tools-ext
@cindex @code{[undefined]}
@kindex [undefined]
@format
@code{[undefined]} ( @i{"<spaces>name" -- flag  }) tools-ext ``bracket-undefined''
@end format
現在の検索順序スタック(the search order)で名前が見つかった場合は false を返します



@findex [IFDEF] ( @var{ "<spaces>name" --   } ) gforth-0.2
@cindex @code{[IFDEF]}
@kindex [IFDEF]
@format
@code{[IFDEF]} ( @i{"<spaces>name" --  }) gforth-0.2 ``bracket-if-def''
@end format
現在の検索順序スタック(the search order)で name が見つかった場合は、 @code{TRUE} フラグを伴った
@code{[IF]} のように振る舞いし、 そうでない場合は、 @code{FALSE} フラグを伴った @code{[IF]} のように動作します。
即実行ワードです。


@findex [IFUNDEF] ( @var{ "<spaces>name" --   } ) gforth-0.2
@cindex @code{[IFUNDEF]}
@kindex [IFUNDEF]
@format
@code{[IFUNDEF]} ( @i{"<spaces>name" --  }) gforth-0.2 ``bracket-if-un-def''
@end format
現在の検索順序スタック(the search order)で name が見つからない場合は、 @code{TRUE} フラグを伴った
@code{[IF]} のように動作し、 それ以外の場合は、@code{FALSE} フラグを伴った @code{[IF]} のように動作します。
即実行ワード。



@findex [?DO] ( @var{ n-limit n-index --   } ) gforth-0.2
@cindex @code{[?DO]}
@kindex [?DO]
@format
@code{[?DO]} ( @i{n-limit n-index --  }) gforth-0.2 ``bracket-question-do''
@end format

@findex [DO] ( @var{ n-limit n-index --   } ) gforth-0.2
@cindex @code{[DO]}
@kindex [DO]
@format
@code{[DO]} ( @i{n-limit n-index --  }) gforth-0.2 ``bracket-do''
@end format

@findex [LOOP] ( @var{ --   } ) gforth-0.2
@cindex @code{[LOOP]}
@kindex [LOOP]
@format
@code{[LOOP]} ( @i{--  }) gforth-0.2 ``bracket-loop''
@end format

@findex [+LOOP] ( @var{ n --   } ) gforth-0.2
@cindex @code{[+LOOP]}
@kindex [+LOOP]
@format
@code{[+LOOP]} ( @i{n --  }) gforth-0.2 ``bracket-question-plus-loop''
@end format

@findex [FOR] ( @var{ n --   } ) gforth-0.2
@cindex @code{[FOR]}
@kindex [FOR]
@format
@code{[FOR]} ( @i{n --  }) gforth-0.2 ``bracket-for''
@end format

@findex [NEXT] ( @var{ n --   } ) gforth-0.2
@cindex @code{[NEXT]}
@kindex [NEXT]
@format
@code{[NEXT]} ( @i{n --  }) gforth-0.2 ``bracket-next''
@end format

@findex [I] ( @var{ run-time -- n   } ) gforth-0.2
@cindex @code{[I]}
@kindex [I]
@format
@code{[I]} ( @i{run-time -- n  }) gforth-0.2 ``bracket-i''
@end format
実行時、 @code{[I]} はテキスト・インタプリタ時の @code{[do]}
の反復(iteration)のループ・インデックスをプッシュします。  インタプリタ時にインデックスを処理したい場合は、 @code{[I]}
を対話的に通訳(interpret)するか、 または @code{INT-[I]} を使用します。


@findex INT-[I] ( @var{ -- n   } ) gforth-1.0
@cindex @code{INT-[I]}
@kindex INT-[I]
@format
@code{INT-[I]} ( @i{-- n  }) gforth-1.0 ``int-bracket-i''
@end format
テキスト・インタプリタ時に @code{[do]} 反復のループ・インデックスをプッシュします。



@findex [BEGIN] ( @var{ --   } ) gforth-0.2
@cindex @code{[BEGIN]}
@kindex [BEGIN]
@format
@code{[BEGIN]} ( @i{--  }) gforth-0.2 ``bracket-begin''
@end format

@findex [UNTIL] ( @var{ flag --   } ) gforth-0.2
@cindex @code{[UNTIL]}
@kindex [UNTIL]
@format
@code{[UNTIL]} ( @i{flag --  }) gforth-0.2 ``bracket-until''
@end format

@findex [AGAIN] ( @var{ --   } ) gforth-0.2
@cindex @code{[AGAIN]}
@kindex [AGAIN]
@format
@code{[AGAIN]} ( @i{--  }) gforth-0.2 ``bracket-again''
@end format

@findex [WHILE] ( @var{ flag --   } ) gforth-0.2
@cindex @code{[WHILE]}
@kindex [WHILE]
@format
@code{[WHILE]} ( @i{flag --  }) gforth-0.2 ``bracket-while''
@end format

@findex [REPEAT] ( @var{ --   } ) gforth-0.2
@cindex @code{[REPEAT]}
@kindex [REPEAT]
@format
@code{[REPEAT]} ( @i{--  }) gforth-0.2 ``bracket-repeat''
@end format


@code{#line} を使用すると、 現在のソース行番号とソース・ファイルに関する Gforth の認識を変更できます。  これは、 Forth
ファイルが他のソース・コード・ファイルから生成されており、 たとえば、
オリジナルのソース・コードを参照するエラー・メッセージなどを取得したい場合に便利です。 その場合、 Forth コード・ジェネレーターは、 必要に応じて
Forth コードに @code{#line} 行を挿入する必要があります。

@findex #line ( @var{ "u" "["file"]" --   } ) gforth-1.0
@cindex @code{#line}
@kindex #line
@format
@code{#line} ( @i{"u" "["file"]" --  }) gforth-1.0 ``#line''
@end format
行番号を @i{u} に設定し、 (存在する場合)ファイル名を @i{file} に設定します。 行の残りの部分を消費します。



@node Recognizers, Text Interpreter Hooks, Interpreter Directives, The Text Interpreter
@subsection Recognizers
@cindex recongizers

テキスト・インタプリタはソース・コードを処理するときに、 コードを空白で区切られた文字列に分割し、
認識器群(recognizers)の中からどれか1つの認識器が文字列を識別(identify)(認識(recognize))するまで認識器群を呼び出して、
それらをワードや数値などとして識別します。 その文字列が認識されない場合、 テキスト・インタプリタはエラー(@code{undefined
word})を報告します。

認識器を取り扱う通常の方法は、 認識器の 1 つを識別(identify)するコードを記述するだけです(@pxref{Default
Recognizers})。 ただし、 それらを操作したり(@pxref{Dealing with existing Recognizers})、
新しい認識器を定義したりすることもできます(@pxref{Defining Recognizers})。

@menu
* Default Recognizers::
* Dealing with existing Recognizers::
* Defining Recognizers::     
@end menu

@node Default Recognizers, Dealing with existing Recognizers, Recognizers, Recognizers
@subsubsection Default Recognizers
@cindex Recognizers normal usage

標準の Forth テキスト・インタプリタは、 検索順序スタック(the search order)内のワード(@code{rec-nt}) と、
整数(@code{rec-num})と、 浮動小数点数(@code{rec-float})を認識します。  デフォルトでは、 Gforth は
以下の構文も認識します

@itemize @bullet

@item
文字列 例: @code{"mystring"} (@code{rec-string})

@item
混合数値(complex numbers) 例: @code{0e+1ei} (@code{rec-complex})

@item
value への格納または defered word の変更 例: @code{->myvalue} (@code{rec-to})

@item
ワードのインタプリタ機能(interpretation semantics)表す xt です。 例: @code{`dup}
(@code{rec-tick})

@item
ワードの nt です。 例: @code{``mysynonym} (@code{rec-dtick})

@item
ワードのボディのアドレス 例: @code{<myarray+8>} (@code{rec-body})

@item
オペレーティング・システムの環境変数へのアクセス 例: @code{$@{HOME@}} (@code{rec-env})

@item
ボキャブラリ内のワード 例: @code{myvoc1:myvoc2:myword} (@code{rec-scope})

@item
指定の認識器(recognizer)使用して何かを認識する(訳注: @var{recognizer}@code{?}
というプレフィックスが付いたワードは、 @code{rec-}@var{recognizer} によって処理され、 認識器の曖昧さを排除します。 例:
@code{hex num?cafe num?add} rec-num としてのみパースさせる、 @code{float?1.}
rec-floatとしてパースさせる)(@code{rec-meta})

@end itemize

@code{locate} (@pxref{Locating source code definitions}) を使用して、 ソース・コードの一片を、
どの認識器(recognizer)が認識するか調べられます。  例:

@example
defer mydefer
locate ->mydefer
@end example

これは @code{rec-to} が @code{->mydefer} を認識したことを示すハズです。  ただし、
認識器がディクショナリのワードを認識する場合(スコープ認識機能など)、 locate はそのワードを表示します。

以下を使用すると、 使用されている認識器と認識器の順序を確認できます

@findex .recognizers ( @var{ --   } ) gforth-experimental
@cindex @code{.recognizers}
@kindex .recognizers
@format
@code{.recognizers} ( @i{--  }) gforth-experimental ``dot-recognizers''
@end format
(.order とは異なり、)最初に検索された認識器を左端にして、 現在の認識器の順序を出力します。 すべての認識器に共通のプレフィックスである
@code{rec-} の代わりに、 反転表示の @code{~} が表示されます。



通常、 認識器は、 他の認識器と同一の文字列との一致を避けるように設計されています。  たとえば、@code{rec-env} (環境変数認識器)には、
@code{$ADD} のような入力文字列の数値認識器との競合を避けるために中かっこ(braces)が必要です。 ただし、
このポリシーにはいくつかの例外があります:

@itemize @bullet

@item
ワード名には任意の名前を付けることができるため、 他の認識器と競合する可能性があります(また、 検索順序スタック(the search
order)は他の認識器よりも前に検索されます)。

ただし、 名前は @code{0} (ゼロ)で始まらない傾向がある(そして @code{0} (ゼロ)
で始まる場合は特殊文字が含まれる傾向がある)ため、 base が @code{hex} の場合は、 数値を @code{0}
(ゼロ)で始めることをお勧めします。

これまで私たちが見てきた幾多のコードでは、 ワードを @code{'} (クォート。 別名ティック)で始める方が、 @code{`}
(バック・クォート。別名バック・ティック) で始めるよりもはるかに一般的であるため、 xt と nt の認識器は @code{`}
(バック・クォート)を使用して競合を減らしてください。

@item
整数認識器 @code{rec-num} と、 浮動小数点認識器 @code{rec-float} は、 どちらも、 たとえば @code{1.}
を認識します。 しかし、 @code{rec-num} が(デフォルトでは)先にあるため、 @code{1.} は2倍長セルの整数として認識されます。
@code{rec-float} を最初に使用するように認識順序を変更すると、 @code{1.} は浮動小数点数として認識されますが、 標準
Forth で書かれたコードを読み込むと、 非標準的な振る舞いになる可能性があります。

いずれの場合も、 以下のようにして、 あなた独自のコード内では、 この競合を回避することをお勧めします。 つまり、
常に数値プレフィックスを付けて2倍長セル整数を記述します(例: @code{#1.})。 また、 浮動小数点数は常に @code{e}
を使用して記述します(例: @code{1e})。

@item
@code{->} で始まるワードをいくつか見てきました。  @code{to myvalue} または @code{to?->myvalue}
(訳注: rec-meta 構文で rec-to を指定の上で ->myvalue を評価)を使用すると競合を回避できます(後者は
@code{postpone} で機能します)。

@end itemize

@node Dealing with existing Recognizers, Defining Recognizers, Default Recognizers, Recognizers
@subsubsection Dealing with existing Recognizers
@cindex Recognizers, dealing with

認識器(recognizer)は、 あなたが文字列を渡すワードです。 認識器が文字列を認識すると、 通常はデータとそのデータを処理するためのワードの
xt を返します。 このワードはトランスレーター(translator)と呼ばれます。 認識器が文字列を認識しない場合は、
@code{notfound} の xt を返します。

すべての認識器(recognizers)のスタック効果は ( c-addr u -- ... xt ) です。



認識器は文字列を受け取り、 いくつかのデータと、 そのデータを通訳(interpret)するためのトランスレーター(翻訳器)を返します。  Gforth
はそのトランスレーターを xt として実装します(これを実行すると、 現在の state でその文字列を処理する適切なアクションが実行されます)。
しかし、 他の Forth システムでは、 内部に 3 つの xt を含む実際のテーブルとして実装する可能性があります。  最初の xt は
通訳時(interpretation)/実行時(run-time) xt で、 データのインタプリタ機能(interpretation
semantics)を実行します(通常はデータをスタックに置くだけです)。  2 番目の xt はコンパイル機能(compilation
semantics)を実行し、 データと実行時機能(run-time semantics)の xt を取得します。  3 番目の xt は
postpone 機能(postpone semantics)を実行し、 データと実行時機能の xt も取得します。  @code{>postpone}
を使用すると、 実行時機能の xt を postpone できます。

認識器群はスタックとして編成されるため、 ボキャブラリ・スタックと同じ方法で認識器群のシーケンスを配置できます。
認識器スタックはそれ自体が認識器群です。 つまり、 認識器スタックは実行可能であり、 文字列を受け取り、 トランスレーターを返します。

@findex notfound ( @var{ state --   } ) gforth-experimental
@cindex @code{notfound}
@kindex notfound
@format
@code{notfound} ( @i{state --  }) gforth-experimental ``notfound''
@end format
認識器の認識が失敗すると、 @code{notfound} の認識器トークン(訳注: 現状では @code{notfound} の xt )を返します


@findex rec-nt ( @var{ addr u -- nt translate-nt | notfound   } ) gforth-experimental
@cindex @code{rec-nt}
@kindex rec-nt
@format
@code{rec-nt} ( @i{addr u -- nt translate-nt | notfound  }) gforth-experimental ``rec-nt''
@end format
名前トークンを認識します


@findex rec-num ( @var{ addr u -- n/d table | notfound   } ) gforth-experimental
@cindex @code{rec-num}
@kindex rec-num
@format
@code{rec-num} ( @i{addr u -- n/d table | notfound  }) gforth-experimental ``rec-num''
@end format
数値を 1倍長/2倍長 整数に変換します


@findex rec-float ( @var{ addr u -- r translate-float | notfound   } ) gforth-experimental
@cindex @code{rec-float}
@kindex rec-float
@format
@code{rec-float} ( @i{addr u -- r translate-float | notfound  }) gforth-experimental ``rec-float''
@end format
浮動小数点数を認識します


@findex rec-string ( @var{ addr u -- addr u' r:string | rectype-null   } ) gforth-experimental
@cindex @code{rec-string}
@kindex rec-string
@format
@code{rec-string} ( @i{addr u -- addr u' r:string | rectype-null  }) gforth-experimental ``rec-string''
@end format
二重引用符(double quotes)で囲まれた文字列(strings)を文字列リテラルに変換します。 エスケープは @code{S\"}
と同様に扱われます。


@findex rec-to ( @var{ addr u -- xt n r:to | rectype-null   } ) gforth-experimental
@cindex @code{rec-to}
@kindex rec-to
@format
@code{rec-to} ( @i{addr u -- xt n r:to | rectype-null  }) gforth-experimental ``rec-to''
@end format
@code{->} で始まるワードは、 @code{TO} が前にあるものとして扱い、 @code{+>} で始まるワードは @code{+TO}
が前にあるものとして扱い、 @code{'>} で始まるワードは @code{ADDR} が前にあるものとして扱い、 @code{@@>}
で始まるワードは @code{ACTION-OF} が前にあるものとして扱い、 @code{=>} で始まるワードは @code{IS}
が前にあるものとして扱います。


@findex rec-tick ( @var{ addr u -- xt rectype-num | rectype-null   } ) gforth-experimental
@cindex @code{rec-tick}
@kindex rec-tick
@format
@code{rec-tick} ( @i{addr u -- xt rectype-num | rectype-null  }) gforth-experimental ``rec-tick''
@end format
@code{`} (バッククォート)の接頭辞が付いたワードはその xt を返します。  例: @code{`dup} は dup の xt を返します


@findex rec-dtick ( @var{ addr u -- nt rectype-num | rectype-null   } ) gforth-experimental
@cindex @code{rec-dtick}
@kindex rec-dtick
@format
@code{rec-dtick} ( @i{addr u -- nt rectype-num | rectype-null  }) gforth-experimental ``rec-dtick''
@end format
@code{``} (バッククォート2つ)で始まるワードは、 その nt を返します。  例: @code{``S"} は @code{S"} の nt
を返します。


@findex rec-body ( @var{ addr u -- xt translate-tick | translate-null   } ) gforth-experimental
@cindex @code{rec-body}
@kindex rec-body
@format
@code{rec-body} ( @i{addr u -- xt translate-tick | translate-null  }) gforth-experimental ``rec-body''
@end format
@code{'<'} @code{'>'} で囲まれたワードはその本体(body)を返します。  例: @code{<dup>} は dup
の本体(body)を返します


@findex get-recognizers ( @var{ -- xt1 .. xtn n   } ) gforth-experimental
@cindex @code{get-recognizers}
@kindex get-recognizers
@format
@code{get-recognizers} ( @i{-- xt1 .. xtn n  }) gforth-experimental ``get-recognizers''
@end format
認識器スタックの内容(content)をスタックにプッシュします。 @i{n} は xt の個数です。


@findex set-recognizers ( @var{ xt1 .. xtn n --   } ) gforth-experimental
@cindex @code{set-recognizers}
@kindex set-recognizers
@format
@code{set-recognizers} ( @i{xt1 .. xtn n --  }) gforth-experimental ``set-recognizers''
@end format
スタック上の内容(content)を認識器スタックに設定します。 @i{n} は xt の個数です。


@findex recognize ( @var{ addr u rec-addr -- ... rectype   } ) gforth-experimental
@cindex @code{recognize}
@kindex recognize
@format
@code{recognize} ( @i{addr u rec-addr -- ... rectype  }) gforth-experimental ``recognize''
@end format
訳注: 認識器スタック @i{rec-addr} の認識器を順に文字列 @i{addr u} に適用し、 認識したら、 そのトランスレーター
@i{rectype} (の xt ) を得ます。 何も適用できなかった場合はトランスレーター @code{notfound} (の xt )を返します


@findex recognizer-sequence: ( @var{ xt1 .. xtn n "name" --   } ) gforth-experimental
@cindex @code{recognizer-sequence:}
@kindex recognizer-sequence:
@format
@code{recognizer-sequence:} ( @i{xt1 .. xtn n "name" --  }) gforth-experimental ``recognizer-sequence:''
@end format
訳注: @i{xt1 .. xtn n } という内容で @i{"name"} という名前の認識器スタックを作成します。 


@findex forth-recognize ( @var{ c-addr u -- ... translate-xt   } ) recognizer
@cindex @code{forth-recognize}
@kindex forth-recognize
@format
@code{forth-recognize} ( @i{c-addr u -- ... translate-xt  }) recognizer ``forth-recognize''
@end format
システム認識器スタックです。


@findex forth-recognizer ( @var{ -- xt   } ) gforth-experimental
@cindex @code{forth-recognizer}
@kindex forth-recognizer
@format
@code{forth-recognizer} ( @i{-- xt  }) gforth-experimental ``forth-recognizer''
@end format
Matthias Trute recognizer API との下位互換性があります。  この構造は、 defer されたワードを value
のようなワードに変換します。


@findex set-forth-recognize ( @var{ xt --   } ) recognizer
@cindex @code{set-forth-recognize}
@kindex set-forth-recognize
@format
@code{set-forth-recognize} ( @i{xt --  }) recognizer ``set-forth-recognize''
@end format
システム認識器スタックを変更する


@findex translate: ( @var{ int-xt comp-xt post-xt "name" --   } ) gforth-experimental
@cindex @code{translate:}
@kindex translate:
@format
@code{translate:} ( @i{int-xt comp-xt post-xt "name" --  }) gforth-experimental ``translate:''
@end format
@i{name} という名前のトランスレーター(トランスレーター・テーブル)を作成し、 トランスレーターのインタプリンタ機能アクション
@i{int-xt} と、 トランスレーターのコンパイル機能アクション @i{comp-xt} と、 トランスレーターの postpone
機能アクション @i{post-xt} を格納します。 加えて拡張機能(extensions)用に 7
つのスロットを用意します(拡張機能スロット初期値は no.extensions の xt で埋めます)。 実行時: @i{name} の 実行時は
state の値に応じてアクションが実行されます。 state が 0 (インタプリンタ状態)ならばインタプリンタ機能アクションを実行し、 stete
が -1 (コンパイル状態) ならばコンパイル機能アクションを実行し、 state が -2
(通常無い値。このために特別にセットする。アクション実行後は以前の値復元の事) ならばpostpone 機能アクションを実行します。


@findex translate-nt ( @var{ i*x nt -- j*x   } ) gforth-experimental
@cindex @code{translate-nt}
@kindex translate-nt
@format
@code{translate-nt} ( @i{i*x nt -- j*x  }) gforth-experimental ``translate-nt''
@end format
名前トークンのトランスレーター


@findex translate-num ( @var{ x -- | x   } ) gforth-experimental
@cindex @code{translate-num}
@kindex translate-num
@format
@code{translate-num} ( @i{x -- | x  }) gforth-experimental ``translate-num''
@end format
数値のトランスレーター


@findex translate-dnum ( @var{ dx -- | dx   } ) gforth-experimental
@cindex @code{translate-dnum}
@kindex translate-dnum
@format
@code{translate-dnum} ( @i{dx -- | dx  }) gforth-experimental ``translate-dnum''
@end format
2倍長整数のトランスレーター


doc-translate-float(訳注: まだ説明書いて無いっぽい)
@findex try-recognize ( @var{ addr u xt -- results | false   } ) gforth-experimental
@cindex @code{try-recognize}
@kindex try-recognize
@format
@code{try-recognize} ( @i{addr u xt -- results | false  }) gforth-experimental ``try-recognize''
@end format
入れ子(nested)になった認識器(recognizers)用です: @var{addr u} の認識を試み、 @var{xt}
を実行して結果が望ましいかどうかを確認します。  @var{xt} が false を返した場合は、 認識器の副作用をすべてクリーンアップして
false を返します。  それ以外の場合は、 @var{xt} 呼び出しの結果をスタックに返し、 そのTOSはゼロ以外でなければなりません。


@findex >interpret ( @var{ translator --   } ) gforth-experimental
@cindex @code{>interpret}
@kindex >interpret
@format
@code{>interpret} ( @i{translator --  }) gforth-experimental ``>interpret''
@end format
指定のトランスレーターのインタプリンタ機能アクションを実行します。


@findex >compile ( @var{ translator --   } ) gforth-experimental
@cindex @code{>compile}
@kindex >compile
@format
@code{>compile} ( @i{translator --  }) gforth-experimental ``>compile''
@end format
指定のトランスレーターのコンパイル機能アクションを実行します。


@findex >postpone ( @var{ translator --   } ) gforth-experimental
@cindex @code{>postpone}
@kindex >postpone
@format
@code{>postpone} ( @i{translator --  }) gforth-experimental ``>postpone''
@end format
指定のトランスレーターの postpone 機能アクションを実行します


@findex translate-method: ( @var{ "name" --   } ) gforth-experimental
@cindex @code{translate-method:}
@kindex translate-method:
@format
@code{translate-method:} ( @i{"name" --  }) gforth-experimental ``translate-method:''
@end format
新しいトランスレーター・メソッドを作成し、 トランスレーター・テーブルを拡張します。  @var{xt rectype} @code{to}
@var{translator} を使用して、 xt を既存のrectypeに割り当てることができます(訳注: @code{>interpret} や
@code{>compile} や @code{>postpone} 定義用。 あなたが更に トランスレーター・メソッドを定義した場合はこれ以降の新規
state 値に対するアクションとなる。 現時点で 7 つまで追加可能)


@findex translate-state ( @var{ xt --   } ) gforth-experimental
@cindex @code{translate-state}
@kindex translate-state
@format
@code{translate-state} ( @i{xt --  }) gforth-experimental ``translate-state''
@end format
@var{xt} として渡された translate-method に一致するトランスレーターのアクションを実行するように、 システムの現在の
state を変更します。



@node Defining Recognizers, , Dealing with existing Recognizers, Recognizers
@subsubsection Defining Recognizers

doc-defining-recognizers(訳注: まだ説明書けて無いっぽい)

@node Text Interpreter Hooks, , Recognizers, The Text Interpreter
@subsection Text Interpreter Hooks
@cindex hooks in the text interpreter

@findex before-line ( @var{ --   } ) gforth-1.0
@cindex @code{before-line}
@kindex before-line
@format
@code{before-line} ( @i{--  }) gforth-1.0 ``before-line''
@end format
テキスト・インタプリタが次の行をパースする前に呼び出される defer されたワード(訳注: 初期値 @code{noop} 。
@code{interpret} 実行開始時にも呼び出される)


@findex before-word ( @var{ --   } ) gforth-0.7
@cindex @code{before-word}
@kindex before-word
@format
@code{before-word} ( @i{--  }) gforth-0.7 ``before-word''
@end format
テキスト・インタプリタが次のワードをパースする前に呼び出される deferd されたワード(訳注: 初期値 @code{noop})


@findex line-end-hook ( @var{ --   } ) gforth-0.7
@cindex @code{line-end-hook}
@kindex line-end-hook
@format
@code{line-end-hook} ( @i{--  }) gforth-0.7 ``line-end-hook''
@end format
ファイルからテキスト通訳(text-interpreting)するときに行末ごとに呼び出される defer されたワード(訳注: 初期値
@code{noop} )    



@c -------------------------------------------------------------
@node The Input Stream, Word Lists, The Text Interpreter, Words
@section The Input Stream
@cindex input stream

@c !! integrate this better with the "Text Interpreter" section
テキスト・インタプリタは、 複数のソース(@pxref{Input Sources})が利用可能な入力ストリームから読み取ります。
いくつかのワード、特に定義ワードや @code{'} のようなワードは、 スタックからではなく入力ストリームからパラメータを読み込みます。

このようなワードは入力ストリームをパース(parse)するため、 パース・ワードと呼ばれます。 パース・ワードの使用は困難です。
なぜならプログラムで生成されたパラメーターを入力ストリームを通じて渡すのが難しいからです。 また、 素朴な実装をすると、
インタプリタ機能(interpretation semantics)とコンパイル機能(compilation
semantics)の組み合わせが直感的でないことが多く、
より直感的な振る舞いを実現しようとする様々なアプローチが生まれています(@pxref{Combined words})。

ワードをパースするのは悪い考えであることは、 最早明らかです。  あなたが、 利便性のためにパース・ワードを実装したいなら、 非パースのバリエーション、
つまり、 パースを行わずスタック上のパラメータを受け取るワードも提供してください。  もし、 その上でパース・ワードを実装するなら、
以下のワード群を使用できます:

@findex parse ( @var{ xchar "ccc<xchar>" -- c-addr u   } ) core-ext,xchar-ext
@cindex @code{parse}
@kindex parse
@format
@code{parse} ( @i{xchar "ccc<xchar>" -- c-addr u  }) core-ext,xchar-ext ``parse''
@end format
パース領域で @i{xchar} で区切られた @i{ccc} をパースします。 @i{c-addr u} は、
パース領域内でパースされた文字列を指します。 パース領域が空の場合、 @i{u} は 0 です(訳注: @code{bl parse ccc type
ccc ok} 。 直後でENTERキーを押して行を終了すると(@code{parse} ENTER)、 長さ0の文字列をスタックに積む)


@findex string-parse ( @var{ c-addr1 u1 "ccc<string>" -- c-addr2 u2   } ) gforth-1.0
@cindex @code{string-parse}
@kindex string-parse
@format
@code{string-parse} ( @i{c-addr1 u1 "ccc<string>" -- c-addr2 u2  }) gforth-1.0 ``string-parse''
@end format
文字列 @i{c-addr1 u1} で区切られた @i{ccc} をパース領域でパースします。 @i{c-addr2 u2} は、
パース領域内のパースされた文字列を指します。 パース領域が空の場合、 @i{u2} は 0 です(訳注: @code{" " string-parse
ccc type ccc ok})


@findex parse-name ( @var{ "name" -- c-addr u   } ) core-ext
@cindex @code{parse-name}
@kindex parse-name
@format
@code{parse-name} ( @i{"name" -- c-addr u  }) core-ext ``parse-name''
@end format
入力バッファーから次の単語(word)を取得します(訳注: @code{parse-name ccc type ccc ok})


@findex parse-word ( @var{ -- c-addr u   } ) gforth-obsolete
@cindex @code{parse-word}
@kindex parse-word
@format
@code{parse-word} ( @i{-- c-addr u  }) gforth-obsolete ``parse-word''
@end format
@code{parse-name} の古い名前。 このワード語は、他の一部のシステムでは矛盾する振る舞いをします。


@findex name ( @var{ -- c-addr u   } ) gforth-obsolete
@cindex @code{name}
@kindex name
@format
@code{name} ( @i{-- c-addr u  }) gforth-obsolete ``name''
@end format
@code{parse-name} の古い名前


@findex word ( @var{ char "<chars>ccc<char>-- c-addr   } ) core
@cindex @code{word}
@kindex word
@format
@code{word} ( @i{char "<chars>ccc<char>-- c-addr  }) core ``word''
@end format
先頭の区切り文字をスキップします。 パース領域で @i{char} で区切られた @i{ccc} をパースします。 @i{c-addr} は、
カウンタ付き文字列形式で、 パースされた文字列を格納する一時領域のアドレスです。 パース領域が空であるか、 区切り文字以外の文字が含まれてい無い場合、
結果の文字列の長さはゼロになります。 プログラムは、 カウンタ付き文字列内の文字を置き換える場合があります。 時代遅れ(OBSOLESCENT):
カウンタ付き文字列の末尾に、 その長さに含まれないスペースがあります。


@findex refill ( @var{ -- flag   } ) core-ext,block-ext,file-ext
@cindex @code{refill}
@kindex refill
@format
@code{refill} ( @i{-- flag  }) core-ext,block-ext,file-ext ``refill''
@end format
入力ソースにより入力バッファーを満たすことを試みます。 入力ソースがユーザー入力デバイスの場合、 端末入力デバイスからの入力の受け取りを試みます。
成功した場合は、 結果を入力バッファーにし、 @code{>IN} を 0 に設定して true を返します。 それ以外の場合は false
を返します。 入力ソースがブロックの場合、 @code{BLK} の値に 1 を加算して、 次のブロックを入力ソースかつ現在の入力バッファーにし、
@code{>IN} を 0 に設定します。 @code{BLK} の新しい値が有効なブロック番号の場合は true を返し、 それ以外の場合は
false を返します。 入力ソースがテキスト・ファイルの場合、 ファイルから次の行を読み取ろうと試みます。 成功した場合は、
結果を現在の入力バッファーにし、 @code{>IN} を 0 に設定して true を返します。 それ以外の場合は false を返します。
いずれの場合も、 成功した結果には、0 文字を含む行の受け取りが含まれます。



非パースなバリエーションが無いパース・ワードを取り扱う必要がある場合、 @code{execute-parsing}
を使用して(スタック経由で)文字列を渡すことができます:

@findex execute-parsing ( @var{ ... addr u xt -- ...   } ) gforth-0.6
@cindex @code{execute-parsing}
@kindex execute-parsing
@format
@code{execute-parsing} ( @i{... addr u xt -- ...  }) gforth-0.6 ``execute-parsing''
@end format
@i{addr u} を現在の入力ソースにして @i{xt @code{( ... -- ... )}} を実行してから、
以前の入力ソースを復元します。



Example:

@example
5 s" foo" ' constant execute-parsing
\ これは、以下と同等です
5 constant foo
@end example

標準 Forth でのこのワードの定義は @file{compat/execute-parsing.fs} で提供されます。

ファイルに対してワードのパースを実行したい場合は、 以下のワードが役に立ちます:

@findex execute-parsing-file ( @var{ i*x fileid xt -- j*x   } ) gforth-0.6
@cindex @code{execute-parsing-file}
@kindex execute-parsing-file
@format
@code{execute-parsing-file} ( @i{i*x fileid xt -- j*x  }) gforth-0.6 ``execute-parsing-file''
@end format
@i{fileid} を現在の入力ソースにして、 @i{xt @code{( i*x -- j*x )}} を実行してから、
以前の入力ソースを復元します。



@c -------------------------------------------------------------
@node Word Lists, Environmental Queries, The Input Stream, Words
@section Word Lists
@cindex word lists
@cindex header space

ワードリスト(wordlist)は名前付きワードのリストです。 新しいワードを追加したり、
ワードを名前で探したりできます(マーカー(markers)を使用して制限された方法でワードを削除することもできます)。  全ての名前付き(および
@code{reveal} された)ワードは 1 つのワードリスト内にあります。

@cindex search order stack
テキスト・インタプリタは、 検索順序スタック(the search
order;ワードリストのスタック)に存在するワードリストをTOSから下へ検索します。 各ワードリスト内では、
概念的には最新のワードから検索が開始されます。 つまり、 ワードリスト内に同一の名前の 2 つのワードがある場合、 新しいワードが検索にヒットします。

@cindex compilation word list
新しいワードは「コンパイル・ワードリスト」(@dfn{compilation wordlist})(現在のワードリスト(current
wordlist)とも呼ばれます)に追加されます。

@cindex wid
ファイルがファイル・ハンドルによって識別されるのとほぼ同じ方法で、 ワードリストはセル・サイズのワードリスト識別子(word list
identifier; @i{wid})によって識別されます。 wid の数値には(移植可能な)意味はなく、 セッションごとに変わる可能性があります。

標準 Forth の ``Search order'' ワード・セットは、
さまざまな異なるスキームの実装を可能にする低レベル・ツールのセットを提供することを目的としています。 Gforth は、 伝統的な Forth
ワードである @code{vocabulary} も提供します。  @file{compat/vocabulary.fs} は、 標準 Forth
での実装を提供します。

@comment TODO: locals section refers to here, saying that every word list (aka
@comment vocabulary) has its own methods for searching etc. Need to document that.
@c anton: but better in a separate subsection on wordlist internals

@comment TODO: document markers, reveal, tables, mappedwordlist

@comment the gforthman- prefix is used to pick out the true definition of a
@comment word from the source files, rather than some alias.

@findex forth-wordlist ( @var{ -- wid   } ) search
@cindex @code{forth-wordlist}
@kindex forth-wordlist
@format
@code{forth-wordlist} ( @i{-- wid  }) search ``forth-wordlist''
@end format
定数(@code{Constant}) -- @i{wid} は、Gforth が提供するすべての標準のワードを含むワードリストを識別します。
Gforth が呼び出されると、 このワードリストがコンパイル・ワードリストとなり、 検索順序スタック(the search
order)のTOSになります。


@findex definitions ( @var{ --   } ) search
@cindex @code{definitions}
@kindex definitions
@format
@code{definitions} ( @i{--  }) search ``definitions''
@end format
現在検索順序スタック(the search order)のTOSにあるワードリストをコンパイル・ワードリストにします(訳注: :
@code{definitions  context @ current ! ;} )


@findex get-current ( @var{ -- wid   } ) search
@cindex @code{get-current}
@kindex get-current
@format
@code{get-current} ( @i{-- wid  }) search ``get-current''
@end format
@i{wid} は、 現在のコンパイル・ワードリストのワードリスト識別子です。


@findex set-current ( @var{ wid --   } ) search
@cindex @code{set-current}
@kindex set-current
@format
@code{set-current} ( @i{wid --  }) search ``set-current''
@end format
@i{wid} で識別されるワードリストをコンパイル・ワードリストに設定します。


@findex get-order ( @var{ -- widn .. wid1 n   } ) search
@cindex @code{get-order}
@kindex get-order
@format
@code{get-order} ( @i{-- widn .. wid1 n  }) search ``get-order''
@end format
検索順序スタック(the search order)の内容をデータ・スタックにコピーします。 現在の検索順序スタックには @i{n}
個のエントリがあり、 そのうち @i{wid1} は最初に検索されるワードリスト(検索順序スタックのTOSにあるワードリスト) を表し、
@i{widn} は最後に検索されるワードリストを表します。


@findex set-order ( @var{ widn .. wid1 n --   } ) search
@cindex @code{set-order}
@kindex set-order
@format
@code{set-order} ( @i{widn .. wid1 n --  }) search ``set-order''
@end format
@var{n}=0 の場合、 検索順序スタック(the search order)を空(empty)にします。  @var{n}=-1 の場合、
検索順序スタックを実装定義で最小化します (Gforth の場合、 これはワードリスト @code{Root} です)。 それ以外の場合は、
@var{n} 個の wid エントリを持ち、 @var{wid1} が最初に検索されるワードリストを表し、 @var{widn}
が最後に検索されるワードリストを表すように、 既存の検索順序スタックを置き換えます。


@findex wordlist ( @var{ -- wid   } ) search
@cindex @code{wordlist}
@kindex wordlist
@format
@code{wordlist} ( @i{-- wid  }) search ``wordlist''
@end format
@i{wid} で表される新しい空(empty)のワードリストを作成します。


@findex table ( @var{ -- wid   } ) gforth-0.2
@cindex @code{table}
@kindex table
@format
@code{table} ( @i{-- wid  }) gforth-0.2 ``table''
@end format
検索テーブル(lookup table)を作成します(英大文字と小文字を区別し、 警告なし)。


@findex cs-wordlist ( @var{ -- wid   } ) gforth-1.0
@cindex @code{cs-wordlist}
@kindex cs-wordlist
@format
@code{cs-wordlist} ( @i{-- wid  }) gforth-1.0 ``cs-wordlist''
@end format
英大文字小文字を区別するワードリストを作成する。


@findex cs-vocabulary ( @var{ "name" --   } ) gforth-1.0
@cindex @code{cs-vocabulary}
@kindex cs-vocabulary
@format
@code{cs-vocabulary} ( @i{"name" --  }) gforth-1.0 ``cs-vocabulary''
@end format
英大文字小文字を区別するボキャブラリを作成する


@findex >order ( @var{ wid --   } ) gforth-0.5
@cindex @code{>order}
@kindex >order
@format
@code{>order} ( @i{wid --  }) gforth-0.5 ``to-order''
@end format
検索順序スタック(the search order)というワードリストのスタックにワードリスト @var{wid} をプッシュする(訳注:
@var{wid} が 検索順序スタックの TOS になる)。


@findex previous ( @var{ --   } ) search-ext
@cindex @code{previous}
@kindex previous
@format
@code{previous} ( @i{--  }) search-ext ``previous''
@end format
検索順序スタック(the search order)というワードリスト・スタックのTOSを捨てる


@findex also ( @var{ --   } ) search-ext
@cindex @code{also}
@kindex also
@format
@code{also} ( @i{--  }) search-ext ``also''
@end format
検索順序スタック(the search order)でTOSを @code{DUP} するかのように振る舞います(訳注: @code{: also
context @ >order ;})。 通常はボキャブラリの前で使います(例えば @code{also Forth})。 これにより、
ボキャブラリによって表されるワードリストが検索順序スタックへプッシュされるという複合的な効果が得られます(訳注:検索順序スタックのTOSを指定のボキャブラリで置き換えるのではなくて、
検索順序スタックのTOSにさらにプッシュする形にして、 ボキャブラリの次が以前の検索順序スタックのTOSになるようにする)


@findex Forth ( @var{ --   } ) search-ext
@cindex @code{Forth}
@kindex Forth
@format
@code{Forth} ( @i{--  }) search-ext ``Forth''
@end format
検索順序スタック(the search order)の先頭にある @i{wid} を、 ワードリスト @code{forth-wordlist}
に関連付けられた @i{wid} に置き換えます。


@findex Only ( @var{ --   } ) search-ext
@cindex @code{Only}
@kindex Only
@format
@code{Only} ( @i{--  }) search-ext ``Only''
@end format
検索順序スタック(the search order)を実装定義で最小化します(Gforth の場合、 これはワードリスト @code{Root}
です)。


@findex order ( @var{ --   } ) search-ext
@cindex @code{order}
@kindex order
@format
@code{order} ( @i{--  }) search-ext ``order''
@end format
検索順序スタック(the search order)とコンパイル・ワードリストを出力します。
検索順序スタックのワードリストは検索される順序で出力されます(従来のスタック表示方法とは逆になります)。 続けて、
コンパイル・ワードリストが最後に表示されます。


@findex .voc ( @var{ wid --   } ) gforth-0.2
@cindex @code{.voc}
@kindex .voc
@format
@code{.voc} ( @i{wid --  }) gforth-0.2 ``dot-voc''
@end format
@var{wid} で表されるワードリストの名前を出力します。  @code{vocabulary} または @code{wordlist
constant} で定義された名前のみ出力できます。 それ以外の場合はアドレスを出力します。



@findex find ( @var{ c-addr -- xt +-1 | c-addr 0   } ) core,search
@cindex @code{find}
@kindex find
@format
@code{find} ( @i{c-addr -- xt +-1 | c-addr 0  }) core,search ``find''
@end format
カウンタ付き文字列 @i{c-addr} によって指定された定義の名前を現在の検索順序スタック(the search
order)内の全てのワードリストで検索します。  定義が見つからない場合、 0 を返します。 定義が見つかった場合は、 1
(定義にデフォルト以外のコンパイル機能(compilation semantics)ある場合)または、 -1
(定義にデフォルトのコンパイル機能(compilation semantics)がある場合)を返します。  インタプリタ状態で返される @i{xt}
はインタプリタ機能(interpretation semantics)を表します。  コンパイル状態で返される @i{xt} は、
コンパイル機能(デフォルト以外のコンパイル機能の場合)を表すか、または、 コンパイル機能が @code{compile,}
(デフォルトのコンパイル機能の場合)となる実行時機能(run-time semantics)を表します。  ANS Forth 標準では、 返される
@i{xt} が何を表すかを明確に規定していない(または、 デフォルト以外のコンパイル機能ではなく即実行性についても言及している)ため、
このワードは移植可能なプログラムでは問題があります。 移植性がなくても問題ない場合には、 @code{find-name}
とその友達の方が優れています(@pxref{Name token})。


@findex search-wordlist ( @var{ c-addr count wid -- 0 | xt +-1   } ) search
@cindex @code{search-wordlist}
@kindex search-wordlist
@format
@code{search-wordlist} ( @i{c-addr count wid -- 0 | xt +-1  }) search ``search-wordlist''
@end format
@i{wid} で識別されるワードリスト内で、 @i{c-addr count} の文字列で指定された定義を検索します。 定義が見つからない場合は 0
を返します。 定義が見つかった場合は、 @i{xt} とともに 1 (定義が即実行である場合)または、  -1 (定義が即実行でない場合)を返します。
Gforth では、返される @i{xt} はインタプリタ機能(interpretation semantics)を表します。  ANS Forth
では、 @i{xt} が何を表すか明確に規定していません。



@findex words ( @var{ --   } ) tools
@cindex @code{words}
@kindex words
@format
@code{words} ( @i{--  }) tools ``words''
@end format
検索順序スタック(the search order)の先頭にあるワードリスト内のすべての定義のリストを表示します。


@findex vlist ( @var{ --   } ) gforth-0.2
@cindex @code{vlist}
@kindex vlist
@format
@code{vlist} ( @i{--  }) gforth-0.2 ``vlist''
@end format
@code{WORDS} の古い(Forth-83 より前の)名前。


@findex wordlist-words ( @var{ wid --   } ) gforth-0.6
@cindex @code{wordlist-words}
@kindex wordlist-words
@format
@code{wordlist-words} ( @i{wid --  }) gforth-0.6 ``wordlist-words''
@end format
ワードリスト wid の内容を表示します(訳注: ワードリストに含まれているワードをリストする)。


@findex mwords ( @var{ ["pattern"] --   } ) gforth-1.0
@cindex @code{mwords}
@kindex mwords
@format
@code{mwords} ( @i{["pattern"] --  }) gforth-1.0 ``mwords''
@end format
オプションのパラメータ @var{pattern} にマッチするすべてのワードをリストします。 指定しない場合、 すべてのワードが一致します。
ワードは古い方から新しい方へとリストされます。  @code{search} のようなパターン・マッチ(デフォルト)ですが、 @code{'
mword-filename-match is mword-match} を使用してワイルドカード(globbing)に切り替えることができます(訳注:
@code{mwords} ENTER で全部リスト、 例えば @code{mwords value} で value を含む名前をリスト)。


@c doc-words-deferred

@c doc-mappedwordlist @c map-structure undefined, implemantation-specific
@findex Root ( @var{ --   } ) gforth-0.2
@cindex @code{Root}
@kindex Root
@format
@code{Root} ( @i{--  }) gforth-0.2 ``Root''
@end format
root ワードリストを検索順序スタック(the search order)に追加します。  このボキャブラリは最小の検索順序を構成し、
search-order のワードのみが含まれます。


@findex Vocabulary ( @var{ "name" --   } ) gforth-0.2
@cindex @code{Vocabulary}
@kindex Vocabulary
@format
@code{Vocabulary} ( @i{"name" --  }) gforth-0.2 ``Vocabulary''
@end format
"name" の定義を作成し、 それに新しいワードリストを関連付けます。  "name" の実行時の効果は、 検索順序スタック(the search
order)のTOSにある @i{wid} を、 "name" に関連付けられた @i{wid} に置き換えることです。


@findex seal ( @var{ --   } ) gforth-0.2
@cindex @code{seal}
@kindex seal
@format
@code{seal} ( @i{--  }) gforth-0.2 ``seal''
@end format
現在検索順序スタック(the search order)のTOSにあるワードリスト以外のすべてのワードリストを検索順序スタックから削除します。


@findex vocs ( @var{ --   } ) gforth-0.2
@cindex @code{vocs}
@kindex vocs
@format
@code{vocs} ( @i{--  }) gforth-0.2 ``vocs''
@end format
システムで定義されているボキャブラリとワードリストをリストします。


@findex current ( @var{ -- addr   } ) gforth-0.2
@cindex @code{current}
@kindex current
@format
@code{current} ( @i{-- addr  }) gforth-0.2 ``current''
@end format
変数(@code{Variable}) -- コンパイル・ワードリストの @i{wid} を保持。


@findex context ( @var{ -- addr   } ) gforth-0.2
@cindex @code{context}
@kindex context
@format
@code{context} ( @i{-- addr  }) gforth-0.2 ``context''
@end format
@code{context} @code{@@} すると、 検索順序スタック(the search order)のTOSにあるワードリストの
@i{wid} が得られます。



@findex map-vocs ( @var{ ... xt -- ...   } ) gforth-1.0
@cindex @code{map-vocs}
@kindex map-vocs
@format
@code{map-vocs} ( @i{... xt -- ...  }) gforth-1.0 ``map-vocs''
@end format
システム内のすべてのワードリスト(テーブルと cs-wordlist を含む)に対して xt ( ... wid -- ...) を実行します。



@menu
* Vocabularies::
* Why use word lists?::
* Word list example::        
@end menu

@node Vocabularies, Why use word lists?, Word Lists, Word Lists
@subsection Vocabularies
@cindex Vocabularies, detailed explanation

以下は、 標準の Forth ワード群を使用して新しいワードリストを作成および使用する例です:

@example
wordlist constant my-new-words-wordlist
: my-new-words get-order nip my-new-words-wordlist swap set-order ;

\ add it to the search order
also my-new-words

\ alternatively, add it to the search order and make it
\ the compilation word list
also my-new-words definitions
\ type "order" to see the problem
@end example

この例での問題は、 @code{order} には @code{my-new-words} という名前をワードリスト の wid
に関連付ける方法がないことです(Gforth では、 @code{order} と @code{vocs} において、 名前が関連付けられていない
wid では wid そのものが表示されます)。 名前を wid に関連付ける標準の方法はありません。

Gforth では、 この例は、 以下のように、 名前を wid に関連付ける @code{vocabulary} を使用して再コーディングできます:

@example
vocabulary my-new-words

\ add it to the search order
also my-new-words

\ alternatively, add it to the search order and make it
\ the compilation word list
my-new-words definitions
\ type "order" to see that the problem is solved
@end example


@node Why use word lists?, Word list example, Vocabularies, Word Lists
@subsection Why use word lists?
@cindex word lists - why use them?

人々がワードリストを使用する理由は以下のとおりです:

@itemize @bullet

@c anton: Gforth's hashing implementation makes the search speed
@c independent from the number of words.  But it is linear with the number
@c of wordlists that have to be searched, so in effect using more wordlists
@c actually slows down compilation.

@c @item
@c To improve compilation speed by reducing the number of header space
@c entries that must be searched. This is achieved by creating a new
@c word list that contains all of the definitions that are used in the
@c definition of a Forth system but which would not usually be used by
@c programs running on that system. That word list would be on the search
@c list when the Forth system was compiled but would be removed from the
@c search list for normal operation. This can be a useful technique for
@c low-performance systems (for example, 8-bit processors in embedded
@c systems) but is unlikely to be necessary in high-performance desktop
@c systems.

@item
一連のワードが、 それらが有効なコンテキスト外で使用されるのを防ぐため。 この典型的な 2 つの例が、
統合エディター(すべての編集コマンドは別個のワードリストで定義されます。 エディターの起動時に検索順序スタック(the search
order)がエディターのワードリストに設定されます。 エディターが終了すると古い検索順序スタックが復元されます)。 )と、
統合されたアセンブラ(マシンのオペコードは、@code{CODE} ワードが定義されるときに使用される別のワードリストで定義されます)。

@item
アプリケーションまたはライブラリのワードを、 ユーザーに表示される組(@code{forth-wordlist} または、
他の一般的なワードリスト内)と、 実装のためだけに使用されるヘルパー・ワードの組(別のワードリストに隠されている)に編成します。 これにより、
@code{words} の出力が少なくなり、 実装とインターフェイスが分離され、 共通のワードリスト内で名前が競合する可能性が減ります。

@item
同じ名前を持つ複数の定義間の名前空間の衝突を防ぐため。 たとえば、 クロス・コンパイラを構築する場合、
ターゲット・システムの条件付きコードを生成するワード @code{IF} が存在する場合があります。 この定義を別のワードリストに配置すると、
検索順序スタック上のワードリストの順序を制御することで、 ホスト・システムの @code{IF} またはターゲット・システムの @code{IF}
を特定の文脈で使用するかどうかを制御できます。 

@end itemize

ワードリストを使用する場合の欠点は以下のとおりです:

@itemize

@item
デバッグがさらに面倒になります。

@item
ワードリストを使用して回避された名前の競合は依然として存在しており、 望ましい結果を得るには検索順序を慎重に調整する必要があります。 これを怠ると、
見つけにくいエラーが発生します(コンパイラとは異なる方法でコードを読み取る場合と同様に、 @code{see} は、 そのような場合に、
名前がいくつかの考えられるワードのうちのどれに解決(resolve)されるかを確認するのに役立ちます）。  @code{see}
はワードの名前だけを表示し、 ワードがどのワードリストに属しているかを表示しないため、 誤解を招く可能性があります。  一意の名前を使用することは、
名前の競合を避けるためのより良いアプローチです。

@item
あなたは、 検索順序スタック(the search order)の変更を明示的に元に戻す必要があります。  多くの場合、
これは暗黙的に行われた方が便利です。  Gforth は現在そのような機能を提供していませんが、 将来的には提供される可能性があります。
@end itemize


@node Word list example, , Why use word lists?, Word Lists
@subsection Word list example
@cindex word lists - example

以下の例は @uref{https://www.complang.tuwien.ac.at/forth/garbage-collection.zip,
garbage collector} からのもので、 ワードリストを使用してパブリック・ワードとヘルパー・ワードを分離しています:

@example
get-current ( wid )
vocabulary garbage-collector also garbage-collector definitions
... \ define helper words
( wid ) set-current \ restore original (i.e., public) compilation wordlist
... \ define the public (i.e., API) words
    \ they can refer to the helper words
previous \ restore original search order (helper words become invisible)
@end example

@c -------------------------------------------------------------
@node Environmental Queries, Files, Word Lists, Words
@section Environmental Queries
@cindex environmental queries

Forth-94 は、システム上で実行されているプログラムがシステムの特定の特性を判断する方法として「環境問い合わせ」(``environmental
query'')という概念を導入しました。  標準では、 システムが認識できるたくさんの文字列と、 それらを問い合わせする方法が指定されています。

@findex environment? ( @var{ c-addr u -- false / ... true   } ) core
@cindex @code{environment?}
@kindex environment?
@format
@code{environment?} ( @i{c-addr u -- false / ... true  }) core ``environment-query''
@end format
文字列 @i{c-addr, u} を指定します。 文字列が認識されない場合は、 @code{false} フラグを返します。
それ以外の場合は、@code{true} フラグと、 問い合わせした文字列に関する(それ固有の)情報を返します。



注意: 例えば @code{ADDRESS-UNIT-BITS} のドキュメントではスタック上に 1 つのセルを返すことが示されていますが、
@code{environment?} を使用して問い合わせすると、 文字列が認識されたことを示す @code{true}
フラグという追加の項目が返されることに注意してください。 @code{ADDRESS-UNIT-BITS} を問い合わせた場合、
@code{environment?} のスタック効果は @code{( c-addr u -- n true )} です。

@c Get all the words in environment-wordlist:
@c gforth -e "environment-wordlist wordlist-words cr bye"|sed 's/[ ]/\n/g'|sed '/^$/d'|tac

いくつかの環境問い合わせ(environmental query)はシステムの制限を取り扱います:

@findex ADDRESS-UNIT-BITS ( @var{ -- n   } ) environment
@cindex @code{ADDRESS-UNIT-BITS}
@kindex ADDRESS-UNIT-BITS
@format
@code{ADDRESS-UNIT-BITS} ( @i{-- n  }) environment ``ADDRESS-UNIT-BITS''
@end format
1 つのアドレス単位のサイズ(ビット単位)。


@findex MAX-CHAR ( @var{ -- u   } ) environment
@cindex @code{MAX-CHAR}
@kindex MAX-CHAR
@format
@code{MAX-CHAR} ( @i{-- u  }) environment ``MAX-CHAR''
@end format
文字セット内の任意の文字の最大値


@findex /COUNTED-STRING ( @var{ -- n   } ) environment
@cindex @code{/COUNTED-STRING}
@kindex /COUNTED-STRING
@format
@code{/COUNTED-STRING} ( @i{-- n  }) environment ``slash-counted-string''
@end format
カウンタ付き文字列の最大サイズ(文字単位)。


@findex /HOLD ( @var{ -- n   } ) environment
@cindex @code{/HOLD}
@kindex /HOLD
@format
@code{/HOLD} ( @i{-- n  }) environment ``slash-hold''
@end format
描写された数値文字列の出力バッファーのサイズ(文字単位)。


@findex /PAD ( @var{ -- n   } ) environment
@cindex @code{/PAD}
@kindex /PAD
@format
@code{/PAD} ( @i{-- n  }) environment ``slash-pad''
@end format
@code{PAD} が指すスクラッチ領域のサイズ(文字数)。


@findex CORE ( @var{ -- f   } ) environment
@cindex @code{CORE}
@kindex CORE
@format
@code{CORE} ( @i{-- f  }) environment ``CORE''
@end format
完全なコア・ワード・セットが存在する場合は true。 Gforth では常に当てはまります。


@findex CORE-EXT ( @var{ -- f   } ) environment
@cindex @code{CORE-EXT}
@kindex CORE-EXT
@format
@code{CORE-EXT} ( @i{-- f  }) environment ``CORE-EXT''
@end format
完全なコア拡張ワード・セットが存在する場合は true。 Gforth では常に当てはまります。


@findex FLOORED ( @var{ -- f   } ) environment
@cindex @code{FLOORED}
@kindex FLOORED
@format
@code{FLOORED} ( @i{-- f  }) environment ``FLOORED''
@end format
true ならば、 @code{/} などで、 フロア除算(floored division)を実行します。


@findex MAX-N ( @var{ -- n   } ) environment
@cindex @code{MAX-N}
@kindex MAX-N
@format
@code{MAX-N} ( @i{-- n  }) environment ``MAX-N''
@end format
使用可能な符号付き整数の最大値。


@findex MAX-U ( @var{ -- u   } ) environment
@cindex @code{MAX-U}
@kindex MAX-U
@format
@code{MAX-U} ( @i{-- u  }) environment ``MAX-U''
@end format
使用可能な符号なし整数の最大値。


@findex MAX-D ( @var{ -- d   } ) environment
@cindex @code{MAX-D}
@kindex MAX-D
@format
@code{MAX-D} ( @i{-- d  }) environment ``MAX-D''
@end format
使用可能な符号付き2倍長整数の最大値。


@findex MAX-UD ( @var{ -- ud   } ) environment
@cindex @code{MAX-UD}
@kindex MAX-UD
@format
@code{MAX-UD} ( @i{-- ud  }) environment ``MAX-UD''
@end format
使用可能な符号なし2倍長整数の最大値。


@findex return-stack-cells ( @var{ -- n   } ) environment
@cindex @code{return-stack-cells}
@kindex return-stack-cells
@format
@code{return-stack-cells} ( @i{-- n  }) environment ``return-stack-cells''
@end format
リターン・スタックの最大サイズ(セル単位)。


@findex stack-cells ( @var{ -- n   } ) environment
@cindex @code{stack-cells}
@kindex stack-cells
@format
@code{stack-cells} ( @i{-- n  }) environment ``stack-cells''
@end format
データ・スタックの最大サイズ(セル単位)。


@findex floating-stack ( @var{ -- n   } ) environment
@cindex @code{floating-stack}
@kindex floating-stack
@format
@code{floating-stack} ( @i{-- n  }) environment ``floating-stack''
@end format
@var{n} はゼロ以外で、 Gforth が深さ @var{n} の別個の浮動小数点スタックを維持していることを示しています。


@findex #locals ( @var{ -- n   } ) environment
@cindex @code{#locals}
@kindex #locals
@format
@code{#locals} ( @i{-- n  }) environment ``number-locals''
@end format
定義内のローカル変数の最大数


@findex wordlists ( @var{ -- n   } ) environment
@cindex @code{wordlists}
@kindex wordlists
@format
@code{wordlists} ( @i{-- n  }) environment ``wordlists''
@end format
検索順序スタック(the search order)で使用できるワード・リストの最大数


@findex max-float ( @var{ -- r   } ) environment
@cindex @code{max-float}
@kindex max-float
@format
@code{max-float} ( @i{-- r  }) environment ``max-float''
@end format
使用可能な浮動小数点数の最大値(Gforth では最大の有限数(finite number)として実装)


@findex XCHAR-ENCODING ( @var{ -- addr u   } ) environment
@cindex @code{XCHAR-ENCODING}
@kindex XCHAR-ENCODING
@format
@code{XCHAR-ENCODING} ( @i{-- addr u  }) environment ``XCHAR-ENCODING''
@end format
エンコーディングを表す印刷可能なASCII文字列を返し、 (あれば)、 優先されるMIME名、 または ``ISO-LATIN-1'' や
``UTF-8'' のような @url{http://www.iana.org/assignments/character-sets}
の名前を使用します。 ただし、``ASCII'' の場合は、 エイリアスの ``ASCII'' を優先します。


@findex MAX-XCHAR ( @var{ -- xchar   } ) environment
@cindex @code{MAX-XCHAR}
@kindex MAX-XCHAR
@format
@code{MAX-XCHAR} ( @i{-- xchar  }) environment ``MAX-XCHAR''
@end format
xchar の最大値。  これはエンコーディングによって異なります。


@findex XCHAR-MAXMEM ( @var{ -- u   } ) environment
@cindex @code{XCHAR-MAXMEM}
@kindex XCHAR-MAXMEM
@format
@code{XCHAR-MAXMEM} ( @i{-- u  }) environment ``XCHAR-MAXMEM''
@end format
1 つの xchar によって消費される最大メモリをアドレス単位で返します。



Forth-94 バージョンのワードセットの存在を確認するための環境問い合わせ(environemtal query)がいくつかあります。
当該文字列が存在する場合、 それらはすべて @code{( -- f )} のスタック効果を持ちます(つまり、 これらの問い合わせの
@code{environment?} のスタック効果は @code{( c-addr u -- false / f true )} です)。

@code{block block-ext double double-ext exception exception-ext facility
facility-ext file file-ext floating floating-ext locals locals-ext
memory-alloc memory-alloc-ext tools tools-ext search-order search-order-ext
string string-ext}

上記ワードセットの問い合わせは、 ほとんど使用および実装されなかったため、 Forth-2012 ではこれらのワードセットの Forth-2012
バリエーションを問い合わせする方法が導入されませんでした。  代わりに、  @code{[defined]} (@pxref{Interpreter
Directives}) を使用するというアイディアです。

Forth-200x (次の標準に取り組むグループ。 このグループが作成するドキュメントも Forth-200x と呼ばれます)は、
提案された拡張機能(extension proposals)の変更が完了すると(CfV 段階)、
提案された拡張機能に対する拡張機能問い合わせ(extension query)を定義します。 そのため、 これらの提案を採用するプログラムは、
提案された拡張機能が適切かどうかを確認できます。 システムにはそれらがあり、 おそらくリファレンス実装(存在する場合)をロードします。
@code{environment?} がそのような問い合わせを見つけた場合、 @url{www.forth200x.org}
上の対応する提案がシステムに実装されます(ただし、 @code{environment?} の場合と同様、 存在しないモノは何も分かりません)。
これらの問い合わせにはスタック効果 @code{( -- )} があります。 つまり、 問い合わせに対して @code{environment?}
ではスタック効果 @code{( c-addr u -- false / true )} があり、 これはワードセット問い合わせよりも便利です。。
これらの提案の多くは Forth-2012 に組み込まれています。  拡張機能問い合わせも Forth
システム実装者の間で特に人気があるわけではないため、 @code{[define]} を使用する方が良いアプローチである可能性があります。
とにもかくにも、 Gforth は以下の拡張機能問い合わせ(extension query)を実装します:

@code{X:2value X:buffer X:deferred X:defined X:ekeys X:escaped-strings
X:extension-query X:fp-stack X:ftrunc X:fvalue X:locals X:n-to-r
X:number-prefixes X:parse-name X:required X:s-escape-quote X:s-to-f
X:structures X:synonym X:text-substitution X:throw-iors X:traverse-wordlist
X:xchar}

さらに、 Gforth は以下の Gforth 固有の問い合わせを実装します:

@findex gforth ( @var{ -- c-addr u   } ) gforth-environment
@cindex @code{gforth}
@kindex gforth
@format
@code{gforth} ( @i{-- c-addr u  }) gforth-environment ``gforth''
@end format
Gforth のこのバージョン(バージョン > 0.3.0)のバージョン文字列を表す文字列。 さまざまなバージョンのバージョン文字列は、
辞書順(lexicographically)に並べることができることが保証されています。


@findex os-class ( @var{ -- c-addr u   } ) gforth-environment
@cindex @code{os-class}
@kindex os-class
@format
@code{os-class} ( @i{-- c-addr u  }) gforth-environment ``os-class''
@end format
ホスト・オペレーティング・システムを説明する文字列。


@findex os-type ( @var{ -- c-addr u   } ) gforth-environment
@cindex @code{os-type}
@kindex os-type
@format
@code{os-type} ( @i{-- c-addr u  }) gforth-environment ``os-type''
@end format
$host_os に等しい文字列



標準の問い合わせでは、 環境問い合わせ(environmental query)に使用されるヘッダー・スペース(header space)が、
定義に使用されるヘッダー・スペースとは異なることが要求されます。

通常、 Forth システムは、 環境問い合わせ(environmental query)「だけ」に使用されるワードリスト内に定義を作成することにより、
環境問い合わせをサポートします。 それが Gforth のやっていることです。
認知されている環境問い合わせのセットに定義を追加する標準的な方法はありませんが、 Gforth や、
ワードリスト・メカニズムを使用するその他のシステムでは、 環境問い合わせを受け入れるために使用されるワードリストは、
他のワードリストと同様に操作できます。

@findex environment-wordlist ( @var{ -- wid   } ) gforth-0.2
@cindex @code{environment-wordlist}
@kindex environment-wordlist
@format
@code{environment-wordlist} ( @i{-- wid  }) gforth-0.2 ``environment-wordlist''
@end format
@i{wid} は、 環境問い合わせ(environmental query)によって検索されるワードリストを識別します(SwiftForth および
VFX に存在)。


@findex environment ( @var{ --   } ) gforth-0.6
@cindex @code{environment}
@kindex environment
@format
@code{environment} ( @i{--  }) gforth-0.6 ``environment''
@end format
@code{environment-wordlist} のボキャブラリ (Win32Forth および VFX に存在)。



@comment TODO Document the standard strings or note where they are documented herein

以下に、 環境問い合わせ(environmental query)の使用例をいくつか示します:

@example
s" address-unit-bits" environment? 0=
[IF]
     cr .( environmental attribute address-units-bits unknown... ) cr
[ELSE]
     drop \ ensure balanced stack effect
[THEN]

\ 標準で throw を使うときにプログラムの冒頭でありそうなコード断片
\ 訳注: throw をサポートしていなければ @code{abort"} に置き換え
s" exception" environment? [IF]
   0= [IF]
      : throw abort" exception thrown" ;
   [THEN]
[ELSE] \ we don't know, so make sure
   : throw abort" exception thrown" ;
[THEN]

s" gforth" environment? [IF] .( Gforth version ) TYPE
                        [ELSE] .( Not Gforth..) [THEN]

\ a program using v*
s" gforth" environment? [IF]
  s" 0.5.0" compare 0< [IF] \ v* is a primitive since 0.5.0
   : v* ( f_addr1 nstride1 f_addr2 nstride2 ucount -- r )
     >r swap 2swap swap 0e r> 0 ?DO
       dup f@@ over + 2swap dup f@@ f* f+ over + 2swap
     LOOP
     2drop 2drop ; 
  [THEN]
[ELSE] \ 
  : v* ( f_addr1 nstride1 f_addr2 nstride2 ucount -- r )
  ...
[THEN]
@end example

以下は、  environment ワードリストに定義を追加する例です:

@example
get-current environment-wordlist set-current
true constant block
true constant block-ext
set-current
@end example

以下のようにして、 environment ワードリストどのような定義があるかを確認できます:

@example
environment-wordlist wordlist-words
@end example


@c -------------------------------------------------------------
@node Files, Blocks, Environmental Queries, Words
@section Files
@cindex files
@cindex I/O - file-handling

Gforth は、 ホスト・オペレーティング・システムのファイル・ システムに保存されているファイルにアクセスするための機能を提供します。 Gforth
によって処理されるファイルは、 以下の 2 つのカテゴリに分類できます:

@itemize @bullet
@item
テキスト・インタプリタによって処理されるファイル(@dfn{Forth source files})
@item
他のプログラムによって処理されるファイル(@dfn{general files})。
@end itemize

@menu
* Forth source files::
* General files::
* Redirection::
* Directories::
* Search Paths::             
@end menu

@c -------------------------------------------------------------
@node Forth source files, General files, Files, Files
@subsection Forth source files
@cindex including files
@cindex Forth source files

ファイルの内容を通訳(interpret)する最も簡単な方法は、 以下の 2 つの形式のいずれかを使用することです:

@example
include mysource.fs
s" mysource.fs" included
@end example

通常、 ファイルをインクルードする必要があるのは、 そのファイルがまだインクルードされていない場合(たとえば、 別のソース・ファイルなど)です。
その場合、 以下の 3 つの形式のいずれかを使用できます:

@example
require mysource.fs
needs mysource.fs
s" mysource.fs" required
@end example

@cindex stack effect of included files
@cindex including files, stack effect
ソース・ファイルを通訳(interpret)してもスタックが変更されないようにソース・ファイルを作成することをお勧めします。
この方法で設計されたソース・ファイルは、 @code{required} やそのファミリーと一緒に問題なく使用できます。 例:

@example
1024 require foo.fs drop
@end example

ここでは、 引数 1024 (バ​​ッファ・サイズなど) を @file{foo.fs} に渡しています。  @file{foo.fs}
の通訳(interpret)にはスタック効果 ( n -- n ) があり、 @code{require} での使用が可能になります。  もちろん、
require されるファイルにこのようなパラメーターを指定する場合は、 最初の @code{require}
がすべての用途に適合することを確認する必要があります(つまり、 マスター・ロード・ファイルの早い段階で @code{require}
することになります)。

@findex include-file ( @var{ i*x wfileid -- j*x   } ) file
@cindex @code{include-file}
@kindex include-file
@format
@code{include-file} ( @i{i*x wfileid -- j*x  }) file ``include-file''
@end format
ファイル @var{wfileid} の内容を通訳(interpret)します(テキスト・インタプリタを使用して処理します)。


@findex included ( @var{ i*x c-addr u -- j*x   } ) file
@cindex @code{included}
@kindex included
@format
@code{included} ( @i{i*x c-addr u -- j*x  }) file ``included''
@end format
文字列 @var{c-addr u} で指定される名前のファイルを @code{include-file} します。


@findex included? ( @var{ c-addr u -- f   } ) gforth-0.2
@cindex @code{included?}
@kindex included?
@format
@code{included?} ( @i{c-addr u -- f  }) gforth-0.2 ``included?''
@end format
ファイル @var{c-addr u} が以前にインクルードされたファイルのリストにある場合にのみ true。 ファイルがロードされている場合、
たとえば @file{foo.fs} として指定されたのが Forth 検索パスのどこかで見つかった可能性があります。  @code{include?}
から @code{true} を返すには、 ファイルへの正確なパス (@file{./foo.fs}< であっても) を指定する必要があります。


@findex include ( @var{ ... "file" -- ...   } ) file-ext
@cindex @code{include}
@kindex include
@format
@code{include} ( @i{... "file" -- ...  }) file-ext ``include''
@end format
@var{file} を @code{include-file} する。


@findex required ( @var{ i*x addr u -- i*x   } ) file-ext
@cindex @code{required}
@kindex required
@format
@code{required} ( @i{i*x addr u -- i*x  }) file-ext ``required''
@end format
既に @code{include} (または @code{required} ) されてないなら、 @var{addr u} で指定した名前のファイルを
@code{include-file} します。 現状では、
これは(パス(path)付きの)ファイル名を以前にインクルードしたファイルの名前と比較することによって機能します。


@findex require ( @var{ ... "file" -- ...   } ) file-ext
@cindex @code{require}
@kindex require
@format
@code{require} ( @i{... "file" -- ...  }) file-ext ``require''
@end format
 @var{file} がまだインクルードされていない場合のみ、 @code{include-file} します。


@findex needs ( @var{ ... "name" -- ...   } ) gforth-0.2
@cindex @code{needs}
@kindex needs
@format
@code{needs} ( @i{... "name" -- ...  }) gforth-0.2 ``needs''
@end format
@code{require} のエイリアス。 他のシステム(Win32Forth など)に存在します。


@findex \\\ ( @var{ --   } ) gforth-1.0
@cindex @code{\\\}
@kindex \\\
@format
@code{\\\} ( @i{--  }) gforth-1.0 ``\\\''
@end format
ソース・ファイルの残りをEOFまでスキップする


@findex .included ( @var{ --   } ) gforth-0.5
@cindex @code{.included}
@kindex .included
@format
@code{.included} ( @i{--  }) gforth-0.5 ``.included''
@end format
インクルードされたファイルの名前をリストします。


@c doc-init-included-files @c internal
@findex sourcefilename ( @var{ -- c-addr u   } ) gforth-0.2
@cindex @code{sourcefilename}
@kindex sourcefilename
@format
@code{sourcefilename} ( @i{-- c-addr u  }) gforth-0.2 ``sourcefilename''
@end format
現在入力ソースとなっているソース・ファイルの名前。  結果は、 ファイルがロードされている間のみ有効です。
現在の入力ソースが(ストリーム)ファイルでない場合、 結果は未定義です。  Gforth では、 結果はセッション全体で有効です(ただし、
@code{savesystem} などを跨いで有効ではありません)。


@findex sourceline# ( @var{ -- u   } ) gforth-0.2
@cindex @code{sourceline#}
@kindex sourceline#
@format
@code{sourceline#} ( @i{-- u  }) gforth-0.2 ``sourceline-number''
@end format
(ストリーム)ファイルから現在通訳(interpret)されている行の行番号。 最初の行は番号 1 です。
現在の入力ソースが(ストリーム)ファイルでない場合、 結果は未定義です。



@code{required} の標準 Forth の定義は @file{compat/required.fs} で提供されます。

@c -------------------------------------------------------------
@node General files, Redirection, Forth source files, Files
@subsection General files
@cindex general files
@cindex file-handling

ファイルは名前と種類によって開かれたり作成されたりします。 以下のファイル・アクセス・メソッド(FAM)が認識されます:

@cindex fam (file access method)
@findex r/o ( @var{ -- fam   } ) file
@cindex @code{r/o}
@kindex r/o
@format
@code{r/o} ( @i{-- fam  }) file ``r-o''
@end format

@findex r/w ( @var{ -- fam   } ) file
@cindex @code{r/w}
@kindex r/w
@format
@code{r/w} ( @i{-- fam  }) file ``r-w''
@end format

@findex w/o ( @var{ -- fam   } ) file
@cindex @code{w/o}
@kindex w/o
@format
@code{w/o} ( @i{-- fam  }) file ``w-o''
@end format

@findex bin ( @var{ fam1 -- fam2   } ) file
@cindex @code{bin}
@kindex bin
@format
@code{bin} ( @i{fam1 -- fam2  }) file ``bin''
@end format

@findex +fmode ( @var{ fam1 rwxrwxrwx -- fam2   } ) gforth-1.0
@cindex @code{+fmode}
@kindex +fmode
@format
@code{+fmode} ( @i{fam1 rwxrwxrwx -- fam2  }) gforth-1.0 ``plus-f-mode''
@end format
ファイル・アクセス・モードを fam に追加 - create-file のみ(訳注: @i{rwxrwxrwx} は chmod と同様 777 とか
666 。 ただし gforth には直接 8進数記述する方法が無い)




ファイルを開いたり作成したりすると、 他のすべてのファイル・コマンドに使用されるファイル識別子 @i{wfileid} が返されます。
すべてのファイル・コマンドは、 ステータス値 @i{wior} も返します。 これは、 操作が成功した場合は 0 を返し、
エラーの場合は実装で定義されたゼロ以外の値を返します。


@findex open-file ( @var{ c-addr u wfam -- wfileid wior  } ) file
@cindex @code{open-file}
@kindex open-file
@format
@code{open-file} ( @i{c-addr u wfam -- wfileid wior }) file ``open-file''
@end format

@findex create-file ( @var{ c-addr u wfam -- wfileid wior  } ) file
@cindex @code{create-file}
@kindex create-file
@format
@code{create-file} ( @i{c-addr u wfam -- wfileid wior }) file ``create-file''
@end format


@findex close-file ( @var{ wfileid -- wior  } ) file
@cindex @code{close-file}
@kindex close-file
@format
@code{close-file} ( @i{wfileid -- wior }) file ``close-file''
@end format

@findex delete-file ( @var{ c-addr u -- wior  } ) file
@cindex @code{delete-file}
@kindex delete-file
@format
@code{delete-file} ( @i{c-addr u -- wior }) file ``delete-file''
@end format

@findex rename-file ( @var{ c-addr1 u1 c-addr2 u2 -- wior  } ) file-ext
@cindex @code{rename-file}
@kindex rename-file
@format
@code{rename-file} ( @i{c-addr1 u1 c-addr2 u2 -- wior }) file-ext ``rename-file''
@end format
ファイル @i{c_addr1 u1} のファイル名を新しい名前 @i{c_addr2 u2} に変更します(rename)

@findex read-file ( @var{ c-addr u1 wfileid -- u2 wior  } ) file
@cindex @code{read-file}
@kindex read-file
@format
@code{read-file} ( @i{c-addr u1 wfileid -- u2 wior }) file ``read-file''
@end format
ファイル @i{wfileid} から @i{u1} 文字を @i{c_addr} からのバッファーに読み取ります。  ゼロ以外の @i{wior}
はエラーを示します。  @i{U2}は読み出したデータの長さを示します。  ファイルの終わりはエラーではなく、 @i{u2}$<$@i{u1} かつ
@i{wior}=0 によって示されます。

@findex read-line ( @var{ c_addr u1 wfileid -- u2 flag wior   } ) file
@cindex @code{read-line}
@kindex read-line
@format
@code{read-line} ( @i{c_addr u1 wfileid -- u2 flag wior  }) file ``read-line''
@end format
@i{wfileid} から @i{c_addr u1} のバッファーに行を読み取ります。  Gforth は、 LF と CR と CRLFの 3
つの一般的な行終端文字をすべてサポートします。  ゼロ以外の @i{wior} はエラーを示します。  false の @i{flag}
は、ファイルの最後(end of the file)で @code{read-line} が呼び出されたことを示します。 @i{u2}
は行の長さ(ターミネータなし)を示します。 @i{u2}$<$@i{u1} は行の長さが @i{u2} 文字であることを示します。
@i{u2}=@i{u1} は、 行が少なくとも @i{u1} 文字長であり、 バッファーの @i{u1} 文字がその行の文字で埋められており、
そして、  その行の次のスライスは次の @code{read-line} で読み取られます。 行の長さが @i{u1} 文字の場合、最初の
@code{read-line} は @i{u2}=@i{u1} を返し、 次の read-line は @i{u2}=0 を返します。


@findex key-file ( @var{ fd -- key   } ) gforth-0.4
@cindex @code{key-file}
@kindex key-file
@format
@code{key-file} ( @i{wfileid -- n  }) gforth-0.4 ``key-file''
@end format
@i{wfileid} から 1 文字 @i{n} を読み取ります。  このワードは @i{wfileid} のバッファリングを無効にします。
あなたが端末から非標準モード(non-canonical
mode)(RAWモード)で文字を読み取りたい場合は、(C言語インターフェイスを使用して)自分で端末を非標準モード(non-canonical
mode)にする必要があります。 例外は @code{stdin} で、 この場合 Gforth は自動的に非正規モード(non-canonical
mode)に設定します。


@findex key?-file ( @var{ wfileid -- f  } ) gforth-0.4
@cindex @code{key?-file}
@kindex key?-file
@format
@code{key?-file} ( @i{wfileid -- f }) gforth-0.4 ``key-q-file''
@end format
@i{f} は、 ブロッキング無しに @i{wfileid} から少なくとも 1 文字を読み取ることができる場合に true になります。
ファイルに対して @code{read-file} または @code{read-line} も使用したい場合は、 最初に
@code{key?-file} または @code{key-file} を呼び出す必要があります(これら 2
つのワードはバッファリングを無効にします)。

@findex file-eof? ( @var{ wfileid -- flag  } ) gforth-0.6
@cindex @code{file-eof?}
@kindex file-eof?
@format
@code{file-eof?} ( @i{wfileid -- flag }) gforth-0.6 ``file-eof-query''
@end format
@var{wfileid} のファイル終了インジケーター(end-of-file indicator)がセットされている場合、 @var{Flag} は
true です。

@findex write-file ( @var{ c-addr u1 wfileid -- wior  } ) file
@cindex @code{write-file}
@kindex write-file
@format
@code{write-file} ( @i{c-addr u1 wfileid -- wior }) file ``write-file''
@end format

@findex write-line ( @var{ c-addr u wfileid -- ior   } ) file
@cindex @code{write-line}
@kindex write-line
@format
@code{write-line} ( @i{c-addr u wfileid -- ior  }) file ``write-line''
@end format

@findex emit-file ( @var{ c wfileid -- wior  } ) gforth-0.2
@cindex @code{emit-file}
@kindex emit-file
@format
@code{emit-file} ( @i{c wfileid -- wior }) gforth-0.2 ``emit-file''
@end format

@findex flush-file ( @var{ wfileid -- wior  } ) file-ext
@cindex @code{flush-file}
@kindex flush-file
@format
@code{flush-file} ( @i{wfileid -- wior }) file-ext ``flush-file''
@end format


@findex file-status ( @var{ c-addr u -- wfam wior  } ) file-ext
@cindex @code{file-status}
@kindex file-status
@format
@code{file-status} ( @i{c-addr u -- wfam wior }) file-ext ``file-status''
\ 訳注: @i{wior} <> 0 ;ファイルが存在しない(@i{wfam}は未定義の値)、
\       @i{wior}=0 かつ  ( @i{wfam}=2 r/w 、 @i{wfam}=0 r/o 、 @i{wfam}=4 w/o 、
\       @i{wfam}=1 r/o bin いずれのacessモードチェックもエラーになった時。
\       便宜的に読み込み専用かつバイナリとして返す)
@end format

@findex file-position ( @var{ wfileid -- ud wior  } ) file
@cindex @code{file-position}
@kindex file-position
@format
@code{file-position} ( @i{wfileid -- ud wior }) file ``file-position''
@end format

@findex reposition-file ( @var{ ud wfileid -- wior  } ) file
@cindex @code{reposition-file}
@kindex reposition-file
@format
@code{reposition-file} ( @i{ud wfileid -- wior }) file ``reposition-file''
@end format

@findex file-size ( @var{ wfileid -- ud wior  } ) file
@cindex @code{file-size}
@kindex file-size
@format
@code{file-size} ( @i{wfileid -- ud wior }) file ``file-size''
@end format

@findex resize-file ( @var{ ud wfileid -- wior  } ) file
@cindex @code{resize-file}
@kindex resize-file
@format
@code{resize-file} ( @i{ud wfileid -- wior }) file ``resize-file''
@end format


@findex slurp-file ( @var{ c-addr1 u1 -- c-addr2 u2   } ) gforth-0.6
@cindex @code{slurp-file}
@kindex slurp-file
@format
@code{slurp-file} ( @i{c-addr1 u1 -- c-addr2 u2  }) gforth-0.6 ``slurp-file''
@end format
@var{c-addr1 u1} はファイル名、 @var{c-addr2 u2} はファイルの内容です(訳注: slurp;音を立ててすする の意味)


@findex slurp-fid ( @var{ fid -- addr u   } ) gforth-0.6
@cindex @code{slurp-fid}
@kindex slurp-fid
@format
@code{slurp-fid} ( @i{fid -- addr u  }) gforth-0.6 ``slurp-fid''
@end format
@var{addr u} はファイル @var{fid} の内容です(訳注: slurp;音を立ててすする の意味)


@findex stdin ( @var{ -- wfileid  } ) gforth-0.4
@cindex @code{stdin}
@kindex stdin
@format
@code{stdin} ( @i{-- wfileid }) gforth-0.4 ``stdin''
@end format
Gforth プロセスの標準入力ファイル。

@findex stdout ( @var{ -- wfileid  } ) gforth-0.2
@cindex @code{stdout}
@kindex stdout
@format
@code{stdout} ( @i{-- wfileid }) gforth-0.2 ``stdout''
@end format
Gforth プロセスの標準出力ファイル。

@findex stderr ( @var{ -- wfileid  } ) gforth-0.2
@cindex @code{stderr}
@kindex stderr
@format
@code{stderr} ( @i{-- wfileid }) gforth-0.2 ``stderr''
@end format
Gforth プロセスの標準エラー出力ファイル。


@c ---------------------------------------------------------
@node Redirection, Directories, General files, Files
@subsection Redirection
@cindex Redirection
@cindex Input Redirection
@cindex Output Redirection

@code{type} や @code{emit} の出力と、
それらを使用するすべてのワード(明示的なターゲット・ファイルを持たないすべての出力用ワード)を、 @code{outfile-execute}
を使用して任意のファイルにリダイレクトできます。 以下のように使用します:

@example
: some-warning ( n -- )
    cr ." warning# " . ;

: print-some-warning ( n -- )
    ['] some-warning stderr outfile-execute ;
@end example

これは、 @code{some-warning} を execute した後、 元の出力先を復元します。 この構造は例外に対して安全です。 同様に、
@code{key} からの入力と、 それを利用した入力(明示的にファイルを指定しない入力用ワード)をリダイレクトするための
@code{infile-execute} があります。

@findex outfile-execute ( @var{ ... xt file-id -- ...   } ) gforth-0.7
@cindex @code{outfile-execute}
@kindex outfile-execute
@format
@code{outfile-execute} ( @i{... xt file-id -- ...  }) gforth-0.7 ``outfile-execute''
@end format
@code{type} などの出力を @i{file-id} にリダイレクトして @i{xt} を execute します。


@findex outfile-id ( @var{ -- file-id   } ) gforth-0.2
@cindex @code{outfile-id}
@kindex outfile-id
@format
@code{outfile-id} ( @i{-- file-id  }) gforth-0.2 ``outfile-id''
@end format
@i{File-id} は、 @code{emit} や、 @code{type} や、 入力として file-id
を受け取らない出力用ワードによって使用されます。  @code{outfile-execute} で変更しない限り、 デフォルトでは
@code{outfile-id} は実行中のプロセスの @code{stdout} を生成します。


@findex infile-execute ( @var{ ... xt file-id -- ...   } ) gforth-0.7
@cindex @code{infile-execute}
@kindex infile-execute
@format
@code{infile-execute} ( @i{... xt file-id -- ...  }) gforth-0.7 ``infile-execute''
@end format
@code{key} などの入力を @i{file-id} にリダイレクトして @i{xt} を実行します。


@findex infile-id ( @var{ -- file-id   } ) gforth-0.4
@cindex @code{infile-id}
@kindex infile-id
@format
@code{infile-id} ( @i{-- file-id  }) gforth-0.4 ``infile-id''
@end format
@i{File-id} は、 @code{key} や、 @code{?key} や、 「ユーザー入力デバイス」(user input
device)を参照するものすべてによって使用されます。  デフォルトでは、 @code{infile-execute}
で変更しない限り、@code{infile-id} は実行中のプロセスの @code{stdin} を生成します。



あなたが、 入力または出力をファイルにリダイレクトしたくない場合は、 @code{key} や @code{emit} や @code{type} が
defer されたワードであるという事実を利用することもできます(@pxref{Deferred Words})。  ただし、 その場合は、 復元と、
例外からの保護について、 自分で心配する必要があります。 また、 この方法で出力をリダイレクトするには、 @code{emit} と
@code{type} の両方をリダイレクトする必要があることに注意してください。

@c ---------------------------------------------------------
@node Directories, Search Paths, Redirection, Files
@subsection Directories
@cindex Directories

あなたは、 ファイル名をディレクトリとベース・コンポーネントに分割できます:

@findex basename ( @var{ c-addr1 u1 -- c-addr2 u2   } ) gforth-0.7
@cindex @code{basename}
@kindex basename
@format
@code{basename} ( @i{c-addr1 u1 -- c-addr2 u2  }) gforth-0.7 ``basename''
@end format
ファイル名が @i{c-addr1 u1} の場合、 @i{c-addr2 u2} は、 先頭のディレクトリ・コンポーネントが削除された部分です(訳注:
"os-class" environment? type unix ok な環境では動いたが、 Windows系では不明('/'
を区切り文字としてハードコーディングしてあるっぽい)。


@findex dirname ( @var{ c-addr1 u1 -- c-addr1 u2   } ) gforth-0.7
@cindex @code{dirname}
@kindex dirname
@format
@code{dirname} ( @i{c-addr1 u1 -- c-addr1 u2  }) gforth-0.7 ``dirname''
@end format
@i{C-addr1 u2} は、 ファイル名 @i{c-addr1 u1} のディレクトリ名部分で、 末尾の @code{/} も含まれます。
@i{caddr1 u1} に @code{/} が含まれていない場合、 @i{u2}=0 です(訳注: pathの区切り文字として @code{/}
をハードコーディングしているので、 Windows系で動くかどうか不明)。



ファイルと同様に、 ディレクトリを開いて読み取ることができます。  読むと、 一度に 1 つのディレクトリ・エントリが得られます。 これを、
(ワイルドカードを使用して)ファイル名とマッチングさせることができます。

@findex open-dir ( @var{ c-addr u -- wdirid wior  } ) gforth-0.5
@cindex @code{open-dir}
@kindex open-dir
@format
@code{open-dir} ( @i{c-addr u -- wdirid wior }) gforth-0.5 ``open-dir''
@end format
@i{c-addr, u} で指定されたディレクトリを開き、 さらにそこにアクセスするために @i{dir-id} を返します。

@findex read-dir ( @var{ c-addr u1 wdirid -- u2 flag wior  } ) gforth-0.5
@cindex @code{read-dir}
@kindex read-dir
@format
@code{read-dir} ( @i{c-addr u1 wdirid -- u2 flag wior }) gforth-0.5 ``read-dir''
@end format
@i{dir-id} で指定されたディレクトリから、 アドレス @i{c-addr} にある長さ @i{u1} のバッファーへ、
次のエントリの読み取りを試みます。 これ以上エントリがないために試行が失敗した場合は、 @i{ior}=0 かつ @i{flag}=0 かつ
@i{u2}=0 となり、 バッファーは変更されません。  他の理由で次のエントリの読み取りに失敗した場合は、 @i{ior}<>0 を返します。
試行が成功した場合、 ファイル名を @i{c-addr} からのバッファーに保存し、 @i{ior}=0 かつ @i{flag}=true かつ
ファイル名のサイズに等しい @i{u2} を返します。  ファイル名の長さが @i{u1} より長い場合は、 ファイル名の最初の @i{u1}
文字をバッファーに格納し、 @i{ior} はエラー "name too long" を示し(訳注: @i{ior}= -548 日本語環境では
"ファイル名が長すぎます")、 かつ @i{flag}=true かつ @i{u2}=@i{u1} です。

@findex close-dir ( @var{ wdirid -- wior  } ) gforth-0.5
@cindex @code{close-dir}
@kindex close-dir
@format
@code{close-dir} ( @i{wdirid -- wior }) gforth-0.5 ``close-dir''
@end format
@i{dir-id} で指定されたディレクトリを閉じます。

@findex filename-match ( @var{ c-addr1 u1 c-addr2 u2 -- flag  } ) gforth-0.5
@cindex @code{filename-match}
@kindex filename-match
@format
@code{filename-match} ( @i{c-addr1 u1 c-addr2 u2 -- flag }) gforth-0.5 ``match-file''
@end format
ファイル名 @var{c_addr1 u1} とパターン @var{c_addr2 u2} のマッチングを行います。  パターンは、複数の文字
('*') または 1 つの文字 ('?') のワイルドカードである特殊文字 '*' と '?' を除き、 文字ごとにマッチします。
マッチングできた場合は true

@findex get-dir ( @var{ c-addr1 u1 -- c-addr2 u2  } ) gforth-0.7
@cindex @code{get-dir}
@kindex get-dir
@format
@code{get-dir} ( @i{c-addr1 u1 -- c-addr2 u2 }) gforth-0.7 ``get-dir''
@end format
@i{c-addr1, u1}で指定されたバッファーにカレント・ディレクトリのパス(path)を格納します。  バッファーサイズが十分でない場合は、 0
0 を返します。

@findex set-dir ( @var{ c-addr u -- wior  } ) gforth-0.7
@cindex @code{set-dir}
@kindex set-dir
@format
@code{set-dir} ( @i{c-addr u -- wior }) gforth-0.7 ``set-dir''
@end format
現在のディレクトリを @i{c-addr, u} に変更します。  これが不可能な場合はエラーを返します(訳注: 例えば @i{ior} = -514
; "そのようなファイルやディレクトリはありません")

@findex =mkdir ( @var{ c-addr u wmode -- wior  } ) gforth-0.7
@cindex @code{=mkdir}
@kindex =mkdir
@format
@code{=mkdir} ( @i{c-addr u wmode -- wior }) gforth-0.7 ``equals-mkdir''
@end format
モード @i{wmode} でディレクトリ @i{c-addr u} を作成します。

@findex mkdir-parents ( @var{ c-addr u mode -- ior   } ) gforth-0.7
@cindex @code{mkdir-parents}
@kindex mkdir-parents
@format
@code{mkdir-parents} ( @i{c-addr u mode -- ior  }) gforth-0.7 ``mkdir-parents''
@end format
ディレクトリ @i{c-addr u} とそのすべての親をモード @i{mode} (umask が掛けられます)で作成します(訳注:
フルパスで指定したディレクトリを作成する。 @code{aaa/bbb/ccc} というディレクトリを指定すればそれを一気に作る。 ここで、
@i{ccc} というファイルが既にある場合は何もせず @i{ior}=-529 「ファイルが存在します」エラーとなる。 注意: @i{aaa} または
@i{bbb} がファイルの場合は「削除」してからディレクトリを作成するので注意。  @i{ior}=-525 なら「許可がありません」(aaa ,
aaa/bbb , aaa/bbb/ccc のいずれで許可が無かったのかは不明)。 注意: gforth には8進数リテラルが無いので注意。
2進数(%0111111101 ; -rwxrwxr-x )がおすすめ。 ディレクトリの作成であるので実行権限(x)の付与を行うこと)



@c ---------------------------------------------------------
@node Search Paths, , Directories, Files
@subsection Search Paths
@cindex path for @code{included}
@cindex file search path
@cindex @code{include} search path
@cindex search path for files

あなたが、 @code{included} や、 そのファミリーのために、 直接ファイル名を指定する場合(つまり、  @file{/} や
@file{~} で始まるファイル名、 または 2 番目の位置に @file{:} が付くファイル名 (@samp{C:...} など))、
そのファイルは、 あなたの期待どおりにインクルードされます。

ファイル名が @file{./} で始まる場合、 これは「現在の」ファイルがインクルードされたディレクトリを指します。  これにより、
(現在の作業ディレクトリや絶対位置に関係なく)ファイル自体の位置を基準にして他のファイルを含めることができます。  この機能は、
ファイルにライブラリの他のファイルが含まれる可能性がある、 複数のファイルで構成されるライブラリにとって不可欠です。  C言語の
@code{#include "..."} に相当します。 現在の入力ソースがファイルでない場合、 @file{.}
はインクルードされた最も内側のファイルのディレクトリを参照します。 インクルードされたファイルがない場合は、
現在の作業ディレクトリからインクルードされます。

(@file{./} で始まらない)相対ファイル名の場合、 Gforth は検索パス(a search path)を使用します。
検索パスに書かれた各ディレクトリ内で、 指定のファイル名を検索し、 最初に見つかったファイル名をインクルードします。  Forth
のソース・ファイルと一般ファイルには別個の検索パスがあります。  検索パスにディレクトリ @file{.} が含まれている場合、 ファイルが
@file{./} で指定されているかのように、 「現在のファイルのディレクトリ」または作業ディレクトリを参照します。

@file{~+} を使用して、 (@code{bash} の Tilde Expansion @code{~+/foo} →
@code{$PWD/foo} のように)現在の作業ディレクトリを参照します(訳注: "~+/my-mkdir-parents.fs"
file-status .s <2> 2 0  ok 2 )

@findex absolute-file? ( @var{ addr u -- flag   } ) gforth-1.0
@cindex @code{absolute-file?}
@kindex absolute-file?
@format
@code{absolute-file?} ( @i{addr u -- flag  }) gforth-1.0 ``absolute-file?''
@end format
ファイル名が @code{/} または @code{~} (チルダ拡張) で始まる場合、 または @code{./*} 拡張正規表現:
@code{^[/~]|./} の形式である場合、 または 2 番目の文字としてコロンが含まれる場合(@code{C:...})、
絶対(absolute)ファイル名です( true を返す)。  パスが @code{/} を含んでいるだけでは絶対ファイル名ではありません(訳注:
厳密にファイル名として成立するかどうかチェックしている訳では無い事に注意、 例えば @code{"~ccc.txt" absolute-file?
. -1  ok} 、また @code{./} 形式を絶対と見なすことも注意。 @code{"./aaa/bbb/ccc.txt"
absolute-file? . -1  ok} )



@c anton: fold the following subsubsections into this subsection?

@menu
* Source Search Paths::
* General Search Paths::     
@end menu

@c ---------------------------------------------------------
@node Source Search Paths, General Search Paths, Search Paths, Search Paths
@subsubsection Source Search Paths
@cindex search path control, source files

検索パス(the search path)は、 Gforth の起動時に初期化されます(@pxref{Invoking Gforth})。
@code{fpath} を一般的なパス処理ワードと組み合わせて使用​​すると、これを表示したり変更したりできます。

@findex fpath ( @var{ -- path-addr   } ) gforth-0.4
@cindex @code{fpath}
@kindex fpath
@format
@code{fpath} ( @i{-- path-addr  }) gforth-0.4 ``fpath''
@end format

@findex .fpath ( @var{ --   } ) gforth-0.4
@cindex @code{.fpath}
@kindex .fpath
@format
@code{.fpath} ( @i{--  }) gforth-0.4 ``.fpath''
@end format
Forth 検索パスの内容を表示します。


@findex file>fpath ( @var{ addr1 u1 -- addr2 u2   } ) gforth-1.0
@cindex @code{file>fpath}
@kindex file>fpath
@format
@code{file>fpath} ( @i{addr1 u1 -- addr2 u2  }) gforth-1.0 ``file>fpath''
@end format
@code{fpath} で @i{c-addr1 u1} という名前のファイルを検索します。 成功した場合、 @i{c-addr u2}
は絶対ファイル名または現在の作業ディレクトリからの相対ファイル名になります。  ファイルを開けない場合(ファイルが見つからない場合)は例外を throw
します。


@c the functionality of the following words is easily available through
@c   fpath and the general path words.  The may go away.
@c doc-fpath+
@c doc-fpath=
@c doc-open-fpath-file

@noindent
@code{fpath} と @code{require} の使用例を以下に示します:

@example
fpath path= /usr/lib/forth/|./
require timer.fs
@end example


@c ---------------------------------------------------------
@node General Search Paths, , Source Search Paths, Search Paths
@subsubsection General Search Paths
@cindex search path control, source files

あなたのアプリケーションでは、 @code{included} のように、 複数のディレクトリ内のファイルを探さなければならない場合があります。
これを容易にするために、 Gforth では、 Forth 検索パスを一般化した等価なモノを提供することで、
あなた独自の検索パスを定義して使用できます。

@findex open-path-file ( @var{ addr1 u1 path-addr -- wfileid addr2 u2 0 | ior   } ) gforth-0.2
@cindex @code{open-path-file}
@kindex open-path-file
@format
@code{open-path-file} ( @i{addr1 u1 path-addr -- wfileid addr2 u2 0 | ior  }) gforth-0.2 ``open-path-file''
@end format
パス @var{path-addr} で、 指定のファイル @var{addr1 u1} を探します。  見つかった場合(@var{ior}=0)は、
結果のパス(@i{addr2 u2})と、 (読み取り専用の)ファイル・デスクリプタ(open file
descriptor)(@i{wfileid})を返します。 ファイルが見つからない場合、 @var{ior}
は(現在の実装では)ファイルを開こうとした最後の試行時点で返されたものです(訳注:ファイルが見つからない場合、 つまり @var{ior}<>0
の場合、返されるのは @var{ior} のみです @i{( addr1 u1 path-addr -- ior )} )。


@findex file>path ( @var{ c-addr1 u1 path-addr -- c-addr2 u2   } ) gforth-1.0
@cindex @code{file>path}
@kindex file>path
@format
@code{file>path} ( @i{c-addr1 u1 path-addr -- c-addr2 u2  }) gforth-1.0 ``file>path''
@end format
@i{path-addr} に保存されたパス内で @i{c-addr1 u1} という名前のファイルを検索します。  成功した場合、@i{c-addr
u2} は絶対ファイル名または現在の作業ディレクトリからの相対ファイル名になります。  ファイルを開けない場合は例外をスローします。


@findex clear-path ( @var{ path-addr --   } ) gforth-0.5
@cindex @code{clear-path}
@kindex clear-path
@format
@code{clear-path} ( @i{path-addr --  }) gforth-0.5 ``clear-path''
@end format
パス @i{path-addr} を空(empty)にします。


@findex also-path ( @var{ c-addr len path-addr --   } ) gforth-0.4
@cindex @code{also-path}
@kindex also-path
@format
@code{also-path} ( @i{c-addr len path-addr --  }) gforth-0.4 ``also-path''
@end format
ディレクトリ @i{c-addr len} を @i{path-addr} に追加します。


@findex .path ( @var{ path-addr --   } ) gforth-0.4
@cindex @code{.path}
@kindex .path
@format
@code{.path} ( @i{path-addr --  }) gforth-0.4 ``.path''
@end format
検索パス @var{path-addr} の内容を表示します。


@findex path+ ( @var{ path-addr  "dir" --   } ) gforth-0.4
@cindex @code{path+}
@kindex path+
@format
@code{path+} ( @i{path-addr  "dir" --  }) gforth-0.4 ``path+''
@end format
ディレクトリ @var{dir} を検索パス @var{path-addr} に追加します(訳注: 検索パスの後ろに追加する)。


@findex path= ( @var{ path-addr "dir1|dir2|dir3" --   } ) gforth-0.4
@cindex @code{path=}
@kindex path=
@format
@code{path=} ( @i{path-addr "dir1|dir2|dir3" --  }) gforth-0.4 ``path-equals''
@end format
パス @i{path-addr} に、 完全に新しい検索パスを作成します。 パス区切り文字は @code{|} です。



@c
カスタム検索パスの作成例を以下に示します:
@example
variable mypath \ no special allocation required, just a variable
mypath path= /lib|/usr/lib \ assign initial directories
mypath path+ /usr/local/lib \ append directory
mypath .path \ output:"/lib /usr/lib /usr/local/lib"
@end example

ファイルを検索し、 結果のパスを表示します(訳注: @code{file>path} だと内部で throw しちゃうので、代わりに
@code{opne-path-file} を使った例…だと思う):
@example
s" libm.so" mypath open-path-file throw type close-file \ output:"/lib/libm.so"
@end example

@c -------------------------------------------------------------
@node Blocks, Other I/O, Files, Words
@section Blocks
@cindex I/O - blocks
@cindex blocks

今どきのデスクトップ・コンピューターで Gforth を実行すると、 特定のサービスを提供するオペレーティング・システムの制御下で Gforth
が実行されます。 これらのサービスの 1 つはファイル・サービスです。 これにより、Forth のソース・コードとデータをファイルに保存し、
Gforth に読み込むことができます(@pxref{Files})。

伝統的に、 Forth は、
オペレーティング・システムを介さずに基盤となるハードウェアと直接インターフェイスするシステム上で有用なプログラミング言語でした。 Forth は、
そのようなシステム上で大容量ストレージにアクセスするためのブロック(@dfn{blocks})と呼ばれるメカニズムを提供します。

ブロックは 1024 バイトのデータ領域であり、 データまたは Forth ソース・コードを保持するために使用できます。
ブロックの内容に構造は課されません。 ブロックはその番号によって識別されます。 ブロックには、1 から実装定義の最大値まで連続した番号が付けられます。

ブロックを使用するが、 オペレーティング・ステムを使用しない一般的なシステムでは、 大容量ストレージとして 1
台のフロッピー・ディスク・ドライブを使用し、 ディスクは 256 バイトのセクターを提供するようにフォーマットされます。 ブロックは、
ディスクの容量の制限まで、 ディスクの最初の 4 セクタをブロック 1 に割り当て、 次の 4 セクタをブロック 2
に割り当てることによって実装されます。 ディスクにはファイル・システム情報は含まれず、 ブロック達のみが含まれます。

@cindex blocks file
ファイル・サービスを提供するシステムでは、 ブロックは通常、単一のブロック・ファイル内に一連のブロックを格納することによって実装されます。
ブロック・ファイルのサイズは、 含まれるブロックの数に対応する 1024 バイトの正確な倍数になります。 これが Gforth
が使用するメカニズムです。

@cindex @file{blocks.fb}
一度に開くことができるブロック・ファイルは 1 つだけです。 ブロック・ファイルを指定せずにブロック・ワードを使用すると、 Gforth
はデフォルトでブロック・ファイル @file{blocks.fb} を使用します。 Gforth は、 ブロック・ファイルを見つけようとするときに
Forth 検索パスを使用します(@pxref{Source Search Paths})。

@cindex block buffers
プログラム制御下でブロックの読み取りと書き込みを行う場合、 Gforth は中間ストレージとして多数のブロック・バッファー(@dfn{block
buffers})を使用します。 @code{load} を使用してブロックの内容を解釈する場合は、 これらのバッファーは使用されません。

ブロック・バッファーの動作はキャッシュ(cache)の動作に似ています。  各ブロック・バッファーには 3 つの状態(state)があります:

@itemize @bullet
@item
未割り当て(unassigned)
@item
割り当て済・未変更(assigned-clean)
@item
割り当て済・変更中(assigned-dirty)
@end itemize

最初は、すべてのブロック・バッファーは「未割り当て」(@i{unassigned})です。 ブロックにアクセスするには、
ブロック(ブロック番号で指定)をブロック・バッファーに割り当てる必要があります。

ブロック・バッファーへのブロックの割り当ては、 @code{block} または @code{buffer} によって行われます。
ブロックの既存の内容を変更する場合は、 @code{block} を使用します。 ブロックの既存の内容を気にしない場合は、 @code{buffer}
を使用します@footnote{@code{buffer} の標準 Forth での定義は、 ディスク I/O を発生させないことを目的としています。
以前の @code{block} コマンドにより、 特定のブロックに関連付けられたデータがすでにブロック・バッファーに格納されている場合、
@code{buffer} はそのブロック・バッファーを返し、 ブロックの既存のコンテンツが利用可能になります。 それ以外の場合、
@code{buffer} は単にそのブロックに新しい空のブロック・バッファーを割り当てます}。

@code{block} または @code{buffer} を使用してブロックをブロック・バッファーに割り当てると、
そのブロック・バッファーが「現在のブロック・バッファー」(@i{current block buffer})になります。
データは「現在のブロック・バッファー」内でのみ操作(読み取りまたは書き込み)できます。

「現在のブロック・バッファー」の内容が変更されている場合は、 「@code{block} または @code{buffer}
を再度呼び出す前に、」(何もせずに)変更を破棄するか、 @code{update} を使用して、
ブロックを変更済みとしてマークする必要があります(割り当て済・変更中;assigned-dirty)。 @code{update}
を使用してもブロック・ファイルは変更されません。
ブロック・バッファーの状態を「割り当て済・変更中」(@i{assigned-dirty})に変更するだけです。 そのブロックは、
そのブロック・バッファーが別のブロックで必要なときに暗黙的に書き込まれるか、 または、 @code{flush} や
@code{save-buffers} によって明示的に書き込まれます。

ワード @code{flush} は、 すべての「割り当て済・変更中」(@i{assigned-dirty})の
ブロックをディスク上のブロック・ファイルに書き込みます。 @code{bye} を指定して Gforth を終了するときは、 @code{flush}
も実行されます。

Gforth では、@code{block} と @code{buffer} は @i{direct-mapped}
アルゴリズムを使用してブロック・バッファーをブロックに割り当てます。 つまり、 特定のブロックは、
(特定の操作に対して)「いけにえ・バッファー」(@i{victim buffer})と呼ばれる 1
つの特定のブロック・バッファーにのみ割り当てることができます。
いけにえ・バッファーが「未割り当て」(@i{unassigned})状態または「割り当て済・未編集」(@i{assigned-clean})状態の場合、
直ちに新しいブロックが割り当てられます。 「割り当て済・編集中」(@i{assigned-dirty})の場合、 その現在の内容は、
新しいブロックが割り当てられる前に、 ディスク上のブロック・ファイルに書き戻されます。

ブロックの内容に構造は課されていませんが、 伝統的に内容は 1 行当たり 64 文字の 16 行として表示します。  一つのブロックは、
単一の連続した入力ストリームを提供します(たとえば、単一のパース領域として機能します) -- ブロック内に行末文字はなく、
ブロックの末尾にファイル終端文字もありません。 これは以下の 2 つの結果をもたらします:

@itemize @bullet
@item
ある行の最後の文字は、そのまま次の行の最初の文字に折り返される(訳注: 繋がっています)。
@item
@code{\} というワード -- 行末までのコメント -- は特別な処理を行います。 ブロックでは、 現在の 64
文字の「1行分」の終わりまでのすべての文字が無視されます。
@end itemize

Gforth では、 存在しないブロック番号を指定して @code{block} を使用すると、 現在のブロック・ファイルが適切なサイズに拡張され、
ブロック・バッファーがスペースで初期化されます。

Gforth にはシンプルなブロック・エディターが含まれています(詳細については @code{use blocked.fb 0 list}
と入力してください)。 ただし、ブロックの使用は推奨されません。 このメカニズムは下位互換性のためにのみ提供されています。

ブロックを取り扱うときに使用される一般的な手法は以下のとおりです:

@itemize @bullet
@item
Forth 環境を離れずにブロックを編集できるスクリーン・エディター。
@item
シャドウ・スクリーン。 ここで、 すべてのコード・ブロックには、 コメントを含むブロックが関連付けられています(例: 奇数のブロック番号のコード、
偶数のブロック番号のコメント)。 通常、 ブロック・エディターは、 コードとコメントを切り替える便利なメカニズムを提供します。
@item
ロード・ブロック。 単一のブロック(通常はブロック 1) には、 アプリケーション全体を @code{load} する多数の @code{thru}
コマンドが含まれています。
@end itemize

ブロックが Forth プログラミング環境にどの程度うまく統合できるかを確認するには、 Frank Sergeant の Pygmy Forth
を参照してください。

@comment TODO what about errors on open-blocks?

@findex open-blocks ( @var{ c-addr u --   } ) gforth-0.2
@cindex @code{open-blocks}
@kindex open-blocks
@format
@code{open-blocks} ( @i{c-addr u --  }) gforth-0.2 ``open-blocks''
@end format
@i{c-addr u} で指定された名前のファイルをブロック・ファイルとして使用します(訳注: エラーの場合はその時点で throw されます)。


@findex use ( @var{ "file" --   } ) gforth-0.2
@cindex @code{use}
@kindex use
@format
@code{use} ( @i{"file" --  }) gforth-0.2 ``use''
@end format
@i{file} をブロック・ファイルとして使用します。


@findex block-offset ( @var{ -- addr   } ) gforth-0.5
@cindex @code{block-offset}
@kindex block-offset
@format
@code{block-offset} ( @i{-- addr  }) gforth-0.5 ``block-offset''
@end format
最初のブロックの番号を含むユーザー変数(0.5.0 以降のデフォルト: 0)。  0.5.0 より前のバージョンの Gforth
で作成されたブロックファイルのオフセットは 1 からです。 これらのファイルを使用する場合は、次のことができます。 @code{1 offset !}
または、 使用されるすべてのブロック番号に 1 を加算します。 または、 ファイルの先頭に 1024 文字追加します。


@findex get-block-fid ( @var{ -- wfileid   } ) gforth-0.2
@cindex @code{get-block-fid}
@kindex get-block-fid
@format
@code{get-block-fid} ( @i{-- wfileid  }) gforth-0.2 ``get-block-fid''
@end format
現在のブロック・ファイルのファイル ID を返します。 まだブロック・ファイルが開かれていない場合は、 @file{blocks.fb}
をデフォルトのブロック・ファイルとして @code{open-blocks} し、
そのファイルID(現在のブロック・ファイルのファイルID)を返します。


@findex block-position ( @var{ u --   } ) block
@cindex @code{block-position}
@kindex block-position
@format
@code{block-position} ( @i{u --  }) block ``block-position''
@end format
ブロック・ファイル内のファイル位置をブロック番号 @i{u} のブロックの先頭に合わせます。



@findex list ( @var{ u --   } ) block-ext
@cindex @code{list}
@kindex list
@format
@code{list} ( @i{u --  }) block-ext ``list''
@end format
ブロック番号 @i{u} のブロックの内容を表示します。  Gforth では、ブロックは 1行 64 文字からなる 16
行の行番号付きで表示されます。


@findex scr ( @var{ -- a-addr   } ) block-ext
@cindex @code{scr}
@kindex scr
@format
@code{scr} ( @i{-- a-addr  }) block-ext ``s-c-r''
@end format
このユーザー変数には、 @code{list} によって最後に処理されたブロックのブロック番号が含まれます。



@findex block ( @var{ u -- a-addr   } ) block
@cindex @code{block}
@kindex block
@format
@code{block} ( @i{u -- a-addr  }) block ``block''
@end format
ブロック番号 @i{u} のブロックにブロック・バッファーが既に割り当てられている場合、
そのブロック・バッファーが更新(「割り当て済・変更中」(assigned-dirty)とマークされているか)されているなら、
そのブロック・バッファー内容を当該ブロック(大容量ストレージ)に上書きしてから、 当該ブロックの内容をそのブロック・バッファーに読み込み、
そのブロック・バッファーを「割り当て済・未変更」(assigned-clean)とマークして、 そのブロック・バッファーの開始アドレス
@i{a-addr} を返します。 それ以外の場合は、 ブロック @i{u} にブロック・バッファーを新たに割り当て、
その新たに割り当てたブロック・バッファーの開始アドレス @i{a-addr} を返します。 Gforth では、 @code{buffer} は単に
@code{block} を呼び出します。


@findex buffer ( @var{ u -- a-addr   } ) block
@cindex @code{buffer}
@kindex buffer
@format
@code{buffer} ( @i{u -- a-addr  }) block ``buffer''
@end format
Gforth では、 @code{buffer} は単に @code{block} を呼び出します。



@findex empty-buffers ( @var{ --   } ) block-ext
@cindex @code{empty-buffers}
@kindex empty-buffers
@format
@code{empty-buffers} ( @i{--  }) block-ext ``empty-buffers''
@end format
すべてのブロック・バッファーを「未割り当て」(unassigned)としてマークします。 (@code{update}
によって)「割り当て済・変更中」(assigned-dirty)としてマークされているブロックがある場合、 それらのブロックへの変更は失われます。


@findex empty-buffer ( @var{ buffer --   } ) gforth-0.2
@cindex @code{empty-buffer}
@kindex empty-buffer
@format
@code{empty-buffer} ( @i{buffer --  }) gforth-0.2 ``empty-buffer''
@end format

@findex update ( @var{ --   } ) block
@cindex @code{update}
@kindex update
@format
@code{update} ( @i{--  }) block ``update''
@end format
現在のブロック・バッファー(current block buffer)の状態を「割り当て・ダーティ」(assigned-dirty)としてマークします。


@findex updated? ( @var{ n -- f   } ) gforth-0.2
@cindex @code{updated?}
@kindex updated?
@format
@code{updated?} ( @i{n -- f  }) gforth-0.2 ``updated?''
@end format
ブロック番号 @i{n} のブロックが更新されている(割り当て済・編集中」(assigned-dirty)としてマークされている)なら true
を返す。


@findex save-buffers ( @var{ --   } ) block
@cindex @code{save-buffers}
@kindex save-buffers
@format
@code{save-buffers} ( @i{--  }) block ``save-buffers''
@end format
更新されている(「割り当て済・変更中」(assigned-dirty)とマークされている)各ブロック・バッファーの内容を大容量ストレージに転送(上書き)し、
すべてのブロック・バッファーを「割当済み・未編集」(assigned-clean)としてマークします。


@findex save-buffer ( @var{ buffer --   } ) gforth-0.2
@cindex @code{save-buffer}
@kindex save-buffer
@format
@code{save-buffer} ( @i{buffer --  }) gforth-0.2 ``save-buffer''
@end format

@findex flush ( @var{ --   } ) block
@cindex @code{flush}
@kindex flush
@format
@code{flush} ( @i{--  }) block ``flush''
@end format
@code{save-buffers} の機能を実行してから @code{empty-buffers} を実行します。



@findex load ( @var{ i*x u -- j*x   } ) block
@cindex @code{load}
@kindex load
@format
@code{load} ( @i{i*x u -- j*x  }) block ``load''
@end format
ブロック番号 @i{u} のブロックをテキスト通訳(Text-interpret)します。 ブロック番号 0 のブロックは @code{load}
できません。


@findex thru ( @var{ i*x n1 n2 -- j*x   } ) block-ext
@cindex @code{thru}
@kindex thru
@format
@code{thru} ( @i{i*x n1 n2 -- j*x  }) block-ext ``thru''
@end format
ブロック @i{n1} 〜 @i{n2} を順番に @code{load} します。


@findex +load ( @var{ i*x n -- j*x   } ) gforth-0.2
@cindex @code{+load}
@kindex +load
@format
@code{+load} ( @i{i*x n -- j*x  }) gforth-0.2 ``+load''
@end format
現在のブロック番号に @i{n} を足した番号のブロックをロードします。 ブロック内で使います。


@findex +thru ( @var{ i*x n1 n2 -- j*x   } ) gforth-0.2
@cindex @code{+thru}
@kindex +thru
@format
@code{+thru} ( @i{i*x n1 n2 -- j*x  }) gforth-0.2 ``+thru''
@end format
現在のブロック番号 + @i{n1} の番号 〜 現在のブロック + @i{n2} の番号の、 ブロックの範囲をロードします。 ブロック内で使います。


@findex --> ( @var{ --   } ) gforth-0.2
@cindex @code{-->}
@kindex -->
@format
@code{-->} ( @i{--  }) gforth-0.2 ``chain''
@end format
ブロック番号 @i{n} のブロックのロード中にこのシンボルが見つかった場合、 そのブロックの残りを破棄してブロック @i{n+1} をロードします。
複数のブロックを単一のロード可能なユニットとして連鎖させるために使用されます。  これは ロードの独立性が損なわれるため、 お勧めできません。
代わりに(標準の) @code{thru} または @code{+thru} を使用してください。


@findex block-included ( @var{ a-addr u --   } ) gforth-0.2
@cindex @code{block-included}
@kindex block-included
@format
@code{block-included} ( @i{a-addr u --  }) gforth-0.2 ``block-included''
@end format
@code{load} によって処理されるブロック内で使用します。 現在のブロック・ファイル仕様を保存し、 @i{a-addr u}
で指定されたブロック・ファイルを開き、 そのファイルからブロック番号 1 のブロックを @code{load} します(これにより、
他のブロックがチェーンまたはロードされる可能性があります)。 そして最後に、 ブロック・ファイルを閉じて、 元のブロック・ファイルを復元します。




@c -------------------------------------------------------------
@node Other I/O, OS command line arguments, Blocks, Words
@section Other I/O
@cindex I/O - keyboard and display

@menu
* Simple numeric output::    定義済みの書式
* Formatted numeric output::  書式化された(目に見える)出力
* Floating-point output::
* Miscellaneous output::
* Displaying characters and strings::  その他もろもろ
* Terminal output::          カーソル移動等
* Single-key input::
* Line input and conversion::
* Pipes::                    あなた独自のパイプラインの作り方
* Xchars and Unicode::       非ASCII文字
* i18n and l10n::            国際化(I18n)とローカライズ
* Substitute::               テキストマクロ置換
* CSV Reader::               データ・インポート機能
@end menu

@node Simple numeric output, Formatted numeric output, Other I/O, Other I/O
@subsection Simple numeric output
@cindex numeric output - simple/free-format

最も単純な出力機能は、 データ・スタックからの数値を表示する機能です。  数値は、 @code{base} に保存されている基数(別名
radix)で表示されます。

@findex . ( @var{ n --   } ) core
@cindex @code{.}
@kindex .
@format
@code{.} ( @i{n --  }) core ``dot''
@end format
(符号付きの1倍長整数である) @var{n} を自由形式(free-format)で表示し、 その後に空白1つを続けます。


@findex dec. ( @var{ n --   } ) gforth-0.2
@cindex @code{dec.}
@kindex dec.
@format
@code{dec.} ( @i{n --  }) gforth-0.2 ``dec.''
@end format
@i{n} を符号付き 10 進数として表示し、 その後に空白1つを続けます。


@findex h. ( @var{ u --   } ) gforth-1.0
@cindex @code{h.}
@kindex h.
@format
@code{h.} ( @i{u --  }) gforth-1.0 ``h.''
@end format
@i{u} は、 先頭に `$` を付けた符号なし 16 進数として表示し、 その後に空白1つ続けます。


@findex hex. ( @var{ u --   } ) gforth-0.2
@cindex @code{hex.}
@kindex hex.
@format
@code{hex.} ( @i{u --  }) gforth-0.2 ``hex.''
@end format
@i{u} を符号なし 16 進数として表示し、 先頭に @code{$} を付け、 その後に空白1つを付けます。  この単語の別名は
@code{h.} で、 他のいくつかのシステムには存在しますが、 1.0 より前の Gforth には存在しません。


@findex u. ( @var{ u --   } ) core
@cindex @code{u.}
@kindex u.
@format
@code{u.} ( @i{u --  }) core ``u-dot''
@end format
(符号なしの1倍長整数の) @var{u} を自由形式で表示し、 その後に空白1つを続けます。


@findex .r ( @var{ n1 n2 --   } ) core-ext
@cindex @code{.r}
@kindex .r
@format
@code{.r} ( @i{n1 n2 --  }) core-ext ``dot-r''
@end format
@var{n1} を @var{n2} 文字幅のフィールドに右揃えで表示します。 数値を表示するために @var{n2} を超える文字が必要な場合は、
すべての桁が表示されます。  必要に応じて、 @var{n2} には先頭に `-` の文字分の幅を含める必要があります。


@findex u.r ( @var{ u n --   } ) core-ext
@cindex @code{u.r}
@kindex u.r
@format
@code{u.r} ( @i{u n --  }) core-ext ``u-dot-r''
@end format
符号なし整数 @var{u} を @var{n} 文字幅のフィールドに右揃えで表示します。 数値を表示するために @var{n}
文字を超える文字が必要な場合は、すべての桁が表示されます。


@findex dec.r ( @var{ u n --   } ) gforth-0.5
@cindex @code{dec.r}
@kindex dec.r
@format
@code{dec.r} ( @i{u n --  }) gforth-0.5 ``dec.r''
@end format
符号なし整数 @i{u} を @i{n} 文字幅のフィールドに符号なし 10 進数として表示します。


@findex d. ( @var{ d --   } ) double
@cindex @code{d.}
@kindex d.
@format
@code{d.} ( @i{d --  }) double ``d-dot''
@end format
(符号付き2倍長整数の) @var{d} を自由形式で表示します。 その後に空白1つが続きます。


@findex ud. ( @var{ ud --   } ) gforth-0.2
@cindex @code{ud.}
@kindex ud.
@format
@code{ud.} ( @i{ud --  }) gforth-0.2 ``u-d-dot''
@end format
(符号付無し2倍長整数の) @var{ud} を自由形式で表示し、 その後に空白1つを続けます。


@findex d.r ( @var{ d n --   } ) double
@cindex @code{d.r}
@kindex d.r
@format
@code{d.r} ( @i{d n --  }) double ``d-dot-r''
@end format
2倍長整数 @var{d} を @var{n} 文字幅のフィールドに右揃えで表示します。 数値を表示するために @var{n}
を超える文字が必要な場合は、 すべての桁が表示されます。  必要に応じて、@var{n} には先頭に `-` 文字分の幅を含める必要があります。


@findex ud.r ( @var{ ud n --   } ) gforth-0.2
@cindex @code{ud.r}
@kindex ud.r
@format
@code{ud.r} ( @i{ud n --  }) gforth-0.2 ``u-d-dot-r''
@end format
符号無し2倍長整数 @var{ud} を @var{n} 文字幅のフィールドに右揃えで表示します。 数値を表示するために @var{n}
文字を超える文字が必要な場合は、すべての桁が表示されます。




@node Formatted numeric output, Floating-point output, Simple numeric output, Other I/O
@subsection Formatted numeric output
@cindex formatted numeric output
@cindex pictured numeric output
@cindex numeric output - formatted

Forth は伝統的に、 整数の書式設定された出力に「表示数値出力」(@dfn{pictured numeric Output})
と呼ばれる手法を使用しています。  この手法では、 数値から数字桁(digits)が抽出され(@code{base} で定義された現在の出力基数を使用
@pxref{Number Conversion})、 ASCII コードに変換され、 メモリのスクラッチパッド領域(@pxref{core-idef,
Implementation-defined options, Implementation-defined
options})に構築される文字列の先頭に付加されます。 抽出プロセス中に、 文字列の先頭に任意の文字を追加できます。
完成した文字列はアドレスと長さによって指定され、 プログラム制御の下で操作(@code{TYPE} や、 コピーや、 変更)できます。

前のセクションで説明したすべての整数出力ワード (@pxref{Simple numeric output}) は、 Gforth
では表示数値出力(pictured numeric output)を使用して実装されています。

表示数値出力(pictured numeric output)について覚えておくべき 3 つの重要な点:

@itemize @bullet
@item
常に2倍長整数を処理します。 1倍長整数を表示するには、 まず最初に2倍長に変換します (これを行う方法は @pxref{Double
precision})。
@item
2倍長整数は常に符号無しであるかのように扱われます。 下記の例は、 符号付き数値を出力する方法を示しています。
@item
文字列は右から左に構築されます。 最下位桁が最初です。
@end itemize

標準 Forth は、 @code{<#} で空にして初期化し、 @code{#>}
で結果文字列を取得する単一の出力バッファー(別名ホールド領域;hold area)をサポートします。

Gforth はさらに、 このバッファーの入れ子になった使用をサポートしており、 たとえば、 ホールド領域を処理するコード内でデバッグ・トレーサー
@code{~~} からの出力を入れ子にすることができます。 @code{<<#} は新しい入れ子を開始し、  @code{#>}
は結果文字列を生成し、 @code{#>>} は入れ子を解除します。 入れ子のホールド領域が再利用され、@code{#>}
は次に外側の入れ子の文字列を生成します。  Gforth の高レベルの数値出力ワードはすべて @code{<<#} ... @code{#>}
... @code{#>>} を使用し、 ホールド領域の他のユーザー内に入れ子にできます。

@findex <# ( @var{ --   } ) core
@cindex @code{<#}
@kindex <#
@format
@code{<#} ( @i{--  }) core ``less-number-sign''
@end format
表示数値出力文字列を 初期化/クリア します(訳注: 表示数値出力用のポインタをホールド領域の末尾(初期値)に戻すだけ。 中身は消さない。)


@findex <<# ( @var{ --   } ) gforth-0.5
@cindex @code{<<#}
@kindex <<#
@format
@code{<<#} ( @i{--  }) gforth-0.5 ``less-less-number-sign''
@end format
@code{#>>} で終わるホールド領域を開始します。 相互に入れ子にすることも、 @code{<#} で入れ子にすることもできます。  注:
@code{<<#} と @code{#>>} を一致させないと、 最終的にホールド領域が不足します。 @code{<#}
を使用してホールド領域を空にリセットできます。


@findex # ( @var{ ud1 -- ud2   } ) core
@cindex @code{#}
@kindex #
@format
@code{#} ( @i{ud1 -- ud2  }) core ``number-sign''
@end format
@code{<<#} と @code{#>} の間で使用されます。  @var{ud1} の最下位桁(@code{base} による)を、
表示数値出力文字列の先頭に追加します。  @var{ud2} は @var{ud1/base}、 つまり残りの桁を表す数値です。


@findex #s ( @var{ ud -- 0 0   } ) core
@cindex @code{#s}
@kindex #s
@format
@code{#s} ( @i{ud -- 0 0  }) core ``number-sign-s''
@end format
@code{<<#} と @code{#>} の間で使用されます。  @var{ud} のすべての数字を表示数値出力文字列の先頭に追加します。
@code{#s} は少なくとも 1 つの数字を変換します。 したがって、 @var{ud} が 0 の場合、 @code{#s}
は表示数値出力文字列の先頭に `0` を追加します。


@findex hold ( @var{ char --   } ) core
@cindex @code{hold}
@kindex hold
@format
@code{hold} ( @i{char --  }) core ``hold''
@end format
@code{<<#} と @code{#>} の間で使用されます。 表示数値出力文字列の前に文字 @var{char} を追加します。


@findex holds ( @var{ addr u --   } ) core-ext
@cindex @code{holds}
@kindex holds
@format
@code{holds} ( @i{addr u --  }) core-ext ``holds''
@end format
@code{<<#} と @code{#>} の間で使用されます。 表示数値出力文字列の前に文字列 @code{addr u} を追加します。


@findex sign ( @var{ n --   } ) core
@cindex @code{sign}
@kindex sign
@format
@code{sign} ( @i{n --  }) core ``sign''
@end format
@code{<<#} と @code{#>} の間で使用されます。 @var{n} (1倍長整数) が負の場合、 表示数値出力文字列の先頭に
@code{-} を追加します。


@findex #> ( @var{ xd -- addr u   } ) core
@cindex @code{#>}
@kindex #>
@format
@code{#>} ( @i{xd -- addr u  }) core ``number-sign-greater''
@end format
変換対象(変換残りの)数値 @var{xd} を破棄し、 フォーマットされた文字列のアドレスと長さを示す @var{addr u} を返すことで、
表示数値出力文字列を完成させます。 標準のプログラムでは、 文字列内の文字を変更する場合があります。  ホールド領域は解放されません。
@code{#>>} を使用して @code{<<#} で始まるホールド領域を解放するか、 @code{<#}
を使用してすべてのホールド領域を解放します。


@findex #>> ( @var{ --   } ) gforth-0.5
@cindex @code{#>>}
@kindex #>>
@format
@code{#>>} ( @i{--  }) gforth-0.5 ``number-sign-greater-greater''
@end format
@code{<<#} で始まるホールド領域を解放します。



@noindent
以下に、 表示数値出力の使用例をいくつか示します:

@example
: my-u. ( u -- )
  \ PNS(Pictured Number String)の最も単純な使用法。標準の u. のように振る舞います。
  0              \ 上記 u を 2倍長にする
  <<#            \ 変換開始
  #s             \ 全桁を変換
  #>             \ 変換終了
  TYPE SPACE     \ 表示、続けて空白1つ
  #>> ;          \ ホールド領域を開放

: cents-only ( u -- )
  0              \ 上記 u を 2倍長整数に変換
  <<#            \ 変換開始
  # #            \ 最下位と最下位からの次の 2 桁のみ変換
  #>             \ 変換完了。他の桁は破棄
  TYPE SPACE     \ 表示、続けて空白1つ
  #>> ;          \ ホールド領域を開放

: dollars-and-cents ( u -- )
  0              \ 上記 u を符号無し2倍長整数に変換
  <<#            \ 変換開始
  # #            \ 下位2桁を変換
  '.' hold       \ 小数点を打つ
  #s             \ 残りの桁を変換
  '$' hold       \ 通貨記号を打つ
  #>             \ 変換完了
  TYPE SPACE     \ 表示、続けて空白1つ
  #>> ;          \ ホールド領域を開放

: my-. ( n -- )
  \ 負数も処理する標準の . のように振る舞う
  s>d            \ 符号付き2倍長整数に変換
  swap over dabs \ 符号バイトを別途保存して数値は符号無し2倍長に
  <<#            \ 変換開始
  #s             \ 全桁を変換
  rot sign       \ 符号チェック。必要なら "-" 付加
  #>             \ 変換完了
  TYPE SPACE     \ 表示、続けて空白1つ
  #>> ;          \ ホールド領域を開放

: account. ( n -- )
  \ (会計風出力)会計士はマイナス記号が嫌いで、
  \ 負の数には括弧を使用します
  s>d            \ 符号付き2倍長整数に変換
  swap over dabs \ 符号バイトを別途保存して数値は符号無し2倍長に
  <<#            \ 変換開始
  2 pick         \ 符号バイトのコピーを得る
  0< IF ')' hold THEN \ これが(あれば)出力の右端の文字
  #s             \ 全桁を変換
  rot            \ 符号バイトを得る
  0< IF '(' hold THEN
  #>             \ 変換完了
  TYPE SPACE     \ 表示、続けて空白1つ
  #>> ;          \ ホールド領域を開放

@end example

これらのワードの利用例をいくつか示します:

@example
1 my-u. 1  ok
hex -1 my-u. decimal FFFFFFFFFFFFFFFF  ok
1 cents-only 01  ok
1234 cents-only 34  ok
2 dollars-and-cents  $0.02  ok
1234 dollars-and-cents  $12.34  ok
123 my-. 123  ok
-123 my-. -123  ok
123 account. 123  ok
-456 account. (456)  ok

@end example

@node Floating-point output, Miscellaneous output, Formatted numeric output, Other I/O
@subsection Floating-point output
@cindex numeric output, FP
@cindex FP output
@cindex floating-point output

浮動小数点数出力は常に基数 10 を使用して表示されます。

@findex f. ( @var{ r --   } ) floating-ext
@cindex @code{f.}
@kindex f.
@format
@code{f.} ( @i{r --  }) floating-ext ``f-dot''
@end format
(浮動小数点数) @i{r} を指数なしで表示し、 その後に空白1つ続けます。


@findex fe. ( @var{ r --   } ) floating-ext
@cindex @code{fe.}
@kindex fe.
@format
@code{fe.} ( @i{r --  }) floating-ext ``f-e-dot''
@end format
@i{r} を工学表記(3 で割り切れる指数) で表示し、 その後に空白1つ続けます。


@findex fs. ( @var{ r --   } ) floating-ext
@cindex @code{fs.}
@kindex fs.
@format
@code{fs.} ( @i{r --  }) floating-ext ``f-s-dot''
@end format
@i{r} を科学表記(指数付き)で表示し、 その後に空白1つ続けます。


@findex fp. ( @var{ r --   } ) floating-ext
@cindex @code{fp.}
@kindex fp.
@format
@code{fp.} ( @i{r --  }) floating-ext ``f-p-dot''
@end format
@i{r} を SI 接頭辞表記(3 で割れる指数を使用し、 可能な場合は SI 接頭辞に変換)で表示し、 その後に空白1つ続けます。



数値 1234.5678E23 をさまざまな浮動小数点数出力形式で出力する例を以下に示します。

@example
1234.5678E23 f. 123456780000000000000000000.  ok
1234.5678E23 fe. 123.456780000000E24  ok
1234.5678E23 fs. 1.23456780000000E26  ok
1234.5678E23 fp. 123.456780000000Y  ok
@end example

出力桁幅は以下の影響を受けます:

@findex precision ( @var{ -- u   } ) floating-ext
@cindex @code{precision}
@kindex precision
@format
@code{precision} ( @i{-- u  }) floating-ext ``precision''
@end format
@i{u} は、 @code{f.} や @code{fe.} や @code{fs.} や @code{fp.} で現在使用されている有効桁数です。 


@findex set-precision ( @var{ u --   } ) floating-ext
@cindex @code{set-precision}
@kindex set-precision
@format
@code{set-precision} ( @i{u --  }) floating-ext ``set-precision''
@end format
@code{f.} や @code{fe.} や @code{fs.} や @code{fp.} で現在使用されている有効桁数を @i{u}
に設定します。



以下のコマンドを使用して、 出力をより詳細に制御できます:

@findex f.rdp ( @var{ rf +nr +nd +np --   } ) gforth-0.6
@cindex @code{f.rdp}
@kindex f.rdp
@format
@code{f.rdp} ( @i{rf +nr +nd +np --  }) gforth-0.6 ``f.rdp''
@end format
浮動小数点数 @i{rf} を書式化して表示します。 出力の合計幅は @i{nr} です。  固定小数点表記の場合、 小数点以下の桁数は
@i{+nd}、 有効桁数の最小値は @i{np} です。  @code{Set-precision} は @code{f.rdp} には影響しません。
固定小数点表記は、 有効桁数が少なくとも @i{np} の場合で、 かつ、 小数点以下の桁数が収まる場合に、 使用されます。
固定小数点表記が使用されない場合は指数表記が使用され、 それでも適合しない場合はアスタリスクが出力されます。
数値がまったく適合しないリスクを避けるために、 @i{nr}>=7 を使用することをお勧めします。 @code{f.rdp}
が指数表記に切り替わるケースを避けるために、 @i{nr}>=@i{np}+5 をお勧めします。 どうしてかというと、
固定小数点表記でも有効桁数が少なすぎるのに、 指数表記では有効桁数が更に少なくなるためです。 一部の数値を固定小数点表記しなければならない場合は、
@i{nr}>=@i{nd}+2 をお勧めします。 @i{np} の値が小さいほど、 より多くの場合で固定小数点表記で表示されます
(固定小数点表記に有効数字がほとんどまたはまったく残っていない場合)。  すべての数値を指数表記したい場合は、@i{np}>@i{nr}
をお勧めします。



出力にどのような影響を与えるかをより直感的に理解できるように、 パラメーターの組み合わせの例をいくつか示します。 各行内は同じ数値が出力されていて、
各列には同じパラメータの組み合わせが出力に使用されています:

@example
    12 13 0    7 3 4   7 3 0   7 3 1   7 5 1   7 7 1   7 0 2  4 2 1
|-1.234568E-6|-1.2E-6| -0.000|-1.2E-6|-1.2E-6|-1.2E-6|-1.2E-6|****|
|-1.234568E-5|-1.2E-5| -0.000|-1.2E-5|-.00001|-1.2E-5|-1.2E-5|****|
|-1.234568E-4|-1.2E-4| -0.000|-1.2E-4|-.00012|-1.2E-4|-1.2E-4|****|
|-1.234568E-3|-1.2E-3| -0.001| -0.001|-.00123|-1.2E-3|-1.2E-3|****|
|-1.234568E-2|-1.2E-2| -0.012| -0.012|-.01235|-1.2E-2|-1.2E-2|-.01|
|-1.234568E-1|-1.2E-1| -0.123| -0.123|-.12346|-1.2E-1|-1.2E-1|-.12|
|-1.2345679E0| -1.235| -1.235| -1.235|-1.23E0|-1.23E0|-1.23E0|-1E0|
|-1.2345679E1|-12.346|-12.346|-12.346|-1.23E1|-1.23E1|   -12.|-1E1|
|-1.2345679E2|-1.23E2|-1.23E2|-1.23E2|-1.23E2|-1.23E2|  -123.|-1E2|
|-1.2345679E3|-1.23E3|-1.23E3|-1.23E3|-1.23E3|-1.23E3| -1235.|-1E3|
|-1.2345679E4|-1.23E4|-1.23E4|-1.23E4|-1.23E4|-1.23E4|-12346.|-1E4|
|-1.2345679E5|-1.23E5|-1.23E5|-1.23E5|-1.23E5|-1.23E5|-1.23E5|-1E5|
@end example

以下を使用して、 数値を表示する代わりに文字列を生成できます:

@findex f>str-rdp ( @var{ rf +nr +nd +np -- c-addr nr   } ) gforth-0.6
@cindex @code{f>str-rdp}
@kindex f>str-rdp
@format
@code{f>str-rdp} ( @i{rf +nr +nd +np -- c-addr nr  }) gforth-0.6 ``f>str-rdp''
@end format
@i{rf} を @i{c-addr nr} の文字列に変換します。  @i{nr +nd np} の変換規則と意味は @code{f.rdp}
と同じです。  結果は表示数値出力(pictured numeric output)バッファーに格納され、
そのバッファを破壊するものによって破壊されます(訳注: このバッファーは、 他の 表示数値出力(pictured numeric output)
と共用であるということ)。


@findex f>buf-rdp ( @var{ rf c-addr +nr +nd +np --   } ) gforth-0.6
@cindex @code{f>buf-rdp}
@kindex f>buf-rdp
@format
@code{f>buf-rdp} ( @i{rf c-addr +nr +nd +np --  }) gforth-0.6 ``f>buf-rdp''
@end format
@i{rf} を @i{c-addr nr} の文字列に変換します。  @i{nr nd np} の変換規則と意味は @code{f.rdp}
と同じです。



以下のような、 高レベルの FP-to-string ワードを実装するために使用されるプリミティブもあります:

@findex represent ( @var{ r c-addr u -- n f1 f2  } ) floating
@cindex @code{represent}
@kindex represent
@format
@code{represent} ( @i{r c-addr u -- n f1 f2 }) floating ``represent''
@end format
@i{r} の 10 進仮数部(別名 mantissa)をバッファ @i{c-addr u} 内の文字列に変換します。 @i{n} は指数で、@i{r}
が負の場合は @i{f1} が true、 @i{r} が有効(Gforth の有限数)の場合は @i{f2} が true です(訳注: 仮数部が u
の桁数になるようそれ以下を四捨五入するっぽい)。


@node Miscellaneous output, Displaying characters and strings, Floating-point output, Other I/O
@subsection Miscellaneous output


@findex cr ( @var{ --   } ) core
@cindex @code{cr}
@kindex cr
@format
@code{cr} ( @i{--  }) core ``c-r''
@end format
(ホスト OS の好みの種類の)改行(newline)を出力します。 注意: Forth
コマンド・ライン・インタプリタの改行(newline)挿入のクセのため、 @code{cr} をテキストの先頭で使用することをお勧めします。 例:
@code{cr ." hello, world"}.


@findex space ( @var{ --   } ) core
@cindex @code{space}
@kindex space
@format
@code{space} ( @i{--  }) core ``space''
@end format
空白を1つ表示する。


@findex spaces ( @var{ u --   } ) core
@cindex @code{spaces}
@kindex spaces
@format
@code{spaces} ( @i{u --  }) core ``spaces''
@end format
@var{u} 個の空白を表示します。 


@findex out ( @var{ -- addr   } ) gforth-1.0
@cindex @code{out}
@kindex out
@format
@code{out} ( @i{-- addr  }) gforth-1.0 ``out''
@end format
@code{addr} には、 ユーザー出力デバイス上の現在行内のカーソルの位置を指定しようと試みる数値が含まれています。 @code{cr} で 0
にリセットされ、 @code{type} によって文字数ずつ増加、 @code{emit} で増加、 @code{backspaces} で減少します。
残念ながら、 タブ文字や、マルチバイト文字や、 幅 0 と 幅2 のユニコード文字の存在は考慮されていないため、 単純な場合にのみ機能します。


@findex .\" ( @var{ compilation 'ccc"' -- ; run-time --   } ) gforth-0.6
@cindex @code{.\"}
@kindex .\"
@format
@code{.\"} ( @i{compilation 'ccc"' -- ; run-time --  }) gforth-0.6 ``dot-backslash-quote''
@end format
@code{."} と似ていますが、
C言語のようなバックスラッシュによるエスケープ・シーケンス(\-escape-sequences)を認識します(詳しくは @code{S\"} 参照)。


@findex ." ( @var{ compilation 'ccc"' -- ; run-time --   } ) core
@cindex @code{."}
@kindex ."
@format
@code{."} ( @i{compilation 'ccc"' -- ; run-time --  }) core ``dot-quote''
@end format
コンパイル時: `"` (二重引用符)で区切られた文字列 @i{ccc} をパースします。 実行時、 その文字列を表示します。
このワードのインタプリタ機能(interpretation semantics)は、 標準 Forth では定義されていません。 Gforth
でのインタプリタ機能(interpretation semantics)は、 その文字列を表示することです。


@findex .( ( @var{ compilation&interpretation "ccc<paren>" --   } ) core-ext
@cindex @code{.(}
@kindex .(
@format
@code{.(} ( @i{compilation&interpretation "ccc<paren>" --  }) core-ext ``dot-paren''
@end format
コンパイル時(compilation semantics)とインタプリタ時(interpretation semantics):
@code{)}(右括弧)で区切られた文字列 @i{ccc} をパースします。 その文字列を表示します。 これは、
コンパイル中に進行状況情報を表示するためによく使用されます。 下記の例を参照してください。



あなたが @code{.( hello)} を使用するべきか @code{." hello"} を使用するべきかを気に掛けたくない場合は、
@code{"hello" type} と書くことができます。 これにより、 通常必要なものが得られます(ただし、他の Forth
システムへの移植性は低くなります)。

@noindent
例として、 ファイル @file{test.fs} に保存されている以下のテキストについて考えてみましょう:

@example
.( text-1)
: my-word
  ." text-2" cr
  .( text-3)
  "text-4" type
;

." text-5"
"text-6" type
@end example

このコードを Gforth にロードすると、 以下の出力が生成されます:

@example
@kbd{include test.fs @key{RET}} text-1text-3text-5text-6 ok
@end example

@itemize @bullet
@item
@code{.(} は即実行ワードであるため、 メッセージ @code{text-1} と @code{text-3} が表示されます。
コロン定義の内側でも外側でも、 全く同じに振る舞います。
@item
@code{."} に対する Gforth の追加インタプリタ機能(interpretation semantics)により、 メッセージ
@code{text-5} が表示されます。
@item
@code{"text-6" type} が通訳(interpret)され、 メッセージ @code{text-6} が表示されます。
@item
テキスト・インタプリタが @code{my-word} の定義内で @code{."} のコンパイル機能(compilation
semantics)を実行するため、 メッセージ @code{text-2} は「表示されません」。
@item
@code{"text-4" type} は @code{my-word} 内にコンパイルされるため、 メッセージ @code{text-4}
は「表示されません」。
@end itemize


@node Displaying characters and strings, Terminal output, Miscellaneous output, Other I/O
@subsection Displaying characters and strings
@cindex characters - displaying
@cindex character strings - displaying

@findex type ( @var{ c-addr u --   } ) core
@cindex @code{type}
@kindex type
@format
@code{type} ( @i{c-addr u --  }) core ``type''
@end format
@var{u}>0 なら、 @var{c-addr} からに格納されている文字列から @var{u} 文字を表示します(訳注:
日本語(UTF-8)の出力も対応)。


@findex xemit ( @var{ xc --   } ) xchar
@cindex @code{xemit}
@kindex xemit
@format
@code{xemit} ( @i{xc --  }) xchar ``x-emit''
@end format
端末に xchar を出力します。


@findex emit ( @var{ c --   } ) core
@cindex @code{emit}
@kindex emit
@format
@code{emit} ( @i{c --  }) core ``emit''
@end format
バイト値 @i{c} を現在の出力に送信します。 ASCII 文字の場合、 @code{emit} は @code{xemit} と同等です。


@findex typewhite ( @var{ addr n --   } ) gforth-0.2
@cindex @code{typewhite}
@kindex typewhite
@format
@code{typewhite} ( @i{addr n --  }) gforth-0.2 ``typewhite''
@end format
type と似ていますが、 文字の代わりに空白が表示されます(訳注: 指定の文字数 @i{n}
だけ空白出すだけなので日本語(UTF-8)だと表示幅がズレる)。




@node Terminal output, Single-key input, Displaying characters and strings, Other I/O
@subsection Terminal output
@cindex output to terminal
@cindex terminal output

端末に出力している場合、 カーソル位置を制御することができます:
@cindex cursor positioning

@findex at-xy ( @var{ x y --   } ) facility
@cindex @code{at-xy}
@kindex at-xy
@format
@code{at-xy} ( @i{x y --  }) facility ``at-x-y''
@end format
カーソルを位置 @i{x y} に置きます。  ディスプレイの左上角は 0 0 です。


@findex at-deltaxy ( @var{ dx dy --   } ) gforth-0.7
@cindex @code{at-deltaxy}
@kindex at-deltaxy
@format
@code{at-deltaxy} ( @i{dx dy --  }) gforth-0.7 ``at-deltaxy''
@end format
現在の位置を @i{x y} として、 カーソルを @i{x+dx y+dy} に置きます。



カーソルをどこに置くかを知るには、 以下のように、 画面(screen)のサイズを知っておくと役立つことがよくあります:
@cindex terminal size

@findex form ( @var{ -- nlines ncols   } ) gforth-0.2
@cindex @code{form}
@kindex form
@format
@code{form} ( @i{-- nlines ncols  }) gforth-0.2 ``form''
\ 訳注:画面のサイズを得る
@end format


また、 以下のようなものを使用したい場合もあります:
@cindex clear screen

@findex page ( @var{ --   } ) facility
@cindex @code{page}
@kindex page
@format
@code{page} ( @i{--  }) facility ``page''
@end format
画面(screen)をクリアする



注意: ターミナル以外では、フォーム・フィード(form feed;FF)を取得するには @code{page} ではなく @code{12 Emit}
を使用する必要があることに注意してください。

@subsubsection Color output
以下のワード群は、 意味・理由ごとに色を変えるために使用されます。 更に細かい設定は、 ワードによって指定された色とスタイルで生成されます。
実際の色とスタイルはテーマによって異なります(下記を参照)。

@findex default-color ( @var{ --   } ) gforth-1.0
@cindex @code{default-color}
@kindex default-color
@format
@code{default-color} ( @i{--  }) gforth-1.0 ``default-color''
@end format
システムのデフォルト用の色


@findex error-color ( @var{ --   } ) gforth-1.0
@cindex @code{error-color}
@kindex error-color
@format
@code{error-color} ( @i{--  }) gforth-1.0 ``error-color''
@end format
エラー用の色: (通常は)赤


@findex error-hl-inv ( @var{ --   } ) gforth-1.0
@cindex @code{error-hl-inv}
@kindex error-hl-inv
@format
@code{error-hl-inv} ( @i{--  }) gforth-1.0 ``error-hl-inv''
@end format
エラー用にハイライトとして反転表示するカラーモード


@findex error-hl-ul ( @var{ --   } ) gforth-1.0
@cindex @code{error-hl-ul}
@kindex error-hl-ul
@format
@code{error-hl-ul} ( @i{--  }) gforth-1.0 ``error-hl-ul''
@end format
エラー用にアンダーラインでハイライトする色変更モード


@findex warning-color ( @var{ --   } ) gforth-1.0
@cindex @code{warning-color}
@kindex warning-color
@format
@code{warning-color} ( @i{--  }) gforth-1.0 ``warning-color''
@end format
警告(warning)の色: 背景が黒の端末では 青/黄


@findex info-color ( @var{ --   } ) gforth-1.0
@cindex @code{info-color}
@kindex info-color
@format
@code{info-color} ( @i{--  }) gforth-1.0 ``info-color''
@end format
情報(info)用の色: 黒色の背景の端末では 緑/シアン 


@findex success-color ( @var{ --   } ) gforth-1.0
@cindex @code{success-color}
@kindex success-color
@format
@code{success-color} ( @i{--  }) gforth-1.0 ``success-color''
@end format
成功(success)の色: 緑


@findex input-color ( @var{ --   } ) gforth-1.0
@cindex @code{input-color}
@kindex input-color
@format
@code{input-color} ( @i{--  }) gforth-1.0 ``input-color''
@end format
ユーザー入力の色: 黒/白 (両方ともボールド)


@findex status-color ( @var{ --   } ) gforth-1.0
@cindex @code{status-color}
@kindex status-color
@format
@code{status-color} ( @i{--  }) gforth-1.0 ``status-color''
@end format
エラー用にハイライトとして反転表示するカラーモード


@c !! Commented out, because it makes no sense to document attr! without
@c    documenting how to produce an attr
@c doc-attr!

@subsubsection Color themes
あなたが、 明るい背景を好むか暗い背景を好むかに応じて、 前景の色テーマ(foreground colors-theme)を以下のように変更できます:

@findex light-mode ( @var{ --   } ) gforth-1.0
@cindex @code{light-mode}
@kindex light-mode
@format
@code{light-mode} ( @i{--  }) gforth-1.0 ``light-mode''
@end format
白背景用の色テーマ


@findex dark-mode ( @var{ --   } ) gforth-1.0
@cindex @code{dark-mode}
@kindex dark-mode
@format
@code{dark-mode} ( @i{--  }) gforth-1.0 ``dark-mode''
@end format
黒背景用の色テーマ


@findex uncolored-mode ( @var{ --   } ) gforth-1.0
@cindex @code{uncolored-mode}
@kindex uncolored-mode
@format
@code{uncolored-mode} ( @i{--  }) gforth-1.0 ``uncolored-mode''
@end format
このモードでは色は設定されませんが、 デフォルトの色が使用されます。


@findex magenta-input ( @var{ --   } ) gforth-1.0
@cindex @code{magenta-input}
@kindex magenta-input
@format
@code{magenta-input} ( @i{--  }) gforth-1.0 ``magenta-input''
@end format
入力色(input color)を認識しやすくします(プレゼンテーションに役立ちます)



@node Single-key input, Line input and conversion, Terminal output, Other I/O
@subsection Single-key input
@cindex single-key input
@cindex input, single-key

単一の印刷可能な文字を取得したい場合は、 @code{key} を使用できます。 文字が @code{key} に使用できるかどうかを確認するには、
@code{key?} を使用できます。

@findex key ( @var{ -- char   } ) core
@cindex @code{key}
@kindex key
@format
@code{key} ( @i{-- char  }) core ``key''
@end format
1 文字 @var{char} を受け取ります(ただし表示はされません)。


@findex key-ior ( @var{ -- char|ior   } ) gforth-1.0
@cindex @code{key-ior}
@kindex key-ior
@format
@code{key-ior} ( @i{-- char|ior  }) gforth-1.0 ``key-ior''
@end format
1 文字 @var{char} を受け取ります (ただし表示はされません)。 エラーまたは割り込みの場合は、 代わりに、 負数の @var{ior}
を返します。


@findex key? ( @var{ -- flag   } ) facility
@cindex @code{key?}
@kindex key?
@format
@code{key?} ( @i{-- flag  }) facility ``key-question''
@end format
文字が @code{key} で使用可能かどうかを判断します。 文字が使用可能な場合、@var{flag} は true です。 次に
@code{key} を呼び出すと、 文字が生成されます。 一度 @code{key?} が true を返すと、 その後に @code{key}
または @code{ekey} を呼び出す前に @code{key?} を呼び出した場合も true が返されます。


@findex xkey? ( @var{ -- flag   } ) xchar
@cindex @code{xkey?}
@kindex xkey?
@format
@code{xkey?} ( @i{-- flag  }) xchar ``x-key-query''
\ 訳注: UTF-8 な環境では key? は xkey? のエイリアスです。
\ xchar 文字が xkey で使用可能かどうかを判断します(たぶん) 
@end format


印刷可能な文字と印刷不可能な文字を組み合わせて処理したい場合は、@code{ekey} とそのファミリーを使用して実行できます。
@code{ekey} は、 @code{ekey>char} で文字に変換するか、 @code{ekey>fkey}
でキー識別子に変換する必要があるキーボード・イベントを生成します。

ekey を使用するための一般的なコードは以下のようになります:

@example
ekey ekey>xchar if ( xc )
  ... \ do something with the character
else ekey>fkey if ( key-id )
  case
    k-up                                  of ... endof
    k-f1                                  of ... endof
    k-left k-shift-mask or k-ctrl-mask or of ... endof
    ...
  endcase
else ( keyboard-event )
  drop \ just ignore an unknown keyboard event type
then then
@end example

@findex ekey ( @var{ -- u   } ) facility-ext
@cindex @code{ekey}
@kindex ekey
@format
@code{ekey} ( @i{-- u  }) facility-ext ``e-key''
@end format
キーボード・イベント @var{u} を受け取りす(実装定義のエンコーディングです) 。


@findex ekey>xchar ( @var{ u -- u false | xc true   } ) xchar-ext
@cindex @code{ekey>xchar}
@kindex ekey>xchar
@format
@code{ekey>xchar} ( @i{u -- u false | xc true  }) xchar-ext ``e-key-to-x-char''
@end format
可能であれば、 キーボード・イベント @var{u} を xchar @code{xc} に変換します。


@findex ekey>char ( @var{ u -- u false | c true   } ) facility-ext
@cindex @code{ekey>char}
@kindex ekey>char
@format
@code{ekey>char} ( @i{u -- u false | c true  }) facility-ext ``e-key-to-char''
@end format
可能であれば、 キーボード・イベント @var{u} を文字 @code{c} に変換します。  注意: 非 ASCII 文字は、
@code{ekey>char} と @code{ekey>fkey} の両方から @code{false} が返ることに注意してください。
利用可能な場合は、 @code{ekey>char} の代わりに @code{ekey>xchar} を使用します。


@findex ekey>fkey ( @var{ u1 -- u2 f   } ) facility-ext
@cindex @code{ekey>fkey}
@kindex ekey>fkey
@format
@code{ekey>fkey} ( @i{u1 -- u2 f  }) facility-ext ``e-key-to-f-key''
@end format
u1 が特殊キー(special key)セット内のキーボード・イベントの場合、 キーボード・イベント @var{u1} をキー ID @var{u2}
に変換し、 true を返します。それ以外の場合は、 @var{u1} と false を返します。


@findex ekey? ( @var{ -- flag   } ) facility-ext
@cindex @code{ekey?}
@kindex ekey?
@format
@code{ekey?} ( @i{-- flag  }) facility-ext ``e-key-question''
@end format
キーボード・イベントが利用可能な場合は True。



カーソル・キーのキー識別子は以下のとおりです:

@findex k-left ( @var{ -- u   } ) facility-ext
@cindex @code{k-left}
@kindex k-left
@format
@code{k-left} ( @i{-- u  }) facility-ext ``k-left''
@end format

@findex k-right ( @var{ -- u   } ) facility-ext
@cindex @code{k-right}
@kindex k-right
@format
@code{k-right} ( @i{-- u  }) facility-ext ``k-right''
@end format

@findex k-up ( @var{ -- u   } ) facility-ext
@cindex @code{k-up}
@kindex k-up
@format
@code{k-up} ( @i{-- u  }) facility-ext ``k-up''
@end format

@findex k-down ( @var{ -- u   } ) facility-ext
@cindex @code{k-down}
@kindex k-down
@format
@code{k-down} ( @i{-- u  }) facility-ext ``k-down''
@end format

@findex k-home ( @var{ -- u   } ) facility-ext
@cindex @code{k-home}
@kindex k-home
@format
@code{k-home} ( @i{-- u  }) facility-ext ``k-home''
@end format
別名 Pos1


@findex k-end ( @var{ -- u   } ) facility-ext
@cindex @code{k-end}
@kindex k-end
@format
@code{k-end} ( @i{-- u  }) facility-ext ``k-end''
@end format

@findex k-prior ( @var{ -- u   } ) facility-ext
@cindex @code{k-prior}
@kindex k-prior
@format
@code{k-prior} ( @i{-- u  }) facility-ext ``k-prior''
@end format
別名 PgUp


@findex k-next ( @var{ -- u   } ) facility-ext
@cindex @code{k-next}
@kindex k-next
@format
@code{k-next} ( @i{-- u  }) facility-ext ``k-next''
@end format
別名 PgDn    


@findex k-insert ( @var{ -- u   } ) facility-ext
@cindex @code{k-insert}
@kindex k-insert
@format
@code{k-insert} ( @i{-- u  }) facility-ext ``k-insert''
@end format

@findex k-delete ( @var{ -- u   } ) facility-ext
@cindex @code{k-delete}
@kindex k-delete
@format
@code{k-delete} ( @i{-- u  }) facility-ext ``k-delete''
@end format
著者の xterm 上では@key{DEL} キーで、 Backspace ではありません



ファンクション・キー(別名キーパッド・キー)のキー識別子は以下のとおりです:

@findex k-f1 ( @var{ -- u   } ) facility-ext
@cindex @code{k-f1}
@kindex k-f1
@format
@code{k-f1} ( @i{-- u  }) facility-ext ``k-f-1''
@end format

@findex k-f2 ( @var{ -- u   } ) facility-ext
@cindex @code{k-f2}
@kindex k-f2
@format
@code{k-f2} ( @i{-- u  }) facility-ext ``k-f-2''
@end format

@findex k-f3 ( @var{ -- u   } ) facility-ext
@cindex @code{k-f3}
@kindex k-f3
@format
@code{k-f3} ( @i{-- u  }) facility-ext ``k-f-3''
@end format

@findex k-f4 ( @var{ -- u   } ) facility-ext
@cindex @code{k-f4}
@kindex k-f4
@format
@code{k-f4} ( @i{-- u  }) facility-ext ``k-f-4''
@end format

@findex k-f5 ( @var{ -- u   } ) facility-ext
@cindex @code{k-f5}
@kindex k-f5
@format
@code{k-f5} ( @i{-- u  }) facility-ext ``k-f-5''
@end format

@findex k-f6 ( @var{ -- u   } ) facility-ext
@cindex @code{k-f6}
@kindex k-f6
@format
@code{k-f6} ( @i{-- u  }) facility-ext ``k-f-6''
@end format

@findex k-f7 ( @var{ -- u   } ) facility-ext
@cindex @code{k-f7}
@kindex k-f7
@format
@code{k-f7} ( @i{-- u  }) facility-ext ``k-f-7''
@end format

@findex k-f8 ( @var{ -- u   } ) facility-ext
@cindex @code{k-f8}
@kindex k-f8
@format
@code{k-f8} ( @i{-- u  }) facility-ext ``k-f-8''
@end format

@findex k-f9 ( @var{ -- u   } ) facility-ext
@cindex @code{k-f9}
@kindex k-f9
@format
@code{k-f9} ( @i{-- u  }) facility-ext ``k-f-9''
@end format

@findex k-f10 ( @var{ -- u   } ) facility-ext
@cindex @code{k-f10}
@kindex k-f10
@format
@code{k-f10} ( @i{-- u  }) facility-ext ``k-f-10''
@end format

@findex k-f11 ( @var{ -- u   } ) facility-ext
@cindex @code{k-f11}
@kindex k-f11
@format
@code{k-f11} ( @i{-- u  }) facility-ext ``k-f-11''
@end format

@findex k-f12 ( @var{ -- u   } ) facility-ext
@cindex @code{k-f12}
@kindex k-f12
@format
@code{k-f12} ( @i{-- u  }) facility-ext ``k-f-12''
@end format


@code{k-f11} と @code{k-f12} はそれほど広くには利用可能ではないことに注意してください。

これらのキー識別子をさまざまなシフト・キーのマスクと組み合わせることができます:

@findex k-shift-mask ( @var{ -- u   } ) facility-ext
@cindex @code{k-shift-mask}
@kindex k-shift-mask
@format
@code{k-shift-mask} ( @i{-- u  }) facility-ext ``k-shift-mask''
@end format

@findex k-ctrl-mask ( @var{ -- u   } ) facility-ext
@cindex @code{k-ctrl-mask}
@kindex k-ctrl-mask
@format
@code{k-ctrl-mask} ( @i{-- u  }) facility-ext ``k-ctrl-mask''
@end format

@findex k-alt-mask ( @var{ -- u   } ) facility-ext
@cindex @code{k-alt-mask}
@kindex k-alt-mask
@format
@code{k-alt-mask} ( @i{-- u  }) facility-ext ``k-alt-mask''
@end format


ASCII 値を持つキーが多数あるため、 特殊キーとして報告される可能性は低いですが、
以下のキーとシフト・キーの組み合わせは特殊キーとして報告される可能性があります:

@findex k-enter ( @var{ -- u   } ) gforth-1.0
@cindex @code{k-enter}
@kindex k-enter
@format
@code{k-enter} ( @i{-- u  }) gforth-1.0 ``k-enter''
@end format

@findex k-backspace ( @var{ -- u   } ) gforth-1.0
@cindex @code{k-backspace}
@kindex k-backspace
@format
@code{k-backspace} ( @i{-- u  }) gforth-1.0 ``k-backspace''
@end format

@findex k-tab ( @var{ -- u   } ) gforth-1.0
@cindex @code{k-tab}
@kindex k-tab
@format
@code{k-tab} ( @i{-- u  }) gforth-1.0 ``k-tab''
@end format


さらに、 キーおよびその他のイベントには以下のキー・コードがあります:

@findex k-winch ( @var{ -- u   } ) gforth-1.0
@cindex @code{k-winch}
@kindex k-winch
@format
@code{k-winch} ( @i{-- u  }) gforth-1.0 ``k-winch''
@end format
ユーザーがウィンドウ・サイズを変更したときに生成される可能性のあるキー・コード。


@findex k-pause ( @var{ -- u   } ) gforth-1.0
@cindex @code{k-pause}
@kindex k-pause
@format
@code{k-pause} ( @i{-- u  }) gforth-1.0 ``k-pause''
@end format

@findex k-mute ( @var{ -- u   } ) gforth-1.0
@cindex @code{k-mute}
@kindex k-mute
@format
@code{k-mute} ( @i{-- u  }) gforth-1.0 ``k-mute''
@end format

@findex k-volup ( @var{ -- u   } ) gforth-1.0
@cindex @code{k-volup}
@kindex k-volup
@format
@code{k-volup} ( @i{-- u  }) gforth-1.0 ``k-volup''
@end format

@findex k-voldown ( @var{ -- u   } ) gforth-1.0
@cindex @code{k-voldown}
@kindex k-voldown
@format
@code{k-voldown} ( @i{-- u  }) gforth-1.0 ``k-voldown''
@end format

@findex k-sel ( @var{ -- u   } ) gforth-1.0
@cindex @code{k-sel}
@kindex k-sel
@format
@code{k-sel} ( @i{-- u  }) gforth-1.0 ``k-sel''
@end format
Androidでの選択(selections)のキー・コード


@findex k-eof ( @var{ -- u   } ) gforth-1.0
@cindex @code{k-eof}
@kindex k-eof
@format
@code{k-eof} ( @i{-- u  }) gforth-1.0 ``k-eof''
@end format


注意: Forth システムに @code{ekey>fkey} とキー識別子のワードがある場合でも、 そのキーが必ずしも利用可能であるとは限らず、
すべてのキーとシフト・マスクとの可能なすべての組み合わせを報告できるとは限らないことに注意してください。
したがって、キーやキーの組み合わせが押せない場合や認識されない場合でも、プログラムが使えるようにプログラムを作成してください。

例: 古いキーボードには F11 キーと F12 キーがないことがよくあります。  xterm で Gforth を実行すると、xterm
は多数の組み合わせ(例: @key{Shift-Up})を捕捉しますが、それを Gforth に渡すことはありません。  最後に、Gforth は現在、
複数のシフト・キーの組み合わせを認識して報告しません(そのため、上記の例の @key{shift-ctrl-left}
のケースは決して入力されません)。

Gforth は、ANSI 端末で利用可能なさまざまなキーを認識します(MS-DOS では、 その動作を実現するには ANSI.SYS
ドライバーが必要です)。 これは、 そのようなキーが押されたときに ANSI 端末が送信するエスケープ・シーケンスを認識することによって機能します。
他のエスケープ・シーケンスを送信する端末を使用している場合、 Gforth では有益な結果は得られません。  他の Forth
システムは異なる方法で動作する可能性があります。

Gforth には、 ファンクション・キーの名前を出力するためのいくつかのワードも用意されています:

@findex fkey. ( @var{ u --   } ) gforth-1.0
@cindex @code{fkey.}
@kindex fkey.
@format
@code{fkey.} ( @i{u --  }) gforth-1.0 ``fkey-dot''
@end format
ファンクション・キー @i{u} の文字列表現を出力します。  @i{U} はファンクション・キー(おそらく修飾子マスク付き)でなければなりません。
そうでない場合は例外が発生する可能性があります。


@findex simple-fkey-string ( @var{ u1 -- c-addr u   } ) gforth-1.0
@cindex @code{simple-fkey-string}
@kindex simple-fkey-string
@format
@code{simple-fkey-string} ( @i{u1 -- c-addr u  }) gforth-1.0 ``simple-fkey-string''
@end format
@i{c-addr u} は、ファンクション・キー @i{u1} の文字列名です。 修飾子マスクのない単純なファンクション・キーに対してのみ機能します。
現在、 単純なファンクション・キーでない @i{u1} では例外を生成します。




@node Line input and conversion, Pipes, Single-key input, Other I/O
@subsection Line input and conversion
@cindex line input from terminal
@cindex input, linewise from terminal
@cindex convertin strings to numbers
@cindex I/O - see input

文字列をメモリに保存する方法については、 @ref{String representations} を参照してください。

@comment TODO examples for >number >float accept key key? pad parse word refill
@comment then index them

キーボードから一行入力するためのワード群:

@findex accept ( @var{ c-addr +n1 -- +n2   } ) core
@cindex @code{accept}
@kindex accept
@format
@code{accept} ( @i{c-addr +n1 -- +n2  }) core ``accept''
@end format
ユーザー入力デバイスから最大 @var{n1} 文字の文字列を取得し、 @var{c-addr} に保存します。  @var{n2}
は受け取った文字列の長さです。 ユーザーは @key{RET} を押して終了を指示します。  Gforth は、 @code{accept} で、
Forth コマンド・ラインで利用できるすべての編集機能(履歴やワード補完を含む)をサポートしています。


@findex edit-line ( @var{ c-addr n1 n2 -- n3   } ) gforth-0.6
@cindex @code{edit-line}
@kindex edit-line
@format
@code{edit-line} ( @i{c-addr n1 n2 -- n3  }) gforth-0.6 ``edit-line''
@end format
@code{accept} のように振る舞いますが、バッファ @var{c-addr n1} の内容を先頭から長さ @i{n2} まで引用します(
@i{n2}=0 の場合、 全く引用せず、 空の状態から入力編集開始になります)。 受け取った文字列の長さを @i{n3} に返します。



変換ワード群:

@findex s>number? ( @var{ addr u -- d f   } ) gforth-0.5
@cindex @code{s>number?}
@kindex s>number?
@format
@code{s>number?} ( @i{addr u -- d f  }) gforth-0.5 ``s>number?''
@end format
文字列 @i{addr u} を 符号付き2倍長整数 @i{d} に変換し、 フラグ @i{f} が true ならば成功、 false
ならば変換失敗です( @i{d} の値は保証されません) (訳注: フラグが true の場合でも @code{-15.}
基数プレフィックスを付けずに記述した場合、 警告が出力されます。 警告が出ないようにするには基数プレフィックスを付けて下さい @code{#-15.})


@findex s>unumber? ( @var{ c-addr u -- ud flag   } ) gforth-0.5
@cindex @code{s>unumber?}
@kindex s>unumber?
@format
@code{s>unumber?} ( @i{c-addr u -- ud flag  }) gforth-0.5 ``s>unumber?''
@end format
文字列 @i{c-addr u} を 符号なし2倍長整数 @i{ud} に変換します。 フラグ @i{f} が true ならば成功、 false
ならば変換失敗です( @i{d} の値は保証されません)。 (訳注: フラグが true の場合でも @code{15.}
基数プレフィックスを付けずに記述した場合、 警告が出力されます。 警告が出ないようにするには基数プレフィックスを付けて下さい @code{#15.} 、
注意: 負数も受け付けます; "#-15." s>unumber? .s <3> -15 -1 -1  ok  drop -15 -1
ud. 340282366920938463463374607431768211441  ok
"#340282366920938463463374607431768211441." s>unumber? .s <3> -15 -1 -1 ok 3
)


@findex >number ( @var{ ud1 c-addr1 u1 -- ud2 c-addr2 u2   } ) core
@cindex @code{>number}
@kindex >number
@format
@code{>number} ( @i{ud1 c-addr1 u1 -- ud2 c-addr2 u2  }) core ``to-number''
@end format
文字列 @var{c-addr1 u1} を現在の基数で符号なし2倍長整数に変換しようと試みます。 符号なし2倍長整数 @var{ud1}
に変換結果を積算して @var{ud2} にします。 変換は、 文字列全体が変換されるか、 現在の基数で変換できない文字( `+` または `-`
を含む)が検出されるまで、 左から右に続行されます。 変換可能な各文字ごとに、 @var{ud1} * @code{base} してから、
次にその文字によって表される値を足しこみます( new ud1 = ud1 * base + digit )。  @var{c-addr2} は、
最初の未変換文字の位置です(文字列全体が変換された場合は文字列の末尾以降)。  @var{u2} は、 文字列内の未変換の文字の数です。
最後まで変換出来たときは 0 です。 オーバーフローは検出されません。


@findex >float ( @var{ c-addr u -- f:... flag  } ) floating
@cindex @code{>float}
@kindex >float
@format
@code{>float} ( @i{c-addr u -- f:... flag }) floating ``to-float''
@end format
実際のスタック効果: ( c_addr u -- r t | f )。  文字列 @i{c-addr u} を内部浮動小数点表現に変換しようとします。
文字列が有効な浮動小数点数を表す場合、 @i{r} が浮動小数点スタックに配置され、 @i{flag} が true になります。
それ以外の場合、@i{flag} は false になります(訳注: この場合、 浮動小数点数スタックには何も積まれない)。
空白の文字列は特殊なケースであり、 浮動小数点数 0 を表します。

@findex >float1 ( @var{ c-addr u c -- f:... flag  } ) gforth-1.0
@cindex @code{>float1}
@kindex >float1
@format
@code{>float1} ( @i{c-addr u c -- f:... flag }) gforth-1.0 ``to-float1''
@end format
実際のスタック効果: ( c_addr u c -- r t | f )  @i{c} を小数点として使用して(訳注: '.'
が小数点とは限らない。ロケールにより異なるため、指定できるようになっている)、 文字列 @i{c-addr u}
を内部浮動小数点表現に変換しようと試みます。  文字列が有効な浮動小数点数を表す場合、 @i{r} が浮動小数点スタックに配置され、 @i{flag}
が true になります。 それ以外の場合、@i{flag} は false になります(この場合、浮動小数点数スタックには何も積まれません)。
空白の文字列は特殊なケースであり、浮動小数点数 0 を表します。


@comment obsolescent words..
時代遅れ(OBSOLESCENT)の入力ワード群と変換ワード群:

@findex convert ( @var{ ud1 c-addr1 -- ud2 c-addr2   } ) core-ext-obsolescent
@cindex @code{convert}
@kindex convert
@format
@code{convert} ( @i{ud1 c-addr1 -- ud2 c-addr2  }) core-ext-obsolescent ``convert''
@end format
時代遅れ(OBSOLESCENT): @code{>number} に置き換えられました。


@findex expect ( @var{ c-addr +n --   } ) core-ext-obsolescent
@cindex @code{expect}
@kindex expect
@format
@code{expect} ( @i{c-addr +n --  }) core-ext-obsolescent ``expect''
@end format
最大 @i{+n} 文字の文字列を受け取り、@i{c-addr} から始まるメモリに保存します。 文字列は表示されます。
<return>キーを押すか、 @i{+n} 文字を受け取ると入力が終了します。 通常の Gforth 行編集機能が利用可能です。 文字列の長さは
@code{span} に保存されますが、 <return> 文字は含まれません。 時代遅れ(OBSOLESCENT): @code{accept}
に置き換えられました。


@findex span ( @var{ -- c-addr   } ) core-ext-obsolescent
@cindex @code{span}
@kindex span
@format
@code{span} ( @i{-- c-addr  }) core-ext-obsolescent ``span''
@end format
変数(variable) -- @i{c-addr} は、 @code{expect}
によって最後に受け取った文字列の長さを格納するセルのアドレスです。 時代遅れ(OBSOLESCENT)。




@node Pipes, Xchars and Unicode, Line input and conversion, Other I/O
@subsection Pipes
@cindex pipes, creating your own

他のプロセスによって作成されたパイプライン(@pxref{Gforth in pipes})を Gforth で使用することに加えて、 あなたは
@code{open-pipe} を使用してあなた独自のパイプラインを作成し、 読み書きすることができます。

@findex open-pipe ( @var{ c-addr u wfam -- wfileid wior  } ) gforth-0.2
@cindex @code{open-pipe}
@kindex open-pipe
@format
@code{open-pipe} ( @i{c-addr u wfam -- wfileid wior }) gforth-0.2 ``open-pipe''
@end format

@findex close-pipe ( @var{ wfileid -- wretval wior  } ) gforth-0.2
@cindex @code{close-pipe}
@kindex close-pipe
@format
@code{close-pipe} ( @i{wfileid -- wretval wior }) gforth-0.2 ``close-pipe''
@end format


パイプラインに書き込む場合、 Gforth は @code{broken-pipe-error} を throw する可能性があります。 あなたが、
この例外をキャッチしない場合、 Gforth は例外をキャッチして通常は黙って(silently)に終了(exit)します(@pxref{Gforth
in pipes})。 しかし、 おそらくこれはあなたの望む事ではないので、 @code{open-pipe} から @code{close-pipe}
までのコードを @code{catch} または @code{try} ブロックで囲むべきです。 そして、 あなた自身で問題を解決し、
通常の処理に戻します。

@findex broken-pipe-error ( @var{ -- n   } ) gforth-0.6
@cindex @code{broken-pipe-error}
@kindex broken-pipe-error
@format
@code{broken-pipe-error} ( @i{-- n  }) gforth-0.6 ``broken-pipe-error''
@end format
壊れたパイプラインのエラー番号



@node Xchars and Unicode, i18n and l10n, Pipes, Other I/O
@subsection Xchars and Unicode

ASCII は英語(English language)にのみ適しています。 ただし、 ほとんどの西洋言語(western
languages)は、それぞれの少数の特殊文字をエンコードするには 1 バイトで十分であるため、 Forth
の枠組みにある程度適合します(ただし、常に同じエンコードを使用できるとは限りません。 ただし、 latin-1 が最も広く使用されています)。
他の言語の場合は、 異なる文字セットを使用する必要があり、その一部は可変幅です。  この問題に対処するために、
文字はスタック上ではユニコード・コードポイント(Unicode codepoints)として表され、 メモリ内では UTF-8
バイト文字列として表されることがよくあります。 ユニコード・コードポイントは、 多くの場合、 1 つのアプリケーション・ レベル(one
application-level character)の文字を表しますが、 ユニコードは、基本文字(base
letter)と結合発音記号(combining diacritical mark)など、
複数のコード・ポイントで構成される分解文字(combining diacritical mark)もサポートします。

ユニコード・コードポイントはメモリ内の複数バイトを消費する可能性があるため、 ここで我々の用語をすり合わせしておきましょう: char
はメモリ内の生のバイト、 またはスタック上の 0 ～ 255 の範囲の値です。  xchar (extended char) は 1
つのコードポイントを表します。 これはメモリ内の 1 バイト以上で表され、 スタック上にはより大きな値が存在する可能性があります。  ASCII 文字は
char や xchar と同一です。 つまり、0 ～ 127 の範囲の値、 かつ、 メモリ内のその値を含む 1 バイトです。

UTF-8 エンコードを使用する場合、 他のすべてのコードポイントは 1 文字あたり 1 バイト以上必要になります。  ほとんどの場合、
このような文字はメモリ内の文字列として扱うだけでよく、 以下のワード群を使用する必要はありませんが、 個々のコードポイントを処理したい場合は、
以下のワード群が役に立ちます。  現時点では、 分解文字(decomposed characters)を扱うためのワードはありません。

xchar ワード群はいくつかのデータ型を追加します:

@itemize

@item
@var{xc} はスタック上の拡張文字(xchar)です。 これは 1 つのセルを占有し、 符号なしセルのサブセットです。  16
ビット・システムでは、 ユニコード文字セットの BMP サブセット (つまり、 コードポイント<65536)のみがスタック上で表現できます。
アプリケーション文字(application characters)を常に文字列として表現すると、 この制限を回避できます。

@item
@var{xc-addr} はメモリ内の xchar のアドレスです。 アライメント要件は @var{c-addr} と同じです。  xchar
のメモリ表現はスタック表現とは異なり、 使用されるエンコーディングによって異なります。 xchar はメモリ内で可変数の char を使用できます。

@item
@var{xc-addr} @var{u} はメモリ内の xchar のバッファで、@var{xc-addr} で始まり @var{u} char
(つまり、 xchar ではなくバイト)の長さになります。

@end itemize

@findex xc-size ( @var{ xc -- u   } ) xchar
@cindex @code{xc-size}
@kindex xc-size
@format
@code{xc-size} ( @i{xc -- u  }) xchar ``x-c-size''
@end format
xchar @var{xc} のメモリ・サイズを char で計算します。


@findex x-size ( @var{ xc-addr u1 -- u2   } ) xchar
@cindex @code{x-size}
@kindex x-size
@format
@code{x-size} ( @i{xc-addr u1 -- u2  }) xchar ``x-size''
@end format
@var{xc-addr} に格納されている最初の xchar のメモリ・サイズを char で計算します。


@findex xc@@ ( @var{ xc-addr -- xc   } ) xchar-ext
@cindex @code{xc@@}
@kindex xc@@
@format
@code{xc@@} ( @i{xc-addr -- xc  }) xchar-ext ``xc-fetch''
@end format
@var{xc-addr1} から xchar @var{xc} を取得します。


@findex xc@@+ ( @var{ xc-addr1 -- xc-addr2 xc   } ) xchar
@cindex @code{xc@@+}
@kindex xc@@+
@format
@code{xc@@+} ( @i{xc-addr1 -- xc-addr2 xc  }) xchar ``x-c-fetch-plus''
@end format
@var{xc-addr1} から xchar @var{xc} を取得します。 @var{xc-addr2} は、 @var{xc}
の後ろの最初のメモリ位置を指します。


@findex xc@@+? ( @var{ xc-addr1 u1 -- xc-addr2 u2 xc   } ) gforth-experimental
@cindex @code{xc@@+?}
@kindex xc@@+?
@format
@code{xc@@+?} ( @i{xc-addr1 u1 -- xc-addr2 u2 xc  }) gforth-experimental ``x-c-fetch-plus-query''
@end format
文字列 @var{xc-addr1 u1} の最初の xchar @var{xc} を取得します。 @var{xc-addr2 u2} は
@var{xc} の後ろの残りの文字列です。


@findex xc!+? ( @var{ xc xc-addr1 u1 -- xc-addr2 u2 f   } ) xchar
@cindex @code{xc!+?}
@kindex xc!+?
@format
@code{xc!+?} ( @i{xc xc-addr1 u1 -- xc-addr2 u2 f  }) xchar ``x-c-store-plus-query''
@end format
xchar @var{xc} を、 アドレス @var{xc-addr1} で始まり @var{u1} 文字分の大きさであるバッファーに格納します。
@var{xc-addr2} は @var{xc} の後の最初のメモリ位置を指し、 @var{u2} はバッファの残りのサイズです。 xchar
@var{xc} がバッファーに収まった場合、 @var{f} は true、 それ以外の場合は @var{f} は false で
@var{xc-addr2} @var{u2} は @var{xc-addr1} @var{u1} と等しくなります。 @code{XC!+?}
はバッファー・オーバーフローに対して安全であるため、 @code{XC!+} よりも推奨されます。


@findex xc!+ ( @var{ xc xc-addr1 -- xc-addr2   } ) xchar
@cindex @code{xc!+}
@kindex xc!+
@format
@code{xc!+} ( @i{xc xc-addr1 -- xc-addr2  }) xchar ``x-c-store''
@end format
xchar @var{xc} を @var{xc-addr1} に保存します。  @var{xc-addr2} は、
バッファ内の次の未使用アドレスです。 これは最大 4 バイトを書き込むため、 アドレスをバッファの末尾と照合するだけの場合は、
有用なデータの上書きを避けるために、 バッファの末尾の後に少なくとも 3 バイトの余裕(パディング)が必要であることに注意してください。


@findex xchar+ ( @var{ xc-addr1 -- xc-addr2   } ) xchar
@cindex @code{xchar+}
@kindex xchar+
@format
@code{xchar+} ( @i{xc-addr1 -- xc-addr2  }) xchar ``x-char-plus''
@end format
@var{xc-addr1} に格納されている xchar のサイズをこのアドレスに加算し、 @var{xc-addr2} を与えます(訳注: つまり、
次の xchar 文字の位置を返す)


@findex xchar- ( @var{ xc-addr1 -- xc-addr2   } ) xchar-ext
@cindex @code{xchar-}
@kindex xchar-
@format
@code{xchar-} ( @i{xc-addr1 -- xc-addr2  }) xchar-ext ``x-char-minus''
@end format
@var{xc-addr1} から xchar が見つかるまで逆方向に進み、 この xchar のサイズを @var{xc-addr2} に加算すると
@var{xc-addr1} になります。


@findex +x/string ( @var{ xc-addr1 u1 -- xc-addr2 u2   } ) xchar-ext
@cindex @code{+x/string}
@kindex +x/string
@format
@code{+x/string} ( @i{xc-addr1 u1 -- xc-addr2 u2  }) xchar-ext ``plus-x-slash-string''
@end format
アドレス @var{xc-addr1} サイズ @var{u1} 文字で定義されたバッファーで xchar 1つ分だけ進めたアドレスを
@var{xc-addr2} に返します。 u2 は xchar 分だけ u1 より減ります(残り文字列長さです)。 u2 が 0
になったら末尾まで到達しています。 注意:  0 になってもそこで止まりません更に進んでしまうので注意(長さが負数になる)


@findex x\string- ( @var{ xc-addr u1 -- xc-addr u2   } ) xchar-ext
@cindex @code{x\string-}
@kindex x\string-
@format
@code{x\string-} ( @i{xc-addr u1 -- xc-addr u2  }) xchar-ext ``x-backslash-string-minus''
@end format
バッファの最後から開始して、 アドレス @var{xc-addr} とサイズ @var{u1} (char単位) で定義されたバッファー内で 1
xchar ずつ後方に進みます。 @var{xc-addr} は変わらず、 @var{u2} は xchar 分ずつ短くなります。 注意: 0
になっても止まりません。そのまま長さが負数になっていきます。


@findex -trailing-garbage ( @var{ xc-addr u1 -- xc-addr u2   } ) xchar-ext
@cindex @code{-trailing-garbage}
@kindex -trailing-garbage
@format
@code{-trailing-garbage} ( @i{xc-addr u1 -- xc-addr u2  }) xchar-ext ``minus-trailing-garbage''
@end format
@var{xc-addr} @var{u1} というバッファー内の最後の XCHAR を調べます --- エンコードが正しく、 完全な文字を表す場合
@var{u2} は @var{u1} と等しいです。 それ以外の場合は @var {u2} は、 最後の(文字化けした) xchar
を除いた文字列を表します。


@findex x-width ( @var{ xc-addr u -- n   } ) xchar-ext
@cindex @code{x-width}
@kindex x-width
@format
@code{x-width} ( @i{xc-addr u -- n  }) xchar-ext ``x-width''
@end format
アドレス @var{xc-addr} 長さ @var{u} (char単位)の文字列に対して、同じ幅の等幅 ASCII 文字での文字数を @var{n}
に得ます。 等幅フォントを想定しています。 つまり文字の幅はいずれも ASCII 文字の幅の整数倍であると仮定します(訳注: 含まれる xchar
ごとにその表示幅を調べたのを積算して返します buf $@@ type abcあdef ok  buf $@@len . 9  ok  buf $@@
x-width . 8  ok)


@findex xkey ( @var{ -- xc   } ) xchar
@cindex @code{xkey}
@kindex xkey
@format
@code{xkey} ( @i{-- xc  }) xchar ``x-key''
@end format
端末から xchar を 1 つ読み取ります。 これにより、xchar の読み取りが完了するまでのすべての入力イベントが破棄されます(訳注:
ヒストリ操作は効いたので…全ての入力イベント…?)。


@findex xc-width ( @var{ xc -- n   } ) xchar-ext
@cindex @code{xc-width}
@kindex xc-width
@format
@code{xc-width} ( @i{xc -- n  }) xchar-ext ``x-c-width''
@end format
@var{xc} の幅は、通常の固定幅グリフ(fixed-width glyph)の幅の @var{n} 倍です。


@findex xhold ( @var{ xc --   } ) xchar-ext
@cindex @code{xhold}
@kindex xhold
@format
@code{xhold} ( @i{xc --  }) xchar-ext ``x-hold''
@end format
@code{<<#} と @code{#>} の間で使用されます。 表示数値出力文字列(pictured numeric output
string)の前に @var{xc} を追加します。  代替手段としては @code{holds} を使用することができます。


@findex xc, ( @var{ xchar --   } ) xchar
@cindex @code{xc,}
@kindex xc,
@format
@code{xc,} ( @i{xchar --  }) xchar ``x-c-comma''
@end format


@node i18n and l10n, Substitute, Xchars and Unicode, Other I/O
@subsection 国際化(I18n)とローカライズ

エンド・ユーザー向けのプログラムは、 エンド・ユーザーの母国語に対応する必要があります。  このような機能については古くから提案があり、 Xchars
(@pxref{Xchars and Unicode})や Substitute (@pxref{Substitute})
などの国際文字セットに関する他の提案から分割されました。  画面に表示されるメッセージは、 開発者の母国語(native
language)からユーザーの現地言語(local languages)に翻訳する必要があります(訳注: gforth
に最初から組み込まれていないので都度 @code{require i18n.fs} 等する必要ある。 本マニュアルに掲載が無いが i18n な
日付用として @code{require i18n-date.fs} するのもいいかもしれない)。

翻訳対象の文字列は @code{L" }@var{string}@code{"} で宣言します。  これにより、
ロケール文字列識別子(LSID)が返されます。  LSID は不明瞭なタイプ(opaque types)であり、 スタック上のセルとして扱われます。
LSID はロケールに変換できます。 ロケールは、 言語およびその言語の国固有のバリエーションです。

@findex L" ( @var{ "lsid<">" -- lsid   } ) gforth-experimental
@cindex @code{L"}
@kindex L"
@format
@code{L"} ( @i{"lsid<">" -- lsid  }) gforth-experimental ``l-quote''
@end format
文字列が一意に新しい場合は、 文字列をパースし、 新しい lsid を定義します。  同一文字列は同一の lsid となり、
同一文字列を使用して複数の場所から同じ lsid を参照できます。


@findex LU" ( @var{ "lsid<">" -- lsid   } ) gforth-experimental
@cindex @code{LU"}
@kindex LU"
@format
@code{LU"} ( @i{"lsid<">" -- lsid  }) gforth-experimental ``l-unique-quote''
@end format
文字列がユニークでない場合でも(重複してても)、 文字列をパースし、 常に新しい lsid を定義します。


@findex native@@ ( @var{ lsid -- addr u   } ) gforth-experimental
@cindex @code{native@@}
@kindex native@@
@format
@code{native@@} ( @i{lsid -- addr u  }) gforth-experimental ``native-fetch''
@end format
@var{lsid} からネイティブ文字列(native string)を取得します


@findex locale@@ ( @var{ lsid -- addr u   } ) gforth-experimental
@cindex @code{locale@@}
@kindex locale@@
@format
@code{locale@@} ( @i{lsid -- addr u  }) gforth-experimental ``locale-fetch''
@end format
現在の言語 かつ 現在の国(country)でローカライズされた文字列を取得します


@findex locale! ( @var{ addr u lsid --   } ) gforth-experimental
@cindex @code{locale!}
@kindex locale!
@format
@code{locale!} ( @i{addr u lsid --  }) gforth-experimental ``locale-store''
@end format
現在のロケール かつ 現在の国の、 ローカライズされた文字列 @var{addr u} を @var{lsid} に保存します。


@findex Language ( @var{ "name" --   } ) gforth-experimental
@cindex @code{Language}
@kindex Language
@format
@code{Language} ( @i{"name" --  }) gforth-experimental ``Language''
@end format
ロケールを定義します。  そのロケールを実行すると、 それが現在のロケールになります。


@findex Country ( @var{ <lang> "name" --   } ) gforth-experimental
@cindex @code{Country}
@kindex Country
@format
@code{Country} ( @i{<lang> "name" --  }) gforth-experimental ``Country''
@end format
現在のロケールのバリエーション(通常: 国;country)を定義します。 そのロケールを実行すると、それが現在のロケールになります。
バリエーションのバリエーションを作成できます(国によってはバリエーションが存在する場合があります。たとえば、 多くの言語で rolls/buns
を表す単語が何語あるかを考えてください)。


@findex locale-file ( @var{ fid --   } ) gforth-experimental
@cindex @code{locale-file}
@kindex locale-file
@format
@code{locale-file} ( @i{fid --  }) gforth-experimental ``locale-file''
@end format
@var{fid} から現在のロケールに行(lines)を読み取ります。


@findex included-locale ( @var{ addr u --   } ) gforth-experimental
@cindex @code{included-locale}
@kindex included-locale
@format
@code{included-locale} ( @i{addr u --  }) gforth-experimental ``included-locale''
@end format
ファイル @var{addr u} から現在のロケールに行(lines)を読み取ります。


@findex include-locale ( @var{ "name" --   } ) gforth-experimental
@cindex @code{include-locale}
@kindex include-locale
@format
@code{include-locale} ( @i{"name" --  }) gforth-experimental ``include-locale''
@end format
指定のファイル @var{"name"} から現在のロケールに行(lines)を読み取ります。


@findex locale-csv ( @var{ "name" --   } ) gforth-experimental
@cindex @code{locale-csv}
@kindex locale-csv
@format
@code{locale-csv} ( @i{"name" --  }) gforth-experimental ``locale-csv''
@end format
カンマ区切り値テーブルをロケールにインポートします。  最初の行にはロケール名が含まれます。 “program” と “default”
は特別なエントリです。  generic languages は特定の国(specific
countries)向けの翻訳よりも優先しなければなりません。  “program” の下のエントリ(一番左にある必要があります) は、 lsid
の検索に使用されます。 空の場合、 行番号 1 は lsid インデックスです。


@findex .locale-csv ( @var{ --   } ) gforth-experimental
@cindex @code{.locale-csv}
@kindex .locale-csv
@format
@code{.locale-csv} ( @i{--  }) gforth-experimental ``dot-locale-csv''
@end format
ロケール・データベースを CSV 形式で端末に出力します。


@findex locale-csv-out ( @var{ "name" --   } ) gforth-experimental
@cindex @code{locale-csv-out}
@kindex locale-csv-out
@format
@code{locale-csv-out} ( @i{"name" --  }) gforth-experimental ``locale-csv''
@end format
ファイル @var{"name"} を作成し、 ロケール・データベースを CSV 形式でファイル @var{"name"} に書き込みます。



@node Substitute, CSV Reader, i18n and l10n, Other I/O
@subsection Substitute

これは単純なテキスト・マクロ置換機能です。  @code{"text %macro% text"} の形式のテキストが処理され、@code{'%'}
で囲まれたマクロ変数が関連する文字列に置き換えられます。  2 つの連続する @code{%} は 1 つの @code{%} に置き換えられます。
マクロは特定のワードリストで定義され、実行時に文字列を返します。 標準では、 マクロを宣言する方法が 1 つだけ、  @code{replaces}
のみ定義されています。 これは文字列を返すだけのマクロを作成します。

@findex macros-wordlist ( @var{ -- wid   } ) gforth-experimental
@cindex @code{macros-wordlist}
@kindex macros-wordlist
@format
@code{macros-wordlist} ( @i{-- wid  }) gforth-experimental ``macros-wordlist''
@end format
文字列置換マクロのワードリスト


@findex replaces ( @var{ addr1 len1 addr2 len2 --   } ) string-ext
@cindex @code{replaces}
@kindex replaces
@format
@code{replaces} ( @i{addr1 len1 addr2 len2 --  }) string-ext ``replaces''
@end format
名前が @var{addr2 len2}、 内容が @var{addr1 len1} のマクロを作成します。  マクロが既に存在する場合は、
内容を変更するだけです。


@findex .substitute ( @var{ addr1 len1 -- n / ior   } ) gforth-experimental
@cindex @code{.substitute}
@kindex .substitute
@format
@code{.substitute} ( @i{addr1 len1 -- n / ior  }) gforth-experimental ``dot-substitute''
@end format
テキスト @var{addr1 len1} 内のすべてのマクロを置き換えて、 結果を出力します。  @var{n} は置換した数。 または負数の場合は
throw 可能な @var{ior} です。


@findex $substitute ( @var{ addr1 len1 -- addr2 len2 n/ior   } ) gforth-experimental
@cindex @code{$substitute}
@kindex $substitute
@format
@code{$substitute} ( @i{addr1 len1 -- addr2 len2 n/ior  }) gforth-experimental ``string-substitute''
@end format
テキスト @var{addr1 len1} 内のすべてのマクロを置き換えます。 @var{addr2 len2} が置換結果で、 @var{n}
は置換の数で、 負数場合は throw 可能な @var{ior} です。


@findex substitute ( @var{ addr1 len1 addr2 len2 -- addr2 len3 n/ior   } ) string-ext
@cindex @code{substitute}
@kindex substitute
@format
@code{substitute} ( @i{addr1 len1 addr2 len2 -- addr2 len3 n/ior  }) string-ext ``substitute''
@end format
テキスト @var{addr1 len1} 内のすべてのマクロを置き換え、 結果を @var{addr2 len2} にコピーします。
@var{addr2 len3} は置換結果で、 @var{n} は置換した数、または負数場合は throw 可能な @var{ior} です。


@findex unescape ( @var{ addr1 u1 dest -- dest u2   } ) string-ext
@cindex @code{unescape}
@kindex unescape
@format
@code{unescape} ( @i{addr1 u1 dest -- dest u2  }) string-ext ``unescape''
@end format
@var{addr1 u1} 内のすべての区切り文字を2重にすることで、 置換後の結果が元のテキストのままになります。  結果を格納するバッファー
@var{dest} には長さ指定の必要が無いことに注意してください。 最悪の場合、 必要な文字数は @var{u1} の 2倍です。
@var{dest u2} は結果の文字列の長さです。


@findex $unescape ( @var{ addr1 u1 -- addr2 u2   } ) gforth-experimental
@cindex @code{$unescape}
@kindex $unescape
@format
@code{$unescape} ( @i{addr1 u1 -- addr2 u2  }) gforth-experimental ``string-unescape''
@end format
@code{unescape} と同じですが、 @code{$tmp} を使用して一時的な結果文字列を作成します。



@node CSV Reader, , Substitute, Other I/O
@subsection CSV Reader

CSV(Comma-separated values)は、 データをやり取りするための一般的なテキスト形式です。  Gforth は
@file{csv.fs} でCSVリーダーを提供します(注意: gforth に最初から組み込まれてはいないので、 都度 @code{require
csv.fs} 等する必要がある)。

@findex read-csv ( @var{ addr u xt --   } ) gforth-experimental
@cindex @code{read-csv}
@kindex read-csv
@format
@code{read-csv} ( @i{addr u xt --  }) gforth-experimental ``read-csv''
@end format
CVS ファイル @var{addr u} を読み取り、 見つかった項目ごとに @var{xt} を実行します。  @var{xt} は @code{(
addr ucol line -- )}、 つまり文字列と、 現在の列番号(0 で始まる)と、 現在の行番号(1 で始まる)を受け取ります。



@node OS command line arguments, Locals, Other I/O, Words
@section OS command line arguments
@cindex OS command line arguments
@cindex command line arguments, OS
@cindex arguments, OS command line

コマンドラインで Gforth プログラムに引数を渡す通常の方法は、 @option{-e} オプションを使用することです。 たとえば、

@example
gforth -e "123 456" foo.fs -e bye
@end example

ただし、 コマンドライン引数を直接パースしたい場合もあります。  その場合、 @code{next-arg}
を通じて(イメージ固有の)コマンドライン引数にアクセスできます:

@findex next-arg ( @var{ -- addr u   } ) gforth-0.7
@cindex @code{next-arg}
@kindex next-arg
@format
@code{next-arg} ( @i{-- addr u  }) gforth-0.7 ``next-arg''
@end format
OS コマンドラインから次の引数を取得し、 それを消費し @i{addr u} に返します。 引数が残っていない場合は、 @code{0 0}
を返します。



@code{next-arg} のプログラム例 @file{echo.fs} を以下に示します:

@example
: echo ( -- )
    begin
	next-arg 2dup 0 0 d<> while
	    type space
    repeat
    2drop ;

echo cr bye
@end example

これは以下のようにして起動します

@example
gforth echo.fs hello world
@end example

そうすると以下のように出力されます

@example
hello world
@end example

以下は、 OS コマンドラインを処理する下位レベルのワード群です:

@findex arg ( @var{ u -- addr count   } ) gforth-0.2
@cindex @code{arg}
@kindex arg
@format
@code{arg} ( @i{u -- addr count  }) gforth-0.2 ``arg''
@end format
@i{u} 番目のコマンドライン引数の文字列を返します。 @i{u} が最後の引数を超えている場合は @code{0 0} を返します。
@code{0 arg} は、 Gforth を起動したプログラム名です。  次の未処理の引数は常に @code{1 arg} で、 その後の引数は
@code{2 arg} などです。 システムによってすでに処理された引数はすべて削除されます。  引数を処理した後、
@code{shift-args} を使用して引数を削除できます。


@findex shift-args ( @var{ --   } ) gforth-0.7
@cindex @code{shift-args}
@kindex shift-args
@format
@code{shift-args} ( @i{--  }) gforth-0.7 ``shift-args''
@end format
@code{1 arg} が削除され、 後続のすべての OS コマンドライン・パラメータが 1 だけ左にシフトされ、@code{argc @@}
が減ります。  このワードは @code{argv @@} を変更できます。



最後に、 Gforth は最下位レベルで以下のワード群を提供します:

@findex argc ( @var{ -- addr   } ) gforth-0.2
@cindex @code{argc}
@kindex argc
@format
@code{argc} ( @i{-- addr  }) gforth-0.2 ``argc''
@end format
変数(@code{Variable}) -- コマンドライン引数の数(コマンド名を含む)。  @code{next-arg} と
@code{shift-args} によって変更されます。


@findex argv ( @var{ -- addr   } ) gforth-0.2
@cindex @code{argv}
@kindex argv
@format
@code{argv} ( @i{-- addr  }) gforth-0.2 ``argv''
@end format
変数(@code{Variable}) -- コマンドライン引数 (コマンド名を含む) へのポインターのベクトル(vector)へのポインター。
各引数は、 C言語スタイルのゼロで終わる文字列として表されます。  @code{next-arg} と @code{shift-args}
によって変更されます。



@c -------------------------------------------------------------
@node Locals, Structures, OS command line arguments, Words
@section Locals
@cindex locals

ローカル変数を使用すると、 Forth プログラミングがより楽しくなり、 Forth プログラムが読みやすくなります。 残念ながら、 標準 Forth
の ローカル変数には制限がたくさんあります。 したがって、 標準 Forth のローカル変数ワードセットだけでなく、 Gforth
独自のより強力なローカル変数ワードセットも提供します(標準Forthのローカル変数ワードセットは、 Gforth
のローカル変数ワードセットで実装しました)。

このセクションのアイデアは、 M. Anton Ertl,
@cite{@uref{https://www.complang.tuwien.ac.at/papers/ertl94l.ps.gz,
Automatic Scoping of Local Variables}}, EuroForth '94 でも公開されています。

@menu
* Gforth locals::
* Standard Forth locals::    
@end menu

@node Gforth locals, Standard Forth locals, Locals, Locals
@subsection Gforth locals
@cindex Gforth locals
@cindex locals, Gforth style

ローカル変数は以下のように定義できます

@example
@{: local1 local2 ... -- comment :@}
@end example
or
@example
@{: local1 local2 ... :@}
@end example
or
@example
@{: local1 local2 ... | ulocal0 ulocal1 -- comment :@}
@end example

例えば、 以下のように使います
@example
: max @{: n1 n2 -- n3 :@}
 n1 n2 > if
   n1
 else
   n2
 endif ;
@end example

ローカル変数定義とスタック・コメントは、 類似するよう意図しています。 ローカル変数定義は、 多くの場合、 ワードのスタック・コメントを置き換えます。
ローカル変数の順序はスタック・コメント内の順序に対応し、 @code{--} 以降はすべて実際はコメントです。

この類似性には 1 つ欠点があります。 ローカル変数宣言とスタック・コメントを混同しやすく、 バグが発生し、 見つけにくくなります。 ただし、
この問題は適切なコーディング規約によって回避できます。 同じプログラム内で両方の表記法を使用しないでください。 そうする場合は、
追加の手段を使用して区別する必要があります。 例えば、 場所によって区別します。

@cindex types of locals
@cindex locals types
ローカルの名前の前に型指定子を付けることができます。 たとえば、浮動小数点値の場合は @code{F:} です:

@example
: CX* @{: F: Ar F: Ai F: Br F: Bi -- Cr Ci :@}
\ 複素数の掛け算
 Ar Br f* Ai Bi f* f-
 Ar Bi f* Ai Br f* f+ ;
@end example

@cindex flavours of locals
@cindex locals flavours
@cindex value-flavoured locals
@cindex varue-flavoured locals
@cindex variable-flavoured locals
Gforth は現在、 セル型指定子(@code{W:}, @code{WA:}, @code{W^})や、 2倍長整数型指定子(@code{D:},
@code{DA:}, @code{D^})や、 浮動小数点数型指定子(@code{F:}, @code{FA:}, @code{F^})と、
さまざまなフレーバーの xt 型指定子(@code{xt:}, @code{xta:})、 をサポートしています:

@table @dfn

@item valueフレーバー(value-flavoured)
(@pxref{Values}) valueフレーバーのローカル変数(@code{W:}、 @code{D:} などで定義)はその値を生成し、
@code{TO} で変更できます。

@item varueフレーバー(vaLue ではなくて vaRue)
(@pxref{Varues}) varueフレーバーのローカル変数 @i{foo} (@code{WA:} などで定義) は、 @code{addr
@i{foo}} を使用してアドレスを取得できること(変数のスコープを離れると無効になります)を除いて、
valueフレーバーのローカル変数とまったく同じように振る舞います。 現時点ではパフォーマンスに違いはありませんが、 長期的には、
valueフレーバーのローカル変数はレジスタに常駐できるため、 大幅に高速になるでしょう。

@item variableフレーバー
(@pxref{Variables}) variableフレーバーのローカル変数(@code{W^}
などで定義)はそのアドレスを生成します(変数のスコープを離れると無効になります)。  たとえば、 標準のワード @code{emit} は、
以下のように variableフレーバーのローカル変数(@code{C^ char*}) と @code{type} で定義できます:

@example
: emit @{: C^ char* -- :@}
    char* 1 type ;
@end example

@item deferフレーバー(defer-flavoured)
(@pxref{Deferred Words}) (@code{XT:} または @code{XTA:} と指定した) defer
フレーバーのローカル変数 xt を @code{execute} します。 @code{action-of} を使用すると、 defer
フレーバーのローカル変数から xt を取得できます。  ローカル変数が @code{xta:} で定義されている場合、 @code{addr}
を使用して、 xt が保存されているアドレス(ローカル変数のスコープの終わりまで有効)を取得できます。  たとえば、 標準のワード
@code{execute} は、 以下のように defer フレーバーのローカル変数で定義できます:

@example
: execute @{: xt: x -- :@}
  x ;
@end example

@end table

@cindex default type of locals
@cindex locals, default type
型指定子のないローカル変数は @code{W:} ローカル変数として扱われます。  以下を使用して @code{addr}
の使用を許可または禁止できます:

@findex default-wa: ( @var{ --   } ) gforth-experimental
@cindex @code{default-wa:}
@kindex default-wa:
@format
@code{default-wa:} ( @i{--  }) gforth-experimental ``default-wa:''
@end format
型指定子なしで定義されたローカル変数で @code{addr} を許可します。  言い換えれば、 型指定子無しでローカル変数定義したときは
@code{wa:} 型指定子を指定したのと同じです


@findex default-w: ( @var{ --   } ) gforth-experimental
@cindex @code{default-w:}
@kindex default-w:
@format
@code{default-w:} ( @i{--  }) gforth-experimental ``default-w:''
@end format
型指定子なしで定義されたローカル変数では @code{addr} を禁止します。  言い換えれば、 型指定子なしで定義されたローカル変数は
@code{w:} 型指定子を指定してローカル変数を定義したのと同じです。



@cindex locals initialization
@cindex initialization of locals
@code{|} の後ろで定義されたローカル変数を除いて、 ローカル変数の全てのフレーバーは、 データ・スタックの値または、 (FP
ローカル変数の場合) FP スタックの値で初期化されます。 Gforth は @code{|} の後ろで定義されたローカル変数を 0 に初期化します。
一部の Forth システムでは初期化されないままになっています。

@cindex data structure locals
Gforth は、 ローカル・バッファーとデータデータ構造体のための角括弧(square bracket)表記をサポートしています。
これらのローカル変数は variableフレーバー のローカル変数に似ており、 サイズは定数式として指定します。  宣言は
@code{@i{name}[ @i{size} ]} のようになります。  Forth の式 @code{@i{size}} は宣言中に評価され、
サイズをバイト単位で指定するスタック効果 @code{( -- +n )} が必要です。  角括弧 @code{[} は定義された名前の一部です。

ローカルのデータ構造体は、 データ・スタックに渡されたアドレスから @i{size} バイトをコピーすることによって初期化されます。 (宣言内の
@code{|} の後の、)初期化されていないローカルのデータ構造体は消去されず、 以前にローカル・スタックにあったデータをすべて含むだけです。

Example:

@example
begin-structure test-struct
  field: a1
  field: a2
end-structure

: test-local @{: foo[ test-struct ] :@}
    foo[ a1 !  foo[ a2 !
    foo[ test-struct dump ;
@end example

Gforth では、コロン定義内のあらゆる場所でローカル変数を定義できます。 これにより、 以下のような疑問が生じます:

@menu
* Locals definition words::
* Where are locals visible by name?::
* How long do locals live?::
* Locals programming style::
* Locals implementation::
* Closures::                 
@end menu

@node Locals definition words, Where are locals visible by name?, Gforth locals, Gforth locals
@subsubsection Locals definitions words

このセクションでは、 ローカル変数を定義するために使用されるワード群を説明します。 注意: ローカル変数を定義するワード(@code{W:}
など)の実行時は、 右端のローカル変数定義から左端のローカル変数定義の方向で実行され、
右端のローカル変数がスタックのTOSから得る事になることに注意してください。

@findex @{: ( @var{ -- hmaddr u latest latestnt wid 0   } ) local-ext
@cindex @code{@{:}
@kindex @{:
@format
@code{@{:} ( @i{-- hmaddr u latest latestnt wid 0  }) local-ext ``open-brace-colon''
@end format
ローカル変数定義の開始。


@findex -- ( @var{ hmaddr u latest latestnt wid 0 ... --   } ) gforth-0.2
@cindex @code{--}
@kindex --
@format
@code{--} ( @i{hmaddr u latest latestnt wid 0 ... --  }) gforth-0.2 ``dash-dash''
@end format
ローカル変数定義中の @code{--} から @code{:@}} までのすべてが無視されます。  これは通常、
ローカル変数定義をスタック効果の説明としても使えるよう、 一人二役の役割を持たせる場合に使います。


@findex | ( @var{ --   } ) gforth-1.0
@cindex @code{|}
@kindex |
@format
@code{|} ( @i{--  }) gforth-1.0 ``bar''
@end format
@code{|} の後ろで定義されたローカル変数はスタックから初期化されません。 したがって、 @code{W:} のようなワードの実行時のスタック効果
@code{( -- )} に変わります。


@findex :@} ( @var{ hmaddr u latest latestnt wid 0 xt1 ... xtn --   } ) gforth-1.0
@cindex @code{:@}}
@format
@code{:@}} ( @i{hmaddr u latest latestnt wid 0 xt1 ... xtn --  }) gforth-1.0 ``colon-close-brace''
@end format
ローカル変数定義の終了。


@findex @{ ( @var{ -- hmaddr u latest latestnt wid 0   } ) gforth-0.2
@cindex @code{@{}
@kindex @{
@format
@code{@{} ( @i{-- hmaddr u latest latestnt wid 0  }) gforth-0.2 ``open-brace''
@end format
ローカル変数定義を開始します。  このワードの Forth-2012 標準名は @code{@{:} です。


@findex @} ( @var{ hmaddr u latest latestnt wid 0 xt1 ... xtn --   } ) gforth-0.2
@cindex @code{@}}
@kindex @}
@format
@code{@}} ( @i{hmaddr u latest latestnt wid 0 xt1 ... xtn --  }) gforth-0.2 ``close-brace''
@end format
ローカル変数定義を終了します。  このワードの Forth-2012 標準名は @code{:@}} です。


@findex W: ( @var{ compilation "name" -- a-addr xt; run-time x --   } ) gforth-0.2
@cindex @code{W:}
@kindex W:
@format
@code{W:} ( @i{compilation "name" -- a-addr xt; run-time x --  }) gforth-0.2 ``w-colon''
@end format
valueフレーバーのセル・ローカル変数 @i{name} を定義します @code{( -- x1 )}


@findex WA: ( @var{ compilation "name" -- a-addr xt; run-time x --   } ) gforth-1.0
@cindex @code{WA:}
@kindex WA:
@format
@code{WA:} ( @i{compilation "name" -- a-addr xt; run-time x --  }) gforth-1.0 ``w-a-colon''
@end format
varueフレーバーのセル・ローカル変数 @i{name} を定義します @code{( -- x1 )}


@findex W^ ( @var{ compilation "name" -- a-addr xt; run-time x --   } ) gforth-0.2
@cindex @code{W^}
@kindex W^
@format
@code{W^} ( @i{compilation "name" -- a-addr xt; run-time x --  }) gforth-0.2 ``w-caret''
@end format
variableフレーバーのセル・ローカル変数 @i{name} を定義します  @code{( -- a-addr )}


@findex D: ( @var{ compilation "name" -- a-addr xt; run-time x1 x2 --   } ) gforth-0.2
@cindex @code{D:}
@kindex D:
@format
@code{D:} ( @i{compilation "name" -- a-addr xt; run-time x1 x2 --  }) gforth-0.2 ``d-colon''
@end format
valueフレーバーの2倍長整数ローカル変数 @i{name} を定義します @code{( -- x3 x4 )}


@findex DA: ( @var{ compilation "name" -- a-addr xt; run-time x1 x2 --   } ) gforth-1.0
@cindex @code{DA:}
@kindex DA:
@format
@code{DA:} ( @i{compilation "name" -- a-addr xt; run-time x1 x2 --  }) gforth-1.0 ``w-a-colon''
@end format
varueフレーバーの2倍長整数ローカル変数 @i{name} を定義します @code{( -- x3 x4 )}


@findex D^ ( @var{ compilation "name" -- a-addr xt; run-time x1 x2 --   } ) gforth-0.2
@cindex @code{D^}
@kindex D^
@format
@code{D^} ( @i{compilation "name" -- a-addr xt; run-time x1 x2 --  }) gforth-0.2 ``d-caret''
@end format
variableフレーバーの2倍長整数ローカル変数 @i{name} を定義します @code{( -- a-addr )}


@findex C: ( @var{ compilation "name" -- a-addr xt; run-time c --   } ) gforth-0.2
@cindex @code{C:}
@kindex C:
@format
@code{C:} ( @i{compilation "name" -- a-addr xt; run-time c --  }) gforth-0.2 ``c-colon''
@end format
valueフレーバーの char ローカル変数 @i{name} を定義します @code{( -- c1 )}


@findex CA: ( @var{ compilation "name" -- a-addr xt; run-time c --   } ) gforth-1.0
@cindex @code{CA:}
@kindex CA:
@format
@code{CA:} ( @i{compilation "name" -- a-addr xt; run-time c --  }) gforth-1.0 ``c-a-colon''
@end format
varueフレーバーの char ローカル変数 @i{name} を定義します @code{( -- c1 )}


@findex C^ ( @var{ compilation "name" -- a-addr xt; run-time c --   } ) gforth-0.2
@cindex @code{C^}
@kindex C^
@format
@code{C^} ( @i{compilation "name" -- a-addr xt; run-time c --  }) gforth-0.2 ``c-caret''
@end format
variableフレーバーの char ローカル変数 @i{name} を定義します @code{( -- c-addr )}


@findex F: ( @var{ compilation "name" -- a-addr xt; run-time r --   } ) gforth-0.2
@cindex @code{F:}
@kindex F:
@format
@code{F:} ( @i{compilation "name" -- a-addr xt; run-time r --  }) gforth-0.2 ``f-colon''
@end format
valueフレーバーの浮動小数点数ローカル変数 @i{name} を定義します @code{( -- r1 )}


@findex FA: ( @var{ compilation "name" -- a-addr xt; run-time f --   } ) gforth-1.0
@cindex @code{FA:}
@kindex FA:
@format
@code{FA:} ( @i{compilation "name" -- a-addr xt; run-time f --  }) gforth-1.0 ``f-a-colon''
@end format
varueフレーバーの浮動小数点数ローカル変数 @i{name} を定義します @code{( -- r1 )}


@findex F^ ( @var{ compilation "name" -- a-addr xt; run-time r --   } ) gforth-0.2
@cindex @code{F^}
@kindex F^
@format
@code{F^} ( @i{compilation "name" -- a-addr xt; run-time r --  }) gforth-0.2 ``f-caret''
@end format
variableフレーバーの浮動小数点数ローカル変数 @i{name} を定義します @code{( -- f-addr )}


@findex XT: ( @var{ compilation "name" -- a-addr xt; run-time xt1 --   } ) gforth-1.0
@cindex @code{XT:}
@kindex XT:
@format
@code{XT:} ( @i{compilation "name" -- a-addr xt; run-time xt1 --  }) gforth-1.0 ``x-t-colon''
@end format
deferフレーバーのセル・ローカル変数 @i{name} を定義します @code{( ... -- ... )}


@findex XTA: ( @var{ compilation "name" -- a-addr xt; run-time ... -- ...   } ) gforth-1.0
@cindex @code{XTA:}
@kindex XTA:
@format
@code{XTA:} ( @i{compilation "name" -- a-addr xt; run-time ... -- ...  }) gforth-1.0 ``x-t-a-colon''
@end format
@code{addr} を使用できる defer フレーバーのローカル変数 @i{name} を定義します。



@code{|} や @code{--} や @code{:@}} や @code{@}} は通常、 検索順序スタック(the search
order)に含まれないことに注意してください(これらは @code{locals-types} ボキャブラリに含まれます)。
そしてこれらは必ずしも全ての Forth システムでワードとして存在しているわけではありません。 したがって、 これらは Gforth
のワードとして文書化されています。

@node Where are locals visible by name?, How long do locals live?, Locals definition words, Gforth locals
@subsubsection Where are locals visible by name?
@cindex locals visibility
@cindex visibility of locals
@cindex scope of locals

ローカル変数をその名前によって可視できるのはどこまででしょうか？ -- 基本的に、 その答えは、 ローカル変数がブロック構造言語で期待される場所で、
場合によってはもうちょっとだけ長くできます。 ローカル変数のスコープを制限したい場合は、 その定義を
@code{SCOPE}...@code{ENDSCOPE} で囲んで下さい。


@findex scope ( @var{ compilation  -- scope ; run-time  --   } ) gforth-0.2
@cindex @code{scope}
@kindex scope
@format
@code{scope} ( @i{compilation  -- scope ; run-time  --  }) gforth-0.2 ``scope''
@end format

@findex endscope ( @var{ compilation scope -- ; run-time  --   } ) gforth-0.2
@cindex @code{endscope}
@kindex endscope
@format
@code{endscope} ( @i{compilation scope -- ; run-time  --  }) gforth-0.2 ``endscope''
@end format



これらのワードは制御構造のワードのように動作するため、 @code{CS-PICK} および @code{CS-ROLL} とともに使用して、
任意の方法で範囲を制限できます。

可視性の質問に対するより正確な答えが必要な場合のために、 ここで基本原則を示します: ローカル変数は、
ローカル変数の定義を通じてのみ到達できるすべての場所で可視です@footnote{コンパイラ構築用語では「すべての場所はローカル変数の定義によって支配される」と言う}。
つまり、 ローカル変数という定義を経由しないと到達できる場所では不可視です。 たとえば、 @code{IF}...@code{ENDIF}
の中で定義されたローカル変数は @code{ENDIF} まで可視で、 @code{BEGIN}...@code{UNTIL}
内で定義されたローカル変数は @code{UNTIL} の後(たとえば、後続の @code{ENDSCOPE} まで)で可視です。

このソリューションの背景にある理由は次のとおりです: 私達は、 意味がある限り、 ローカル変数を可視させたいと考えています。 ユーザーは、
明示的なスコープを使用することで、 いつでも可視性を短くすることができます。 ローカル変数の定義によってのみ到達できる場所では、
ローカル変数名の意味は明らかです。 他の場所ではそうではありません。
ローカル変数定義が含まれていない制御フロー・パスでローカル変数はどのように初期化されるのでしょうか？  2 つの独立した制御フロー
パスで同一ローカル変数名が 2 回定義されている場合、 それはどちらのローカル変数を意味するのでしょうか？

上記で、 ほぼすべてのユーザーにとって十分詳細であるため、 このセクションの残りの部分はスキップしてかまいません。
本当にすべての血みどろの詳細とオプションを知る必要がある場合は、 以下を読み続けてください。

このルールを実装するには、 コンパイラはどの場所が到達不能(unreachable)であるかを認識する必要があります。 @code{AHEAD} や
@code{AGAIN} や @code{EXIT} や @code{LEAVE} の後で、 これが自動的に認識されます。 他の場合(例: ほとんどの
@code{THROW} の後)、 @code{UNREACHABLE} というワードを使用して、
制御フローがその場所に到達しないことをコンパイラに伝えることができます。 @code{UNREACHABLE} が使用できる場所で使用されなかった場合、
唯一の結果は、 一部のローカル変数の可視性が上記のルールに記載されているよりも制限されることです。 @code{UNREACHABLE}
を使用すべきではない場所で使用すると(つまり、 コンパイラに嘘をついた場合)、 バグのあるコードが生成されます。


@findex UNREACHABLE ( @var{ --   } ) gforth-0.2
@cindex @code{UNREACHABLE}
@kindex UNREACHABLE
@format
@code{UNREACHABLE} ( @i{--  }) gforth-0.2 ``UNREACHABLE''
@end format



このルールのもう 1 つの問題は、 @code{BEGIN} で、 どのローカル変数が incoming back-edge
で可視されるかをコンパイラが認識できないことです。 以下で説明するすべての問題は、 コンパイラのこの無知が原因です(@code{BEGIN}
ループを例として使用してこの問題について説明します。 この説明は @code{?DO} および他のループにも当てはまります)。
おそらく最も陰険な例は以下のとおりです:
@example
AHEAD
BEGIN
  x
[ 1 CS-ROLL ] THEN
  @{: x :@}
  ...
UNTIL
@end example

これは、 可視性ルールに従って合法である必要があります。 @code{x} の使用には、 定義を介してのみ到達できます。 ただし、
下記に明示した使用法でなければなりません。

この例から、 可視性ルールを完全に実装するには大きな問題が伴うことが明らかです。 私たちの実装は、 一般的なケースを宣伝どおりに扱い、
例外は安全な方法で処理されます。 コンパイラは、 @code{BEGIN} の後に可視できるローカル変数について合理的な推測を行います。
悲観的すぎると、 ローカル変数が定義されていないという偽のエラーがユーザーに表示されます。 コンパイラが楽観的すぎる場合、 後でこれに気づき、
警告を発行します。 上記の場合、 コンパイラは @code{x} が使用時に未定義であることについて文句を言います。 このセクションのあいまいな例から、
コンパイラをトラブルに陥らせるには非常に特殊な制御構造が必要であることがわかりますが、 それでもコンパイラは多くの場合問題なく動作します。

@code{BEGIN} がそれより上から到達可能な場合、 最も楽観的な推測は、 @code{BEGIN} の前に可視であるすべてのローカル変数も
@code{BEGIN} の後にも可視であることです。 この推測は、 @code{BEGIN} 経由でのみ入るすべてのループ、 特に通常の
@code{BEGIN}...@code{WHILE}...@code{REPEAT} および @code{BEGIN}...@code{UNTIL}
ループに対して有効であり、 コンパイラに実装されています。 @code{BEGIN} への分岐が @code{AGAIN} または
@code{UNTIL} によって最終的に生成されると、 コンパイラは推測をチェックし、 それが楽観的すぎる場合はユーザーに警告します:
@example
IF
  @{: x :@}
BEGIN
  \ x ? 
[ 1 cs-roll ] THEN
  ...
UNTIL
@end example

ここで、 @code{x} は @code{BEGIN} までのみ存続しますが、 コンパイラは @code{THEN}
まで存続すると楽観的に想定します。 @code{UNTIL} をコンパイルするときにこの違いに気づき、 警告を発行します。 ユーザーは警告を回避し、
明示的なスコープを使用して @code{x} が間違った領域で使用されていないことを確認できます:
@example
IF
  SCOPE
  @{: x :@}
  ENDSCOPE
BEGIN
[ 1 cs-roll ] THEN
  ...
UNTIL
@end example

推測は楽観的であるため、 未定義のローカル変数に関する偽のエラー・メッセージは表示されません。

@code{BEGIN} がそれより上から到達可能でない場合(たとえば、 @code{AHEAD} または @code{EXIT} の後)、
@code{BEGIN} の後で定義されたローカル変数の可視については、 コンパイラは楽観的な推測を行うことさえできません。

悲観的に、 制御構造の外側の最新の場所(つまり、 制御フロー・スタック上に何もない場所)で可視であったすべてのローカル変数が可視であると仮定します。
これは以下のことを意味します:

@example
: foo
  IF @{: z :@} THEN
  @{: x :@}
  AHEAD
    BEGIN
      ( * )
    [ 1 CS-ROLL ] THEN
    @{: y :@}
    ...
  UNTIL ;
@end example

ここで、 @code{( * )} でマークされた場所では、 @code{x} は可視ですが、 @code{y} は不可視です(ただし、
到達可能性ルールによれば、 可視であるべきです)。 @code{z} はそこでは不可視で、 可視であるべきではありません。

ただし、 @code{ASSUME-LIVE} を使用すると、 最上位の制御フロー・スタック項目が作成された時点と同じローカル変数が BEGIN
で可視になるのだと、 コンパイラに想定させることができます。


@findex ASSUME-LIVE ( @var{ orig -- orig   } ) gforth-0.2
@cindex @code{ASSUME-LIVE}
@kindex ASSUME-LIVE
@format
@code{ASSUME-LIVE} ( @i{orig -- orig  }) gforth-0.2 ``ASSUME-LIVE''
@end format



@noindent
例えば、 以下のように使います
@example
IF
  @{: x :@}
  AHEAD
    ASSUME-LIVE
    BEGIN
      x
    [ 1 CS-ROLL ] THEN
    ...
  UNTIL
THEN
@end example

ここで、 @code{x} のローカル変数定義は制御構造内にあるため、 @code{x} を使用した時点では @code{x} は可視ではありませんが、
@code{ASSUME-LIVE} を使用することで、 プログラマはコンパイラに @code{AHEAD} の時点で可視である、 そのローカル変数が、
@code{BEGIN} の時点でも可視であるべきであると伝えます。

@code{BEGIN} の前にローカル変数が定義されている他のケースは、 @code{ASSUME-LIVE} の前に適切な
@code{CS-ROLL} を挿入する(そして @code{ASSUME-LIVE}
の背後にある制御フロー・スタック操作を変更する)ことで処理できます。

ローカル変数が @code{BEGIN} の後で定義されている場合(ただし、 @code{BEGIN} の直後で可視である必要があります)は、
ループを再配置することによってのみ処理できます。 たとえば、上記の「最も陰険な」例は以下のように整理できます:
@example
BEGIN
  @{: x :@}
  ... 0=
WHILE
  x
REPEAT
@end example

@node How long do locals live?, Locals programming style, Where are locals visible by name?, Gforth locals
@subsubsection How long do locals live?
@cindex locals lifetime
@cindex lifetime of locals

ローカル変数の生存期間はどのくらいなのか？ -- 生存期間に関する質問に対する正しい答えは、次のとおりです: ローカル変数は、
少なくともアクセスできる限りは生存します。 valueフレーバーのローカル変数の場合、 これは、 その可視性が終了するまでを意味します。 ただし、
variableフレーバーのローカル変数は、可視性の範囲をはるかに超えてアドレスを通じてアクセスできる可能性があります。 結局のところ、
これはそのようなローカル変数がガベージ・コレクションを受けなければならないことを意味します。 これには、Forth らしくない実装の複雑さが伴うため、
他の言語(C言語など)と同じ引っ込み思案な解決策を採用しました。 つまり、 ローカル変数は、
それが可視である間のみ生存します。その後、そのアドレスは無効になります(そして、 その後そのアドレスにアクセスするプログラムはエラーになります)。

@node Locals programming style, Locals implementation, How long do locals live?, Gforth locals
@subsubsection Locals programming style
@cindex locals programming style
@cindex programming style, locals

どこでもローカル変数を定義できる自由は、 プログラミング・スタイルを劇的に変える可能性を秘めています。 特に、
中間ストレージにリターン・スタックを使用する必要がなくなります。 さらに、 すべてのスタック操作(実行時に決定される引数を持つ @code{PICK}
や @code{ROLL} を除く)を排除できます。 スタック項目の順序が間違っている場合は、 すべてのスタック項目のローカル変数定義を記述し、
その次に、 あなたが必要とする順序で項目を書き込むだけです。

これは少し突飛なように思えますし、 スタック操作を排除することが意識的なプログラミング目標になる可能性は低いです。 それでも、
ローカル変数を積極的に使用すれば、 スタック操作の数は大幅に減少します(例: @code{max} (@pxref{Gforth locals}) を
@code{max} の従来の実装と比較してみましょう)。

これは、 ローカル変数の潜在的な利点の 1 つ、 つまり Forth プログラムを読みやすくすることを示しています。 もちろん、 この利点は、
プログラマがワードを長ったらしく書くための自由度を追加する訳ではなく、 ファクタリング(因数分解)の原則を尊重し続けた場合にのみ実現されます。

@cindex single-assignment style for locals
@code{TO} の使用は可能な限り避けるべきです。  @code{TO} がない場合、 すべてのvalueフレーバーのローカル変数には 1
つの代入しかなく、 関数型言語の多くの利点が Forth に当てはまります。 つまり、 プログラムの分析・最適化・読み取りが容易になります。
ローカル変数が何を表すかは定義から明らかであり、 後で別のものに変わることはありません。

たとえば、 @code{TO} を使用したローカル変数定義は以下のようになります:
@example
: strcmp @{: addr1 u1 addr2 u2 -- n :@}
 u1 u2 min 0
 ?do
   addr1 c@@ addr2 c@@ -
   ?dup-if
     unloop exit
   then
   addr1 char+ TO addr1
   addr2 char+ TO addr2
 loop
 u1 u2 - ;
@end example
ここで、 @code{TO} は、 ループの反復ごとに @code{addr1} と @code{addr2} を更新するために使用されます。
@code{strcmp} は、@code{TO} の使用による可読性の問題の典型的な例です。  @code{strcmp} を読み始めると、
@code{addr1} が文字列の先頭を指していると考えるでしょう。 ループの終わり近くになって初めて、 それが何か別のものであることがわかります。

これは、 現在の反復に適切な値で初期化される 2 つのローカル変数をループの開始時に定義することで回避できます。
@example
: strcmp @{: addr1 u1 addr2 u2 -- n :@}
 addr1 addr2
 u1 u2 min 0 
 ?do @{: s1 s2 :@}
   s1 c@@ s2 c@@ -
   ?dup-if
     unloop exit
   then
   s1 char+ s2 char+
 loop
 2drop
 u1 u2 - ;
@end example
ここで、 @code{s1} がループの反復ごとに異なる値を持つことは最初から明らかです。

@node Locals implementation, Closures, Locals programming style, Gforth locals
@subsubsection Locals implementation
@cindex locals implementation
@cindex implementation of locals

@cindex locals stack
Gforth は追加のローカル変数用スタック(ローカル・スタック)を使用します。 この最も説得力のある理由は、
リターン・スタックが浮動小数点数に整列されていないことです。 この追加のスタックを使用すると、
リターン・スタックをローカル変数用スタックとして使用する場合の問題や制限も解消されます。 他のスタックと同様に、
ローカル・スタックは下位アドレスに向かって成長します。 いくつかのプリミティブにより効率的な実装になっています。 あなたは、
これらを直接使用するべきではありませんが、 @code{see} の出力には表示されるため、 以下に文書化しておきます:

@findex @@localn ( @var{ noffset -- w  } ) gforth-internal
@cindex @code{@@localn}
@kindex @@localn
@format
@code{@@localn} ( @i{noffset -- w }) gforth-internal ``fetch-local-n''
\ 訳注: ローカル・スタックのTOSを0として @i{noffset} 番目のコピーをデータ・スタックに積む
@end format

@findex f@@localn ( @var{ noffset -- r  } ) gforth-1.0
@cindex @code{f@@localn}
@kindex f@@localn
@format
@code{f@@localn} ( @i{noffset -- r }) gforth-1.0 ``f-fetch-local-n''
@end format

@findex lp@@ ( @var{ -- c-addr  } ) gforth-0.2
@cindex @code{lp@@}
@kindex lp@@
@format
@code{lp@@} ( @i{-- c-addr }) gforth-0.2 ``lp-fetch''
@end format
@i{C_addr} は、 ローカル・スタック・ポインタの現在の値です。

doc-lp+!#(訳注: まだ説明書いて無いっぽい)
@findex lp! ( @var{ c-addr --  } ) gforth-internal
@cindex @code{lp!}
@kindex lp!
@format
@code{lp!} ( @i{c-addr -- }) gforth-internal ``lp-store''
@end format

@findex >l ( @var{ w --  } ) gforth-0.2
@cindex @code{>l}
@kindex >l
@format
@code{>l} ( @i{w -- }) gforth-0.2 ``to-l''
\ 訳注: w をローカル・スタックにプッシュ
@end format

@findex f>l ( @var{ r --  } ) gforth-0.2
@cindex @code{f>l}
@kindex f>l
@format
@code{f>l} ( @i{r -- }) gforth-0.2 ``f-to-l''
@end format



これらのプリミティブに加えて、 一般的に発生するインライン引数に対するこれらのプリミティブのいくつかの特殊化が、 効率上の理由から提供されています(例:
@code{0 @@localn} の特殊化として @code{@@local0} )。 以下のコンパイル・ワード(compiling words)は、
適切な特殊バージョン、 または一般バージョンを適切にコンパイルします(訳注: @code{@@local0} シリーズは、
@code{@@local0} ローカル・スタックのTOS(のコピー)をスタックに積む、 @code{@@local1}
ローカル・スタックの2nd(のコピー)をスタックに積む、 〜 @code{@@local4} まである):


@c doc-compile-@local
@c doc-compile-f@local
@findex compile-lp+! ( @var{ n --   } ) gforth-0.2
@cindex @code{compile-lp+!}
@kindex compile-lp+!
@format
@code{compile-lp+!} ( @i{n --  }) gforth-0.2 ``compile-l-p-plus-store''
@end format



@code{?branch-lp+!#} のような、 条件分岐と @code{lp+!#}
の組み合わせ(ローカル・スタック・ポインタは分岐が選択された場合にのみ変更されます)は、 ループの効率と正確性のために提供されています。

ディクショナリ空間内の特別な領域が、 ローカル変数名を保持するために予約されています。 @code{@{:}
はディクショナリ・ポインタをこの領域に切り替え、 @code{:@}} はそれを元に戻し、 ローカル変数の初期化コードを生成します。 @code{W:}
などは通常の定義ワードです。 この特別な領域は、 すべてのコロン定義の先頭でクリアされます。

@cindex word list for defining locals
Gforth のディクショナリの特別な機能は、 型指定子なしでローカルの定義を実装するために使用されます。
すべてのワードリスト(別名ボキャブラリ)には、 検索などのための独自のメソッド(methods)があります (@pxref{Word Lists})。
型指定子なしでローカルの定義を実装するという目的のために、 私達は特別な検索メソッドを使用してワードリストを定義しました。 ワードが検索されると、
実際には @code{W:} を使用してそのワードが作成されます。  @code{@{:} は、 最初に @code{:@}} や @code{W:}
などを含むワードリストで検索し、 次に型指定子のないローカル変数を定義するためのワードリストで検索するよう検索順序スタック(the search
order)を変更します。

ライフタイム・ルールは、 コロン定義内のスタック規律(stack discipline)をサポートします。 ローカル変数のライフタイムは、
他のローカル変数のライフタイムと入れ子になっているか、 他のローカル変数のライフタイムと重ならないか、 です。

@code{BEGIN} や @code{IF} や @code{AHEAD} では、 ローカル・スタック・ポインター操作のコードは生成されません。
制御構造のワード間で、 ローカル変数定義はローカル変数をローカル・スタックにプッシュできます。 @code{AGAIN} は、 他の 3
つの制御フローワードとの中で最も単純です。 分岐する前に、 対応する @code{BEGIN} のローカル・スタックの深さを復元する必要があります。
そのコードは以下のようになります:
@format
@code{lp+!#} current-locals-size @minus{} dest-locals-size
@code{branch} <begin>
@end format

@code{UNTIL} はもう少し複雑です。 分岐して戻る場合は、 @code{AGAIN} と同じようにローカル・スタックを調整する必要があります。
ただし、 戻らずにその後ろへ流れる場合は、 ローカル・スタックを変更してはなりません。 コンパイラは以下のコードを生成します:
@format
@code{?branch-lp+!#} <begin> current-locals-size @minus{} dest-locals-size
@end format
ローカル・スタック・ポインタは、 分岐が行われた場合にのみ調整されます。

@code{THEN} は、 やや非効率なコードを生成する可能性があります:
@format
@code{lp+!#} current-locals-size @minus{} orig-locals-size
<orig target>:
@code{lp+!#} orig-locals-size @minus{} new-locals-size

@end format
2 番目の @code{lp+!#} は、 ローカル・スタック・ポインタを @i{orig} 時点のレベルから  @code{THEN}
の後のレベルに調整します。 最初の @code{lp+!#} は、 ローカル・スタック・ポインタを現在のレベルから orig
時点のレベルに調整するため、 完全な効果は、@code{THEN} の後の現在のレベルから正しいレベルに調整されることになります。

@cindex locals information on the control-flow stack
@cindex control-flow stack items, locals information
従来の Forth の実装では、 dest 制御フロー・スタック・エントリはターゲット・アドレスにすぎず、 orig
エントリはパッチ当てされるアドレスにすぎません。 ローカル変数の実装は、 すべての orig または dest 項目にワードリストを追加します。
これは、 エントリによって記述された時点で可視である(または可視である想定される)ローカル変数のリストです。 私たちの実装では、
エントリの種類を識別するためのタグも追加します。 特に、
生きているのと死んでいるエントリ(到達可能なエントリと到達不可能なエントリ)を区別するためです。

ローカル変数のワードリストに対して、 いくつかの珍しい操作を実行する必要があります:

@findex common-list ( @var{ list1 list2 -- list3   } ) gforth-internal
@cindex @code{common-list}
@kindex common-list
@format
@code{common-list} ( @i{list1 list2 -- list3  }) gforth-internal ``common-list''
@end format

@findex sub-list? ( @var{ list1 list2 -- f   } ) gforth-internal
@cindex @code{sub-list?}
@kindex sub-list?
@format
@code{sub-list?} ( @i{list1 list2 -- f  }) gforth-internal ``sub-list?''
@end format

@findex list-size ( @var{ list -- u   } ) gforth-internal
@cindex @code{list-size}
@kindex list-size
@format
@code{list-size} ( @i{list -- u  }) gforth-internal ``list-size''
@end format



ローカル変数のワードリスト実装のいくつかの機能により、 これらの操作の実装が簡単になります。
ローカル変数のワードリストはリンクされたリストとして編成されます。 リストに同一のローカル変数が含まれている場合、 これらのリストの末尾は共有されます。
名前のアドレスは、 リスト内でその後ろにある名前のアドレスよりも大きくなります。

もう 1 つの重要な実装の詳細は、 変数 @code{dead-code} です。これは、 @code{BEGIN} と @code{THEN}
によって直接到達できるか、 解決するブランチ経由でのみ到達できるかを判断するために使用されます。 @code{dead-code} は
@code{UNREACHABLE} や @code{AHEAD} や @code{EXIT} などによって設定され、 コロン定義の先頭 や
@code{BEGIN} や 通常は @code{THEN} によってクリアされます。.

カウンタ付きループはほとんどの点で他のループと似ていますが、 @code{LEAVE} には特別な注意が必要です。 基本的に @code{AHEAD}
と同じサービスを実行しますが、 制御フロー・スタック・エントリは作成されません。 したがって、 情報は別の場所に保存する必要があります。 従来、 情報は
@code{LEAVE} によって作成されたブランチのターゲット・フィールドに、
これらのフィールドをリンク・リストに編成することによって格納されていました。 残念ながら、 この巧妙なトリックでは、
拡張制御フロー情報を保存するための十分なスペースが提供されません。 したがって、 別のスタックである Leave スタックを導入します。 これには、
すべての未解決の @code{LEAVE} の制御フロー・スタック・エントリが含まれています。

ローカル変数名は、 どの制御フロー経路にも表示されなくなった場合でも、 コロン定義の終わりまで保持されます。 場合によっては、
これによりローカル変数の名前領域に必要な領域が増加する可能性がありますが、 通常はこの領域を再利用するよりもコード量にかかるコストは少なくなります。

@node Closures, , Locals implementation, Gforth locals
@subsubsection Closures
@cindex closures

Gforth は基礎的なクロージャ(closure)も提供します。  クロージャは、
引用(quotation)(@pxref{Quotations})とローカル変数の組み合わせです。  Gforth のクロージャには、
クロージャの実行時に値が入力されるローカル変数があり、 トランポリン xt (trampoline xt)が生成されます。  そのトランポリン xt を
execute すると、 ローカル・スタック上のクロージャのローカル変数にアクセスして、 クロージャのコードが実行されます。
クロージャのローカル変数の変更は永続的ではありません。 つまり、 クロージャが @code{EXIT} されると、 変更された値は失われます。

@findex [@{: ( @var{ -- hmaddr u latest latestnt wid 0   } ) gforth-experimental
@cindex @code{[@{:}
@kindex [@{:
@format
@code{[@{:} ( @i{-- hmaddr u latest latestnt wid 0  }) gforth-experimental ``start-closure''
@end format
クロージャを開始します。  クロージャはまず、 クロージャのために使用するローカル変数フレームを宣言し、
次にそれらのローカル変数で実行されるコードを宣言します。  クロージャは引用(quotations)のように @code{;]} で終わります。
ローカル宣言は、 クロージャ・ローカルが作成される場所に応じて終了します。  実行時、 クロージャは トランポリン xt として作成され、
スタックからローカル変数・フレームの値を埋めます。  xt の実行時に、 ローカル変数・フレームがローカル・スタックにコピーされ、
クロージャのコード内で使用されます。  戻った後、 これらの値はローカル・スタックから削除され、 クロージャ自体は更新されません。


@findex :@}l ( @var{ hmaddr u latest latestnt wid 0 a-addr1 u1 ... --   } ) gforth-1.0
@cindex @code{:@}l}
@format
@code{:@}l} ( @i{hmaddr u latest latestnt wid 0 a-addr1 u1 ... --  }) gforth-1.0 ``close-brace-locals''
@end format
クロージャ・ローカルの宣言を終了します。 クロージャはローカル・スタックに割り当てられます。


@findex :@}d ( @var{ hmaddr u latest latestnt wid 0 a-addr1 u1 ... --   } ) gforth-1.0
@cindex @code{:@}d}
@format
@code{:@}d} ( @i{hmaddr u latest latestnt wid 0 a-addr1 u1 ... --  }) gforth-1.0 ``colon-close-brace-d''
@end format
クロージャ・ローカル宣言を終了します。  クロージャはディクショナリに割り当てられます。


@findex :@}h ( @var{ hmaddr u latest latestnt wid 0 a-addr1 u1 ... --   } ) gforth-1.0
@cindex @code{:@}h}
@format
@code{:@}h} ( @i{hmaddr u latest latestnt wid 0 a-addr1 u1 ... --  }) gforth-1.0 ``colon-close-brace-h''
@end format
クロージャ・ローカル宣言を終了します。  クロージャーはヒープに割り当てられます。


@findex :@}h1 ( @var{ hmaddr u latest latestnt wid 0 a-addr1 u1 ... --   } ) gforth-1.0
@cindex @code{:@}h1}
@format
@code{:@}h1} ( @i{hmaddr u latest latestnt wid 0 a-addr1 u1 ... --  }) gforth-1.0 ``colon-close-brace-h''
@end format
クロージャ・ローカル宣言を終了します。  クロージャーはヒープに割り当てられます。


@findex :@}xt ( @var{ hmaddr u latest latestnt wid 0 a-addr1 u1 ... --   } ) gforth-1.0
@cindex @code{:@}xt}
@format
@code{:@}xt} ( @i{hmaddr u latest latestnt wid 0 a-addr1 u1 ... --  }) gforth-1.0 ``colon-close-brace-x-t''
@end format
クロージャ・ローカル宣言を終了します。  クロージャは xt によってスタック上に割り当てられるため、 クロージャの実行時のスタック効果は
@code{( xt-alloc -- xt-closure )} となります。


@findex >addr ( @var{ xt -- addr   } ) gforth-experimental
@cindex @code{>addr}
@kindex >addr
@format
@code{>addr} ( @i{xt -- addr  }) gforth-experimental ``to-addr''
@end format
(@code{free-closure} から呼び出されます)ヒープ上のクロージャの xt を @var{addr} に変換し、 @code{free}
に渡すことでクロージャを削除できます。


@findex free-closure ( @var{ xt --   } ) gforth-internal
@cindex @code{free-closure}
@kindex free-closure
@format
@code{free-closure} ( @i{xt --  }) gforth-internal ``free-closure''
@end format
ヒープに割り当てられたクロージャを解放(free)します



@example
: foo [@{: a f: b d: c xt: d :@}d a . b f. c d. d ;] ;
5 3.3e #1234. ' cr foo execute
@end example

上記 @code{foo} は、 単一セルと浮動小数点数と2倍長整数と xt を含むクロージャをディクショナリ内に作成し、呼び出し時に最初の 3
つの値を出力後に xt を実行します。

これにより、 Algol コンパイラをテストするために 1964 年にドナルド・クヌースが提案した ``Man or boy test''
を実装することができます(訳注: 手元ではサッパリ動いてない(0.7.9_20240418, 2024.7))

@example
: A @{: w^ k x1 x2 x3 xt: x4 xt: x5 | w^ B :@} recursive
    k @ 0<= IF  x4 x5 f+  ELSE
        B k x1 x2 x3 action-of x4 [@{: B k x1 x2 x3 x4 :@}L
            -1 k +!
            k @ B @ x1 x2 x3 x4 A ;] dup B !
        execute  THEN ;
: man-or-boy? ( n -- ) [: 1e ;] [: -1e ;] 2dup swap [: 0e ;] A f. ;
@end example

場合によっては、 クロージャを変更するには永続的なストレージが必要です。 複数のクロージャがその永続ストレージを共有する可能性さえあります。
上の例では、 外部プロシージャのローカル変数がこれに使用されていますが、 場合によっては、 クロージャが外部プロシージャよりも長く存続します。 特に、
ディクショナリまたはヒープ上に割り当てられたクロージャは、 親プロシージャより長く存続するように設計されています。

これらについては、 クロージャのように割り当てられるホーム・ロケーション(home locations)がありますが、
そのコードは作成時に直接実行され、 ホーム・ロケーションのアドレスを提供する必要があります。

@example
: bar ( a b c -- aaddr baddr caddr hl-addr )
    <@{: w^ a w^ b w^ c :@}h a b c ;> ;
@end example

この例では、 ヒープ上に 3 つのセルを持つホーム・ロケーション(home location)を作成し、 3
つのロケーションのアドレスとホーム・ロケーションのアドレスを返します。  このアドレスは、 ホーム・ロケーションが不要になったときに
@code{free} するために使用できます。

@findex <@{: ( @var{ -- hmaddr u latest latestnt wid 0   } ) gforth-experimental
@cindex @code{<@{:}
@kindex <@{:
@format
@code{<@{:} ( @i{-- hmaddr u latest latestnt wid 0  }) gforth-experimental ``start-homelocation''
@end format
ホーム・ロケーション(home location)の開始


@findex ;> ( @var{ --   } ) gforth-experimental
@cindex @code{;>}
@kindex ;>
@format
@code{;>} ( @i{--  }) gforth-experimental ``end-homelocation''
@end format
ホーム・ロケーションの終了



@node Standard Forth locals, , Gforth locals, Locals
@subsection Standard Forth locals
@cindex locals, Standard Forth style

Forth-2012 標準では、 Gforth のローカル変数の制限付きバージョンであるローカル変数構文が定義されています:

@itemize @bullet
@item
ローカル変数はセル・サイズの値のみにすることができます(型指定子は許可されません)。
@item
ローカル変数は制御構造の外側でのみ定義できます。
@item
定義ごとに許可されるローカル変数定義は 1 つだけです。
@item
ローカル変数は、 リターン・スタックの明示的な使用を妨げる可能性があります。 正確な(そして長い)ルールについては、 標準を参照してください。
ローカル変数を使用している定義でリターン・スタックにアクセスするワードを使用しない場合は問題ありません。 このルールの目的は、
リターン・スタックを使ったローカル変数の実装を容易にすることです。
@item
ローカル変数定義全体を 1 行に含める必要があります。
@end itemize

標準 Forth ローカル変数ワードセット自体は @code{@{:} と 以下の 2 つのワードで構成されます:

@findex (local) ( @var{ addr u --   } ) local
@cindex @code{(local)}
@kindex (local)
@format
@code{(local)} ( @i{addr u --  }) local ``paren-local-paren''
@end format


ANS Forth ローカル変数拡張ワードセット(ANS Forth locals extension wordset)は @code{locals|}
を使用して構文を定義しますが、 これはとても酷い代物なので、 使用しないことを強くお勧めします。 Gforth
への移植を容易にするためにこの構文を実装しましたが、 ここでは文書化しません。 この構文の問題は、
ローカル変数が標準のスタック・コメント表記とは逆の順序で定義されているため、 プログラムが読みにくくなり、
読み間違いや書き間違いが起こりやすくなることです。 この構文の唯一の利点は、 ANS Forth
ローカル変数ワードセットを使用して実装が簡単であることですが、 @code{@{:} 構文だって同じくらい実装は簡単ですからね？

@c ----------------------------------------------------------
@node Structures, Object-oriented Forth, Locals, Words
@section Structures
@cindex structures
@cindex records

このセクションでは、 Gforth に付属する構造体パッケージを紹介します。 標準 Forth で実装されたパッケージのバージョンは、
@file{compat/struct.fs} で入手できます。 このパッケージは、 1989 年の comp.lang.forth
への投稿に触発されました(残念ながら、誰による投稿かは覚えていません。おそらく John Hayes によるものでしょう)。
このセクションのバージョンは、 M. Anton Ertl,
@uref{https://www.complang.tuwien.ac.at/forth/objects/structs.html, Yet
Another Forth Structures Package}, Forth Dimensions 19(3), pages 13--16 です。
Marcel Hendrix は有益なコメントを提供してくれました。

@menu
* Why explicit structure support?::
* Structure Usage::
* Structure Naming Convention::
* Structure Implementation::
* Structure Glossary::
* Forth200x Structures::     
@end menu

@node Why explicit structure support?, Structure Usage, Structures, Structures
@subsection Why explicit structure support?

@cindex address arithmetic for structures
@cindex structures using address arithmetic
複数のフィールドを含む構造体を使用したい場合は、 その構造体用にメモリを予約し、
アドレス算術演算を使用してフィールドにアクセスするだけです(@pxref{Address arithmetic})。 例として、
以下のフィールドを持つ構造体を考えてみましょう

@table @code
@item a
これは浮動小数点数(float)です
@item b
これはセル(cell)です
@item c
これは浮動小数点数(float)です
@end table

構造体の (float 整列された) ベース・アドレスが与えられると、

@table @code
@item a
それ以上何もせずに a フィールドが得られます。
@item b
@code{float+} すると b フィールドが得られます。
@item c
@code{float+ cell+ faligned} すると c フィールドが得られます。
@end table

これが非常に疲れる可能性があることは容易にわかります。 

さらに加えて、 @code{cell+} を見ても、 どの構造体がアクセスされているか、 どのフィールドがアクセスされているかがわからないため、
あまり読みやすくありません。 何らかの方法で構造体の種類を推測し、
その構造体のどのフィールドがそのオフセットに対応するかをドキュメントで調べる必要があります。

最後に、 この種のアドレス計算はメンテナンスの問題も引き起こします。 構造体の途中にフィールドを追加・削除した場合、
その後フィールドのすべてのアドレス計算を探し出して変更する必要があります。

そこで、 @code{cell+} とそのファミリーを直接使用する代わりに、 以下のようにオフセットを定数に保存してはどうでしょうか？:

@example
0 constant a-offset
0 float+ constant b-offset
0 float+ cell+ faligned c-offset
@end example

これで、 @code{x-offset +} を使用してフィールド @code{x} のアドレスを取得できるようになりました。
これはあらゆる点ではるかに優れています。 もちろん、 フィールドを追加する場合は、 その後のオフセット定義をすべて変更する必要があります。 これは、
以下の方法でオフセットを宣言することで改良できます:

@example
0 constant a-offset
a-offset float+ constant b-offset
b-offset cell+ faligned constant c-offset
@end example

オフセット計算にはいつも @code{+} を使うので、 定義されたワードのアクションに @code{+} を含む定義ワード @code{cfield}
を使用できます:

@example
: cfield ( n "name" -- )
    create ,
does> ( name execution: addr1 -- addr2 )
    @@ + ;

0 cfield a
0 a float+ cfield b
0 b cell+ faligned cfield c
@end example

今や、 @code{x-offset +} の代わりに、 単に @code{x} と書くことができるようになりました。

構造体フィールドのワード群が非常にうまく使用できるようになりました。 ただし、 その定義はまだ少し面倒です。 名前を繰り返す必要があり、
サイズと配置に関する情報はフィールド定義の前後に配置されます。 このセクションで紹介する構造体パッケージは、 これらの問題に対処します。

@node Structure Usage, Structure Naming Convention, Why explicit structure support?, Structures
@subsection Structure Usage
@cindex structure usage

@cindex @code{field} usage
@cindex @code{struct} usage
@cindex @code{end-struct} usage
以下のコマンドを使用して、 (データのない)リンク・リストの構造体を定義できます(訳注: これは構造体テンプレートを定義するだけです。
構造体変数とするには別途 @code{%alloc} 等する必要があります):
@example
struct
    cell% field list-next
end-struct list%
@end example

スタック上のリスト・ノードのアドレスを使用して、 @code{list-next}
を使用して次のノードのアドレスを含むフィールドのアドレスを計算できます。 たとえば、 以下のようにしてリストの長さを決定できます:

@example
: list-length ( list -- n )
\ "list" is a pointer to the first element of a linked list
\ "n" is the length of the list
    0 BEGIN ( list1 n1 )
        over
    WHILE ( list1 n1 )
        1+ swap list-next @@ swap
    REPEAT
    nip ;
@end example

@code{list% %allot} を使用すると、 ディクショナリ内にリスト・ノード用のメモリを確保でき、 これにより、
リスト・ノードのアドレスがスタック上に残ります。ヒープ上で同様の割り当てを行うには、 @code{list% %alloc}
を使用できます(または、@code{allocate} のようなスタック効果(つまり、ior を使用)が欲しい場合は、 @code{list%
%allocate} を使用します)。 リスト・ノードのサイズは @code{list% %size} で取得でき、 そのセル・アライメントは
@code{list% %alignment} で取得できます。

注意: 標準 Forth では、 @code{create} されたワードの本体は @code{aligned} されていますが、 必ずしも
@code{faligned} されている訳ではない事に注意してください。したがって、 以下のようにすると:

@example
create "name" foo% %allot drop
@end example

@noindent
この場合、 @code{foo%} に割り当てられたメモリは、 @code{foo%}
に文字フィールドやセル・フィールドや2倍長整数フィールドのみが含まれている場合にのみ、 @code{@emph{name}}
の本体から開始されることが保証されます。 したがって、 浮動小数点数が含まれる場合は、以下を使用することをお勧めします

@example
foo% %allot constant "name"
@end example

@cindex structures containing structures
以下のように、 構造体 @code{foo%} を別の構造体のフィールドとして含めることができます:
@example
struct
...
    foo% field ...
...
end-struct ...
@end example

@cindex structure extension
@cindex extended records
構造体をいちから構築する代わりに、 既存の構造体を拡張できます。 たとえば、 上記例で定義したような、
データのない単純なリンク・リストはほとんど役に立ちません。 これを以下のように、
整数の値を持つリンク・リストに拡張できます:@footnote{この機能は「拡張レコード」(extended records)とも呼ばれます。 これは、
オベロン・プログラミング言語が成した主な革新です。 言い換えれば、 この機能を Modula-2 に追加することで、 Wirth は新しい言語を作成し、
新しいコンパイラの記述等を行いました。 この機能を Forth に追加するには、 数行のコードが必要なだけでした。}

@example
list%
    cell% field intlist-int
end-struct intlist%
@end example

@code{intlist%} は、 @code{list-next} と @code{intlist-int} の 2
つのフィールドを持つ構造体です。

@cindex structures containing arrays
以下のように、 @i{n} 要素の  @code{foo%} 型を含む配列型を指定できます:

@example
foo% @i{n} *
@end example

この配列型は、 通常の型を使用できる場所であればどこでも使用できます(例: @code{field} を定義する場所や @code{%allot}
を使用するとき)。

@cindex first field optimization
最初のフィールドは構造体のベース・アドレスにあり、 この、 最初のフィールドのワード(例:
@code{list-next})は実際にはスタック上のアドレスを変更しません。 あなたは実行時間と領域の効率を考慮して、
最初のフィールドのワードを取り除きたいとと思うかもしれません。 しかし、 構造体パッケージがこの場合を最適化するため、 そのは必要ありません。
最初のフィールドのワードをコンパイルする場合、 コードは生成されません。 したがって、 読みやすさと保守性を考慮して、
最初のフィールドにアクセスするときにその最初のフィールドのワードは含めるべきです。


@node Structure Naming Convention, Structure Implementation, Structure Usage, Structures
@subsection Structure Naming Convention
@cindex structure naming convention

(構造体の命名規則)(私が)思いつくフィールド名は非常に汎用的なものが多く、 使用すると頻繁に名前の衝突が発生します。 たとえば、
多くの構造体にはたいてい @code{counter} フィールドが含まれています。 (私の)頭に浮かぶ構造体名は、 多くの場合、
そのような構造体を作成するワードの名前の論理的な選択でもあります。

したがって、 私は以下の命名規則を採用しました: 

@itemize @bullet
@cindex field naming convention
@item
フィールド名の形式は @code{@emph{struct}-@emph{field}} です。 @code{struct}
は構造体の基本名、@code{field} はフィールドの基本名です。 フィールド・ワードは、
構造体(のアドレス)をフィールド(のアドレス)に変換するものと考えることができます。

@cindex structure naming convention
@item
構造体の名前は @code{struct%} の形式で、 @code{struct} は構造体の基本名です。
@end itemize

この命名規則は、 拡張構造体のフィールドではあまり機能しません。 たとえば、 上記例の整数リスト構造体にはフィールド
@code{intlist-int} がありますが、 @code{intlist-next} ではなく @code{list-next} があります。

@node Structure Implementation, Structure Glossary, Structure Naming Convention, Structures
@subsection Structure Implementation
@cindex structure implementation
@cindex implementation of structures

この実装の核となるアイデアは、 構築されている構造体に関するデータをグローバル変数ではなくスタックに渡すことです。 この設計上の決定が下されると、
他のすべては自然に配置されます。

スタック上の型の説明は @i{align size} の形式です。 サイズをスタックのTOSに維持すると、 配列の処理が非常に簡単になります。

@code{field} は、 @code{Create} と @code{DOES>} を使用する定義ワードです。
フィールドの本体にはフィールドのオフセットが含まれており、 通常の @code{DOES>} アクションは以下のようになります:

@example
@@ +
@end example

@noindent
つまり、 アドレスにオフセットを加算して、 フィールドのスタック効果 @i{addr1 -- addr2} を与えます。

@cindex first field optimization, implementation
この単純な構造は、 オフセット 0 のフィールドの最適化によって少し複雑になります。 これには、 別の @code{DOES>}
部分が必要です(そのようなフィールドがコンパイル中に呼び出された場合、 スタック上に何かがあることに依存できないため)。 したがって、 異なる
@code{DOES>} 部分を別々のワードに配置し、 オフセットに基づいてどれを呼び出すかを決定します。 ゼロ・オフセットの場合、
フィールドは基本的に noop です。 これは即実行ワードであるため、 コンパイル時にコードは生成されません。

@node Structure Glossary, Forth200x Structures, Structure Implementation, Structures
@subsection Structure Glossary
@cindex structure glossary


@findex %align ( @var{ align size --   } ) gforth-0.4
@cindex @code{%align}
@kindex %align
@format
@code{%align} ( @i{align size --  }) gforth-0.4 ``%align''
@end format
データ空間ポインタをアラインメント @var{align} に整列(align)します。 


@findex %alignment ( @var{ align size -- align   } ) gforth-0.4
@cindex @code{%alignment}
@kindex %alignment
@format
@code{%alignment} ( @i{align size -- align  }) gforth-0.4 ``%alignment''
@end format
構造体のアライメント


@findex %alloc ( @var{ align size -- addr   } ) gforth-0.4
@cindex @code{%alloc}
@kindex %alloc
@format
@code{%alloc} ( @i{align size -- addr  }) gforth-0.4 ``%alloc''
@end format
サイズ @var{size} のアドレス・ユニットをアラインメント @var{align} で整列(align)して割り当て、
割り当てたデータ・ブロックのアドレスを @var{addr} に返します。 成功しなかった場合は負数の @i{ior} を @code{throw}
します。


@findex %allocate ( @var{ align size -- addr ior   } ) gforth-0.4
@cindex @code{%allocate}
@kindex %allocate
@format
@code{%allocate} ( @i{align size -- addr ior  }) gforth-0.4 ``%allocate''
@end format
@code{allocate} と同様に、 サイズ @var{size} のアドレス単位をアライメント @var{align}
で整列(align)して割り当て、 割り当てたデータ・ブロックのアドレスを @var{addr} に返します。 成功した場合、 @i{ior}=0,
成功しなかった場合は @i{ior}<0


@findex %allot ( @var{ align size -- addr   } ) gforth-0.4
@cindex @code{%allot}
@kindex %allot
@format
@code{%allot} ( @i{align size -- addr  }) gforth-0.4 ``%allot''
@end format
データ空間にサイズ @var{size} アドレス単位をアラインメント @var{align} で割り当てます。 結果のデータ・ブロックのアドレスを
@var{addr} に返します。


@findex cell% ( @var{ -- align size   } ) gforth-0.4
@cindex @code{cell%}
@kindex cell%
@format
@code{cell%} ( @i{-- align size  }) gforth-0.4 ``cell%''
\訳注: セル1つ分のサイズ @i{size} と、 サイズをアライメントした @i{align} を返す
@end format

@findex char% ( @var{ -- align size   } ) gforth-0.4
@cindex @code{char%}
@kindex char%
@format
@code{char%} ( @i{-- align size  }) gforth-0.4 ``char%''
\訳注: char 1つ分のサイズ @i{size} と、 そのサイズをアライメントした @i{align} を返します
@end format

@findex dfloat% ( @var{ -- align size   } ) gforth-0.4
@cindex @code{dfloat%}
@kindex dfloat%
@format
@code{dfloat%} ( @i{-- align size  }) gforth-0.4 ``dfloat%''
@end format

@findex double% ( @var{ -- align size   } ) gforth-0.4
@cindex @code{double%}
@kindex double%
@format
@code{double%} ( @i{-- align size  }) gforth-0.4 ``double%''
\訳注: 2倍長整数1つ分のサイズ @i{size} と、サイズをアライメントした @i{align} を返します
@end format

@findex end-struct ( @var{ align size "name" --   } ) gforth-0.2
@cindex @code{end-struct}
@kindex end-struct
@format
@code{end-struct} ( @i{align size "name" --  }) gforth-0.2 ``end-struct''
@end format
アライメント @var{align} とサイズ @var{size} を使用して 構造体/型記述子 @var{name}
を定義します(@var{size} は @var{align} の倍数になるように切り上げられます -- @i{size1})。 @code{name}
実行時: ( -- @var{align size1})


@findex field ( @var{ align1 offset1 align size "name" --  align2 offset2   } ) gforth-0.2
@cindex @code{field}
@kindex field
@format
@code{field} ( @i{align1 offset1 align size "name" --  align2 offset2  }) gforth-0.2 ``field''
@end format
オフセット @var{offset1} と @var{align size} で指定された型を持つフィールド  @var{name} を作成します。
@var{offset2} は次のフィールドのオフセットで、@var{align2} は、 (そこまでの)すべてのフィールドのアライメントです。
@code{name} の実行時: ( @var{addr1} -- @var{addr2} )
@var{addr2}=@var{addr1}+@var{offset1}


@findex float% ( @var{ -- align size   } ) gforth-0.4
@cindex @code{float%}
@kindex float%
@format
@code{float%} ( @i{-- align size  }) gforth-0.4 ``float%''
@end format

@findex sfloat% ( @var{ -- align size   } ) gforth-0.4
@cindex @code{sfloat%}
@kindex sfloat%
@format
@code{sfloat%} ( @i{-- align size  }) gforth-0.4 ``sfloat%''
@end format

@findex %size ( @var{ align size -- size   } ) gforth-0.4
@cindex @code{%size}
@kindex %size
@format
@code{%size} ( @i{align size -- size  }) gforth-0.4 ``%size''
@end format
構造体のサイズを返す


@findex struct ( @var{ -- align size   } ) gforth-0.2
@cindex @code{struct}
@kindex struct
@format
@code{struct} ( @i{-- align size  }) gforth-0.2 ``struct''
@end format
空の構造体。 構造体定義を開始するために使用されます。




@node Forth200x Structures, , Structure Glossary, Structures
@subsection Forth200x Structures
@cindex Structures in Forth200x

Forth 2012 標準では、 やや不便な形式の構造体が定義されています。  一般に @code{field+} を使用する場合は、
自分でアライメントを行う必要がありますが、 アライメント機能を含む便利なワード(例: @code{field:})が多数あります。

典型的な使用例は以下のとおりです:

@example
0
  field:                   s-a
  faligned 2 floats +field s-b
constant s-struct
@end example

この構造体を記述する別の方法は以下のとおりです:

@example
begin-structure s-struct
  field:                   s-a
  faligned 2 floats +field s-b
end-structure
@end example

以下のように、 同一のフィールドと追加のフィールドを持つ構造体を定義できます:

@example
s-struct
  cfield: t-c
  cfield: t-d
constant t-struct
@end example

あるいは、

@example
s-struct extend-structure t-struct
  cfield: t-c
  cfield: t-d
end-structure
@end example

@findex begin-structure ( @var{ "name" -- struct-sys 0   } ) facility-ext
@cindex @code{begin-structure}
@kindex begin-structure
@format
@code{begin-structure} ( @i{"name" -- struct-sys 0  }) facility-ext ``begin-structure''
@end format

@findex extend-structure ( @var{ n "name" -- struct-sys n   } ) gforth-1.0
@cindex @code{extend-structure}
@kindex extend-structure
@format
@code{extend-structure} ( @i{n "name" -- struct-sys n  }) gforth-1.0 ``extend-structure''
@end format
サイズ @i{n} の既存の構造体の拡張として、 新しい構造体 @i{name} を開始します。


@findex end-structure ( @var{ struct-sys +n --   } ) facility-ext
@cindex @code{end-structure}
@kindex end-structure
@format
@code{end-structure} ( @i{struct-sys +n --  }) facility-ext ``end-structure''
@end format
@code{begin-struction} で開始された構造体を終了します


@findex +field ( @var{ noffset1 nsize "name" -- noffset2   } ) facility-ext
@cindex @code{+field}
@kindex +field
@format
@code{+field} ( @i{noffset1 nsize "name" -- noffset2  }) facility-ext ``plus-field''
@end format
定義ワード。 @i{name} @code{( addr1 -- addr2 )} を定義します。 ここで、 @i{addr2} は
@i{addr1+noffset1} です。  @i{noffset2} は @i{noffset1+nsize} です。


@findex cfield: ( @var{ u1 "name" -- u2   } ) facility-ext
@cindex @code{cfield:}
@kindex cfield:
@format
@code{cfield:} ( @i{u1 "name" -- u2  }) facility-ext ``c-field-colon''
@end format
文字サイズのフィールドを定義します


@findex field: ( @var{ u1 "name" -- u2   } ) facility-ext
@cindex @code{field:}
@kindex field:
@format
@code{field:} ( @i{u1 "name" -- u2  }) facility-ext ``field-colon''
@end format
アライメントされたセル・サイズのフィールドを定義します


@findex 2field: ( @var{ u1 "name" -- u2   } ) gforth-0.7
@cindex @code{2field:}
@kindex 2field:
@format
@code{2field:} ( @i{u1 "name" -- u2  }) gforth-0.7 ``two-field-colon''
@end format
アライメントされた2倍長セル・サイズのフィールドを定義します


@findex ffield: ( @var{ u1 "name" -- u2   } ) floating-ext
@cindex @code{ffield:}
@kindex ffield:
@format
@code{ffield:} ( @i{u1 "name" -- u2  }) floating-ext ``f-field-colon''
@end format
アライメントされた浮動小数点サイズのフィールドを定義します


@findex sffield: ( @var{ u1 "name" -- u2   } ) floating-ext
@cindex @code{sffield:}
@kindex sffield:
@format
@code{sffield:} ( @i{u1 "name" -- u2  }) floating-ext ``s-f-field-colon''
@end format
sfaligned された sfloat サイズのフィールドを定義します


@findex dffield: ( @var{ u1 "name" -- u2   } ) floating-ext
@cindex @code{dffield:}
@kindex dffield:
@format
@code{dffield:} ( @i{u1 "name" -- u2  }) floating-ext ``d-f-field-colon''
@end format
dfaligned された dfloat サイズのフィールドを定義します


@findex wfield: ( @var{ u1 "name" -- u2   } ) gforth-1.0
@cindex @code{wfield:}
@kindex wfield:
@format
@code{wfield:} ( @i{u1 "name" -- u2  }) gforth-1.0 ``w-field-colon''
@end format
16 ビット値のアライメントされたフィールドを定義します。


@findex lfield: ( @var{ u1 "name" -- u2   } ) gforth-1.0
@cindex @code{lfield:}
@kindex lfield:
@format
@code{lfield:} ( @i{u1 "name" -- u2  }) gforth-1.0 ``l-field-colon''
@end format
32ビット値にアライメントされたフィールドを定義します。


@findex xfield: ( @var{ u1 "name" -- u2   } ) gforth-1.0
@cindex @code{xfield:}
@kindex xfield:
@format
@code{xfield:} ( @i{u1 "name" -- u2  }) gforth-1.0 ``x-field-colon''
@end format
64ビット値にアライメントされたフィールドを定義します。



@c -------------------------------------------------------------
@node Object-oriented Forth, Regular Expressions, Structures, Words
@section Object-oriented Forth

Gforth には、オブジェクト指向プログラミング用の 3 つのパッケージ (@file{objects.fs} と @file{oof.fs} と
@file{mini-oof.fs}) が付属しています。 どれも最初から組み込まれていないため、 使用する前にインクルードする必要があります。
これらのパッケージ(および、 その他のパッケージ)の最も重要な違いについては、 @ref{Comparison with other object
models} で説明します。 すべてのパッケージは 標準 Forth で書かれており、 他の 標準 Forth でも使用できます。

@menu
* Why object-oriented programming?::
* Object-Oriented Terminology::
* Objects::
* OOF::
* Mini-OOF::
* Mini-OOF2::
* Comparison with other object models::  
@end menu

@c ----------------------------------------------------------------
@node Why object-oriented programming?, Object-Oriented Terminology, Object-oriented Forth, Object-oriented Forth
@subsection Why object-oriented programming?
@cindex object-oriented programming motivation(オブジェクト指向プログラミングの動機)
@cindex motivation for object-oriented programming

@comment TODO add some other operations eg perimeter, area
@comment and tie in to concrete examples later..
多くの場合、 いくつかのデータ構造「オブジェクト」(object)を扱わなければなりません。 それらは、 いつくかの側面では同様に扱う必要がありますが、
それ以外の側面では異なる扱いをしなければなりません。 グラフィカル・オブジェクトとは教科書的な例で言えば、 円や三角形や恐竜の絵やアイコン等ですが、
プログラム開発中にさらに追加することもできます。 あなたが、 任意のグラフィカル・オブジェクトにいくつかの操作を適用したいとしましょう。 たとえば、
画面上に表示するための @code{draw} 操作です。 しかしながら、 この @code{draw}
はオブジェクトの種類ごとに異なる処理を行う必要があります。

@code{draw} を、 描画されるオブジェクトの種類に依存して適切なコードを実行する、 大きな @code{CASE}
制御構造として実装することはできます。 これはあまり洗練されたものではなく、 さらに、
新しい種類のグラフィック・オブジェクト(例えば宇宙船など)を追加するたびに @code{draw} を変更する必要があります。

私たちがやりたいことは、 宇宙船を定義するときにシステムに次のように指示することです: 「宇宙船を @code{draw}
する方法は私たちがこれこれこのとおり書いたので、 それ以外の処理はシステム側でよしなしにしてください」

@comment TODO ?list properties of oo systems.. oo vs o-based?
これは、 (当然ながら、 )オブジェクト指向と呼ばれるすべてのシステムで解決すべき問題です。 ここで紹介するオブジェクト指向パッケージは、
この問題を解決します(それ以外の問題はあんまり解決できません…)。

@c ------------------------------------------------------------------------
@node Object-Oriented Terminology, Objects, Why object-oriented programming?, Object-oriented Forth
@subsection Object-Oriented Terminology
@cindex object-oriented terminology(オブジェクト指向用語)
@cindex terminology for object-oriented programming

このセクションは主にリファレンスであるため、 すぐにすべてを理解する必要はありません。  用語は主に Smalltalk
からインスピレーションを得たものです:

@table @emph
@cindex クラス(class)
@item クラス(class)
いくつかの追加機能を備えたデータ構造定義。

@cindex オブジェクト(object)
@item オブジェクト(object)
クラス定義によって記述されたデータ構造の実体(インスタンス;instance)。

@cindex インスタンス変数(instance variables)
@item インスタンス変数(instance variables)
データ構造のフィールド。

@cindex セレクター(selector)
@cindex method selector
@cindex virtual function
@item セレクター(selector)
(または「メソッド・セレクター」)さまざまなデータ構造(クラス)に対して操作を実行するワード(例: @code{draw})。 セレクターは、
「何の」(what)操作を行うかを記述します。 C++ 用語では (純粋)仮想関数 と言います

@cindex メソッド(method)
@item メソッド(method)
特定のクラスのセレクターによって記述された操作を実行する具体的な定義。 メソッドは、
特定のクラスに対して「どのように」(how)操作が実行されるかを指定します。

@cindex セレクター呼び出し(selector invocation)
@cindex message send
@cindex invoking a selector
@item セレクター呼び出し(selector invocation)
セレクターの呼び出し。 呼び出しの 1 つの引数(TOS(スタックの頂上))は、 どのメソッドが使用されるかを決定するために使用されます。
Smalltalk の用語では、 (セレクターとその他の引数で構成される、)メッセージがオブジェクトに送信される と言います。

@cindex 受信オブジェクト(receiving object)
@item 受信オブジェクト(receiving object)
セレクターの呼び出しによって実行されるメソッドを決定するために使用されるオブジェクト。  @file{objects.fs} モデルでは、
セレクターが呼び出されたときに TOS 上にあるオブジェクトです。 (「受信」という言葉は、 Smalltalk の 「メッセージ」関連用語由来です。)

@cindex 子クラス(child class)
@cindex parent class(親クラス)
@cindex inheritance(継承)
@item 子クラス(child class)
「親クラス」のすべてのプロパティ(インスタンス変数やセレクターやメソッド)を「継承」(inherit)したクラス。  Smalltalk の用語では、
サブクラスはスーパークラスを継承します、 と言います。 C++ 用語では、 派生クラスは基底クラスから継承します(The derived class
inherits from the base class.)、 と言います。

@end table

@c If you wonder about the message sending terminology, it comes from
@c a time when each object had it's own task and objects communicated via
@c message passing; eventually the Smalltalk developers realized that
@c they can do most things through simple (indirect) calls. They kept the
@c terminology.

@c --------------------------------------------------------------
@node Objects, OOF, Object-Oriented Terminology, Object-oriented Forth
@subsection The @file{objects.fs} model
@cindex objects
@cindex object-oriented programming

@cindex @file{objects.fs}
@cindex @file{oof.fs}

@c McKewan's and Zsoter's packages
このセクションでは、 @file{objects.fs} パッケージについて説明します。 この資料は、 M. Anton Ertl,
@cite{@uref{https://www.complang.tuwien.ac.at/forth/objects/objects.html,
Yet Another Forth Objects Package}}, Forth Dimensions 19(2), pages 37--43
でも公開されています。

このセクションは、 @ref{Structures} を読了済であることを前提としています。

このモデルの基礎となっている技術は、 パーサ・ジェネレーター Gray の実装に使用されており、 Gforth
でもさまざまな種類のワードリスト(ハッシュの有無や、大文字と小文字の区別の有無や、
ローカル変数用などの特殊用途のワードリスト)を実装するために使用されています)。


@menu
* Properties of the Objects model::
* Basic Objects Usage::
* The Objects base class::
* Creating objects::
* Object-Oriented Programming Style::
* Class Binding::
* Method conveniences::
* Classes and Scoping::
* Dividing classes::
* Object Interfaces::
* Objects Implementation::
* Objects Glossary::         
@end menu

Marcel Hendrix は、 このセクションに関して役立つコメントを提供しました。

@node Properties of the Objects model, Basic Objects Usage, Objects, Objects
@subsubsection Properties of the @file{objects.fs} model
@cindex @file{objects.fs} properties

@itemize @bullet
@item
オブジェクトをスタックに渡すのは簡単明瞭です。 スタック上でセレクターを渡すのは多少めんどくさいですが、 可能です。

@item
オブジェクトはメモリ内の単なるデータ構造であり、 そのアドレスによって参照されます。 @code{constant}
のような通常の定義ワードを使用してオブジェクトのワードを作成できます。 同様に、
オブジェクトを含むインスタンス変数と他のデータを含むインスタンス変数の間に違いはありません。

@item
遅延結び付け(Late binding)は効率的で使いやすいです。

@item
遅延結び付け(Late binding)によりパースが回避されるため、
状態スマート性(state-smartness)や拡張性の低下に関する問題が回避されます。 便宜上、 いくつかのパース・ワードがありますが、
それらには非パース・ワードもあります。 パースする定義ワードもいくつかあります。 すべての標準の定義ワードは(@code{:noname}
を除いて)パースするため、 これを避けるのは困難です。 ただし、 このようなワードは状態スマート(state-smart)ではないため、
他の多くのパース・ワードほど悪くはありません。

@item
このモデルではすべてを取り入れようとしているわけではありません。 (著者の私見ですけども)このモデルでは、 いくつかのことをうまくやるといった体です。
特に、 このモデルでは情報の隠蔽をサポートするように設計されていません(情報の隠蔽に役立つ可能性のある機能はありますが)。
これを実現するには、また別のパッケージが使用可能です。

@item
このモデルは階層構造((layered))になっています。 このモデルを使用するために下位階層まですべての機能を学習して使用する必要はありません。
必要な機能はほんのわずかです((@pxref{Basic Objects Usage}, @pxref{The Objects base class},
@pxref{Creating objects})。 その他の機能はオプションであり、 互いに独立しています。

@item
gforth 固有ではなく、 標準 Forth 用の実装が利用可能です。

@end itemize


@node Basic Objects Usage, The Objects base class, Properties of the Objects model, Objects
@subsubsection Basic @file{objects.fs} Usage
@cindex basic objects usage
@cindex objects, basic usage

以下のようにして graphical オブジェクト(図形オブジェクト)のクラスを定義できます:

@cindex @code{class} usage
@cindex @code{end-class} usage
@cindex @code{selector} usage
@example
object class \ クラス名 "object" は親クラスです
  selector draw ( x y graphical -- )
end-class graphical
@end example

このコードは、 @code{draw} 操作を持つクラス @code{graphical} を定義します。 任意の @code{graphical}
オブジェクトに対して @code{draw} 操作を実行できます。例:

@example
100 100 t-rex draw
@end example

@noindent
ここで、 @code{t-rex} は、 graphical オブジェクトを生成するワード(定数(constant)など)です。

@comment TODO add a 2nd operation eg perimeter.. and use for
@comment a concrete example

@cindex abstract class
graphical オブジェクトを作成するにはどうすればよいでしょうか？ 現在の定義では、 有用な graphical オブジェクトを作成できません。
クラス @code{graphical} は graphical オブジェクト一般を記述しますが、 具体的な graphical
オブジェクト・タイプを記述しません(C++ ユーザーはこれを「抽象クラス」(abstract class)と呼びます)。 たとえば、 クラス
@code{graphical} にはセレクター @code{draw} のメソッドがありません。

具体的な graphical オブジェクトのために、 クラス @code{graphical} の子クラスを定義します。 例:

@cindex @code{overrides} usage
@cindex @code{field} usage in class definition
@example
graphical class \ 親クラスは graphical
  cell% field circle-radius

:noname ( x y circle -- )
  circle-radius @@ draw-circle ;
overrides draw

:noname ( n-radius circle -- )
  circle-radius ! ;
overrides construct

end-class circle
@end example

ここでは、 フィールド @code{circle-radius} を持つクラス @code{circle} を @code{graphical}
の子として定義しています(フィールド @code{circle-radius}
は構造体のフィールドと同じように動作します(@pxref{Structures})。 セレクター @code{draw} と
@code{construct} 用の新しいメソッドを定義します(@code{construct} は @code{graphical} の親クラスの
@code{object} クラスで定義されています))。

以下のようにして、 ヒープ上(つまり、 @code{allocate} されたメモリ)に circle を作成できます:

@cindex @code{heap-new} usage
@example
50 circle heap-new constant my-circle
@end example

@noindent
@code{heap-new} は @code{construct} を呼び出し、 フィールド @code{circle-radius} を 50
で初期化します。 以下のようにして、 この新しい円を (100,100) の位置に描画(draw)できます:

@example
100 100 my-circle draw
@end example

@cindex selector invocation, restrictions
@cindex class definition, restrictions
注意: セレクターを呼び出すことができるのは、 TOS 上のオブジェクト(受信オブジェクト) が、 セレクターが定義されたクラス、 またはその子孫の 1
つに属している場合のみです。 たとえば、 @code{draw} は、 @code{graphical} またはその子孫(例:
@code{circle})に属するオブジェクトに対してのみ呼び出すことができます。  @code{end-class}
の直前の検索順序スタック(the search order)は、 @code{class} の直後と同じである必要があります。

@node The Objects base class, Creating objects, Basic Objects Usage, Objects
@subsubsection The @file{object.fs} base class
@cindex @code{object} class

あなたがクラスを定義するときは、 必ず親クラスを指定する必要があります。  では、 (最初の)クラス定義はどのようにすればよいのでしょうか？
そのために最初から使用できるクラスが 1 つだけあります。 それは @code{object} という名前のクラスです。
これはすべてのクラスの祖先であるため、 親を持たない唯一のクラスです。 そして、 @code{construct} と @code{print} という
2 つのセレクターを持っています。

@node Creating objects, Object-Oriented Programming Style, The Objects base class, Objects
@subsubsection Creating objects
@cindex creating objects
@cindex object creation
@cindex object allocation options

@cindex @code{heap-new} discussion
@cindex @code{dict-new} discussion
@cindex @code{construct} discussion
@code{heap-new} ( ... class -- object )
を使用するとヒープ上にクラスのオブジェクトを作成して初期化することができ、 @code{dict-new} ( ... class -- object
) を使用するとディクショナリ内(@code{allot} による割り当て)にクラスのオブジェクトを作成して初期化することができます。
どちらのワードも当該クラス @i{class} の @code{construct} を呼び出し、 当該クラス @i{class} の
@code{construct} のスタック効果(上記「...」の部分)で示されたスタック項目を消費します(訳注: 例えば 6.24.3.2 Basic
‘objects.fs’ Usage の例のように、 @code{circle} の @code{construct} のスタック効果 n-radius
が必要で、 @code{50 circle heap-new constant my-circle} としなければならない)。

@cindex @code{init-object} discussion
@cindex @code{class-inst-size} discussion
オブジェクトに自分でメモリを割り当てたい場合は、 @code{class-inst-size 2@@} ( class -- align size )
を使用してクラスのアライメント(alignment)とサイズを取得できます。 オブジェクト用のメモリを確保したら、
@code{init-object} ( ... class object -- )でオブジェクトを初期化できます(訳注: @i{class}
のためのデータ構造を @i{object} からに構築し、 その後そのオブジェクトに対して @code{construct} を実行します。 注意:
当該 @i{class} の @code{construct} 用のスタック項目の指定も必要な事に注意)。

@node Object-Oriented Programming Style, Class Binding, Creating objects, Objects
@subsubsection Object-Oriented Programming Style
@cindex object-oriented programming style
@cindex programming style, object-oriented

このセクションはすべてを網羅したものではありません。

@cindex stack effects of selectors
@cindex selectors and stack effects
一般に、 同一のセレクターのすべてのメソッドが同一スタック効果を持つようにするのは良いアイデアです。 セレクターを呼び出すとき、
どのメソッドが呼び出されるのかわからないことが多いため、 すべてのメソッドが同じスタック効果を持たない限り、
セレクター呼び出しのスタック効果を知ることはできません。

このルールには例外がひとつあります。 セレクター @code{construct} のメソッドです。 同一の場所に構築するクラスを指定しているため、
どのメソッドが呼び出されるのかがわかります。 実際、 著者はユーザーに初期化を指定する便利な方法を提供するためだけに @code{construct}
をセレクターとして定義しました。 使用方法としては、 セレクター呼び出しとは異なるメカニズムの方が自然です(ただし、
おそらく説明するにはより多くのコードとスペースが必要になります)。

@node Class Binding, Method conveniences, Object-Oriented Programming Style, Objects
@subsubsection Class Binding
@cindex class binding
@cindex early binding

@cindex late binding
通常のセレクター呼び出し(selector invocation)では、 受信オブジェクト(receiving
object)のクラスに応じて実行時(run-time)にメソッドが決定されます。
この実行時の選択(selection)は「遅延結び付け」(@i{late binding})と呼ばれます。

場合によっては、 別のメソッドを呼び出すことが望ましい場合があります。 たとえば、  出力オブジェクト(@code{print}ing
@code{object}s)では、 受信用クラス(receiver class)の冗長になりがちな @code{print} メソッドの代わりに、
単純なメソッドを使用したい事があります。 これを実現するには、 @code{print} の呼び出しを以下のように置き換えます(コンパイル時の場合):

@cindex @code{[bind]} usage
@example
[bind] object print
@end example

@noindent
または、 インタプリタ時は以下のようにします:

@cindex @code{bind} usage
@example
bind object print
@end example

@cindex class binding, alternative to
@noindent
あるいは、 メソッドを名前(例: @code{print-object})で定義し、 その名前を使用して呼び出すこともできます。
クラス結び付け(Class binding)は、 同じ効果を達成する(多くの場合、 より便利な)方法にすぎません。 これにより、
名前の乱雑さが回避され、 最初に名前を付けずにメソッドを直接呼び出すことができます。

@cindex superclass binding
@cindex parent class binding
クラス結び付け(class binding)のよくある使用法は次のとおりです: セレクターのメソッドを定義するとき、
親クラスでセレクターが行っていることと、 それ以上のことをメソッドに実行させたいことがよくあります。 この目的には、 @code{[parent]}
という特別なワードがあります。 @code{[parent] "selector"} は @code{[bind] "parent selector"}
と同等です。 ここで、@code{parent} は現在のクラスの親クラスです。 たとえば、メソッド定義は以下のようになります:

@cindex @code{[parent]} usage
@example
:noname
  dup [parent] foo \ 受信オブジェクトに対して親の foo を実行します
  ... \ (親の foo に加えて)更に何かする
; overrides foo
@end example

@cindex class binding as optimization
@cite{Object-oriented programming in ANS Forth} (Forth Dimensions, March
1997) で Andrew McKewan は最適化手法としてクラス結び付け(class binding)を紹介しています。 著者は緊急の場合を除き、
最適化手法の目的で使用しないことをお勧めします。 とにかく、 このモデルでは遅延結び付け(Late binding)が非常に高速であるため、
クラス結び付け(class binding)を使用するメリットは小さいです。 適切でない場合にクラス結び付け(class binding)を使用すると、
保守性が低下します。

プログラミング・スタイルの質問については次のとおりです。 セレクターは受信オブジェクト(receiving object)の祖先クラス(ancestor
classes)にのみ結び付け(bind)すべきです。 たとえば、 受信オブジェクトがクラス @code{foo}
またはその子孫であることがわかっているとします。 その場合は、 @code{foo} とその祖先にのみ結び付け(bind)するべきです。

@node Method conveniences, Classes and Scoping, Class Binding, Objects
@subsubsection Method conveniences
@cindex method conveniences

【メソッドをより便利に】通常、 メソッドでは受信オブジェクト(receiving object)に頻繁にアクセスします。
メソッドをプレーンなコロン定義(@code{:noname} など)として定義する場合、 多くのスタック体操が必要になる場合があります。
これを回避するには、 @code{m: ... ;m} を使用してメソッドを定義します。たとえば、 以下を使用して @code{circle} を
@code{draw} するメソッドを定義できます

@cindex @code{this} usage
@cindex @code{m:} usage
@cindex @code{;m} usage
@example
m: ( x y circle -- )
  ( x y ) this circle-radius @@ draw-circle ;m
@end example

@cindex @code{exit} in @code{m: ... ;m}
@cindex @code{exitm} discussion
@cindex @code{catch} in @code{m: ... ;m}
このメソッドが実行されるときは、 受信オブジェクト(receiver object)(上記例の @i{circle})がスタックから取り除かれます。
その代わりに、 @i{m:} 〜 @i{;m} の間は @code{this} を使用して受信オブジェクトにアクセスできます(ええ、 確かに、この例では
@code{m: ... ;m} を使用する利点ないかもしれませんね)。 注意: しかし、 スタック・コメントとしては @code{m:} と
@code{;m} の間のコードだけでなく、 メソッド全体(つまり、
受信オブジェクトを含むメソッド全体)のスタック効果を指定していることに注意してください。 なお、 @code{m:...;m} では
@code{exit} を使用できません。 代わりに、 @code{exitm} を使用してください@footnote{さらに、
@code{catch} を呼び出すワードや、 @code{objects.fs} をロードする前に定義されているワードについては、
@code{catch} を再定義したように、  これらも再定義する必要があります: @code{: catch this >r catch r>
to-this ;}}。

@cindex @code{inst-var} usage
あなたは @code{this "field"} という形式のシーケンスを頻繁に使用するハメになると思います(上記例では: @code{this
circle-radius})。 そこで、 この方法でのみフィールドを使用する場合は、 @code{inst-var} を使用してフィールドを定義し、
フィールド名の前の @code{this} を削れます。 たとえば、 上記例の @code{circle} クラスは以下のように定義することもできます:

@example
graphical class
  cell% inst-var radius

  m: ( x y circle -- )
    radius @@ draw-circle ;m
  overrides draw

  m: ( n-radius circle -- )
    radius ! ;m
  overrides construct

end-class circle
@end example

@code{radius} は、 @code{circle} や、 その子孫クラスと、 それらの @code{m:...;m} 内でのみ使用できます。

@cindex @code{inst-value} usage
@code{inst-value} を使用してフィールドを定義することもできます。 これは、 @code{variable} に対して
@code{value} があるのと同様に、 @code{inst-var} に対して @code{inst-value} があるのです。
このようなフィールドの値は @code{[to-inst]} を使用して変更できます。  たとえば、 クラス @code{circle}
を以下のように定義することもできます:

@example
graphical class
  inst-value radius

  m: ( x y circle -- )
    radius draw-circle ;m
  overrides draw

  m: ( n-radius circle -- )
    [to-inst] radius ;m
  overrides construct

end-class circle
@end example

@c !! :m is easy to confuse with m:.  Another name would be better.

@c Finally, you can define named methods with @code{:m}.  One use of this
@c feature is the definition of words that occur only in one class and are
@c not intended to be overridden, but which still need method context
@c (e.g., for accessing @code{inst-var}s).  Another use is for methods that
@c would be bound frequently, if defined anonymously.


@node Classes and Scoping, Dividing classes, Method conveniences, Objects
@subsubsection Classes and Scoping
@cindex classes and scoping
@cindex scoping and classes

構造体の拡張とは異なり、 継承は頻繁に行われます。 これは、フィールド名命名規則の問題をさらに悪化させます(@pxref{Structure
Naming Convention}): フィールドが最初にどのクラスで定義されたかを常に覚えておく必要があります。 クラス構造の一部を変更すると、
影響を受けないコードの名前も変更する必要があります。

@cindex @code{inst-var} visibility(可視性)
@cindex @code{inst-value} visibility(可視性)
この問題を解決するために、 著者は(著者のオリジナルのモデルにはなかった)スコープ・メカニズムを追加しました。 @code{inst-var} (または
@code{inst-value})で定義されたフィールドは、 それが定義されているクラスと、 そのクラスの子孫のクラスでのみ可視です。
このようなフィールドの使用は、 いずれにしても、 これらのクラスの @code{m:} で定義されたメソッドでのみ意味があります。

このスコープ・メカニズムにより、 名前が無関係なワードと衝突する可能性が大幅に低くなるため、 着飾っていないフィールド名を使用できます。

@cindex @code{protected} discussion
@cindex @code{private} discussion
スコープ・メカニズムがあれば、 他のワードの可視性を制御するために使用することもできます。 @code{protected}
の後に定義されたすべてのワードは、 現在のクラスとその子孫でのみ表示されます。  @code{public} は、 以前に有効だった the
current wordlist (新しく定義されたワードを入れるワードリスト)(つまり ユーザー変数 @code{current})を復元します。
@code{public} または @code{set-current} が介在せずに複数の @code{protected} がある場合、
@code{public} はこれらの最初の @code{protected} より前の有効な the current wordlist を復元します。

@node Dividing classes, Object Interfaces, Classes and Scoping, Objects
@subsubsection Dividing classes
@cindex Dividing classes
@cindex @code{methods}...@code{end-methods}

メソッドの定義を、 クラスや、そのセレクターや、 フィールドや、 インスタンス変数、 の定義とは別に行う、 つまり、
実装を定義から分離することもできます。  これは以下の方法で行うことができます:

@example
graphical class
  inst-value radius
end-class circle

... \ do some other stuff

circle methods \ now we are ready

  m: ( x y circle -- )
    radius draw-circle ;m
  overrides draw

  m: ( n-radius circle -- )
    [to-inst] radius ;m
  overrides construct

end-methods
@end example

複数の @code{methods}...@code{end-methods} セクションを使用できます。
これらのセクションでクラスに対して実行できることは、 メソッドの定義とクラスのセレクターのオーバーライドのみです。
新しいセレクターやフィールドを定義してはいけません。

注意: 多くの場合、 セレクターを使用する前にオーバーライドする必要があることに注意してください。  特に、 @code{heap-new}
とその他のメソッドを呼び出す前に、 通常は @code{construct} を新しいメソッドでオーバーライドする必要があります。  たとえば、
上記例の @code{overrides construction} シーケンスの前に circle を作成してはなりません。

@node Object Interfaces, Objects Implementation, Dividing classes, Objects
@subsubsection Object Interfaces
@cindex object interfaces
@cindex interfaces for objects

このモデルでは、 受信オブジェクト(receiving objects)のクラスまたはその祖先の 1
つに定義されたセレクターのみを呼び出すことができます。 これらのクラスのいずれにも属さない受信オブジェクトを使用してセレクターを呼び出した場合、
結果は未定義になります。 あなたの運が良ければ、 プログラムは即座にクラッシュします。

@cindex selectors common to hardly-related classes
ここで、 2 つのクラスで 1 つまたは複数のセレクターを使用できるようにしたい場合を考えてみましょう。
セレクターを共通の祖先クラスに追加する必要があり、 最悪の場合は @code{object} に追加する必要があります。 たとえば、
他の誰かがこの祖先クラスに対して責任を負っているなどの理由で、 共通の祖先クラスへのセレクターの追加を実行したくない場合もあります。

この問題の解決策はインターフェイス(interface)です。 インターフェイスはセレクターのコレクション(collection)です。
クラスがインターフェイスを実装(implement)している場合、
そのインターフェイスのセレクターはそのクラスとその子孫のクラスで使用できるようになります。 クラスは無制限の数のインターフェイスを実装できます。
上で説明した問題については、 セレクター達の為にインターフェイスを定義し、 両方のクラスでそのインターフェイスを実装します。

例として、 オブジェクトをディスクに書き込んで戻すための @code{storage} というインターフェイスと、 それを実装するクラス
@code{foo} について考えてみましょう。 そのコードは以下のようになります:

@cindex @code{interface} usage
@cindex @code{end-interface} usage
@cindex @code{implementation} usage
@example
interface
  selector write ( file object -- )
  selector read1 ( file object -- )
end-interface storage

bar class
  storage implementation

  ... overrides write
  ... overrides read1
  ...

end-class foo
@end example

@noindent
(著者は、 ここから更に  @code{read1} を内部的に使用するワード @code{read} @i{( file -- object )}
を追加するのですが、 それはインターフェイスとは関係ないので、 ここでは説明を割愛します。 )

注意: インターフェイスでは @code{protected} を使用できないことに注意してください。 もちろん、
フィールドを定義することもできません。

Neon モデルでは、 すべてのセレクターがすべてのクラスで使用できます。 したがってインターフェイスは必要ありません。 Neon
モデルで支払う代償は、 遅延結び付け(late binding)が遅くなるため、 遅延結び付けを回避するために複雑さが増すことです。

@node Objects Implementation, Objects Glossary, Object Interfaces, Objects
@subsubsection @file{objects.fs} Implementation
@cindex @file{objects.fs} implementation

@cindex @code{object-map} discussion
オブジェクトは、 @code{struct...end-struct} で記述されたデータ構造体の 1 つである、 メモリの一片です。 これは、
そのオブジェクトのクラスのメソッド・マップ(the method map) を指すフィールド @code{object-map} を持っています。

@cindex method map
@cindex virtual function table
「メソッド・マップ」(method map)@footnote{「メソッド・マップ」(method map)は著者自作用語です。 C++ 用語では、
仮想関数テーブル と言います。}は、 そのオブジェクトのクラスのメソッドの実行トークン(@i{xt})を含む配列です。 各セレクターには、
メソッド・マップへのオフセットが含まれています。

@cindex @code{selector} implementation, class
@code{selector} は、@code{CREATE} と @code{DOES>} を使用する定義ワードです。 selector
の本体の内容はメソッド・マップのオフセット値です。 クラスのセレクターの @code{DOES>} アクションは、 基本的には以下のとおりです(訳注:
メソッド・マップの実装上のフィールド名は "object-map"):

@example
( object addr ) @@ over object-map @@ + @@ execute
@end example

なお、 @code{object-map} はオブジェクトの最初のフィールドであるため、 コードは生成されません。 ご覧のとおり、
セレクターの呼び出しには小さいけれども一定のコストがかかります。

@cindex @code{current-interface} discussion
@cindex class implementation and representation
クラスは基本的に @code{struct} とメソッド・マップを組み合わせたものです。 @code{struct} の場合と同様に、 クラス定義中に、
クラスのアライメントとサイズがスタックに渡されるため、 @code{field} をクラスのフィールドの定義にも使用できます。 ただし、
スタックにさらに多くの項目を渡すと不便になるため、 @code{class} はメモリ内にデータ構造を構築し、 変数
@code{current-interface} を通じてアクセスします。 定義が完了すると、 クラスはポインタ(たとえば、
子クラス定義のパラメータとして利用したりする)としてスタックに置かれます。

新しいクラスは、 その親のアライメントとサイズ、 およびその親のメソッド・マップのコピーから始まります。 新しいフィールドを定義すると、
サイズとアライメントが拡張されます。 同様に、 新しいセレクターを定義すると、 メソッド・マップが拡張されます。 @code{overrides} は、
セレクターによって指定されたオフセットでメソッド・マップに新しい @i{xt} を保存するだけです。

@cindex class binding, implementation
クラス結び付け(class binding)は、 そのクラスのメソッド・マップからセレクターによって指定されたオフセットで @i{xt} を取得し、
それをコンパイル(@code{compile,})するだけです(@code{[bind]} の場合)。

@cindex @code{this} implementation
@cindex @code{catch} and @code{this}
@cindex @code{this} and @code{catch}
著者は @code{this} を @code{value} として実装しました。 @code{m:...;m} メソッドの開始時に、 古い
@code{this} がリターン・スタックに保存され、 最後に復元されます。 TOS 上のオブジェクトは @code{TO this} で保存します。
この手法には欠点が 1 つあります。 ユーザーが @code{;m} 経由ではなく @code{throw} または @code{exit}
経由でメソッドを終了した場合、 @code{this} は復元されません(そして @code{exit} がクラッシュする可能性があります)。 著者は
@code{throw} の問題に対処するために、 @code{this} を保存および復元するために @code{catch}
を再定義しました(訳注: "objects.fs" をインクルードした時に "redefined catch" と警告が出るが、
意図的に再定義してあるので無視してください、 ということ)。 例外をキャッチできるワードについても全く同様に行うべきです。 @code{exit}
については、 単純に使用を禁止します(代わりに @code{exitm} を用意しました)。

@cindex @code{inst-var} implementation
@code{inst-var} は @code{field} とまったく同じですが、 @code{DOES>} アクションが異なります:
@example
@@ this +
@end example
@code{inst-value} も同様です。

@cindex class scoping implementation
各クラスは、 @code{inst-var} と @code{inst-value} で定義されたワードや、 それらの protected
されたワードを含む、 ワードリストを持っています。 また、 その親へのポインタも持っています。 @code{class} は、
クラスとそのすべての祖先のワードリストを検索順序スタック(the search order)にプッシュし、 @code{end-class}
はそれらをスタックから drop します。

@cindex interface implementation
インターフェイスは、 フィールドと親と protected されたワードのないクラスに似ています。 つまり、 メソッド・マップがあるだけです。
クラスがインターフェイスを実装する場合、 そのメソッド・マップにはインターフェイスのメソッド・マップへのポインターが含まれます。
マップ内の正のオフセットはクラス・メソッド用に予約されているため、 インターフェイス・マップ・ポインターは負のオフセットを持ちます。
クラス・セレクターとは異なり、 インターフェイスにはシステム全体で一意のオフセットがあります。 クラス・セレクターのオフセットは、
セレクターが利用可能な(呼び出し可能な)クラスに対してのみ一意です。

この構造は、 インターフェイス・セレクターがメソッドを見つけるために、 クラス・セレクターよりも 1
つ多い間接参照を実行する必要があることを意味します。 その本体には、 クラス・メソッド・マップ内のインターフェイス・マップ・ポインター・オフセットと、
インターフェイス・メソッド・マップ内のメソッド・オフセットが含まれています。 インターフェイス・セレクターの @code{does>} アクションは、
基本的には以下のとおりです:

@example
( object selector-body )
2dup selector-interface @@ ( object selector-body object interface-offset )
swap object-map @@ + @@ ( object selector-body map )
swap selector-offset @@ + @@ execute
@end example

ここで、 @code{object-map} と @code{selector-offset} は最初のフィールドであり、 コードは生成されません。

具体的な例として、 以下のコードについて考えてみましょう: 

@example
interface
  selector if1sel1
  selector if1sel2
end-interface if1

object class
  if1 implementation
  selector cl1sel1
  cell% inst-var cl1iv1

  ' m1 overrides construct
  ' m2 overrides if1sel1
  ' m3 overrides if1sel2
  ' m4 overrides cl1sel2
end-class cl1

create obj1 object dict-new drop
create obj2 cl1    dict-new drop
@end example

@comment TODO add this diagram..
このコードで作成されたデータ構造 (@code{object} のデータ構造を含む) は、セル・サイズ 4 を想定して
@uref{objects-implementation.png,figure} に図示されています。

@node Objects Glossary, , Objects Implementation, Objects
@subsubsection @file{objects.fs} Glossary
@cindex @file{objects.fs} Glossary


@findex bind ( @var{ ... "class" "selector" -- ...   } ) objects
@cindex @code{bind}
@kindex bind
@format
@code{bind} ( @i{... "class" "selector" -- ...  }) objects ``bind''
@end format
指定のクラス @var{class} の 指定セレクター @var{selector} のメソッドを execute します。


@findex <bind> ( @var{ class selector-xt -- xt   } ) objects
@cindex @code{<bind>}
@kindex <bind>
@format
@code{<bind>} ( @i{class selector-xt -- xt  }) objects ``<bind>''
@end format
@var{xt} は、 指定クラス @var{class} のセレクター @var{selector-xt} のメソッドです。


@findex bind' ( @var{ "class" "selector" -- xt   } ) objects
@cindex @code{bind'}
@kindex bind'
@format
@code{bind'} ( @i{"class" "selector" -- xt  }) objects ``bind'''
@end format
@var{xt} は 指定のクラス @var{class} の 指定のセレクター @var{selector} のメソッドです。


@findex [bind] ( @var{ compile-time: "class" "selector" -- ; run-time: ... object -- ...   } ) objects
@cindex @code{[bind]}
@kindex [bind]
@format
@code{[bind]} ( @i{compile-time: "class" "selector" -- ; run-time: ... object -- ...  }) objects ``[bind]''
@end format
指定のクラス @var{class} の 指定のセレクター @var{selector} のメソッドをコンパイルします。


@findex class ( @var{ parent-class -- align offset   } ) objects
@cindex @code{クラス(class)}
@kindex クラス(class)
@format
@code{class} ( @i{parent-class -- align offset  }) objects ``class''
@end format
@var{parent-class} の子として新しいクラス定義を開始します。 スタックに積まれた @var{align offset} は
@var{field} などで使用されます。


@findex class->map ( @var{ class -- map   } ) objects
@cindex @code{class->map}
@kindex class->map
@format
@code{class->map} ( @i{class -- map  }) objects ``class->map''
@end format
指定のクラス @var{class} のメソッド・マップへのポインタを @var{map} に返します。


@findex class-inst-size ( @var{ class -- addr   } ) objects
@cindex @code{class-inst-size}
@kindex class-inst-size
@format
@code{class-inst-size} ( @i{class -- addr  }) objects ``class-inst-size''
@end format
指定のクラス @var{class} のインスタンス(つまり、 オブジェクト)のサイズ仕様を指します。 通常 @code{class-inst-size
2@@ ( class -- align size )} として使用されます。


@findex class-override! ( @var{ xt sel-xt class-map --   } ) objects
@cindex @code{class-override!}
@kindex class-override!
@format
@code{class-override!} ( @i{xt sel-xt class-map --  }) objects ``class-override!''
@end format
指定の @var{xt} は、 指定の @var{class-map} のセレクター @var{sel-xt} の新しいメソッドです。


@findex class-previous ( @var{ class --   } ) objects
@cindex @code{class-previous}
@kindex class-previous
@format
@code{class-previous} ( @i{class --  }) objects ``class-previous''
@end format
指定の @var{class} のワードリストを検索順序スタック(the search order)から drop します。  @var{class}
のワードリストが実際に検索順序スタックに含まれているかどうかのチェックは行われません。


@findex class>order ( @var{ class --   } ) objects
@cindex @code{class>order}
@kindex class>order
@format
@code{class>order} ( @i{class --  }) objects ``class>order''
@end format
クラス @var{class} のワードリストを検索順序スタック(the search-order)の先頭に追加します。


@findex construct ( @var{ ... object --   } ) objects
@cindex @code{construct}
@kindex construct
@format
@code{construct} ( @i{... object --  }) objects ``construct''
@end format
指定の @var{object} のデータ・フィールドを初期化します。 基底クラス @var{object} の @i{construct}
メソッドは何も行いません: @code{( object -- )}.


@findex current' ( @var{ "selector" -- xt   } ) objects
@cindex @code{current'}
@kindex current'
@format
@code{current'} ( @i{"selector" -- xt  }) objects ``current'''
@end format
@var{xt} は、 現在のクラスの指定の @var{selector} のメソッドです。


@findex [current] ( @var{ compile-time: "selector" -- ; run-time: ... object -- ...   } ) objects
@cindex @code{[current]}
@kindex [current]
@format
@code{[current]} ( @i{compile-time: "selector" -- ; run-time: ... object -- ...  }) objects ``[current]''
@end format
現在のクラスの @var{selector} のメソッドをコンパイルします。


@findex current-interface ( @var{ -- addr   } ) objects
@cindex @code{current-interface}
@kindex current-interface
@format
@code{current-interface} ( @i{-- addr  }) objects ``current-interface''
@end format
変数(Variable): 現在定義中のクラスまたはインターフェイスが含まれます。


@findex dict-new ( @var{ ... class -- object   } ) objects
@cindex @code{dict-new}
@kindex dict-new
@format
@code{dict-new} ( @i{... class -- object  }) objects ``dict-new''
@end format
指定のクラス @var{class} オブジェクト用の領域を @code{allot} を使用してディクショナリ内に確保し、
初期化(@code{init-object})したオブジェクトへのポインタを @var{object} に返します(訳注: @var{object}
は領域の先頭ではなくてメソッド・マップ(@i{object-map})フィールドを指している事に注意)


@findex end-class ( @var{ align offset "name" --   } ) objects
@cindex @code{end-class}
@kindex end-class
@format
@code{end-class} ( @i{align offset "name" --  }) objects ``end-class''
@end format
@var{name} という名前を付けてクラス定義を終了します。  @var{name} 実行時: @code{-- class}


@findex end-class-noname ( @var{ align offset -- class   } ) objects
@cindex @code{end-class-noname}
@kindex end-class-noname
@format
@code{end-class-noname} ( @i{align offset -- class  }) objects ``end-class-noname''
@end format
クラス定義を終了します。 結果のクラスは @var{class} です。


@findex end-interface ( @var{ "name" --   } ) objects
@cindex @code{end-interface}
@kindex end-interface
@format
@code{end-interface} ( @i{"name" --  }) objects ``end-interface''
@end format
@code{name} という名前を付けてインターフェイス定義を終了します。 @code{name} の実行時: @code{--interface}


@findex end-interface-noname ( @var{ -- interface   } ) objects
@cindex @code{end-interface-noname}
@kindex end-interface-noname
@format
@code{end-interface-noname} ( @i{-- interface  }) objects ``end-interface-noname''
@end format
インターフェイス定義を終了します。 結果のインターフェイスは @var{interface}


@findex end-methods ( @var{ --   } ) objects
@cindex @code{end-methods}
@kindex end-methods
@format
@code{end-methods} ( @i{--  }) objects ``end-methods''
@end format
クラスのメソッド定義から通常モードに切り替えます(現在、 これは古い検索順序スタックを復元するだけです)。


@findex exitm ( @var{ --   } ) objects
@cindex @code{exitm}
@kindex exitm
@format
@code{exitm} ( @i{--  }) objects ``exitm''
@end format
メソッドから @code{exit} します。 古い @code{this} を復元します。


@findex heap-new ( @var{ ... class -- object   } ) objects
@cindex @code{heap-new}
@kindex heap-new
@format
@code{heap-new} ( @i{... class -- object  }) objects ``heap-new''
@end format
@code{allocate} し、 クラス @var{class} のオブジェクトを初期化します。


@findex implementation ( @var{ interface --   } ) objects
@cindex @code{implementation}
@kindex implementation
@format
@code{implementation} ( @i{interface --  }) objects ``implementation''
@end format
現在のクラスは指定のインターフェイス @var{interface} を実装します。 つまり、 あなたは、 現在のクラス内とその子孫のクラス内で、
指定のインターフェイス @var{interface} の全てのセレクターを使用できます。


@findex init-object ( @var{ ... class object --   } ) objects
@cindex @code{init-object}
@kindex init-object
@format
@code{init-object} ( @i{... class object --  }) objects ``init-object''
@end format
メモリのチャンク @var{object} (アドレス)をクラス @var{class} のオブジェクトのために初期化します。 それから
@code{construct} を実行します(訳注: @var{class} の @code{construct} 用のスタック項目も必要な事に注意。
6.24.3.2 Basic ‘objects.fs’ Usage の例 circle で言えば n-radius が必要で(my-circle2
というメモリ領域をクラス・オブジェクトにするとして、) @code{50 circle my-circle-2 init-object}
としなければならない)


@findex inst-value ( @var{ align1 offset1 "name" -- align2 offset2   } ) objects
@cindex @code{inst-value}
@kindex inst-value
@format
@code{inst-value} ( @i{align1 offset1 "name" -- align2 offset2  }) objects ``inst-value''
@end format
@var{align2} @var{offset2} は @var{w} のサイズだけ足し込んだ値です。 @var{name} の実行時:
@code{-- w} @var{w} は、@code{this} オブジェクトの @var{name} フィールドの値です。


@findex inst-var ( @var{ align1 offset1 align size "name" -- align2 offset2   } ) objects
@cindex @code{inst-var}
@kindex inst-var
@format
@code{inst-var} ( @i{align1 offset1 align size "name" -- align2 offset2  }) objects ``inst-var''
@end format
@var{addr} は、@code{this} オブジェクトのフィールド @var{name} のアドレスです。 @var{name} の実行時:
@code{-- addr}


@findex interface ( @var{ --   } ) objects
@cindex @code{interface}
@kindex interface
@format
@code{interface} ( @i{--  }) objects ``interface''
@end format
インターフェイス定義を開始します。


@findex m: ( @var{ -- xt colon-sys; run-time: object --   } ) objects
@cindex @code{m:}
@kindex m:
@format
@code{m:} ( @i{-- xt colon-sys; run-time: object --  }) objects ``m:''
@end format
メソッド定義を開始します。 定義中は指定の @var{object} が新しい @code{this} になります。


@findex :m ( @var{ "name" -- xt; run-time: object --   } ) objects
@cindex @code{:m}
@format
@code{:m} ( @i{"name" -- xt; run-time: object --  }) objects ``:m''
@end format
名前付きメソッド定義を開始します。 定義中は指定の @var{object} が新しい @code{this} になります。  @code{;m}
で終わらせる必要があります。


@findex ;m ( @var{ colon-sys --; run-time: --   } ) objects
@cindex @code{;m}
@kindex ;m
@format
@code{;m} ( @i{colon-sys --; run-time: --  }) objects ``;m''
@end format
メソッド定義を終了します。 古い @code{this} を復元します。


@findex method ( @var{ xt "name" --   } ) objects
@cindex @code{メソッド(method)}
@kindex メソッド(method)
@format
@code{method} ( @i{xt "name" --  }) objects ``method''
@end format
セレクター @var{name} を作成し、@var{xt} を現在のクラスのメソッドにします。 @code{name} の実行時:
@code{... object -- ...}


@findex methods ( @var{ class --   } ) objects
@cindex @code{methods}
@kindex methods
@format
@code{methods} ( @i{class --  }) objects ``methods''
@end format
@var{class} を現在のクラスにします。 これは、 セレクターをオーバーライドするメソッドを定義するために使用することを目的としています。
新しいフィールドやセレクターを定義することはできません。


@findex object ( @var{ -- class   } ) objects
@cindex @code{オブジェクト(object)}
@kindex オブジェクト(object)
@format
@code{object} ( @i{-- class  }) objects ``object''
@end format
すべてのクラスの祖先。


@findex overrides ( @var{ xt "selector" --   } ) objects
@cindex @code{overrides}
@kindex overrides
@format
@code{overrides} ( @i{xt "selector" --  }) objects ``overrides''
@end format
現在のクラスの @var{selector} のデフォルト・メソッドを @var{xt} に置き換えます。 @code{overrides}
はインターフェイス定義中に使用してはいけません。


@findex [parent] ( @var{ compile-time: "selector" -- ; run-time: ... object -- ...   } ) objects
@cindex @code{[parent]}
@kindex [parent]
@format
@code{[parent]} ( @i{compile-time: "selector" -- ; run-time: ... object -- ...  }) objects ``[parent]''
@end format
現在のクラスの親の @var{selector} のメソッドをコンパイルします。


@findex print ( @var{ object --   } ) objects
@cindex @code{print}
@kindex print
@format
@code{print} ( @i{object --  }) objects ``print''
@end format
オブジェクトを出力します。 指定のクラス @var{object} のメソッドは、 オブジェクトのアドレスとそのクラスのアドレスを出力します。


@findex protected ( @var{ --   } ) objects
@cindex @code{protected}
@kindex protected
@format
@code{protected} ( @i{--  }) objects ``protected''
@end format
現在のクラスのワードリストをコンパイル・ワードリスト(the compilation wordlist)にセットします


@findex public ( @var{ --   } ) objects
@cindex @code{public}
@kindex public
@format
@code{public} ( @i{--  }) objects ``public''
@end format
実際にコンパイル・ワードリスト(the compilation wordlist)を変更した最後の @code{protected}
より前に有効だったコンパイル・ワードリストを復元します。


@findex selector ( @var{ "name" --   } ) objects
@cindex @code{セレクター(selector)}
@kindex セレクター(selector)
@format
@code{selector} ( @i{"name" --  }) objects ``selector''
@end format
現在のクラスとその子孫のセレクター @var{name} を作成します。 @code{overrides} を使用して、
現在のクラスのセレクターのメソッドを設定できます。 @var{name} の実行時: @code{... object -- ...}


@findex this ( @var{ -- object   } ) objects
@cindex @code{this}
@kindex this
@format
@code{this} ( @i{-- object  }) objects ``this''
@end format
現在のメソッドの受信オブジェクト(receiving object)(別名アクティブ・オブジェクト)。


@findex <to-inst> ( @var{ w xt --   } ) objects
@cindex @code{<to-inst>}
@kindex <to-inst>
@format
@code{<to-inst>} ( @i{w xt --  }) objects ``<to-inst>''
@end format
実行トークン @var{xt} を inst-value で作成したフィールドとみなしてフィールド・オフセットを取得し、
現在のオブジェクト(@i{this})の当該フィールドに指定の値 @var{w} を格納します。


@findex [to-inst] ( @var{ compile-time: "name" -- ; run-time: w --   } ) objects
@cindex @code{[to-inst]}
@kindex [to-inst]
@format
@code{[to-inst]} ( @i{compile-time: "name" -- ; run-time: w --  }) objects ``[to-inst]''
@end format
@var{w} を @code{this} オブジェクトの @var{name} フィールドに格納します。


@findex to-this ( @var{ object --   } ) objects
@cindex @code{to-this}
@kindex to-this
@format
@code{to-this} ( @i{object --  }) objects ``to-this''
@end format
@code{this} を設定します(内部的に使用されるものですが、 デバッグ時に役立ちます)。


@findex xt-new ( @var{ ... class xt -- object   } ) objects
@cindex @code{xt-new}
@kindex xt-new
@format
@code{xt-new} ( @i{... class xt -- object  }) objects ``xt-new''
@end format
@code{xt ( align size -- addr )} を使用して何らかの形で領域を確保し、 そこに指定のクラス @i{class}
の新しいオブジェクトを作成(@code{init-object})します。




@c -------------------------------------------------------------
@node OOF, Mini-OOF, Objects, Object-oriented Forth
@subsection The @file{oof.fs} model
@cindex oof
@cindex object-oriented programming

@cindex @file{objects.fs}
@cindex @file{oof.fs}

このセクションでは、 @file{oof.fs} パッケージについて説明します。

このセクションで説明するパッケージは、 1991 年以来 bigFORTH で使用されており、
新薬作成に使用されるクロマトグラフィー・システムと、グラフィック・ユーザー・インターフェイス・ライブラリ (MINOS) という 2
つの大きなアプリケーションに使用されています。

@file{oof.fs} の説明 (ドイツ語) は、@cite{Vierte Dimension} 10(2), 1994 に掲載された Bernd
Paysan による @cite{Object Oriented bigFORTH} にあります。

@menu
* Properties of the OOF model::
* Basic OOF Usage::
* The OOF base class::
* Class Declaration::
* Class Implementation::     
@end menu

@node Properties of the OOF model, Basic OOF Usage, OOF, OOF
@subsubsection Properties of the @file{oof.fs} model
@cindex @file{oof.fs} properties

@itemize @bullet
@item
このモデルは、 オブジェクト指向プログラミングと情報隠蔽を組み合わせたものです。 クラス指向のスコープが提供されるため、
スコープが必要な大規模なアプリケーションを作成するのに役立ちます。

@item
名前付きオブジェクトや、 オブジェクト・ポインターや、 オブジェクト配列を作成できます。
セレクターの呼び出しには「オブジェクト・セレクター」構文が使用されます。
スタック上のオブジェクトやセレクターに対するセレクターの呼び出しはあまり便利ではありませんが、 可能です。

@item
セレクターの呼び出しと、 アクティブ・オブジェクトのインスタンス変数の使用は、 どちらもアクティブ・オブジェクトを使用するため、 簡単です。

@item
遅延結び付け(Late binding)は効率的で使いやすいです。

@item
ステートスマート・オブジェクトはセレクターをパースします。 ただし、(パース) セレクター @code{postpone} とセレクター
@code{'} を使用して拡張性が提供されます。

@item
gforth 固有ではなく、 標準 Forth 用の実装が利用可能です。

@end itemize


@node Basic OOF Usage, The OOF base class, Properties of the OOF model, OOF
@subsubsection Basic @file{oof.fs} Usage
@cindex @file{oof.fs} usage

このセクションでは、 @code{objects} (@pxref{Basic Objects Usage}) と同じ例を使用します。

以下のようにして graphical オブジェクト(図形オブジェクト)のクラスを定義できます:

@cindex @code{class} usage
@cindex @code{class;} usage
@cindex @code{method} usage
@example
object class graphical \ "object" is the parent class
  method draw ( x y -- )
class;
@end example

このコードは、 @code{draw} 操作を持つクラス @code{graphical} を定義します。 任意の @code{graphical}
オブジェクトに対して @code{draw} 操作を実行できます。例:

@example
100 100 t-rex draw
@end example

@noindent
ここで、 @code{t-rex} (訳注: 恐竜ティラノサウルス) はオブジェクトまたはオブジェクト・ポインターであり、
たとえば次のように作成されます: @code{graphical : t-rex}

@cindex abstract class
graphical オブジェクトを作成するにはどうすればよいでしょうか？ 現在の定義では、 有用な graphical オブジェクトを作成できません。
クラス @code{graphical} は graphical オブジェクト一般を記述しますが、 具体的な graphical
オブジェクト・タイプを記述しません(C++ ユーザーはこれを「抽象クラス」(abstract class)と呼びます)。 たとえば、 クラス
@code{graphical} にはセレクター @code{draw} のメソッドがありません。

具体的な graphical オブジェクトのために、 クラス @code{graphical} の子クラスを定義します。 例:

@example
graphical class circle \ "graphical" is the parent class
  cell var circle-radius
how:
  : draw ( x y -- )
    circle-radius @@ draw-circle ;

  : init ( n-radius -- )
    circle-radius ! ;
class;
@end example

ここでは、 クラス @code{circle} を @code{graphical} の子として、 フィールド @code{circle-radius}
とともに定義します。 セレクター @code{draw} および @code{init} の新しいメソッドが定義されています(@code{init}
は、 @code{graphical} の親クラスである @code{object} で定義されています)。

いまや、 以下のコマンドを使用してディクショナリ内に circle を作成できます:

@example
50 circle : my-circle
@end example

@noindent
@code{:} は @code{init} を呼び出し、 フィールド @code{circle-radius} を 50 で初期化します。
以下のようにして、この新しい circle を (100,100) に描画できます:

@example
100 100 my-circle draw
@end example

@cindex selector invocation, restrictions
@cindex class definition, restrictions
注意: セレクターを呼び出すことができるのは、 受信オブジェクトが、 セレクターが定義されたクラス、またはその子孫の 1 つに属している場合のみです。
たとえば、 @code{draw} は、 @code{graphical} またはその子孫(例:
@code{circle})に属するオブジェクトに対してのみ呼び出すことができます。 このクラス階層で定義されていないセレクターを呼び出そうとすると、
スコープ・メカニズムがチェックするため、 コンパイル時にエラーが発生します。


@node The OOF base class, Class Declaration, Basic OOF Usage, OOF
@subsubsection The @file{oof.fs} base class
@cindex @file{oof.fs} base class

クラスを定義するときは、 親クラスを指定する必要があります。 では、 クラスの定義はどのように始めればよいのでしょうか？ 最初から使用できるクラスは 1
つあります。 それは @code{object} です。 これをすべてのクラスの祖先として使用する必要があります。
これは親が存在しない唯一のクラスです。 クラスはインスタンス変数を持たない点を除けばオブジェクトでもあります。
クラスの継承や定義の変更などのクラス操作は、 クラス @code{object} のセレクターを通じて処理されます。

@code{object} はいくつかのセレクターを提供します:

@itemize @bullet
@item
サブクラス化には @code{class} を、 後で定義を追加するには @code{settings} を、 型情報を取得するには
@code{class?} (現在のクラスはスタックに渡されたクラスのサブクラスかどうか？ を調べる)。

@findex object-class ( @var{ "name" --   } ) oof
@cindex @code{object-class}
@kindex object-class
@format
@code{object-class} ( @i{"name" --  }) oof ``object-class''
@end format

@findex object-definitions ( @var{ --   } ) oof
@cindex @code{object-definitions}
@kindex object-definitions
@format
@code{object-definitions} ( @i{--  }) oof ``object-definitions''
@end format

@findex object-class? ( @var{ o -- flag   } ) oof
@cindex @code{object-class?}
@kindex object-class?
@format
@code{object-class?} ( @i{o -- flag  }) oof ``class-query''
@end format



@item
@code{init} と @code{dispose} をオブジェクトのコンストラクターとデストラクターとして使用します。 @code{init}
はオブジェクトのメモリが割り当て後に呼び出されますが、 @code{dispose} は割り当て解除処理も行います。 したがって、
@code{dispose} を再定義する場合は、 @code{super destroy} を使用して親の destroy も呼び出す必要があります。

@findex object-init ( @var{ ... --   } ) oof
@cindex @code{object-init}
@kindex object-init
@format
@code{object-init} ( @i{... --  }) oof ``object-init''
@end format

@findex object-dispose ( @var{ --   } ) oof
@cindex @code{object-dispose}
@kindex object-dispose
@format
@code{object-dispose} ( @i{--  }) oof ``object-dispose''
@end format



@item
@code{new} や @code{new[]} や @code{:} や @code{ptr} や @code{asptr} や @code{[]}
を使用して、 名前付きおよび名前なしで、 オブジェクトとオブジェクト配列またはオブジェクト・ポインタ を作成します。

@findex object-new ( @var{ -- o   } ) oof
@cindex @code{object-new}
@kindex object-new
@format
@code{object-new} ( @i{-- o  }) oof ``object-new''
@end format

@findex object-new[] ( @var{ n -- o   } ) oof
@cindex @code{object-new[]}
@kindex object-new[]
@format
@code{object-new[]} ( @i{n -- o  }) oof ``new-array''
@end format

@findex object-: ( @var{ "name" --   } ) oof
@cindex @code{object-:}
@kindex object-:
@format
@code{object-:} ( @i{"name" --  }) oof ``define''
@end format

@findex object-ptr ( @var{ "name" --   } ) oof
@cindex @code{object-ptr}
@kindex object-ptr
@format
@code{object-ptr} ( @i{"name" --  }) oof ``object-ptr''
@end format

@findex object-asptr ( @var{ o "name" --   } ) oof
@cindex @code{object-asptr}
@kindex object-asptr
@format
@code{object-asptr} ( @i{o "name" --  }) oof ``object-asptr''
@end format

@findex object-[] ( @var{ n "name" --   } ) oof
@cindex @code{object-[]}
@kindex object-[]
@format
@code{object-[]} ( @i{n "name" --  }) oof ``array''
@end format



@item
@code{::} と @code{super} は明示的なスコープ設定に使用します。 明示的なスコープ指定は、
スーパークラスまたは同じインスタンス変数セットを持つクラスに対してのみ使用する必要があります。
明示的にスコープ指定されたセレクターは早期結び付け(early binding)を使用します。

@findex object-:: ( @var{ "name" --   } ) oof
@cindex @code{object-::}
@kindex object-::
@format
@code{object-::} ( @i{"name" --  }) oof ``scope''
@end format

@findex object-super ( @var{ "name" --   } ) oof
@cindex @code{object-super}
@kindex object-super
@format
@code{object-super} ( @i{"name" --  }) oof ``object-super''
@end format



@item
@code{self} でオブジェクト自身のアドレスを取得します

@findex object-self ( @var{ -- o   } ) oof
@cindex @code{object-self}
@kindex object-self
@format
@code{object-self} ( @i{-- o  }) oof ``object-self''
@end format



@item
@code{bind} や @code{bound} や @code{link} や @code{is} を使用して、 オブジェクト・ポインターと
instance defers を割り当てます。

@findex object-bind ( @var{ o "name" --   } ) oof
@cindex @code{object-bind}
@kindex object-bind
@format
@code{object-bind} ( @i{o "name" --  }) oof ``object-bind''
@end format

@findex object-bound ( @var{ class addr "name" --   } ) oof
@cindex @code{object-bound}
@kindex object-bound
@format
@code{object-bound} ( @i{class addr "name" --  }) oof ``object-bound''
@end format

@findex object-link ( @var{ "name" -- class addr   } ) oof
@cindex @code{object-link}
@kindex object-link
@format
@code{object-link} ( @i{"name" -- class addr  }) oof ``object-link''
@end format

@findex object-is ( @var{ xt "name" --   } ) oof
@cindex @code{object-is}
@kindex object-is
@format
@code{object-is} ( @i{xt "name" --  }) oof ``object-is''
@end format



@item
@code{'} はセレクター・トークンを取得し、 @code{send} はスタックからセレクターを呼び出し、 @code{postpone}
はセレクター呼び出しコードを生成します。

@findex object-' ( @var{ "name" -- xt   } ) oof
@cindex @code{object-'}
@kindex object-'
@format
@code{object-'} ( @i{"name" -- xt  }) oof ``tick''
@end format

@findex object-postpone ( @var{ "name" --   } ) oof
@cindex @code{object-postpone}
@kindex object-postpone
@format
@code{object-postpone} ( @i{"name" --  }) oof ``object-postpone''
@end format



@item
@code{with} と @code{endwith} は、 スタックから得たオブジェクトをアクティブ・オブジェクトにし、
そのオブジェクトのスコープを有効にします。 @code{with} と @code{endwith} を使用すると、
ステートスマート・オブジェクトにトラップされることなく、 セレクターを @code{postpone} してコードを作成することもできます。

@findex object-with ( @var{ o --   } ) oof
@cindex @code{object-with}
@kindex object-with
@format
@code{object-with} ( @i{o --  }) oof ``object-with''
@end format

@findex object-endwith ( @var{ --   } ) oof
@cindex @code{object-endwith}
@kindex object-endwith
@format
@code{object-endwith} ( @i{--  }) oof ``object-endwith''
@end format



@end itemize

@node Class Declaration, Class Implementation, The OOF base class, OOF
@subsubsection Class Declaration
@cindex class declaration

@itemize @bullet
@item
インスタンス変数

@findex var ( @var{ size --   } ) oof
@cindex @code{var}
@kindex var
@format
@code{var} ( @i{size --  }) oof ``var''
@end format
インスタンス変数を作成する




@item
オブジェクト・ポインタ

@findex ptr ( @var{ --   } ) oof
@cindex @code{ptr}
@kindex ptr
@format
@code{ptr} ( @i{--  }) oof ``ptr''
@end format
インスタンス・ポインターを作成します


@findex asptr ( @var{ class --   } ) oof
@cindex @code{asptr}
@kindex asptr
@format
@code{asptr} ( @i{class --  }) oof ``asptr''
@end format
インスタンス・ポインターへのエイリアスを作成し、 別のクラスにキャスト(cast)します。




@item
Instance defers

@findex defer ( @var{ --   } ) oof
@cindex @code{defer}
@kindex defer
@format
@code{defer} ( @i{--  }) oof ``defer''
@end format
instance defer を作成します




@item
メソッド・セレクター

@findex early ( @var{ --   } ) oof
@cindex @code{early}
@kindex early
@format
@code{early} ( @i{--  }) oof ``early''
@end format
早期結び付け(early binding)用のメソッド・セレクターを作成します。


@findex method ( @var{ --   } ) oof
@cindex @code{メソッド(method)}
@kindex メソッド(method)
@format
@code{method} ( @i{--  }) oof ``method''
@end format
メソッド・セレクターを作成します。




@item
クラス変数(class-wide variables)

@findex static ( @var{ --   } ) oof
@cindex @code{static}
@kindex static
@format
@code{static} ( @i{--  }) oof ``static''
@end format
クラス全体のセル・サイズの変数を作成します。




@item
宣言部分を終わらせる

@findex how: ( @var{ --   } ) oof
@cindex @code{how:}
@kindex how:
@format
@code{how:} ( @i{--  }) oof ``how-to''
@end format
宣言を終わらせ、 実装部分を開始する


@findex class; ( @var{ --   } ) oof
@cindex @code{class;}
@kindex class;
@format
@code{class;} ( @i{--  }) oof ``end-class''
@end format
クラス宣言または実装の終わり




@end itemize

@c -------------------------------------------------------------
@node Class Implementation, , Class Declaration, OOF
@subsubsection Class Implementation
@cindex class implementation

@c -------------------------------------------------------------
@node Mini-OOF, Mini-OOF2, OOF, Object-oriented Forth
@subsection The @file{mini-oof.fs} model
@cindex mini-oof

Gforth の 3 番目のオブジェクト指向 Forth パッケージは 12行野郎(12-liner)です。 @file{objects.fs} 構文と
@file{oof.fs} 構文を組み合わせて使用​​し、 機能を最小限に抑えています。 これは、Bernd Paysan の
comp.lang.forth への投稿に基づいています。

@menu
* Basic Mini-OOF Usage::
* Mini-OOF Example::
* Mini-OOF Implementation::  
@end menu

@c -------------------------------------------------------------
@node Basic Mini-OOF Usage, Mini-OOF Example, Mini-OOF, Mini-OOF
@subsubsection Basic @file{mini-oof.fs} Usage
@cindex mini-oof usage

@comment TODO better description of the last one
基底クラス(base class)(@code{class}、 オブジェクト・ポインターに 1 つのセルを割り当てます) に加えて、
7つのワードがあります。 それは、 メソッドの定義、 変数の定義、 クラスの定義開始、 クラスの定義終了、 結び付けの解決(resolve
binding)、 オブジェクトの割り当て、 クラス・メソッドのコンパイル、 です。


@findex object ( @var{ -- a-addr   } ) mini-oof
@cindex @code{オブジェクト(object)}
@kindex オブジェクト(object)
@format
@code{object} ( @i{-- a-addr  }) mini-oof ``object''
@end format
@var{object} はすべてのオブジェクトの基底クラス(base class)です。


@findex method ( @var{ m v "name" -- m' v   } ) mini-oof
@cindex @code{メソッド(method)}
@kindex メソッド(method)
@format
@code{method} ( @i{m v "name" -- m' v  }) mini-oof ``method''
@end format
セレクターを定義します。


@findex var ( @var{ m v size "name" -- m v'   } ) mini-oof
@cindex @code{var}
@kindex var
@format
@code{var} ( @i{m v size "name" -- m v'  }) mini-oof ``var''
@end format
@var{size} バイトのサイズの変数を定義します。


@findex class ( @var{ class -- class selectors vars   } ) mini-oof
@cindex @code{クラス(class)}
@kindex クラス(class)
@format
@code{class} ( @i{class -- class selectors vars  }) mini-oof ``class''
@end format
クラスの定義を開始します。


@findex end-class ( @var{ class selectors vars "name" --   } ) mini-oof
@cindex @code{end-class}
@kindex end-class
@format
@code{end-class} ( @i{class selectors vars "name" --  }) mini-oof ``end-class''
@end format
クラスの定義を終了します。


@findex defines ( @var{ xt class "name" --   } ) mini-oof
@cindex @code{defines}
@kindex defines
@format
@code{defines} ( @i{xt class "name" --  }) mini-oof ``defines''
@end format
@var{xt} をクラス @var{class} のセレクター @var{name} に結び付け(bind)します。


@findex new ( @var{ class -- o   } ) mini-oof
@cindex @code{new}
@kindex new
@format
@code{new} ( @i{class -- o  }) mini-oof ``new''
@end format
クラス @var{class} の新しい具体化(incarnation)を作成します。


@findex :: ( @var{ class "name" --   } ) mini-oof
@cindex @code{::}
@format
@code{::} ( @i{class "name" --  }) mini-oof ``colon-colon''
@end format
クラス @var{class} のセレクター @var{name} のメソッドをコンパイルします (注意: 即実行ではありません！)。





@c -------------------------------------------------------------
@node Mini-OOF Example, Mini-OOF Implementation, Basic Mini-OOF Usage, Mini-OOF
@subsubsection Mini-OOF Example
@cindex mini-oof example

@comment TODO could flesh this out with some comments from the Forthwrite article
短い例で、 このパッケージの使い方を示します。 他の例として button オブジェクト の Mini-OOF バージョンが
@file{moof-exm.fs} にあります。

@example
object class
  method init
  method draw
end-class graphical
@end example

このコードは、 @code{draw} 操作を持つクラス @code{graphical} を定義します。 任意の @code{graphical}
オブジェクトに対して @code{draw} 操作を実行できます。例:

@example
100 100 t-rex draw
@end example

ここで、 @code{t-rex} はオブジェクトまたはオブジェクト・ポインターであり、 たとえば次のように作成されます:
@code{graphical new Constant t-rex}

具体的な graphical オブジェクトのために、 クラス @code{graphical} の子クラスを定義します。 例:

@example
graphical class
  cell var circle-radius
end-class circle \ "graphical" is the parent class

:noname ( x y -- )
  circle-radius @@ draw-circle ; circle defines draw
:noname ( r -- )
  circle-radius ! ; circle defines init
@end example

暗黙的な init メソッドはないため、 明示的に定義する必要があります。 オブジェクトの作成コードは明示的に init を呼び出す必要があります。

@example
circle new Constant my-circle
50 my-circle init
@end example

すべてのオブジェクトの同じ場所に @code{init} がある場合、 @code{init}
の自動呼び出しで名前付きオブジェクトを作成する関数を追加することもできます:

@example
: new: ( .. o "name" -- )
    new dup Constant init ;
80 circle new: large-circle
@end example

以下のようにして、 この新しい circle を (100,100) に描画できます:

@example
100 100 my-circle draw
@end example

@node Mini-OOF Implementation, , Mini-OOF Example, Mini-OOF
@subsubsection @file{mini-oof.fs} Implementation

遅延結び付け(late binding)を備えたオブジェクト指向システムは通常、 「vtable」アプローチを使用します。 つまり、
各オブジェクトの最初の変数はテーブルへのポインタであり、 テーブルには関数ポインタとしてメソッドが含まれています。 vtable
には他の情報も含まれる場合があります。

まず、 セレクターを宣言しましょう:

@example
: method ( m v "name" -- m' v ) Create  over , swap cell+ swap
  DOES> ( ... o -- ... ) @@ over @@ + @@ execute ;
@end example

セレクターの宣言中、 セレクターの数とインスタンス変数は(アドレス単位で)スタック上にあります。 @code{method} はセレクターを 1
つ作成し、 セレクター番号をインクリメントします。 セレクターを実行するには、 オブジェクトを取得し、 vtable ポインターを取得し、
オフセットを追加して、 そこに保存されているメソッド @i{xt} を実行します。 実行時、 各セレクターは、 スタック・パラメーターのTOSとして、
セレクターを呼び出すオブジェクトを受け取り、 パラメーター(オブジェクトを含む)を変更せずに、 適切なメソッドに渡します。

いまや、 インスタンス変数も宣言しなければなりません

@example
: var ( m v size "name" -- m v' ) Create  over , +
  DOES> ( o -- addr ) @@ + ;
@end example

同様に、 ワードには現在のオフセットを書き込んで作成されます。 インスタンス変数はさまざまなサイズ(セル、 浮動小数点数、 2倍長整数、
char)にすることができるため、 そのサイズを取得してオフセットに追加します。 マシンにアライメント制限がある場合は、 変数の前に適切な
@code{aligned} または @code{faligned} を配置して、 変数のオフセットを調整します。 それが @i{size}
がスタックのTOSにある理由です。

開始点(基底オブジェクト)と、 いくつかの糖衣構文も必要です:

@example
Create object  1 cells , 2 cells ,
: class ( class -- class selectors vars ) dup 2@@ ;
@end example

継承の場合、 新しい派生クラスが宣言されるときに、 親オブジェクトの vtable をコピーする必要があります。 これにより、
親クラスのすべてのメソッドが提供されますが、 それらはオーバーライドすることもできます。

@example
: end-class  ( class selectors vars "name" -- )
  Create  here >r , dup , 2 cells ?DO ['] noop , 1 cells +LOOP
  cell+ dup cell+ r> rot @@ 2 cells /string move ;
@end example

最初の行は、 @code{noop} で初期化された vtable を作成します。  2 行目は継承メカニズムで、 親 vtable から xt
達をコピーします。

新しいメソッドを定義する方法がまだありませんね。 ここで定義しましょう:

@example
: defines ( xt class "name" -- ) ' >body @@ + ! ;
@end example

新しいオブジェクトを割り当てるためのワードも必要です:

@example
: new ( class -- o )  here over @@ allot swap over ! ;
@end example

派生クラスが親オブジェクトのメソッドにアクセスしたい場合があります。 Mini-OOF でこれを実現するには 2 つの方法があります: 1
つ目は名前付きのワードを使用する方法で、 2 つ目は親オブジェクトの vtable を検索する方法です。

@example
: :: ( class "name" -- ) ' >body @@ + @@ compile, ;
@end example


混乱しないためには良い例に勝るものはないので、 以下に例を示します。 まず、
テキストとその位置を格納するテキスト・オブジェクト(@code{button} と呼ばれます)を宣言しましょう:

@example
object class
  cell var text
  cell var len
  cell var x
  cell var y
  method init
  method draw
end-class button
@end example

@noindent
次に、 @code{draw} と @code{init} の 2 つのメソッドを実装します:

@example
:noname ( o -- )
 >r r@@ x @@ r@@ y @@ at-xy  r@@ text @@ r> len @@ type ;
 button defines draw
:noname ( addr u o -- )
 >r 0 r@@ x ! 0 r@@ y ! r@@ len ! r> text ! ;
 button defines init
@end example

@noindent
継承のデモンストレーションとして、 新しいデータや新しいセレクターを持たない、 クラス @code{bold-button} を定義します:

@example
button class
end-class bold-button

: bold   27 emit ." [1m" ;
: normal 27 emit ." [0m" ;
@end example

@noindent
クラス @code{bold-button} には @code{button} とは異なる draw メソッドがありますが、 新しいメソッドは
@code{button} の draw メソッドに関して定義されています:

@example
:noname bold [ button :: draw ] normal ; bold-button defines draw
@end example

@noindent
最後に、 2 つのオブジェクトを作成し、セレクターを適用します:

@example
button new Constant foo
s" thin foo" foo init
page
foo draw
bold-button new Constant bar
s" fat bar" bar init
1 bar y !
bar draw
@end example

@node Mini-OOF2, Comparison with other object models, Mini-OOF, Object-oriented Forth
@subsection Mini-OOF2

Mini-OOF2 は多くの点で Mini-OOF とよく似ていますが、 いくつかの点で大きく異なります。  特に、 Mini-OOF2
には現在のオブジェクト変数(current object variable)を持ち、 プリミティブの @code{>o} と @code{o>}
を使用してそのオブジェクト・スタックを操作します。  すべてのメソッド呼び出しとインスタンス変数へのアクセスは、 現在のオブジェクト(current
object)を参照します。

@findex >o ( @var{ c-addr -- r:c-old  } ) new
@cindex @code{>o}
@kindex >o
@format
@code{>o} ( @i{c-addr -- r:c-old }) new ``to-o''
@end format
現在のオブジェクト(current object)を @var{c_addr} に設定し、
以前の現在のオブジェクトをリターン・スタックにプッシュします。

@findex o> ( @var{ r:c-addr --  } ) new
@cindex @code{o>}
@kindex o>
@format
@code{o>} ( @i{r:c-addr -- }) new ``o-restore''
@end format
リターン・スタックから以前の現在のオブジェクト(current object)を復元します


メソッド呼び出しまたはインスタンス変数アクセスへのオブジェクト・ポインターの受け渡しを容易にするために、 追加の認識器(recognizer)
@code{rec-moof2} がアクティブ化されます。

@findex rec-moof2 ( @var{ addr u -- xt translate-moof2 | notfound   } ) mini-oof2
@cindex @code{rec-moof2}
@kindex rec-moof2
@format
@code{rec-moof2} ( @i{addr u -- xt translate-moof2 | notfound  }) mini-oof2 ``rec-moof2''
@end format
この認識器は非常に単純なドット・パーサ(dot-parser)で、 @code{.SELECTOR} や @code{.IVAR} を @code{>o
SELECTOR o>} や @code{>o IVAR o>} に変換します。



セレクターにメソッドを割り当てるには、 @var{xt class} @code{is} @var{selector} を使用するため、
@code{defines} は必要ありません。  メソッドの早期結び付け(early binding)には、 @code{[} @var{class}
@code{] defers} @var{selector} が使用され、 @code{::} は必要ありません。

@node Comparison with other object models, , Mini-OOF2, Object-oriented Forth
@subsection Comparison with other object models
@cindex comparison of object models
@cindex object models, comparison

【他のオブジェクト・モデルとの比較】オブジェクト指向の Forth 拡張機能が数多く提案されています(@cite{A survey of
object-oriented Forths} (SIGPLAN Notices, April 1996) by Bradford
J. Rodriguez and W. F. S. Poehlman lists 17)。 このセクションでは、 先程説明した、 よく知られた
2つのモデルと、 (メソッド・マップの使用に関して)密接に関連した 2 つのモデルとの関係について議論します。 このセクションでは Andras
Zsoter が協力してくれました。

@cindex Neon model
現在最も人気のあるモデルは Neon モデル(参照: @cite{Object-oriented programming in ANS Forth}
(Forth Dimensions, March 1997)であるようですですが、
このモデルには多くの制限があります@footnote{この批評の長いバージョンは、Anton Ertl の @cite{On Standardizing
Object-Oriented Forth Extensions} (Forth Dimensions, May 1997) にあります。}:

@itemize @bullet
@item
@code{selector object} 構文を使用しているため、 スタック上でオブジェクトを渡すのが不自然になります。

@item
セレクターが入力ストリームを(コンパイル時に)パースする必要があります。 これにより、 拡張性が低下し、 バグが発見されにくくなります。

@item
これにより、 すべてのオブジェクトですべてのセレクターを使用できるようになり、 インターフェイスが不要になりますが、
効率的な実装を作成することが難しくなります。
@end itemize

@cindex Pountain's object-oriented model
もう 1 つのよく知られた出版物は、 @cite{Object-Oriented Forth} (Academic Press, London,
1987) by Dick Pountain ですが、 遅延結び付け(late binding)をほとんど扱っていないため、
真のオブジェクト指向プログラミングに関するモノとは言えません。 代わりに、 Ada (83)
のようなモジュラー言語の特徴である情報隠蔽やオーバーロードなどの機能に焦点を当てています。

@cindex Zsoter's object-oriented model
@uref{http://www.forth.org/oopf.html, Does late binding have to be slow?}
(Forth Dimensions 18(1) 1996, pages 31-35)(「遅延結び付けは遅くないといけないのか？」) で、 Andras
Zsoter は(@file{objects.fs} の @code{this}
のような)アクティブ・オブジェクトを多用するモデルについて説明しています。 アクティブ・オブジェクトは、
すべてのフィールドにアクセスするために使用されるだけでなく、 すべてのセレクター呼び出しの受信オブジェクトも指定します。 あなたは @code{@{
... @}} を使用してアクティブなオブジェクトを明示的に変更する必要がありますが、 @file{objects.fs} では @code{m:
... ;m} で多かれ少なかれ暗黙的に変更されます。 Zsoter のモデルでは、 受信オブジェクトがすでにアクティブなオブジェクトであるため、
メソッドのエントリ・ポイントでのこのような変更は不要です。 一方、 Zsoter のモデルでは明示的な変更(機能)が絶対に必要です。 そうしないと、
誰もアクティブ・オブジェクトを変更できなくなるからです。 このモデルの標準 Forth での実装は、
@uref{http://www.forth.org/oopf.html} から入手できます。

@cindex @file{oof.fs}, differences to other models
@file{oof.fs} モデルは、
(さまざまなワードリストに名前を保持することにより、)情報の隠蔽とオーバーロードの解決(resolution)をオブジェクト指向プログラミングと組み合わせます。
メソッドのエントリ時にアクティブ・オブジェクトを暗黙的に設定しますが、 (@code{>o...o>} または
@code{with...endwith} を使用して、)明示的に変更することもできます。 オーバーロードの解決と早期結び付け(early
binding)のために、 パースと、 ステートスマートなオブジェクトとクラスを使用します: オブジェクトまたはクラスはセレクターをパースし、
そこからメソッドを決定します。 セレクターがオブジェクトまたはクラスによってパースされない場合、 Zsoter のモデルのように、
アクティブなオブジェクトのセレクターへの呼び出し(遅延結び付け;late binding)が実行されます。
フィールドには常にアクティブ・オブジェクトを通じてアクセスします。 このモデルの大きな欠点は、 パースとステート・スマートです。
これにより拡張性が低下し、微妙なバグが発生する可能性が高くなります。 基本的に、 オブジェクトやクラスをティック(tick)したり
@code{postpone} したりしない場合にのみ安全です(Bernd は反対しているが、 著者 (Anton) は納得していない)。

@cindex @file{mini-oof.fs}, differences to other models
@file{mini-oof.fs} モデルは、 @file{objects.fs} モデルの非常に簡素化されたバージョンに非常に似ていますが、
構文的には @file{objects.fs} と @file{oof.fs} モデルが混合されたものです。 。

@c -------------------------------------------------------------
@node Regular Expressions, Programming Tools, Object-oriented Forth, Words
@section Regular Expressions
@cindex regexps

正規表現(regular expression)は、 多くの現代的プログラミング言語で見られる、 文字列のパターン・マッチング・アルゴリズムです。
あなたは  @code{require regexp.fs} を使用して正規表現機能を Gforth に追加できます。

このパターン・マッチングの古典的な実装はバックトラッキング・アルゴリズムです。 これは、 後方参照などの機能を使用する場合にも必要です。  Gforth
は、 パターン・マッチングのためのバックトラッキング・プログラムを定義する言語(language)を提供することで正規表現を実装します。
基本要素は制御構造 @code{FORK} @dots{} @code{JOIN} です。 これはワード内での前方呼び出しであるため、
軽量の試行錯誤制御構造(try and fail control structure)をコーディングできます。

@findex FORK ( @var{ compilation -- orig ; run-time f --   } ) gforth-0.7
@cindex @code{FORK}
@kindex FORK
@format
@code{FORK} ( @i{compilation -- orig ; run-time f --  }) gforth-0.7 ``FORK''
@end format
AHEAD のような制御構造: JOIN の後にコードを呼び出します。


@findex JOIN ( @var{ orig --   } ) gforth-0.7
@cindex @code{JOIN}
@kindex JOIN
@format
@code{JOIN} ( @i{orig --  }) gforth-0.7 ``JOIN''
@end format
FORK のための、 THEN のような制御構造



あなたは、 チェックが失敗した場合に、 フラグと @code{?LEAVE} を計算することで、 任意の種類のチェックを自分でプログラムできます。
正規表現コードは @code{((} と @code{))} で囲まれています。

@findex (( ( @var{ addr u --   } ) regexp-pattern
@cindex @code{((}
@kindex ((
@format
@code{((} ( @i{addr u --  }) regexp-pattern ``((''
@end format
正規表現ブロックの開始


@findex )) ( @var{ -- flag   } ) regexp-pattern
@cindex @code{))}
@kindex ))
@format
@code{))} ( @i{-- flag  }) regexp-pattern ``))''
@end format
正規表現ブロックの終了



正規表現のパターン・マッチングには要素として文字セットがあるため、 多くの機能を使用して文字クラス(@code{charclass}
と呼ばれる)を作成・変更できます。  ここでの文字はすべてバイトであるため、 ユニコード文字用には拡張されません。

@findex charclass ( @var{ --   } ) regexp-cg
@cindex @code{charclass}
@kindex charclass
@format
@code{charclass} ( @i{--  }) regexp-cg ``charclass''
@end format
文字クラスを作成します


@findex +char ( @var{ char --   } ) regexp-cg
@cindex @code{+char}
@kindex +char
@format
@code{+char} ( @i{char --  }) regexp-cg ``+char''
@end format
現在の文字クラスに @i{char} を追加します


@findex -char ( @var{ char --   } ) regexp-cg
@cindex @code{-char}
@kindex -char
@format
@code{-char} ( @i{char --  }) regexp-cg ``-char''
@end format
現在の文字クラスから @i{char} を削除します


@findex ..char ( @var{ start end --   } ) regexp-cg
@cindex @code{..char}
@kindex ..char
@format
@code{..char} ( @i{start end --  }) regexp-cg ``..char''
@end format
char の範囲(@i{start} 〜 @i{end})を現在の文字クラスに追加します


@findex +chars ( @var{ addr u --   } ) regexp-cg
@cindex @code{+chars}
@kindex +chars
@format
@code{+chars} ( @i{addr u --  }) regexp-cg ``+chars''
@end format
charの文字列(string)を現在の文字クラスに追加します


@findex +class ( @var{ class --   } ) regexp-cg
@cindex @code{+class}
@kindex +class
@format
@code{+class} ( @i{class --  }) regexp-cg ``+class''
@end format
文字クラス @var{class} と現在の文字クラスの結合(union)


@findex -class ( @var{ class --   } ) regexp-cg
@cindex @code{-class}
@kindex -class
@format
@code{-class} ( @i{class --  }) regexp-cg ``-class''
@end format
現在の文字クラスから、 文字クラス @var{class} を抜き取ります(subtract)。



事前定義された文字クラス(charclasses)とそれらのテストと、 一般的なチェックがあります。  チェックが失敗した場合は、
次に考えられる正規表現の代替が試行されるか、 または、 ループが終了(@i{leave})します(訳注: 基本的には、 チェックが成功した場合は
@var{addr} を 1文字(char)分進めた @var{addr'} を返し、 失敗した場合はスタックに何も積まずに @i{leave}
する)。

@findex c? ( @var{ addr class --   } ) regexp-pattern
@cindex @code{c?}
@kindex c?
@format
@code{c?} ( @i{addr class -- addr' }) regexp-pattern ``c?''
@end format
文字クラス @var{class} にマッチ(@var{addr} の位置の char が文字クラス @var{class} に含まれているなら
@var{addr} の 1 char 次のアドレスを @var{addr`} に返し、 含まれていないなら @code{leave} する)


@findex -c? ( @var{ addr class --   } ) regexp-pattern
@cindex @code{-c?}
@kindex -c?
@format
@code{-c?} ( @i{addr class -- addr' }) regexp-pattern ``-c?''
@end format
文字クラス @var{class} 以外にマッチ(@var{addr} の位置の文字が文字クラス @var{class} に含まれていなければ
@var{addr} の1文字後ろのアドレスを @var{addr'} に返し、含まれていたら @code{leave} する)


@findex \d ( @var{ addr -- addr'   } ) regexp-pattern
@cindex @code{\d}
@kindex \d
@format
@code{\d} ( @i{addr -- addr'  }) regexp-pattern ``\d''
@end format
数字([0-9])にマッチ(指定の @var{addr} の char が digit かどうか([0-9])しらべ、 そうなら @var{addr}
の char 分次のアドレスを addr' に返す。 そうでなければ @code{leave} する)


@findex \s ( @var{ addr -- addr'   } ) regexp-pattern
@cindex @code{\s}
@kindex \s
@format
@code{\s} ( @i{addr -- addr'  }) regexp-pattern ``\s''
@end format
非表示文字(\x00〜\x20)にマッチ(指定の @var{addr} の char が blanks かどうか([\x00-\x20])しらべ、
そうなら @var{addr} の char 分次のアドレスを addr' に返す。 そうでなければ @code{leave} する)


@findex .? ( @var{ addr -- addr'   } ) regexp-pattern
@cindex @code{.?}
@kindex .?
@format
@code{.?} ( @i{addr -- addr'  }) regexp-pattern ``.?''
@end format
任意の1文字(char)にマッチ(任意の1文字(char)であれば次の文字のアドレスを @i{addr'} に返します。 そうでなければ
@i{leave} します)


@findex -\d ( @var{ addr -- addr'   } ) regexp-pattern
@cindex @code{-\d}
@kindex -\d
@format
@code{-\d} ( @i{addr -- addr'  }) regexp-pattern ``-\d''
@end format
@i{addr} の文字が数字で無ければ([^0-9])次の文字のアドレスを @i{addr'} に返します。 そうでなければ @i{leave}
します。


@findex -\s ( @var{ addr -- addr'   } ) regexp-pattern
@cindex @code{-\s}
@kindex -\s
@format
@code{-\s} ( @i{addr -- addr'  }) regexp-pattern ``-\s''
@end format
指定の @var{addr} の char が blanks で無いかどうか([^\x00-\x20])しらべ、 そうなら @var{addr} の
char 分次のアドレスを @i{addr'} に返す。 そうでなければ @code{leave} する


@findex ` ( @var{ "char" --   } ) regexp-pattern
@cindex @code{`}
@kindex `
@format
@code{`} ( @i{addr "char" -- addr' }) regexp-pattern ```''
@end format
指定の文字をチェックします。 @code{` c} の形で使用し、 @var{addr} の文字が 文字 c ならば、 次の文字へのアドレスを
@var{addr'} に返し、そうでなければ @i{leave} します。


@findex `? ( @var{ "char" --   } ) regexp-pattern
@cindex @code{`?}
@kindex `?
@format
@code{`?} ( @i{addr "char" -- addr | addr' }) regexp-pattern ```?'' @*\ 訳注: @code{`? c}  @var{addr} の文字が c ならば @var{addr} をそのまま返す。 c でなければ次の文字へのアドレスを @var{addr'} に返す。
@end format

@findex -` ( @var{ "char" --   } ) regexp-pattern
@cindex @code{-`}
@kindex -`
@format
@code{-`} ( @i{addr "char" -- addr' }) regexp-pattern ``-`'' @*\ 訳注: @code{-` c} @var{addr} の文字が c でなければ次の文字へのアドレスを @var{addr'} に返す。 そうでなければ @i{leave} する。
@end format
指定の文字をチェックします。 @code{` c} の形で使用し、 @var{addr} の文字が 文字 c ならば、 次の文字へのアドレスを
@var{addr'} に返し、そうでなければ @i{leave} します。



明示的に文字列の開始と終了、および文字列定数全体をチェックすることもできます。

@findex \^ ( @var{ addr -- addr   } ) regexp-pattern
@cindex @code{\^}
@kindex \^
@format
@code{\^} ( @i{addr -- addr  }) regexp-pattern ``\^''
@end format
文字列の開始にマッチ


@findex \$ ( @var{ addr -- addr   } ) regexp-pattern
@cindex @code{\$}
@kindex \$
@format
@code{\$} ( @i{addr -- addr  }) regexp-pattern ``\$''
@end format
文字列の終了にマッチ


@findex str=? ( @var{ addr1 addr u -- addr2   } ) regexp-pattern
@cindex @code{str=?}
@kindex str=?
@format
@code{str=?} ( @i{addr1 addr u -- addr2  }) regexp-pattern ``str=?''
@end format
指定の文字列 @i{addr u} にマッチ(等しい)するかどうかチェックします(マッチすれば文字列の次のアドレスを @i{addr2} に返します。
マッチしない場合は @i{leave} します)


doc-='' (原文未記述)

繰り返される文字セットをチェックするループは、 貪欲(greedy)または非貪欲(non-greedy)にすることができます。

@findex @{** ( @var{ addr -- addr addr   } ) regexp-pattern
@cindex @code{@{**}
@kindex @{**
@format
@code{@{**} ( @i{addr -- addr addr  }) regexp-pattern ``begin-greedy-star''
@end format
貪欲な 0 個以上のパターンの開始


@findex **@} ( @var{ sys --   } ) regexp-pattern
@cindex @code{**@}}
@kindex **@}
@format
@code{**@}} ( @i{sys --  }) regexp-pattern ``end-greedy-star''
@end format
貪欲な 0 個以上のパターンの終わり


@findex @{++ ( @var{ addr -- addr addr   } ) regexp-pattern
@cindex @code{@{++}
@kindex @{++
@format
@code{@{++} ( @i{addr -- addr addr  }) regexp-pattern ``begin-greedy-plus''
@end format
貪欲な 1 つ以上のパターンの開始


@findex ++@} ( @var{ sys --   } ) regexp-pattern
@cindex @code{++@}}
@kindex ++@}
@format
@code{++@}} ( @i{sys --  }) regexp-pattern ``end-greedy-plus''
@end format
貪欲な 1 つ以上のパターンの終わり


@findex @{* ( @var{ addr -- addr addr   } ) regexp-pattern
@cindex @code{@{*}
@kindex @{*
@format
@code{@{*} ( @i{addr -- addr addr  }) regexp-pattern ``begin-non-greedy-star''
@end format
非貪欲な 0 個以上のパターンの開始


@findex *@} ( @var{ addr addr' -- addr'   } ) regexp-pattern
@cindex @code{*@}}
@kindex *@}
@format
@code{*@}} ( @i{addr addr' -- addr'  }) regexp-pattern ``end-non-greedy-star''
@end format
非貪欲な 0 個以上のパターンの終わり


@findex @{+ ( @var{ addr -- addr addr   } ) regexp-pattern
@cindex @code{@{+}
@kindex @{+
@format
@code{@{+} ( @i{addr -- addr addr  }) regexp-pattern ``begin-non-greedy-plus''
@end format
非貪欲な 1 つ以上のパターンの開始


@findex +@} ( @var{ addr addr' -- addr'   } ) regexp-pattern
@cindex @code{+@}}
@kindex +@}
@format
@code{+@}} ( @i{addr addr' -- addr'  }) regexp-pattern ``end-non-greedy-plus''
@end format
非貪欲な 1 つ以上のパターンの終わり



例: 部分文字列の検索は、 実際にはその前にあるものとの非貪欲な一致です。

@findex // ( @var{ --   } ) regexp-pattern
@cindex @code{//}
@kindex //
@format
@code{//} ( @i{--  }) regexp-pattern ``//''
@end format
文字列内を検索(後続のパターンを文字列先頭ではなく文字列中でのマッチにする)(訳注:@*: ([0-9])  ( addr u -- )  (( \(
\d \) )) IF ." [" \1 type ." ]" ELSE ." fail" THEN ;@*"0123" ([0-9])  [0]
ok@*"A123" ([0-9])  fail ok@*: (//[0-9])  ( addr u -- )  (( // \( \d \) ))
IF ." [" \1 type ." ]" ELSE ." fail" THEN ;.@*"0123" (//[0-9])  [0]
ok@*"A123" (//[0-9])  [1] ok@*"ABC3" (//[0-9]) [3] ok)



選択肢(alternative)は以下のように書きます。

@findex @{@{ ( @var{ addr -- addr addr   } ) regexp-pattern
@cindex @code{@{@{}
@kindex @{@{
@format
@code{@{@{} ( @i{addr -- addr addr  }) regexp-pattern ``begin-alternatives''
@end format
選択肢(alternatives)の開始


@findex || ( @var{ addr addr -- addr addr   } ) regexp-pattern
@cindex @code{||}
@kindex ||
@format
@code{||} ( @i{addr addr -- addr addr  }) regexp-pattern ``next-alternative''
@end format
選択肢の区切り文字


@findex @}@} ( @var{ addr addr -- addr   } ) regexp-pattern
@cindex @code{@}@}}
@kindex @}@}
@format
@code{@}@}} ( @i{addr addr -- addr  }) regexp-pattern ``end-alternatives''
@end format
選択肢の終了



@code{\1} ～ @code{\9} という名前の変数を最大 9 つ使用して、 一致した部分文字列を参照できます

@findex \( ( @var{ addr -- addr   } ) regexp-pattern
@cindex @code{\(}
@kindex \(
@format
@code{\(} ( @i{addr -- addr  }) regexp-pattern ``\(''
@end format
マッチング変数の開始;変数は \\1〜9 として参照されます


@findex \) ( @var{ addr -- addr   } ) regexp-pattern
@cindex @code{\)}
@kindex \)
@format
@code{\)} ( @i{addr -- addr  }) regexp-pattern ``\)''
@end format
マッチング変数の終わり


@findex \0 ( @var{ -- addr u   } ) regexp-pattern
@cindex @code{\0}
@kindex \0
@format
@code{\0} ( @i{-- addr u  }) regexp-pattern ``\0''
@end format
文字列全体



もちろん、 あなたは、 見つけたパターンを置換するコードを作成することもできます。

@findex s>> ( @var{ addr -- addr   } ) regexp-replace
@cindex @code{s>>}
@kindex s>>
@format
@code{s>>} ( @i{addr -- addr  }) regexp-replace ``s>>''
@end format
検索/置換 の置換パターン領域の開始


@findex >> ( @var{ addr -- addr   } ) regexp-replace
@cindex @code{>>}
@kindex >>
@format
@code{>>} ( @i{addr -- addr  }) regexp-replace ``>>''
@end format
任意の置換コードを開始し、 コードはスタック上の文字列を評価し、 それを @code{<<} に渡します。


@findex << ( @var{ run-addr addr u -- run-addr   } ) regexp-replace
@cindex @code{<<}
@kindex <<
@format
@code{<<} ( @i{run-addr addr u -- run-addr  }) regexp-replace ``<<''
@end format
置換パターン領域の先頭からを、 指定の文字列 @var{addr} @var{u} に置換します


@findex <<" ( @var{ "string<">" --   } ) regexp-replace
@cindex @code{<<"}
@kindex <<"
@format
@code{<<"} ( @i{"string<">" --  }) regexp-replace ``<<"''
@end format
置換パターン領域の先頭から文字列を @var{string} に置換します(訳注: 使い方: @code{<<" @var{string}} )


@findex s// ( @var{ addr u -- ptr   } ) regexp-replace
@cindex @code{s//}
@kindex s//
@format
@code{s//} ( @i{addr u -- ptr  }) regexp-replace ``s//''
@end format
検索/置換 ループの開始


@findex //s ( @var{ ptr --   } ) regexp-replace
@cindex @code{//s}
@kindex //s
@format
@code{//s} ( @i{ptr --  }) regexp-replace ``//s''
@end format
検索の終わり


@findex //o ( @var{ ptr addr u -- addr' u'   } ) regexp-replace
@cindex @code{//o}
@kindex //o
@format
@code{//o} ( @i{ptr addr u -- addr' u'  }) regexp-replace ``//o''
@end format
検索/置換 の単一ループの終了


@findex //g ( @var{ ptr addr u -- addr' u'   } ) regexp-replace
@cindex @code{//g}
@kindex //g
@format
@code{//g} ( @i{ptr addr u -- addr' u'  }) regexp-replace ``//g''
@end format
検索/置換 の全てのループの終了



これらの使用例は @code{test/regexp-test.fs} にあります。

@c -------------------------------------------------------------
@node Programming Tools, Multitasker, Regular Expressions, Words
@section Programming Tools
@cindex programming tools

@c !! move this and assembler down below OO stuff.

@menu
* Locating source code definitions::  and editing
* Locating uses of a word::  @code{where}.
* Locating exception source::  バックトレースの検証(examing)
* Examining compiled code::  @code{see} and friends.
* Examining data::           スタック と メモリ
* Forgetting words::         通常、再ロード前に使われます
* Debugging::                トレーサー @code{~~} 
                               を適宜挿入することによって
* Assertions::               あなたのプログラムを自己チェックさせます
* Singlestep Debugger::      あなたのプログラムをワート単位で実行します
* Code Coverage::            実行頻度を測定します
@end menu

@node Locating source code definitions, Locating uses of a word, Programming Tools, Programming Tools
@subsection Locating source code definitions
@cindex source code of a word
@cindex @code{view} (called @code{locate} in Gforth)
@cindex integrated development environment
@cindex IDE (integrated development environment)

多くのプログラミング・システムは、 エディターがシステムのハブとなり、 プログラムを構築して実行できる統合開発環境(IDE)として編成されています。
それが必要な場合は、Gforth にもそれがあります(@pxref{Emacs and Gforth})。

しかしながら、いくつかの Forth システムには異なる種類の IDE を持っています: Forth コマンド・ラインが開発環境のハブです。
そこからさまざまな方法でソースを表示し、 必要に応じてエディターを呼び出すことができます。

gforth もそのような IDE を実装しています。 gforth は SwiftForth の慣習をほぼ踏襲していますが、
それ以上の機能を実装しています。

このアプローチの利点は、 お気に入りのエディターを使用できることです。 環境変数 @code{EDITOR} をお気に入りのエディターに設定すると、
編集コマンドがそのエディターを呼び出します。 Gforth はバックグラウンドでいくつかの GUI エディターを呼び出し(そのため、 Forth
セッションは続行するので、 編集を終了する必要はありません)、 ターミナル上のエディターはフォアグラウンドで呼び出します(Gforth
に認識されないエディターのデフォルトはフォアグラウンドです)。  @code{EDITOR} を設定していない場合、 デフォルトのエディターは
@file{vi} です。

@findex locate ( @var{ "name" --   } ) gforth-1.0
@cindex @code{locate}
@kindex locate
@format
@code{locate} ( @i{"name" --  }) gforth-1.0 ``locate''
@end format
ワード @i{name} のソース・コードを表示し、 現在位置(current location)をそこに設定します。


doc-xt-locate(原文 未記述)

「現在位置」(current location)は、 @code{locate} に加えて、 他の多くのワードによって設定されます。  また、
ファイルのロード中にエラーが発生した場合、 エラーの場所が現在位置になります。

多くのワードが現在位置(current location)で機能します:

@findex l ( @var{ --   } ) gforth-1.0
@cindex @code{l}
@kindex l
@format
@code{l} ( @i{--  }) gforth-1.0 ``l''
@end format
現在位置(current location)のソースコードの行達を表示します。


@findex n ( @var{ --   } ) gforth-1.0
@cindex @code{n}
@kindex n
@format
@code{n} ( @i{--  }) gforth-1.0 ``n''
@end format
現在位置より後ろの行、 または最後の @code{n} または @code{b} 出力より後ろの行を表示します。


@findex b ( @var{ --   } ) gforth-1.0
@cindex @code{b}
@kindex b
@format
@code{b} ( @i{--  }) gforth-1.0 ``b''
@end format
現在位置より前の行、 または最後の @code{n} または @code{b} 出力より前の行を表示します。


@findex g ( @var{ --   } ) gforth-0.7
@cindex @code{g}
@kindex g
@format
@code{g} ( @i{--  }) gforth-0.7 ``g''
@end format
現在位置、 または最後の @code{n} または @code{b} 出力の先頭からエディターに入ります。



以下の値を変更することで、 @code{l} や @code{n} や @code{b} で表示する行数を制御できます:

@findex before-locate ( @var{ -- u   } ) gforth-1.0
@cindex @code{before-locate}
@kindex before-locate
@format
@code{before-locate} ( @i{-- u  }) gforth-1.0 ``before-locate''
@end format
現在位置の前に表示される行数(デフォルトは 3)。


@findex after-locate ( @var{ -- u   } ) gforth-1.0
@cindex @code{after-locate}
@kindex after-locate
@format
@code{after-locate} ( @i{-- u  }) gforth-1.0 ``after-locate''
@end format
現在位置の後に表示される行数 (デフォルトは 12)。



最後に、以下を使用すると、 エディターを開いて当該ワードのソース・コードに直接移動できます。

@findex edit ( @var{ "name" --   } ) gforth-1.0
@cindex @code{edit}
@kindex edit
@format
@code{edit} ( @i{"name" --  }) gforth-1.0 ``edit''
@end format
"name" の場所でエディターを起動します。



以下を使用すると、 似た名前のワードの定義を確認できます

@findex browse ( @var{ "subname" --   } ) gforth-1.0
@cindex @code{browse}
@kindex browse
@format
@code{browse} ( @i{"subname" --  }) gforth-1.0 ``browse''
@end format
(@code{mwords} のように、) @i{subname}
を名前の一部に含むワードが定義されているすべての場所を表示します(@pxref{Word Lists})。  その後、 @code{ww} または
@code{nw} または @code{bw} (@pxref{Locating uses of a word}) を使用して、
特定の場所をより詳細に調査できます(訳注: 表示結果各行末尾の数(インデックス)を指定して、 @code{ww} で当該の場所の内容を閲覧する、 等)




@node Locating uses of a word, Locating exception source, Locating source code definitions, Programming Tools
@subsection Locating uses of a word
@cindex Uses of a word

@findex where ( @var{ "name" --   } ) gforth-1.0
@cindex @code{where}
@kindex where
@format
@code{where} ( @i{"name" --  }) gforth-1.0 ``where''
@end format
@i{name} が「使用されている」すべての場所を表示します(テキスト・インタプリタ時)。  その後、 @code{ww} または @code{nw}
または @code{bw} を使用して、 特定の場所をより詳細に調べられます。  gforth の @code{where} では @i{name}
の定義は表示されません。 そのためには @code{locate} を使用してください。


@findex ww ( @var{ u --   } ) gforth-1.0
@cindex @code{ww}
@kindex ww
@format
@code{ww} ( @i{u --  }) gforth-1.0 ``ww''
@end format
その後の @code{l} や @code{g} で閲覧する場所をインデックス @i{u} で指定します。 ここで、 インデックスは
@code{browse} や @code{where} で表示した際の行末尾の数字です。


@findex nw ( @var{ --   } ) gforth-1.0
@cindex @code{nw}
@kindex nw
@format
@code{nw} ( @i{--  }) gforth-1.0 ``nw''
@end format
次の @code{l} または @code{g} では、 @code{browse} または @code{where} の次の行の場所を表示します。
現在位置(current location)が @code{browse} や @code{where} の表示の最後のモノである場合、
@code{nw} の後には何も無いです。 現在位置(current location)がまだ設定されていない時は、 @code{nw} の後は、
@code{browse} や @code{where} の表示の最初のものが現在位置(current location)になります。


@findex bw ( @var{ --   } ) gforth-1.0
@cindex @code{bw}
@kindex bw
@format
@code{bw} ( @i{--  }) gforth-1.0 ``bw''
@end format
次の @code{l} または @code{g} では、 @code{browse} または @code{where} の前の行の場所を表示します。
現在位置(current location)が @code{browse} や @code{where} の表示の最初のモノである場合、
@code{bw} の後には何も無いです。 現在位置(current location)がまだ設定されていない時は、 @code{nw} の後は、
@code{browse} や @code{where} の表示の最後のものが現在位置(current location)になります。


@findex gg ( @var{ --   } ) gforth-1.0
@cindex @code{gg}
@kindex gg
@format
@code{gg} ( @i{--  }) gforth-1.0 ``gg''
@end format
このワードの次の @code{ww} や @code{nw} や @code{bw} や @code{bb} や @code{nb} や
@code{lb} (ただし、 @code{locate} や @code{edit} や @code{l} や @code{g} は除く)は、
その結果を(@code{g} のように)エディターに流し込みます。  これをこの場限り(one-shot)では無くく永続的にするには、 @code{gg
gg} を使用します。


@findex ll ( @var{ --   } ) gforth-1.0
@cindex @code{ll}
@kindex ll
@format
@code{ll} ( @i{--  }) gforth-1.0 ``ll''
@end format
このワードの次の @code{ww} や @code{nw} や @code{bw} や @code{bb} や @code{nb} や
@code{lb} (ただし、 @code{locate} や @code{edit} や @code{l} や @code{g}
は除く)は(@code{l} のように) Forth システムに表示されます。  これを1回限りではなく永続的にするには、 @code{ll ll}
を使用します。


@findex whereg ( @var{ "name" --   } ) gforth-1.0
@cindex @code{whereg}
@kindex whereg
@format
@code{whereg} ( @i{"name" --  }) gforth-1.0 ``whereg''
@end format
@code{where} と似ていますが、 出力をエディターに流し込みます。  Emacs では、コンパイル・モード・コマンド
(@pxref{Compilation Mode,,,emacs,GNU Emacs Manual}) を使用して、
特定の箇所をより詳細に調査できます。


@findex short-where ( @var{ --   } ) gforth-1.0
@cindex @code{short-where}
@kindex short-where
@format
@code{short-where} ( @i{--  }) gforth-1.0 ``short-where''
@end format
短いファイル形式を使用するように @code{where} を設定します(デフォルト)。


@findex expand-where ( @var{ --   } ) gforth-1.0
@cindex @code{expand-where}
@kindex expand-where
@format
@code{expand-where} ( @i{--  }) gforth-1.0 ``expand-where''
@end format
完全に拡張されたファイル形式を使用するように @code{where} を設定します(例えば、 エディターなどに渡すためです)。


@findex prepend-where ( @var{ --   } ) gforth-1.0
@cindex @code{prepend-where}
@kindex prepend-where
@format
@code{prepend-where} ( @i{--  }) gforth-1.0 ``prepend-where''
@end format
@code{where} を設定してファイルを別の行に表示し、 その後にファイル名のない @code{where} 行が続きます(SwiftForth
風)。



ワードの使用状況に関するデータを利用すると、 どのワードが使用されていないのかを表示することもできます:

@findex unused-words ( @var{ --   } ) gforth-1.0
@cindex @code{unused-words}
@kindex unused-words
@format
@code{unused-words} ( @i{--  }) gforth-1.0 ``unused-words''
@end format
使用されていないすべてのワードをリストします



@node Locating exception source, Examining compiled code, Locating uses of a word, Programming Tools
@subsection Locating exception source
@cindex exception source code
@cindex source code for exception
@cindex backtrace examination

@findex tt ( @var{ u --   } ) gforth-1.0
@cindex @code{tt}
@kindex tt
@format
@code{tt} ( @i{u --  }) gforth-1.0 ``tt''@*\ 訳注: エラー表示時の Backtrace: で表示される番号を指定して、その場所を表示します。
@end format

@findex nt ( @var{  --   } ) gforth-1.0
@cindex @code{nt}
@kindex nt
@format
@code{nt} ( @i{ --  }) gforth-1.0 ``nt''@*\ 訳注: @code{tt} の次の backtrace 行の場所を表示します。
@end format

@findex bt ( @var{ --   } ) gforth-1.0
@cindex @code{bt}
@kindex bt
@format
@code{bt} ( @i{--  }) gforth-1.0 ``bt''@*\ 訳注: @code{tt} で表示した1行前の backtrace 行の場所を表示します。
@end format


@node Examining compiled code, Examining data, Locating exception source, Programming Tools
@subsection Examining compiled code
@cindex compiled code examination

そして最後に、 @code{see} とそのファミリーが、 コンパイル済のコードの表示を行います。  ソース・コード内の一部の内容は、
コンパイルされたコードには存在しません(書式設定やコメント等)。 しかし、 これは、 マクロや Gforth
の最適化機能によってどのようなスレッド化コード(threaded code)やネイティブ・コード(native
code)が生成されるかを確認するのに役立ちます。

@findex see ( @var{ "<spaces>name" --   } ) tools
@cindex @code{see}
@kindex see
@format
@code{see} ( @i{"<spaces>name" --  }) tools ``see''
@end format
現在の検索順序(search order)を使用して @var{name} を @code{locate} します。 @code{locate}
できたら、 その定義を表示します。 これは定義を逆コンパイルすることで実現されるため、 書式は機械化され、
一部のソース情報(コメントや定義内のインタプリトされたシーケンスなど)は失われます。


@findex xt-see ( @var{ xt --   } ) gforth-0.2
@cindex @code{xt-see}
@kindex xt-see
@format
@code{xt-see} ( @i{xt --  }) gforth-0.2 ``xt-see''
@end format
@i{xt} で表される定義を逆コンパイルします。


@findex simple-see ( @var{ "name" --   } ) gforth-0.6
@cindex @code{simple-see}
@kindex simple-see
@format
@code{simple-see} ( @i{"name" --  }) gforth-0.6 ``simple-see''
@end format
コロン定義 @i{name} を逆コンパイルして各セルごとに行表示し、 セルの意味を推測してそれを表示します。


@findex xt-simple-see ( @var{ xt --   } ) gforth-1.0
@cindex @code{xt-simple-see}
@kindex xt-simple-see
@format
@code{xt-simple-see} ( @i{xt --  }) gforth-1.0 ``xt-simple-see''
@end format
@code{simple-see} のようにコロン定義 @i{xt} を逆コンパイルします。


@findex simple-see-range ( @var{ addr1 addr2 --   } ) gforth-0.6
@cindex @code{simple-see-range}
@kindex simple-see-range
@format
@code{simple-see-range} ( @i{addr1 addr2 --  }) gforth-0.6 ``simple-see-range''
@end format
[@i{addr1},@i{addr2}) ( @i{addr1} <= and < @i{addr2} )の範囲のコードを
@code{simple-see}  のように逆コンパイルします


@findex see-code ( @var{ "name" --   } ) gforth-0.7
@cindex @code{see-code}
@kindex see-code
@format
@code{see-code} ( @i{"name" --  }) gforth-0.7 ``see-code''
@end format
@code{simple-see} と似ていますが、 インライン化されたプリミティブの動的ネイティブ・コード(dynamic native
code)も表示されます。  静的命令融合(superinstructions)の場合、
最初のプリミティブではなくプリミティブ・シーケンスが表示されます(命令融合(superinstructions)の他のプリミティブも表示されます)。
ネイティブ・コードが生成されるプリミティブの場合、 最初と最後のレジスタ内のスタック項目の数が表示されます(たとえば、 @code{1->1} は、
最初と最後のレジスタに 1 つのスタック項目があることを意味します)。
ネイティブ・コードを使用した各プリミティブまたは命令融合(superinstructions)については、
インライン引数とコンポーネント・プリミティブが最初に表示され、 次にネイティブ・コードが表示されます。


@findex xt-see-code ( @var{ xt --   } ) gforth-1.0
@cindex @code{xt-see-code}
@kindex xt-see-code
@format
@code{xt-see-code} ( @i{xt --  }) gforth-1.0 ``xt-see-code''
@end format
コロン定義 @i{xt} を @code{see-code} のように逆コンパイルします。


@findex see-code-range ( @var{ addr1 addr2 --   } ) gforth-0.7
@cindex @code{see-code-range}
@kindex see-code-range
@format
@code{see-code-range} ( @i{addr1 addr2 --  }) gforth-0.7 ``see-code-range''
@end format
[@i{addr1},@i{addr2}) ( @i{addr1} <= and < @i{addr2} )の範囲のコードを
@code{see-code} のように逆コンパイルします。



例として、 以下について考えてみましょう:

@example
: foo x f@@ fsin drop over ;
@end example

この例は特に役に立つわけではありませんが、 さまざまなコード生成の違いを示しています。  これを AMD64 の @code{gforth-fast}
でコンパイルし、 @code{see-code foo} を使用すると以下の出力が得られます(訳注: OSのコマンドラインから、
@code{gforth} ではなくて @code{gforth-fast} で起動する):

@example
$7FD0CEE8C510 lit f@@     1->1 
$7FD0CEE8C518 x
$7FD0CEE8C520 f@@
7FD0CEB51697:   movsd   [r12],xmm15
7FD0CEB5169D:   mov     rax,$00[r13]
7FD0CEB516A1:   sub     r12,$08
7FD0CEB516A5:   add     r13,$18
7FD0CEB516A9:   movsd   xmm15,[rax]
7FD0CEB516AE:   mov     rcx,-$08[r13]
7FD0CEB516B2:   jmp     ecx
$7FD0CEE8C528 fsin
$7FD0CEE8C530 drop    1->0 
7FD0CEB516B4:   add     r13,$08
$7FD0CEE8C538 over    0->1 
7FD0CEB516B8:   mov     r8,$10[r15]
7FD0CEB516BC:   add     r13,$08
$7FD0CEE8C540 ;s    1->1 
7FD0CEB516C0:   mov     r10,[rbx]
7FD0CEB516C3:   add     rbx,$08
7FD0CEB516C7:   lea     r13,$08[r10]
7FD0CEB516CB:   mov     rcx,-$08[r13]
7FD0CEB516CF:   jmp     ecx
@end example

まず、 コンポーネント @code{lit} と @code{f@@}
を含む静的命令融合(superinstruction)のスレッド化コード・セルが表示されます。 それは、 レジスタ内の 1 つのデータ・スタック項目
(@code{1->1}) で始まり・終わります。 )。 これに、@code{lit} の引数 @code{x} のセルと、 命令融合の
@code{f@@} コンポーネントのセルが続きます。 後者のセルは使用されませんが、 Gforth 内部の理由により存在します。

その次に、 命令融合 @code{lit f@@} に対して動的に生成されたネイティブ・コードを表示します。 注意: アドレスを比較するとわかるように、
このネイティブ・コードはメモリ内のスレッド化コードと混合されていない(not mixed)ことに注意してください。

ここに表示されているネイティブ・コードを理解するには、以下のレジスタについて知っておくべきです:@*スレッド化コードの命令ポインタは
@code{r13}@*データ・スタック・ポインタは @code{r15}@*最初(TOS)のデータ・スタック・レジスタは @code{r8}
(データ・スタックのTOS、 つまり、 レジスタにデータ・スタック項目が 1 つある場合、 スタックのTOSがそこに存在します)@*リターン・スタック
ポインタは @code{rbx}@*FP スタック・ポインタは @code{r12}@*FP スタックの先頭(TOS)は
@code{xmm15}@*注意: レジスタの割り当てはエンジンによって異なるため、
コード表示においては異なるレジスタの割り当てが表示される場合があることに注意してください。

@code{lit f@@} の動的ネイティブ・コードは、 ディスパッチ・ジャンプ(dispatch jump;別名 NEXT)(訳注:
古典的には内部インタプリタへ制御を戻すためのジャンプ)で終了します。 これは、 定義内の次のワード @code{fsin}
のネイティブ・コードは動的に生成しないためです。

次に、 @code{fsin} のスレッド化コード・セルが表示されます。  このワードには動的に生成されるネイティブ・コードはなく、
@code{see-code} では静的ネイティブ・コードは表示されません(@code{fsin} の静的ネイティブ・コードを確認したければ
@code{see fsin})。  @code{gforth-fast} 内の静的ネイティブ・コードを含むすべてのワードと同様、
データ・スタック表現への影響は @code{1->1} (@code{gforth} エンジンでは @code{0->0}) です。 しかし、
これは表示されません。

次に、 @code{drop} のスレッド化コード・セルが表示されます。 ここで使用されるネイティブ・コード版のバリエーションは、 レジスタ内の 1
つのデータ・スタック項目で始まり、 レジスタ内の 0 個のデータ スタック項目で終わります(@code{1->0})。  この後に
@code{drop} のこのバリエーションのネイティブ・コードが続きます。 ここのネイティブ・コードは次のワードのコードに続くため、 ここには
NEXT はありません。

次に、 @code{over} のスレッド化コード・セルと、 その後に @code{0->1}
バリエーションで動的に生成されたネイティブ・コードが表示されます。

最後に、 @code{;s}  のスレッド化されたネイティブ・コード(@code{foo} 内の @code{;}
用にコンパイルされたプリミティブ)が表示されます。 @code{;s} は制御フローを実行する(制御フローからリターンする)ため、 NEXT
で終了する必要があります。

@node Examining data, Forgetting words, Examining compiled code, Programming Tools
@subsection Examining data and code
@cindex examining data and code

以下のワード群は、 スタックを非破壊的に調査します:

@findex ... ( @var{ x1 .. xn -- x1 .. xn   } ) gforth-1.0
@cindex @code{...}
@kindex ...
@format
@code{...} ( @i{x1 .. xn -- x1 .. xn  }) gforth-1.0 ``...''
@end format
@code{.s} のスマート・バージョン


@findex .s ( @var{ --   } ) tools
@cindex @code{.s}
@kindex .s
@format
@code{.s} ( @i{--  }) tools ``dot-s''
@end format
データ・スタック上の項目の数を表示し、 その後に項目のリストを表示します(ただし、 @code{maxdepth-.s}
で指定された値を超えないようにします)。 右端が TOS になります。


@findex f.s ( @var{ --   } ) gforth-0.2
@cindex @code{f.s}
@kindex f.s
@format
@code{f.s} ( @i{--  }) gforth-0.2 ``f-dot-s''
@end format
浮動小数点スタック上の項目の数を表示し、 その後に項目のリストを表示します(ただし、 @code{maxdepth-.s}
で指定された値を超えないようにします)。 右端が TOS になります。


@findex f.s-precision ( @var{ -- u   } ) gforth-1.0
@cindex @code{f.s-precision}
@kindex f.s-precision
@format
@code{f.s-precision} ( @i{-- u  }) gforth-1.0 ``f.s-precision''
@end format
@code{value} 型変数です。 @i{u} は f.s の出力のフィールド幅です。 他の精度の詳細はこの値から導出されます。


@findex maxdepth-.s ( @var{ -- addr   } ) gforth-0.2
@cindex @code{maxdepth-.s}
@kindex maxdepth-.s
@format
@code{maxdepth-.s} ( @i{-- addr  }) gforth-0.2 ``maxdepth-dot-s''
@end format
変数(variable)。 デフォルトは 9 です。 @code{.s} と @code{f.s} は最大でその数のスタック項目を表示します。



@code{.r} というワードがありますが、 リターン・戻りスタックは「表示されません」。 これは、
フォーマットされた数値出力に使用されるワードです(@pxref{Simple numeric output})。

以下のワード群は、 スタックの深さを決定したり、スタックをクリアしたりして、 スタック全体に作用します:

@findex depth ( @var{ -- +n   } ) core
@cindex @code{depth}
@kindex depth
@format
@code{depth} ( @i{-- +n  }) core ``depth''
@end format
@var{+n} は、 @var{+n} 自体がスタックに置かれる前にデータ・スタックに置かれていた項目の数です。


@findex fdepth ( @var{ -- +n   } ) floating
@cindex @code{fdepth}
@kindex fdepth
@format
@code{fdepth} ( @i{-- +n  }) floating ``f-depth''
@end format
データ・スタックに積まれた @i{+n} は、 浮動小数点スタック上にある(浮動小数点)値の現在の数です。


@findex clearstack ( @var{ ... --   } ) gforth-0.2
@cindex @code{clearstack}
@kindex clearstack
@format
@code{clearstack} ( @i{... --  }) gforth-0.2 ``clear-stack''
@end format
データ・スタックから全ての項目を削除して破棄します(訳注: データ・スタックを空にします)。


@findex fclearstack ( @var{ r0 .. rn --   } ) gforth-1.0
@cindex @code{fclearstack}
@kindex fclearstack
@format
@code{fclearstack} ( @i{r0 .. rn --  }) gforth-1.0 ``f-clearstack''
@end format
浮動小数点スタックをクリアします


@findex clearstacks ( @var{ ... --   } ) gforth-0.7
@cindex @code{clearstacks}
@kindex clearstacks
@format
@code{clearstacks} ( @i{... --  }) gforth-0.7 ``clear-stacks''
@end format
データ・スタックと FP スタックを空にします



以下のワード群はメモリを調べます。

@findex ? ( @var{ a-addr --   } ) tools
@cindex @code{?}
@kindex ?
@format
@code{?} ( @i{a-addr --  }) tools ``question''
@end format
アドレス @var{a-addr} の内容を現在の基数(base)で表示します。


@findex dump ( @var{ addr u --   } ) tools
@cindex @code{dump}
@kindex dump
@format
@code{dump} ( @i{addr u --  }) tools ``dump''
@end format
メモリのアドレス @var{addr} から始まる @var{u} バイトを表示します。 各行には 16 バイト分の内容が表示されます。  Gforth
がオペレーティング・システム上で実行されている場合、 任意の場所にアクセスしようとすると、 @file{Invalid memory address}
エラーが発生する可能性があります。



@node Forgetting words, Debugging, Examining data, Programming Tools
@subsection Forgetting words
@cindex words, forgetting
@cindex forgeting words

@c  anton: other, maybe better places for this subsection: Defining Words;
@c  Dictionary allocation.  At least a reference should be there.

forth は、 ワード達 (および、 その後ろでディクショナリ割り当てられたすべての内容) を LIFO 方式で忘れさすことができます。

@findex marker ( @var{ "<spaces> name" --   } ) core-ext
@cindex @code{marker}
@kindex marker
@format
@code{marker} ( @i{"<spaces> name" --  }) core-ext ``marker''
@end format
@i{name} という定義を作成します(マーク(@i{mark})と呼ばれる)。 その実行機能(execution semantics)は、
それ自体とその後に定義されたすべてのものを削除します(訳注: 注意: 古典的な forth の @code{forget name} と異なり、
任意のワード以降を「忘れる」コマンドでは無い事に注意。 あらかじめ @code{marker} でマークした位置でしか「忘れる」事はできない)。



この機能の最も一般的な使用法は、 プログラム開発時です。 ソース・ファイルを変更するときは、 定義されているワードをすべて忘れて、
再度ロードします(ソース・ファイルのロード後に定義されたワードもすべて忘れるので、 それも再ロードする必要があります)。
変数への保存やシステム・ワードの破壊などの効果は、 ワードを忘れても元に戻されないことに注意してください。  著者は、 gforth
のようなシステムでは、 起動とコンパイルが十分に速いので、 gforth を終了して再起動する方が、 白紙の状態(clean
state)で使えるので便利だと思います。

デバッグしているソース・ファイルの先頭で @code{marker} を使用する例を以下に示します。 これにより、
そのファイルの定義は二重定義されないようになります。

@example
[IFDEF] my-code
    my-code
[ENDIF]

marker my-code
init-included-files

\ .. definitions start here
\ .
\ .
\ end
@end example


@node Debugging, Assertions, Forgetting words, Programming Tools
@subsection Debugging
@cindex debugging

編集/コンパイル/リンク/テスト の開発ループが遅い言語では、 デバッグを容易にするために高度な トレース/ステッピング
デバッガが必要になる傾向があります。

高速コンパイル言語でのより良い(より速い)方法は、 適切に選択した場所に表示コード(printing code)を追加し、
プログラムを実行してその出力を見て、 問題が発生した箇所を確認し、 バグが見つかるまでさらに表示コード等を追加することです(訳注: C言語で言うところの
printf デバッグすると言っている)。

@file{debugs.fs} で提供される単純なデバッグ支援機能は、 このスタイルのデバッグをサポートすることを目的としています。

@code{~~} というワードは、 デバッグ情報(デフォルトではソースの場所とスタックの内容)を出力します。
これは簡単にソース・コードに挿入できます。 Emacs を使用している場合は、 削除も簡単です(Emacs Forth モードで @kbd{C-x ~}
を実行すると、 @code{~~} を ""(nothing) に query-replace します)。 defer ワード
@code{printdebugdata} と @code{.debugline} は、 @code{~~} の出力を制御します。
デフォルトのソース位置出力形式は Emacs のコンパイル・モードで適切に動作するため、 @kbd{C-x `}
を使用してソース・レベルでプログラムをステップ実行できます(ステップ実行デバッガーと比較した利点は、 任意の方向にステップ実行でき、
クラッシュが発生した場所や奇妙なデータが発生した箇所を知る事ができるということです)。

@findex ~~ ( @var{ --   } ) gforth-0.2
@cindex @code{~~}
@kindex ~~
@format
@code{~~} ( @i{--  }) gforth-0.2 ``tilde-tilde''
@end format
@code{~~} を記述したソース・コードの場所とスタックの内容を @code{.debugline} を使って出力します。


@findex printdebugdata ( @var{ --   } ) gforth-0.2
@cindex @code{printdebugdata}
@kindex printdebugdata
@format
@code{printdebugdata} ( @i{--  }) gforth-0.2 ``print-debug-data''
@end format

@findex .debugline ( @var{ nfile nline --   } ) gforth-0.6
@cindex @code{.debugline}
@kindex .debugline
@format
@code{.debugline} ( @i{nfile nline --  }) gforth-0.6 ``print-debug-line''
@end format
@var{nfile nline} で示されるソース・コードの場所と追加のデバッグ情報を出力します。 デフォルトの @code{.debugline}
は、 @code{printdebugdata} を使用して追加情報を出力します。


@findex debug-fid ( @var{ -- file-id   } ) gforth-1.0
@cindex @code{debug-fid}
@kindex debug-fid
@format
@code{debug-fid} ( @i{-- file-id  }) gforth-1.0 ``@i{File-id}''
@end format
デバッグ用の出力先。  デフォルトでは、 当該プロセスの @code{stderr} です。



@cindex filenames in @code{~~} output
@code{~~} (およびアサート(assertions))は、 その出現後に同一ファイル内で marker が実行されると、 通常、
間違ったファイル名を出力します。 @code{~~} (およびアサート(assertions))は、 その出現前に同じファイル内で marker
が実行されると、 ファイル名として「どこか」(somewhere)を出力します。

@findex once ( @var{ --   } ) gforth-1.0
@cindex @code{once}
@kindex once
@format
@code{once} ( @i{--  }) gforth-1.0 ``once''
@end format
@code{once} から THEN までの操作を 1 回だけ だけ実行します(訳注: 1度実行されるとその旨を body に書き込むので、
再度実行するには @code{once} を含む定義を「忘れ」(forget)て再度定義(読み込み)する必要がある)


@findex ~~bt ( @var{ --   } ) gforth-1.0
@cindex @code{~~bt}
@kindex ~~bt
@format
@code{~~bt} ( @i{--  }) gforth-1.0 ``~~bt''
@end format
スタック・ダンプとバックトレースを出力


@findex ~~1bt ( @var{ --   } ) gforth-1.0
@cindex @code{~~1bt}
@kindex ~~1bt
@format
@code{~~1bt} ( @i{--  }) gforth-1.0 ``~~1bt''
@end format
スタックダンプとバックトレースを(@code{once}と同様) 1 回だけ実行します


@findex ??? ( @var{ --   } ) gforth-0.2
@cindex @code{???}
@kindex ???
@format
@code{???} ( @i{--  }) gforth-0.2 ``???''
@end format
デバッグ・シェルを実行します


@findex WTF?? ( @var{ --   } ) gforth-1.0
@cindex @code{WTF??}
@kindex WTF??
@format
@code{WTF??} ( @i{--  }) gforth-1.0 ``WTF??''
@end format
バックトレースとスタック・ダンプを使用してデバッグ・シェルを実行します


@findex !!FIXME!! ( @var{ --   } ) gforth-1.0
@cindex @code{!!FIXME!!}
@kindex !!FIXME!!
@format
@code{!!FIXME!!} ( @i{--  }) gforth-1.0 ``!!FIXME!!''
@end format
決してこの場所に到達してはいけないワード(訳注: -2605 を throw する)


@findex replace-word ( @var{ xt1 xt2 --   } ) gforth-1.0
@cindex @code{replace-word}
@kindex replace-word
@format
@code{replace-word} ( @i{xt1 xt2 --  }) gforth-1.0 ``replace-word''
@end format
xt2 が xt1 を実行するようにします。 両方ともコロン定義である必要があります。(訳注: @*: foo ." foo" ;@*: bar ."
bar" ;@*foo foo ok@*bar bar ok@*' foo ' bar replace-word  ok@*foo foo
ok@*bar foo ok


@findex ~~Variable ( @var{ "name" --   } ) gforth-1.0
@cindex @code{~~Variable}
@kindex ~~Variable
@format
@code{~~Variable} ( @i{"name" --  }) gforth-1.0 ``~~Variable''
@end format
アクセスごとにワッチされる(@code{~~} する)変数(variable を ~~variable に一時的にリネームする)


@findex ~~Value ( @var{ n "name" --   } ) gforth-1.0
@cindex @code{~~Value}
@kindex ~~Value
@format
@code{~~Value} ( @i{n "name" --  }) gforth-1.0 ``~~Value''
@end format
アクセスごとにワッチされる(@code{~~} する) value ( value を 一時的に ~~value にリネームする)


@findex +ltrace ( @var{ --   } ) gforth-1.0
@cindex @code{+ltrace}
@kindex +ltrace
@format
@code{+ltrace} ( @i{--  }) gforth-1.0 ``+ltrace''
@end format
行単位のトレースをONにする。


@findex -ltrace ( @var{ --   } ) gforth-1.0
@cindex @code{-ltrace}
@kindex -ltrace
@format
@code{-ltrace} ( @i{--  }) gforth-1.0 ``-ltrace''
@end format
行単位のトレースをOFFにする


@findex #loc ( @var{ nline nchar "file" --   } ) gforth-1.0
@cindex @code{#loc}
@kindex #loc
@format
@code{#loc} ( @i{nline nchar "file" --  }) gforth-1.0 ``#loc''
@end format
次のワードの場所を @var{"file"} の @var{nline nchar} と設定します



@node Assertions, Singlestep Debugger, Debugging, Programming Tools
@subsection Assertions
@cindex assertions

特にメンテナンス中に無効になる可能性があると仮定する場合(たとえば、 データ構造の特定のフィールドは決してゼロにならない、 等)、
プログラムを自己チェックするようにすることをお勧めします。 Gforth は、
こ​​の目的のために「アサート」(@dfn{assertions})をサポートしています。 それらは以下のように使用します:

@example
assert( @i{flag} )
@end example

@code{assert(} と @code{)} の間のコードは @i{flag} を計算する必要があります。 すべてが正常な場合は true
、それ以外の場合は false になります。 スタック上の他のものは何も変更しないでください。 アサートの全体的なスタック効果は @code{( --
)} です。 例:

@example
assert( 1 1 + 2 = ) \ what we learn in school
assert( dup 0<> ) \ assert that the top of stack is not zero
assert( false ) \ このコードには決して到達してはならない
@end example

アサートの必要性は、 その時々によって異なります。 デバッグ中はより多くのチェックが必要ですが、 運用環境では速度をより重視することがあります。
したがって、アサートをオフにすることができます。 その場合、 つまり、 アサートはコメントになります。
アサートの重要性とそのチェックにかかる時間に応じて、 一部のアサートをオフにし、 他のアサートをオンにしたほうがよい場合があります。 Gforth
は、こ​​の目的のためにいくつかのレベルのアサートを提供します:


@findex assert0( ( @var{ --   } ) gforth-0.2
@cindex @code{assert0(}
@kindex assert0(
@format
@code{assert0(} ( @i{--  }) gforth-0.2 ``assert-zero''
@end format
常にオンにする必要がある重要なアサート。


@findex assert1( ( @var{ --   } ) gforth-0.2
@cindex @code{assert1(}
@kindex assert1(
@format
@code{assert1(} ( @i{--  }) gforth-0.2 ``assert-one''
@end format
通常のアサート: デフォルトではオンになっています。


@findex assert2( ( @var{ --   } ) gforth-0.2
@cindex @code{assert2(}
@kindex assert2(
@format
@code{assert2(} ( @i{--  }) gforth-0.2 ``assert-two''
@end format
デバッグ用のアサート。


@findex assert3( ( @var{ --   } ) gforth-0.2
@cindex @code{assert3(}
@kindex assert3(
@format
@code{assert3(} ( @i{--  }) gforth-0.2 ``assert-three''
@end format
通常のデバッグでは有効にしたくないであろう遅いアサート。 主に徹底的なチェックを行うためにオンにします。


@findex assert( ( @var{ --   } ) gforth-0.2
@cindex @code{assert(}
@kindex assert(
@format
@code{assert(} ( @i{--  }) gforth-0.2 ``assert(''
@end format
@code{assert1(} と同等です


@findex ) ( @var{ --   } ) gforth-0.2
@cindex @code{)}
@kindex )
@format
@code{)} ( @i{--  }) gforth-0.2 ``close-paren''
@end format
アサートを終了します。 汎用の終端なので、 他の同様の目的でも使用されます




変数 @code{assert-level} は、オンにする最高のアサートを指定します。 つまり、デフォルトの @code{assert-level}
の 1 では、 @code{assert0(} および @code{assert1(} はチェックを実行しますが、 @code{assert2(}
および @code{assert3(}) はコメントとして扱われます。

@code{assert-level} の値は、 実行時ではなくコンパイル時に評価されます。 したがって、
実行時にアサートをオンまたはオフにすることはできません。 あなたはコードをコンパイルする前に @code{assert-level}
を適切に設定する必要があります。 異なるコード部分を異なる @code{assert-level} でコンパイルできます(例:
信頼に足るライブラリはレベル 1 で、 新しく作成されたコードはレベル 3 など)。


@findex assert-level ( @var{ -- a-addr   } ) gforth-0.2
@cindex @code{assert-level}
@kindex assert-level
@format
@code{assert-level} ( @i{-- a-addr  }) gforth-0.2 ``assert-level''
@end format
変数(variable)。 指定のレベルを超えるすべてのアサートはオフになります。




アサートが失敗すると、 Emacs のコンパイル・モードと互換性のあるメッセージが生成され、 実行が中止(abort)されます(現在は
@code{ABORT"} を使用します。 あなたの興味があれば、 特別な throw コードを導入します。 ただし、
特定の条件をキャッチ(@code{catch})したい場合は、 おそらくアサートよりも @code{throw} を使用する方が適切です)。

@cindex filenames in assertion output
アサート (および @code{~~}) の出現後に同じファイル内で marker が実行されると、 通常は間違ったファイル名が出力されます。 アサート
(および @code{~~}) の出現前に同じファイル内で marker が実行された場合、
ファイル名として「どれか」(somewhere)が出力されます。

これらのアサート・ワードの標準 Forth での定義は、 @file{compat/assert.fs} で提供されます。


@node Singlestep Debugger, Code Coverage, Assertions, Programming Tools
@subsection Singlestep Debugger
@cindex singlestep Debugger
@cindex debugging Singlestep

シングルステップ・デバッガーは、 @code{gforth-itc} エンジンでのみ動作します(訳注: OSコマンドラインから @i{gforth}
ではなくて @i{gforth-itc} で起動する)。

新しいワードを作成するとき、 それが正しく動作するかどうかを確認する必要があることがよくあります。 これを行うには、@code{dbg badword}
と入力します。 デバッグ・セッションは以下のようになります:

@example
: badword 0 DO i . LOOP ;  ok
2 dbg badword 
: badword  
Scanning code...

Nesting debugger ready!

400D4738  8049BC4 0              -> [ 2 ] 00002 00000 
400D4740  8049F68 DO             -> [ 0 ] 
400D4744  804A0C8 i              -> [ 1 ] 00000 
400D4748 400C5E60 .              -> 0 [ 0 ] 
400D474C  8049D0C LOOP           -> [ 0 ] 
400D4744  804A0C8 i              -> [ 1 ] 00001 
400D4748 400C5E60 .              -> 1 [ 0 ] 
400D474C  8049D0C LOOP           -> [ 0 ] 
400D4758  804B384 ;              ->  ok
@end example

各行が 1 ステップです。 次のワードを実行して表示するには、 常に Return キーを押す必要があります。 次のワード全体を実行したくない場合は、
@code{nest} に対して @kbd{n} と入力する必要があります。 利用可能なキーの概要は以下のとおりです:

@table @i

@item @key{RET}
Next; 次のワードを実行する(execute)。

@item n
Nest; 次のワードまで 1 ステップずつ辿る。

@item u
Unnest; デバッグを停止し(stop)、残りのワードを実行します(execute)。 ネスト(nest)機能でこのワードに到達した場合、
それを呼び出したワードでデバッグを続行します。

@item d
Done; デバッグを停止し(stop)、 残りを実行します(execute)。

@item s
Stop; 直ちに終了(abort)します。

@end table

このメカニズムを使用して大規模なアプリケーションをデバッグすることは、
あなたが関心のある部分が始まる前にプログラム内に非常に深くネストする必要があるため、 非常に困難です。 これにはとても時間がかかります。 

これをより直接的に行うには、 @code{BREAK:} コマンドをあなたのソース・コードに追加します。 プログラムの実行が @code{BREAK:}
に達すると、 シングル・ステップ・デバッガーが呼び出され、 上記すべての機能が利用できるようになります。

デバッグする部分が複数ある場合、 プログラムが現在どこで停止しているかを把握できると便利です。 これを行うには、 @code{BREAK"
string"} コマンドを使用します。 これは @code{BREAK:} と同様に動作しますが、
「ブレークポイント」に到達したときに文字列が出力される点が異なります。


@findex dbg ( @var{ "name" --   } ) gforth-0.2
@cindex @code{dbg}
@kindex dbg
@format
@code{dbg} ( @i{"name" --  }) gforth-0.2 ``dbg''
@end format

@findex break: ( @var{ --   } ) gforth-0.4
@cindex @code{break:}
@kindex break:
@format
@code{break:} ( @i{--  }) gforth-0.4 ``break:''
@end format

@findex break" ( @var{ 'ccc"' --   } ) gforth-0.4
@cindex @code{break"}
@kindex break"
@format
@code{break"} ( @i{'ccc"' --  }) gforth-0.4 ``break"''
@end format


@c -------------------------------------------------------------
@node Code Coverage, , Singlestep Debugger, Programming Tools
@subsection Code Coverage and Execution Frequency
@cindex code coverage
@cindex execution frequency

あなたのコードに対して広範なテスト(extensive tests)を実行する場合、
そのテストがコードのすべての部分を実行するかどうかを確認する必要が生じることがよくあります。  これを(テスト)カバレッジと呼びます。  ファイル
@file{coverage.fs} には、 カバレッジと実行頻度を測定するためのツールが含まれています(訳注: gforth
に組み込まれて無いので使う時は @file{coverage.fs} をロードしてください)。

コード・カバレッジは、 @file{coverage.fs}
の後にロードされるすべての基本ブロック(逐次実行のコード・シーケンス)にカウント(計数)コードを挿入します。
コードが実行されるたびに、その基本ブロックのカウンター(計数器)がインクリメントされます。
後で、これらの基本ブロックに挿入されたカウント(計数)を含むソース・ファイルを表示できます。

@findex nocov[ ( @var{ --   } ) gforth-1.0
@cindex @code{nocov[}
@kindex nocov[
@format
@code{nocov[} ( @i{--  }) gforth-1.0 ``nocov-bracket''
@end format
(即実行ワード) 一時的にカバレッジをオフにすることを開始。


@findex ]nocov ( @var{ --   } ) gforth-1.0
@cindex @code{]nocov}
@kindex ]nocov
@format
@code{]nocov} ( @i{--  }) gforth-1.0 ``bracket-nocov''
@end format
(即実行ワード) 一時的にカバレッジをオフにすることを終了。


@findex coverage? ( @var{ -- f   } ) gforth-internal
@cindex @code{coverage?}
@kindex coverage?
@format
@code{coverage?} ( @i{-- f  }) gforth-internal ``coverage?''
@end format
Value: カバレッジ・チェックの オン/オフ


@findex cov+ ( @var{ --   } ) gforth-experimental
@cindex @code{cov+}
@kindex cov+
@format
@code{cov+} ( @i{--  }) gforth-experimental ``cov+''
@end format
(即実行ワード) ここ(here)にカバレッジ・カウンターを配置します。


@findex ?cov+ ( @var{ flag -- flag   } ) gforth-experimental
@cindex @code{?cov+}
@kindex ?cov+
@format
@code{?cov+} ( @i{flag -- flag  }) gforth-experimental ``?cov+''
@end format
(即実行ワード) フラグ(@i{flag})のカバレッジ・カウンター。 カバレッジの出力では、 @code{?cov} の後ろに 3
つの数字が表示されます。 1 つ目はスタックの最上位が 0 以外だった実行の数です。 2 番目は、 ゼロだった場合の実行数です。 3
番目は実行の合計数です。


@findex .coverage ( @var{ --   } ) gforth-experimental
@cindex @code{.coverage}
@kindex .coverage
@format
@code{.coverage} ( @i{--  }) gforth-experimental ``.coverage''
@end format
コードを実行頻度(execution frequencies)とともに表示します。


@findex annotate-cov ( @var{ --   } ) gforth-experimental
@cindex @code{annotate-cov}
@kindex annotate-cov
@format
@code{annotate-cov} ( @i{--  }) gforth-experimental ``annotate-cov''
@end format
カバレッジ情報を含むファイルごとに、 実行頻度(execution frequencies)が挿入された @code{.cov} ファイルを作成します。
最初に @code{bw-cover} を使用することをお勧めします(デフォルトの @code{color-cover} を使用すると、
ファイル内にエスケープ シーケンスが含まれます)。


@findex cov% ( @var{ --   } ) gforth-experimental
@cindex @code{cov%}
@kindex cov%
@format
@code{cov%} ( @i{--  }) gforth-experimental ``cov-percent''
@end format
@file{coverage.fs} の後でロードされ、 少なくとも 1 回実行された基本ブロックの割合を出力します。


@findex .cover-raw ( @var{ --   } ) gforth-experimental
@cindex @code{.cover-raw}
@kindex .cover-raw
@format
@code{.cover-raw} ( @i{--  }) gforth-experimental ``.cover-raw''
@end format
生の実行カウントを出力します。


@c commented out because the included-file index is not a
@c   user-friendly way to pass a file (yet).
@c doc-.cover-file
@c doc-covered?

デフォルトでは、 カウント(計数)は(ANSI エスケープ・シーケンスを使用して、)カラーで表示されますが、 @code{bw-cover}
を使用すると、 エスケープ・シーケンスを使用せずに括弧で囲まれた形式でカウントを表示できます。

@findex bw-cover ( @var{ --   } ) gforth-1.0
@cindex @code{bw-cover}
@kindex bw-cover
@format
@code{bw-cover} ( @i{--  }) gforth-1.0 ``bw-cover''
@end format
実行カウントを(カラー表示ではなく)括弧内に出力します(ソース・コード互換)(訳注: つまり forth のコメントとして出力する。出力をそのまま
forth のソース・コードとして利用可能)。


@findex color-cover ( @var{ --   } ) gforth-1.0
@cindex @code{color-cover}
@kindex color-cover
@format
@code{color-cover} ( @i{--  }) gforth-1.0 ``color-cover''
@end format
実行カウントをカラーで表示します(デフォルト)。



カバレッジ・カウンター(計数器)をバイナリ形式で保存および再ロードして、 複数のテスト実行にわたるカバレッジ・カウンターを集計できます。

@findex save-cov ( @var{ --   } ) gforth-experimental
@cindex @code{save-cov}
@kindex save-cov
@format
@code{save-cov} ( @i{--  }) gforth-experimental ``save-cov''
@end format
カバレッジ・カウンターを保存します。


@findex load-cov ( @var{ --   } ) gforth-experimental
@cindex @code{load-cov}
@kindex load-cov
@format
@code{load-cov} ( @i{--  }) gforth-experimental ``load-cov''
@end format
カバレッジ・カウンターをロードします。



@c -------------------------------------------------------------
@node Multitasker, C Interface, Programming Tools, Words
@section Multitasker
@cindex multitasker

@menu
* Pthreads::                 ネイティブ Unix 用マルチタスカー
* Cilk::                     Cilk風の spawn+sync 実装
@end menu

Gforth は 2 つのマルチタスカーを提供します。 1 つは従来の協調的なラウンドロビン・マルチタスカー(cooperative
round-robin multitasker)で、 もう 1 つはマルチコア・マシン上で複数のスレッドを同時に実行できる pthread
ベースのマルチタスカーです。  将来、 Forth マルチタスカーの標準化により、 その意味は変更せずにワードの名前が変更される可能性が高いため、
pthread ベースのマルチタスカーは現在、 実験的な機能としてマークされています。

@node Pthreads, Cilk, Multitasker, Multitasker
@subsection Pthreads
@cindex pthread

@c You need to include @file{unix/pthread.fs} to use the following words.

pthred 、 つまり posix スレッドは、 複数のコア上で並行実行することも、 1
つのコア上でプリエンプティブ・マルチタスクで実行することもできます。  ただし、 以下のワード群の多くは、
従来の協調マルチタスク(traditional cooperative multi-tasker)の場合と同一です。

さらに、 一度に 1 つのタスクのみが何かを変更することを確認したり、 タスク間のコミュニケーションに使用したりするためのワード群もあります。
@code{pause}
の呼び出し間でトランザクション(取引)を実行する協調マルチタスク(cooperative-multitasking)はこの環境では機能しないため、
これらのワード群はプリエンプティブ・マルチタスクおよびマルチコア・マルチタスクで必要なものです。

@menu
* Basic multi-tasking::
* Task-local data::
* Semaphores::
* Hardware operations for multi-tasking::
* Message queues::           
@end menu

@node Basic multi-tasking, Task-local data, Pthreads, Pthreads
@subsubsection Basic multi-tasking

タスクは @code{newtask} または @code{newtask4} を使用して、 指定された量のスタック領域(すべて同じ、 または、
データ・スタックとリターン・スタックと FP スタックとローカル変数スタックそれぞれのサイズを指定)で作成できます。

@findex newtask ( @var{ stacksize -- task   } ) gforth-experimental
@cindex @code{newtask}
@kindex newtask
@format
@code{newtask} ( @i{stacksize -- task  }) gforth-experimental ``newtask''
@end format
タスク(@i{task}を作成します。 データ・スタックとリターン・スタックと FP
スタックとローカル変数スタックのサイズは全て同じにします(@i{stacksize})(訳注: スタックごとに個別サイズ指定したい時は
@code{newtask4} を使用してください)。


@findex task ( @var{ ustacksize "name" --   } ) gforth-experimental
@cindex @code{task}
@kindex task
@format
@code{task} ( @i{ustacksize "name" --  }) gforth-experimental ``task''
@end format
タスク @i{name} を作成します。 各スタック(データ・スタック、 リターン・スタック、 FP スタック、 ローカル変数スタック) サイズは
@i{ustacksize} です。@*実行時: ( -- @i{task} )


@findex newtask4 ( @var{ u-data u-return u-fp u-locals -- task   } ) gforth-experimental
@cindex @code{newtask4}
@kindex newtask4
@format
@code{newtask4} ( @i{u-data u-return u-fp u-locals -- task  }) gforth-experimental ``newtask4''
@end format
データ・スタック・サイズ @i{u-data}、 リターン・スタック・サイズ @i{u-return}、 FP スタック・サイズ @i{u-fp}、
ローカル変数スタック・サイズ @i{u-locals} で @i{task} を作成します。



あなたが、 タスクにどのスタック・サイズを使用すればよいかわからない場合は、 メイン・タスクのサイズを流用できます:

@findex stacksize ( @var{ -- u   } ) gforth-experimental
@cindex @code{stacksize}
@kindex stacksize
@format
@code{stacksize} ( @i{-- u  }) gforth-experimental ``stacksize''
@end format
@i{u} はメイン・タスクのデータ・スタックサイズです。


@findex stacksize4 ( @var{ -- u-data u-return u-fp u-locals   } ) gforth-experimental
@cindex @code{stacksize4}
@kindex stacksize4
@format
@code{stacksize4} ( @i{-- u-data u-return u-fp u-locals  }) gforth-experimental ``stacksize4''
@end format
メイン・タスクのデータ・スタック・サイズと、 リターン・スタック・サイズと、 FP スタック・サイズと、 ローカル変数スタックサイズを、
プッシュします。



タスクは非アクティブ状態(inactive state)で作成されます。  実行するには、
以下のいずれかのワードを使用してアクティブ化(activate)する必要があります:

@findex initiate ( @var{ xt task --   } ) gforth-experimental
@cindex @code{initiate}
@kindex initiate
@format
@code{initiate} ( @i{xt task --  }) gforth-experimental ``initiate''
@end format
@i{task} に @i{xt} を @i{execute} させます。  @i{xt} から戻ると、 タスクは自動的に終了します(VFX 互換)。
ワンタイム実行可能クロージャ(one-time executable closures)を使用して、 任意のパラメータをタスクに渡せます。



以下の古い(legacy)ワード、 @code{activate} と @code{pass} は、 @code{initiate}
と同じ機能を提供しますが、 インターフェイスが異なります:  @code{does>} と同様に、 含まれるコロン定義が 2 つの部分に分割されます:
@code{activate}/@code{pass} より前の部分はタスクをアクティブ化する部分で実行され、
タスクをアクティブ化した後に呼び出し元に戻ります。  @code{activate}/@code{pass} より後の部分は、
アクティブ化されたターゲット・タスク内で実行されます。

@findex activate ( @var{ run-time nest-sys1 task --   } ) gforth-experimental
@cindex @code{activate}
@kindex activate
@format
@code{activate} ( @i{run-time nest-sys1 task --  }) gforth-experimental ``activate''
@end format
指定のタスク(@i{task})に @code{activate} のより後ろにあるコードを実行させ、 @code{activate}
を含むワードの呼び出し元に戻ります。 タスクが @code{activate} の後ろにあるコードから戻ると、 タスク自体が終了します。


@findex pass ( @var{ x1 .. xn n task --   } ) gforth-experimental
@cindex @code{pass}
@kindex pass
@format
@code{pass} ( @i{x1 .. xn n task --  }) gforth-experimental ``pass''
@end format
現在のタスクのデータ・スタックから @i{x1 .. xn n} を取り出し、 @i{x1 .. xn} を @i{task}
のデータ・スタックにプッシュします。  @i{task} に @code{pass} の後ろのコードを実行させ、 @code{pass}
を含むワードの呼び出し元に戻ります。  タスクが @code{pass} の後ろにあるコードから戻ると、 タスク自体が終了します。



作成とアクティブ化(activation)をワン・ステップで行うこともできます:

@findex execute-task ( @var{ xt -- task   } ) gforth-experimental
@cindex @code{execute-task}
@kindex execute-task
@format
@code{execute-task} ( @i{xt -- task  }) gforth-experimental ``execute-task''
@end format
メイン・タスクと同じスタック・サイズで新しいタスク @var{task} を作成します。 @i{task} に @i{xt} を @i{execute}
させます。  @i{xt} から戻ると、 タスクは自動的に終了します。



タスクは最後まで実行して終了する以外に、 @code{kill-task} を使用してタスク自身を終了することもできます。 他のタスクは
@code{kill} で終了できます。

@findex kill-task ( @var{ --   } ) gforth-experimental
@cindex @code{kill-task}
@kindex kill-task
@format
@code{kill-task} ( @i{--  }) gforth-experimental ``kill-task''
@end format
現在のタスクを終了(terminate)します。


@findex kill ( @var{ task --   } ) gforth-experimental
@cindex @code{kill}
@kindex kill
@format
@code{kill} ( @i{task --  }) gforth-experimental ``kill''
@end format
指定のタスク(@i{task})を終了(terminate)します。



タスク自体を一時的に停止(temporarily stop)したり、 タスクを停止(be stopped)したりすることもできます:

@findex halt ( @var{ task --   } ) gforth-experimental
@cindex @code{halt}
@kindex halt
@format
@code{halt} ( @i{task --  }) gforth-experimental ``halt''
@end format
タスクを停止(stop)する


@findex stop ( @var{ --   } ) gforth-experimental
@cindex @code{stop}
@kindex stop
@format
@code{stop} ( @i{--  }) gforth-experimental ``stop''
@end format
現在のタスクを停止(stop)し、 イベントを待ちます(再起動(restart)される可能性があります)


@findex stop-ns ( @var{ timeout --   } ) gforth-experimental
@cindex @code{stop-ns}
@kindex stop-ns
@format
@code{stop-ns} ( @i{timeout --  }) gforth-experimental ``stop-ns''
@end format
タイムアウト(ナノ秒単位)まで停止(stop)します。 @code{ms} のより良い代替品です



タスクは、 タイムアウトが経過(timeout is over)するか、
別のタスクが以下のワードでウェイクアップ(wake)すると再起動(restart)します:

@findex restart ( @var{ task --   } ) gforth-experimental
@cindex @code{restart}
@kindex restart
@format
@code{restart} ( @i{task --  }) gforth-experimental ``restart''
@end format
タスクを起動(wake)する



こちらもどうぞ:

@findex pause ( @var{ --   } ) gforth-experimental
@cindex @code{pause}
@kindex pause
@format
@code{pause} ( @i{--  }) gforth-experimental ``pause''
@end format
次の待機中のタスクに自発的に切り替えます(@code{pause} は従来の協調(cooperative)タスク・スイッチャー(切替器)です。
pthread マルチタスクでは、 協調するのに @code{pause} は必要ありませんが、 それでも使用できます。 例えば、
何らかの理由でポーリングに頼らなければならないときです)。 これにより、 キュー内のイベントもチェックされます。



@node Task-local data, Semaphores, Basic multi-tasking, Pthreads
@subsubsection Task-local data
@cindex user variables
@cindex user space
@cindex task-local data

Forth では、 すべてのタスクには、 「ユーザー領域」(user area)と呼ばれる、 基本的に同じタスク・ローカル・データがあります(初期の
Forth システムはマルチ・ユーザー・システムであり、 タスクごとに 1 人のユーザーが存在することがよくありました)。  @i{task} の結果、
たとえば@code{newtask} は、そのユーザー領域の開始アドレスです。 各タスクは、 システムによって定義されたユーザー・データ(例:
@code{base})を取得します。 あなたは以下を使用して追加のユーザー・データを定義できます:

@findex User ( @var{ "name" --   } ) gforth-0.2
@cindex @code{User}
@kindex User
@format
@code{User} ( @i{"name" --  }) gforth-0.2 ``User''
@end format
@i{name} という名前のユーザー変数(1 セル)を作成します。@*@i{name} 実行時: ( -- @i{addr} )@* @i{addr}
は現在のタスクのユーザー変数のアドレスです。


@findex AUser ( @var{ "name" --   } ) gforth-0.2
@cindex @code{AUser}
@kindex AUser
@format
@code{AUser} ( @i{"name" --  }) gforth-0.2 ``AUser''
@end format
@i{name} というユーザー変数を作成します( @code{User} とはクロス・コンパイラーでのみ違いが生じます)。


@findex uallot ( @var{ n1 -- n2   } ) gforth-0.3
@cindex @code{uallot}
@kindex uallot
@format
@code{uallot} ( @i{n1 -- n2  }) gforth-0.3 ``uallot''
@end format
@i{n1} バイトのユーザー・データを確保します。  確保した領域の先頭をユーザー領域内のオフセット値(@i{n2})として返します。


@findex UValue ( @var{ "name" --   } ) gforth-1.0
@cindex @code{UValue}
@kindex UValue
@format
@code{UValue} ( @i{"name" --  }) gforth-1.0 ``UValue''
@end format
@i{name} はユーザー value です。@*@i{name} 実行時: ( -- @i{x} )


@findex UDefer ( @var{ "name" --   } ) gforth-1.0
@cindex @code{UDefer}
@kindex UDefer
@format
@code{UDefer} ( @i{"name" --  }) gforth-1.0 ``UDefer''
@end format
@i{name} はタスク・ローカルの deferされたワードです。@*@i{Name} 実行時: ( ... -- ... )



ユーザー・データを扱う場合には、 以下のようなワード群もあります。

@findex up@@ ( @var{ -- a-addr  } ) new
@cindex @code{up@@}
@kindex up@@
@format
@code{up@@} ( @i{-- addr }) new ``up-fetch''
@end format
@i{addr} は現在のタスクのユーザー領域の先頭です(@i{addr} は現在のタスクの @i{task} 識別子としても機能します)。

@findex user' ( @var{ "name" -- u   } ) gforth-experimental
@cindex @code{user'}
@kindex user'
@format
@code{user'} ( @i{"name" -- u  }) gforth-experimental ``user'''
@end format
各タスクのユーザー領域のユーザー変数 @i{name} の、 ユーザー領域先頭からのオフセット値を @i{U} に返します。


@findex 's ( @var{ addr1 task -- addr2   } ) gforth-experimental
@cindex @code{'s}
@kindex 's
@format
@code{'s} ( @i{addr1 task -- addr2  }) gforth-experimental ``'s''
@end format
@i{addr1} が現在のタスクのユーザー・データ内のアドレスである場合、 @i{addr2} は
指定のタスク(@i{task})のユーザー・データ内の対応するアドレスです。



@c doc-udp

@node Semaphores, Hardware operations for multi-tasking, Task-local data, Pthreads
@subsubsection Semaphores

協調的(cooperative)マルチタスカーは、 @code{pause} の 2 つの呼び出しの間に相互作用する他のタスクがないことを保証できます。
しかしながら、 pthread は実際には(少なくともマルチコア CPU 上では)並列(concurrent)タスクであるため、
同じリソースにアクセスする際の競合を回避するためのいくつかのテクニックが必要です。

セマフォ(semaphore)を取得できるのは 1 つのスレッドのみであり、 他のすべてのスレッドはセマフォが解放されるまで待機する必要があります。

@findex semaphore ( @var{ "name" --   } ) gforth-experimental
@cindex @code{semaphore}
@kindex semaphore
@format
@code{semaphore} ( @i{"name" --  }) gforth-experimental ``semaphore''
@end format
名前付きセマフォ @i{name} を作成します@*@i{name} 実行時: ( -- @i{semaphore} )


@findex lock ( @var{ semaphore --   } ) gforth-experimental
@cindex @code{lock}
@kindex lock
@format
@code{lock} ( @i{semaphore --  }) gforth-experimental ``lock''
@end format
セマフォをロック(lock)


@findex unlock ( @var{ semaphore --   } ) gforth-experimental
@cindex @code{unlock}
@kindex unlock
@format
@code{unlock} ( @i{semaphore --  }) gforth-experimental ``unlock''
@end format
セマフォのロックを解除します(unlock)



同時アクセスを防ぐもう 1 つのアプローチが、 クリティカル・セクションです。 ここではクリティカル・セクションをセマフォで実装しているため、
クリティカル・セクションに使用するセマフォを指定する必要があります。  同一のセマフォを使用するクリティカル・セクション達のみが相互に排他的です。

@findex critical-section ( @var{ xt semaphore --   } ) gforth-experimental
@cindex @code{critical-section}
@kindex critical-section
@format
@code{critical-section} ( @i{xt semaphore --  }) gforth-experimental ``critical-section''
@end format
@i{semaphore}をロックした状態で @i{xt} を @i{execute} します。  @i{xt} を離れた後は、 それが例外の
throw によるものであっても @i{semaphore} のロックが解除されます。



@node Hardware operations for multi-tasking, Message queues, Semaphores, Pthreads
@subsubsection Hardware operations for multi-tasking

アトミックなハードウェア操作は、 他のタスクが中間状態を参照することなく、 操作全体を実行します。 これらの操作は、 遅い OS
プリミティブを使用せずにタスクを同期するために使用できますが、 非アトミックな操作シーケンスと比較すると遅くなる傾向があります。 アトミックな操作は、
アライメントを必要としないハードウェアであっても、 アライメントされたアドレスでのみ正しく機能します。

@findex !@@ ( @var{ u1 a-addr -- u2  } ) gforth-experimental
@cindex @code{!@@}
@kindex !@@
@format
@code{!@@} ( @i{u1 a-addr -- u2 }) gforth-experimental ``store-fetch''
@end format
@var{a_addr} から 値を @var{u2} に取得し、 そして、 @var{a_addr} に 値 @var{u1} を格納する操作を、
アトミック操作として行います。

@findex +!@@ ( @var{ u1 a-addr -- u2  } ) gforth-experimental
@cindex @code{+!@@}
@kindex +!@@
@format
@code{+!@@} ( @i{u1 a-addr -- u2 }) gforth-experimental ``add-store-fetch''
@end format
@var{a_addr} から 値 @var{u2} を取得し、 @var{a_addr} の値に @var{u1} を足し込む操作を、
アトミック操作として行います。

@findex ?!@@ ( @var{ unew uold a-addr -- uprev  } ) gforth-experimental
@cindex @code{?!@@}
@kindex ?!@@
@format
@code{?!@@} ( @i{unew uold a-addr -- uprev }) gforth-experimental ``question-store-fetch''
@end format
@var{a_addr} から値 @var{uprev} を取得し、それを @var{uold} と比較し、 等しい場合は @var{unew} を
@var{a_addr} に格納する操作を、 アトミック操作として行います。


もう 1 つのハードウェア操作はメモリ・バリアです(memory barrier)。  残念ながら、 最新のハードウェアでは、
メモリ操作を他のメモリ操作と比較して(別のコアから見た場合に)並べ替えることができることが多く、 メモリ・バリアにより、
タスク実行のある時点でこの並べ替えを抑制します。

@findex barrier ( @var{ --  } ) gforth-experimental
@cindex @code{barrier}
@kindex barrier
@format
@code{barrier} ( @i{-- }) gforth-experimental ``barrier''
@end format
バリア前のすべてのメモリ操作は、 バリア後のメモリ操作より前に実行されます。


@node Message queues, , Hardware operations for multi-tasking, Pthreads
@subsubsection Message queues

Gforth のメッセージ・キューはアクター・モデルのバリエーションです。

イベントは xt です。 送信タスクは受信タスクにイベントを実行するようにお願いし、 受信タスクは準備ができたらそのメッセージ・キューからイベントを 1
つ実行します。  単一実行クロージャ(Execute-once closures)は、 パラメータを渡すイベントに使用できます。

@findex send-event ( @var{ xt task --   } ) gforth-experimental
@cindex @code{send-event}
@kindex send-event
@format
@code{send-event} ( @i{xt task --  }) gforth-experimental ``send-event''
@end format
タスク IPC: @var{xt} を @var{task} に送信します。  @var{task} で @i{xt} が @i{execute}
されます。 使い捨てクロージャ(one-shot closure)を使用して、 @i{xt} でパラメータを渡します。



複数のタスクが 1 つのタスクにイベントを送信する場合、 イベントは任意の順序で到着する可能性があります。  イベントを受信するには、
受信タスクに以下のいずれかのワードを使います:

@findex ?events ( @var{ --   } ) gforth-experimental
@cindex @code{?events}
@kindex ?events
@format
@code{?events} ( @i{--  }) gforth-experimental ``question-events''
@end format
現在のタスクのメッセージ・キュー内のすべてのイベント・シーケンスを一度に 1 つずつ実行します。


@findex event-loop ( @var{ --   } ) gforth-experimental
@cindex @code{event-loop}
@kindex event-loop
@format
@code{event-loop} ( @i{--  }) gforth-experimental ``event-loop''
@end format
イベント・シーケンスを待ち、 イベント・シーケンスが到着したら実行します。  キューにイベント・シーケンスがない場合は待機に戻ります。
このワードは二度と制御を戻しません(This word never returns.)。



@code{event-loop} の代わりに、 タスクが @code{stop} 状態になると、 イベントを受信する準備も整い、 そして、
イベントを受信するとタスクが起動(wake)されます。

@c @node Conditions,  , Message queues, Pthreads
@c @subsubsection Conditions
@c 
@c The pthreads library also provides conditional variables, which allow to
@c wait for a condition.  Using the message queue is generally preferred.
@c 
@c doc-cond
@c doc-pthread_cond_signal
@c doc-pthread_cond_broadcast
@c doc-pthread_cond_wait
@c doc-pthread_cond_timedwait

@node Cilk, , Pthreads, Multitasker
@subsection Cilk

gforth の Cilk は、 同じ名前のプログラミング言語からインスピレーションを得た、
複数のコアで実行される複数のタスク間で作業を分割するためのフレームワークです。  Cilk を使用する場合は、 @code{require
cilk.fs} としてください。

考え方としては、 並行して解決できる部分問題(subproblems)を特定し、
フレームワークがワーカー・タスクをこれらの部分問題に割り当てるというものです。 特に、 各サブ・タスクに対して @code{spawn} ワードの 1
つを使用します。  最終的には、 部分問題が解決されるまで @code{cilk-sync} で待つ必要があります。

現在、 すべての生成は 1 つのタスクから発生する必要があり、 @code{cilk-sync}
はすべての部分問題(subproblems)が完了するまで待機するため、 再帰アルゴリズムに現在の gforth Cilk
を使用するのは簡単ではありません。

オーバーヘッドを避けるために、 部分問題を細かく分割しすぎないでください。 どのくらい細かいかは、
部分問題の実行時間がどの程度均一であるかによって決まりますが、 かなりの実行時間の問題の場合は、 5*@code{cores}
個の部分問題(subproblems)にするのが、 おそらく良い出発点となります。

@findex cores ( @var{ -- u   } ) cilk
@cindex @code{cores}
@kindex cores
@format
@code{cores} ( @i{-- u  }) cilk ``cores''
@end format
使用するワーカー・タスクの数を含む値。  デフォルトでは、 これはハードウェア・スレッドの数(SMT/HT の場合)です。
(決定できれば、)それ以外の場合は 1 になります。 別の数を使用したい場合は、 @code{cilk-init} を呼び出す前に
@code{cores} を変更します。 


@findex cilk-init ( @var{ --   } ) cilk
@cindex @code{cilk-init}
@kindex cilk-init
@format
@code{cilk-init} ( @i{--  }) cilk ``cilk-init''
@end format
ワーカー・タスクがまだ実行されていない場合は開始します。


@findex spawn ( @var{ xt --   } ) cilk
@cindex @code{spawn}
@kindex spawn
@format
@code{spawn} ( @i{xt --  }) cilk ``spawn''
@end format
ワーカー・タスクで @i{xt} ( -- ) を @i{execute} します。  使い捨て実行可能クロージャ(one-time
executable closures)を使用して、 ヒープに割り当てられたクロージャを渡し、 @code{spawn} 呼び出し側から、
ワーカーで実行されているコードに任意のデータを渡すことができます。@* 例: @code{( n r ) [@{: n f: r :@}h1 code
;] spawn}


@findex spawn1 ( @var{ x xt --   } ) cilk
@cindex @code{spawn1}
@kindex spawn1
@format
@code{spawn1} ( @i{x xt --  }) cilk ``spawn1''
@end format
Execute @i{xt} ( x -- ) in a worker task.


@findex spawn2 ( @var{ x1 x2 xt --   } ) cilk
@cindex @code{spawn2}
@kindex spawn2
@format
@code{spawn2} ( @i{x1 x2 xt --  }) cilk ``spawn2''
@end format
Execute @i{xt} ( x1 x2 -- ) in a worker task.


@findex cilk-sync ( @var{ --   } ) cilk
@cindex @code{cilk-sync}
@kindex cilk-sync
@format
@code{cilk-sync} ( @i{--  }) cilk ``cilk-sync''
@end format
すべての部分問題が完了(complete)するまで待ちます(wait)。


@findex cilk-bye ( @var{ --   } ) cilk
@cindex @code{cilk-bye}
@kindex cilk-bye
@format
@code{cilk-bye} ( @i{--  }) cilk ``cilk-bye''
@end format
すべてのワーカーを終了(terminate)します。



@c ------------------------------------------------------------
@node C Interface, Assembler and Code Words, Multitasker, Words
@section C Interface
@cindex C interface
@cindex foreign language interface
@cindex interface to C functions

Gforth の C言語インターフェイスは、 Forth スタックからパラメータを取得してC言語の関数を呼び出す、
C言語の関数を含むラッパー・ライブラリをコンパイルすることによって機能します。
このラッパー・ライブラリはC言語のコンパイラによってコンパイルされます。 コンパイル結果はキャッシュされるため、
ラッパー・ライブラリを変更する必要がある場合、 Gforth は C言語のコンパイルを再実行するだけで済みます。
このビルド処理は自動(automatic)で、 インターフェイス宣言の最後に行われます。  Gforth は、 この処理に libtool と GCC
を使用します。

C言語のインターフェイスはほぼ完成した状態で、 コールバックも既に追加されていますが、 構造体については、 独立したスコープを持たない
Forth2012 構造体を使用します。 これらの構造体のオフセットは、 SWIG プラグインを使用してヘッダー・ファイルから抽出されます。

@menu
* Calling C Functions::
* Declaring C Functions::
* Calling C function pointers::
* Defining library interfaces::
* Declaring OS-level libraries::
* Callbacks::
* C interface internals::
* Low-Level C Interface Words::
* Automated interface generation using SWIG::
* Migrating the C interface from earlier Gforth::  
@end menu

@node Calling C Functions, Declaring C Functions, C Interface, C Interface
@subsection Calling C functions
@cindex C functions, calls to
@cindex calling C functions

C言語の関数関数が宣言されたら(@pxref{Declaring C Functions} 参照)、 次のように呼び出すことができます:
あなたは引数達をスタックにプッシュしてから、 C言語関数のワードを呼び出します。  引数は、
C言語のドキュメントに記載されているのと同じ順序でプッシュする必要があります(つまり、 最初の引数がスタックの最も深いところにあります)。
整数およびポインタ引数はデータ・スタックにプッシュする必要があり、 浮動小数点引数は FP スタックにプッシュする必要があります。 これらの引数は、
呼び出されたC言語の関数によって消費されます。

C言語の関数から戻るとき、 戻り値がある場合、 その戻り値は適切なスタックに置きます。 整数の戻り値はデータ・スタックにプッシュされ、 FP の戻り値は
FP スタックにプッシュされ、 void 戻り値の場合は何もプッシュされません。 C言語ではあまり使用されない場合でも、
ほとんどのC言語の関数には戻り値があることに注意してください。 Forth では、 この戻り値を使用しない場合は、
明示的に捨てる(@code{drop})必要があります。

C言語インターフェイスは、 必要に応じて、 ベストエフォートで C言語の型と Forth の型の間で自動的に変換します(場合によっては、
ある程度の損失が発生する可能性があります)。

例として、 POSIX 関数 @code{lseek()} について考察してみましょう:

@example
off_t lseek(int fd, off_t offset, int whence);
@end example

この関数は 3 つの整数引数を受け取り、 整数引数 1 つ返すため、 現在のファイルのオフセットをファイルの先頭に設定するための Forth
呼び出しは以下のようになります:

@example
fd @@ 0 SEEK_SET lseek -1 = if
  ... \ error handling
then
@end example

あなたは、 @code{off_t} がセルに収まらないため、 lseek に大きなオフセットを渡すことができず、
戻り値の一部しか取得できないのではないかと心配するかもしれません。  その場合、 関数の宣言(@pxref{Declaring C
Functions})で、off_t 引数と戻り値に 2倍長セルを使用するように宣言し、 結果の Forth ワードに @code{dlseek}
などの別の名前を付ける必要があります。 その結果は以下のように呼び出すことができます:

@example
fd @@ #0. SEEK_SET dlseek #-1. d= if
  ... \ error handling
then
@end example

構造体または共用体の受け渡しは現在、 このインターフェイスではサポートされていません@footnote{あなたが C
言語コンパイラの呼び出し規則を知っていれば、 通常は何らかの方法でそのような関数を呼び出すことはできますが、 その方法は通常、
プラットフォーム間で移植可能ではなく、 場合によっては C 言語コンパイラ間でさえ移植可能ではありません。}

可変個の引数を持つ関数の呼び出し(「variadic関数」例: @code{printf()})は、 引数パターンごとに 1
つの関数呼び出しワードを宣言し、 目的のパターンに適切なワードを呼び出すことによってのみサポートされます。



@node Declaring C Functions, Calling C function pointers, Calling C Functions, C Interface
@subsection Declaring C Functions
@cindex C functions, declarations
@cindex declaring C functions

あなたは、 先の例の @code{lseek} や @code{dlseek} を呼び出す前に、 宣言する必要があります。  宣言は以下の 2
つの部分で構成されます: 

@table @b

@item C言語部分
関数の C 言語宣言です。 より一般的かつ移植性の高いものとしては、 C 言語の関数の宣言を含むファイルの C 言語スタイルの
@code{#include} です。

@item Forth部分
パラメータの Forth 型と、 C言語の関数に対応する Forth ワード名を宣言します。

@end table

前述の @code{lseek} と @code{dlseek} の宣言は以下のとおりです:

@example
\c #define _FILE_OFFSET_BITS 64
\c #include <sys/types.h>
\c #include <unistd.h>
c-function lseek lseek n n n -- n
c-function dlseek lseek n d n -- d
@end example

宣言の C言語部分は @code{\c} という接頭辞が付けられ、 @code{\c} の行の残りの部分は通常の C 言語のコードです。 C
言語の宣言の行は好きなだけ使用でき、 それ以降のすべての関数宣言で参照できます。

Forth 部分は、 @code{c-function} で各インターフェイス・ワードを宣言し、 その後にワードの Forth 名と、 呼び出される C
言語の関数名と、 ワードのスタック効果が続きます。  スタック効果には、 任意の数のパラメータのタイプ、 @code{--}、 そして戻り値の「 1
つ」のタイプが含まれます。  可能なタイプは以下のとおりです:

@table @code

@item n
単一セル整数

@item a
アドレス(単一セル)

@item d
2倍長セル整数

@item r
浮動小数点数値

@item func
C言語の関数へのポインタ

@item void
値なし(void 関数の戻り値の型として使用)

@end table

@cindex variadic C functions

可変個の引数(variadic)の C 言語の関数を扱うには、 あなたが使用したいパターンごとに 1 つの Forth ワードを宣言します。 例:

@example
\c #include <stdio.h>
c-function printf-nr printf a n r -- n
c-function printf-rn printf a r n -- n
@end example

注意: C 言語の関数が可変個(variadic)の引数として宣言されている場合(または関数プロトタイプを提供していない場合)、 C
言語インターフェイスには変換先の C 言語の型がないため、 自動変換は行われず、
場合によっては移植性の問題が発生する可能性があることに注意してください。  C 言語の型キャストを中括弧で囲んで Forth 型の後に追加できます。
これにより、 例えば、 Forth ではスタック上に存在できない構造体を C 言語の関数へ渡す事も可能になります。

@example
c-function printfll printf a n@{(long long)@} -- n
c-function pass-struct pass_struct a@{*(struct foo *)@} -- n
@end example

C言語では左辺値(lvalues)の型キャスト(typecast)が許可されていないため、 この型キャストは戻り値には使用できません。

@findex \c ( @var{ "rest-of-line" --   } ) gforth-0.7
@cindex @code{\c}
@kindex \c
@format
@code{\c} ( @i{"rest-of-line" --  }) gforth-0.7 ``backslash-c''
@end format
C言語インターフェイスのC言語宣言の1行


@findex c-function ( @var{ "forth-name" "c-name" "@{type@}" "---" "type" --   } ) gforth-0.7
@cindex @code{c-function}
@kindex c-function
@format
@code{c-function} ( @i{"forth-name" "c-name" "@{type@}" "--" "type" --  }) gforth-0.7 ``c-function''
@end format
Forth ワード @i{forth-name} を定義します。  @i{Forth-name} には指定されたスタック効果(@i{@{type@}}
と @i{type})があり、 C言語関数 @code{c-name} を呼び出します。


@findex c-value ( @var{ "forth-name" "c-name" "---" "type" --   } ) gforth-1.0
@cindex @code{c-value}
@kindex c-value
@format
@code{c-value} ( @i{"forth-name" "c-name" "--" "type" --  }) gforth-1.0 ``c-value''
@end format
Forth ワード @i{forth-name} を定義します。  @i{Forth-name} には指定されたスタック効果(@i{type})があり、
@code{c-name} の C言語からの値を与えます(訳注: スタック効果の通り、 読み取りのみ)。


@findex c-variable ( @var{ "forth-name" "c-name" --   } ) gforth-1.0
@cindex @code{c-variable}
@kindex c-variable
@format
@code{c-variable} ( @i{"forth-name" "c-name" --  }) gforth-1.0 ``c-variable''
@end format
Forth ワード @i{forth-name} を定義します。  @i{Forth-name} は @code{c-name} のアドレスを返します。



この C言語インターフェイスが機能するために、 実行時に GCC を呼び出し、 動的リンク(dynamic linking)を使用します。
これらの機能が利用できない場合は、 @file{lib.fs} と @file{oldlib.fs} に、利便性と移植性に劣る他の C
言語インターフェイスが用意されています。 これらのインターフェイスはほとんど文書化されておらず、 また文書化された
C言語インターフェイスとほとんど互換性がありません。 あなたが例を見たければ、 @file{lib.fs} インターフェイスの例が
@file{lib.fs} にあります。


@node Calling C function pointers, Defining library interfaces, Declaring C Functions, C Interface
@subsection Calling C function pointers from Forth
@cindex C function pointers, calling from Forth

C言語の関数へのポインタ(たとえば、 C言語で構築された構造体など)を見つけて、 それを Forth プログラムから呼び出したい場合は、
マクロを定義することで上記の構造体を使用できます。 または、 @code{c-funptr} を使用します。

@findex c-funptr ( @var{ "forth-name" <@{>"c-typecast"<@}> "@{type@}" "---" "type" --   } ) gforth-1.0
@cindex @code{c-funptr}
@kindex c-funptr
@format
@code{c-funptr} ( @i{"forth-name" <@{>"c-typecast"<@}> "@{type@}" "--" "type" --  }) gforth-1.0 ``c-funptr''
@end format
Forth ワード @i{Forth-name} を定義します。 @i{Forth-name} には、 その後続に記述されたスタック効果と、
スタックのTOSに置かれた呼び出されたポインタ(the called pointer)(つまり @{type@} ptr -- type )があり、
型キャスト(typecast)または構造体アクセス(c-typecast)を使用して C 言語の関数へのポインタ @code{ptr} を呼び出します。



ヘッダー・ファイル @file{func1.h} に C言語の関数ポインタ型 @code{func1} が定義されており、 これらの関数は 1
つの整数引数を受け取り、 整数の結果を返すことがわかっているとします。 そして、 そのようなポインタを介して関数を呼び出したいとします。
あなたは以下のように定義するだけです

@example
\c #include <func1.h>
c-funptr call-func1 @{((func1)ptr)@} n -- n
@end example

そして、 例えば、 以下のようにして @code{func1-addr} が指す関数を呼び出すことができます:

@example
-5 func1-addr call-func1 .
@end example

Forth ワード @code{call-func1} は @code{execute} に似ていますが、Forth 実行トークンの代わりに C 言語の
@code{func1} ポインタを使用し、 @code{func1} ポインタ固有である点が異なります。  Forth から呼び出したい C
言語の関数ポインタのタイプごとに、 個別の呼び出しワードを定義する必要があります。

@node Defining library interfaces, Declaring OS-level libraries, Calling C function pointers, C Interface
@subsection Defining library interfaces
@cindex giving a name to a library interface
@cindex library interface names

以下のように、 一連の C 言語関数宣言(ライブラリ・インターフェイス)に名前を付けることができます:

@example
c-library lseek-lib
\c #define _FILE_OFFSET_BITS 64
...
end-c-library
@end example

インターフェイスにこのような名前を付けると、 生成されるファイルの名前にその名前が含まれるようになり、 インターフェイスを 2 回目に使用するときに、
再度生成してコンパイルする代わりに既存のファイルが使用されるため、時間を節約できます。 生成されたファイルにはソース・コードの 128
ビット・ハッシュ(暗号的に安全ではありませんが、 この目的には十分である)が含まれているため、 宣言を変更すると新しいコンパイルが発生します。  通常、
これらのファイルは @file{$HOME/.gforth/}@var{architecture}@file{/libcc-named}
にキャッシュされるため、 問題が発生した場合、 または再コンパイルの強制が必要なその他の理由がある場合は、そこにあるファイルを削除してください。

注意: @code{c-library} を使用すると、 一部の設定がリセットされるため、 そのライブラリに関連する他のすべての処理の前に
@code{c-library} を使用する必要があることに注意してください。 @code{c-library} の考え方は、 一般的な使用法としては、
各 @code{c-library}...@code{end-c-library} ユニットを独自のファイルに配置し、
これらのファイルを任意の順序でインクルードできるようにすることです。  C 言語インターフェースを扱う他のすべてのワードは、 ボキャブラリ
@code{c-lib} に隠されており、 @code{c-library} によって検索順序スタックの最上位に置かれ、
@code{end-c-library} によって検索順序スタックの最上位から削除されます。

注意: ライブラリ名はディクショナリに割り当てられないため、 ディクショナリ内の名前に影響を与えないことに注意してください。
ファイル・システムで使用されるため、 ファイル・システムに適した命名規則を使用する必要があります。
この名前はC言語のシンボルの一部としても使用されますが、 正当なC言語のシンボル名以外の文字はアンダースコアに置き換えられます。  また、
@code{c-library} の後で宣言した関数を @code{end-c-library} を実行する前に呼び出してはなりません。

これらの名前付きライブラリ・インターフェイスの主な利点は、 それらが生成されると、 その生成に使用したツール(特に C 言語のコンパイラと
libtool)が不要になるため、 ツールがインストールされていないマシンでもインターフェイスを使用できることです。 Gforth
のビルド・システムはこれらのライブラリをクロス・コンパイルすることもできるため、
ビルド・ツールがインストールされていないプラットフォームでもライブラリを利用できます。

@findex c-library-name ( @var{ c-addr u --   } ) gforth-0.7
@cindex @code{c-library-name}
@kindex c-library-name
@format
@code{c-library-name} ( @i{c-addr u --  }) gforth-0.7 ``c-library-name''
@end format
@i{c-addr u} という名前で C ライブラリ・インターフェイスを開始。


@findex c-library ( @var{ "name" --   } ) gforth-0.7
@cindex @code{c-library}
@kindex c-library
@format
@code{c-library} ( @i{"name" --  }) gforth-0.7 ``c-library''
@end format
@code{c-library-name} のパース対応(parsing)バージョンです


@findex end-c-library ( @var{ --   } ) gforth-0.7
@cindex @code{end-c-library}
@kindex end-c-library
@format
@code{end-c-library} ( @i{--  }) gforth-0.7 ``end-c-library''
@end format
直近の C ライブラリ・インターフェイスを終了し、 (必要に応じて)ビルドします。




@node Declaring OS-level libraries, Callbacks, Defining library interfaces, C Interface
@subsection Declaring OS-level libraries
@cindex Shared libraries in C interface
@cindex Dynamically linked libraries in C interface
@cindex Libraries in C interface

一部の C 言語の関数を呼び出すには、 その関数を含む特定の OS レベルのライブラリとリンクする必要があります。  たとえば、@code{sin}
関数では、 コマンドライン・スイッチ @code{-lm} を使用して特別なライブラリをリンクする必要があります。 C 言語インターフェイスでは、
以下のように @code{add-lib} を呼び出して同等のことを行います:

@example
clear-libs
s" m" add-lib
\c #include <math.h>
c-function sin sin r -- r
@end example

まず、 (あなたが @code{sin} に必要としない、)以前に宣言された可能性のあるライブラリをすべてクリアします。 次に @code{m}
ライブラリ(実際には @code{libm.so} など) を現在宣言されているライブラリに追加します。 これは必要なだけ追加できます。  最後に、
上に示したように関数を宣言します。  通常は、 多くの関数宣言に同じライブラリ宣言のセットを使用します。 あなたは、 最初に、 この組を、 ただ 1
つだけ作成する必要があります。

注意: @code{c-library...end-c-library} 内で @code{clear-libs}
を呼び出してはいけないことに注意してください。 しかしながら、 @code{c-library} は @code{clear-libs}
の機能も実行するため、 @code{clear-libs} は必要なく、 そして、 あなたは、 通常は @code{add-lib} 呼び出しを
@code{c-library...end-c-library} 内に置きたいと思うでしょう。

@findex clear-libs ( @var{ --   } ) gforth-0.7
@cindex @code{clear-libs}
@kindex clear-libs
@format
@code{clear-libs} ( @i{--  }) gforth-0.7 ``clear-libs''
@end format
libs のリストをクリア


@findex add-lib ( @var{ c-addr u --   } ) gforth-0.7
@cindex @code{add-lib}
@kindex add-lib
@format
@code{add-lib} ( @i{c-addr u --  }) gforth-0.7 ``add-lib''
@end format
ライブラリ lib@i{string} をライブラリのリストに追加します。ここで、 @i{string} は @i{c-addr u} で表されます。


@findex add-libpath ( @var{ c-addr u --   } ) gforth-0.7
@cindex @code{add-libpath}
@kindex add-libpath
@format
@code{add-libpath} ( @i{c-addr u --  }) gforth-0.7 ``add-libpath''
@end format
パス @i{string} をライブラリ検索パスのリストに追加します。 ここで、@i{string} は @i{c-addr u} で表されます。


@findex add-framework ( @var{ c-addr u --   } ) gforth-1.0
@cindex @code{add-framework}
@kindex add-framework
@format
@code{add-framework} ( @i{c-addr u --  }) gforth-1.0 ``add-framework''
@end format
フレームワーク lib@i{string} をフレームワークのリストに追加します。 ここで、@i{string} は @i{c-addr u}
で表されます。


@findex add-incdir ( @var{ c-addr u --   } ) gforth-1.0
@cindex @code{add-incdir}
@kindex add-incdir
@format
@code{add-incdir} ( @i{c-addr u --  }) gforth-1.0 ``add-incdir''
@end format
パス @i{c-addr u} をインクルード検索パスのリストに追加します


@findex add-cflags ( @var{ c-addr u --   } ) gforth-1.0
@cindex @code{add-cflags}
@kindex add-cflags
@format
@code{add-cflags} ( @i{c-addr u --  }) gforth-1.0 ``add-cflags''
@end format
あらゆる種類の cflags をC言語コンパイラに追加します


@findex add-ldflags ( @var{ c-addr u --   } ) gforth-1.0
@cindex @code{add-ldflags}
@kindex add-ldflags
@format
@code{add-ldflags} ( @i{c-addr u --  }) gforth-1.0 ``add-ldflags''
@end format
リンカにフラグを追加



@node Callbacks, C interface internals, Declaring OS-level libraries, C Interface
@subsection Callbacks
@cindex Callback functions written in Forth
@cindex C function pointers to Forth words

場合によっては、 C言語の関数へ関数のポインタを渡す必要があります。 つまり、
ライブラリがアプリケーションにコールバックしたい場合です(ポイント先の関数はコールバック関数と呼ばれます)。
既存のC言語の関数のアドレス(@code{lib-sym} で取得。 @pxref{Low-Level C Interface
Words})を渡すことができますが、 適切な C言語の関数がない場合、 あなたは Forth ワードをC言語の関数として定義したい筈です。 その際は、
下記にて説明する、 コールバックを生成する必要があります:

@code{c-callback} を使用して Forth コードからC言語のコールバックを生成できます。

@findex c-callback ( @var{ "forth-name" "@{type@}" "---" "type" --   } ) gforth-1.0
@cindex @code{c-callback}
@kindex c-callback
@format
@code{c-callback} ( @i{"forth-name" "@{type@}" "--" "type" --  }) gforth-1.0 ``c-callback''
@end format
指定のシグネチャ @i{forth-name} を使用してコールバック・インスタンス化器(instantiator;インスタンシエーター)を定義します。
コールバック・インスタンス化器 @i{forth-name} @code{( xt -- addr )} は、 @var{xt} を受け取り、
そのコールバックを処理する C言語関数の @var{addr} を返します。


@findex c-callback-thread ( @var{ "forth-name" "@{type@}" "---" "type" --   } ) gforth-1.0
@cindex @code{c-callback-thread}
@kindex c-callback-thread
@format
@code{c-callback-thread} ( @i{"forth-name" "@{type@}" "--" "type" --  }) gforth-1.0 ``c-callback-thread''
@end format
指定のシグネチャ @i{forth-name} を使用してコールバック・インスタンス化器を定義します。  コールバック・インスタンス化器
@i{forth-name} @code{( xt -- addr )} は、 @var{xt} を受け取り、 そのコールバックを処理する
C言語の関数の @var{addr} を返します。  このコールバックは、 別のスレッドから呼び出された場合に安全です



これにより、 (value @code{callback#} までの)多数のコールバック関数がプリコンパイルされます。  C言語の関数プロトタイプは、
Forth シグネチャから推定されます。  これでは不十分な場合は、 Forth 型の後に中かっこで囲んで型を追加できます。

@example
c-callback vector4double: f f f f -- void
c-callback vector4single: f@{float@} f@{float@} f@{float@} f@{float@} -- void
@end example

@c I don't understand the existing callback interface from the example - anton


@c > > Und dann gibt's noch die fptr-Deklaration, die einem
@c > > C-Funktionspointer entspricht (Deklaration gleich wie bei
@c > > Library-Funktionen, nur ohne den C-Namen, Aufruf mit der
@c > > C-Funktionsadresse auf dem TOS).
@c >
@c > Ja, da bin ich dann ausgestiegen, weil ich aus dem Beispiel nicht
@c > gesehen habe, wozu das gut ist.
@c 
@c Irgendwie muss ich den Callback ja testen. Und es soll ja auch 
@c vorkommen, dass man von irgendwelchen kranken Interfaces einen 
@c Funktionspointer übergeben bekommt, den man dann bei Gelegenheit 
@c aufrufen muss. Also kann man den deklarieren, und das damit deklarierte 
@c Wort verhält sich dann wie ein EXECUTE für alle C-Funktionen mit 
@c demselben Prototyp.


@node C interface internals, Low-Level C Interface Words, Callbacks, C Interface
@subsection How the C interface works

文書化されたC言語インターフェイスは、 宣言から C コードを生成することによって機能します。

特に、 @code{c-function} で宣言されたすべての Forth ワードに対して、 Forth スタックから Forth
データを取得するラッパー関数をC言語で生成し、 これらのデータを引数としてターゲットのC言語の関数を呼び出します。  次に、 C言語のコンパイラは、
スタックからの Forth 型と、 C言語の関数プロトタイプによって指定されるパラメーターのC言語の型、 の間で暗黙的な変換を実行します。
C言語の関数から戻った後、 戻り値も同様に暗黙的に Forth 型に変換され、 スタックに書き戻されます。

@code{\c} 行はそのままC言語のコードに含まれており(ただし、@code{\c} は含まれません)、 C言語のコンパイラーがC言語の型を認識し、
そして、 変換を実行するのに十分な情報を得るために必要な宣言を提供します。 

これらのラッパー関数は最終的にコンパイルされ、そして、 Gforth に動的にリンクされ、 そして、 呼び出すことができるようになります。

@code{add-lib} で追加されたライブラリは、 コンパイラのコマンド・ラインで @code{-l@var{lib}}
で依存ライブラリを指定するために使用され、 ラッパー関数がリンクされるときにこれらのライブラリが動的にリンクされます。


@node Low-Level C Interface Words, Automated interface generation using SWIG, C interface internals, C Interface
@subsection Low-Level C Interface Words

@findex open-lib ( @var{ c-addr1 u1 -- u2  } ) gforth-0.4
@cindex @code{open-lib}
@kindex open-lib
@format
@code{open-lib} ( @i{c-addr1 u1 -- u2 }) gforth-0.4 ``open-lib''@*\ 訳注: 指定の名前のライブラリを開く。 @i{u2} にハンドルを返す。@*エラーの場合は @i{u2} に 0 を返し、 @code{lib-error} で参照できるエラーメッセージをセットする。
@end format

@findex lib-sym ( @var{ c-addr1 u1 u2 -- u3  } ) gforth-0.4
@cindex @code{lib-sym}
@kindex lib-sym
@format
@code{lib-sym} ( @i{c-addr1 u1 u2 -- u3 }) gforth-0.4 ``lib-sym''@*\ 訳注: @code{open-lib} で取得したハンドル @i{u2} を使って@* シンボル文字列 @i{c-addr1 u1} のシンボル・テーブルのアドレスを @i{u3} に返す。@*エラーの場合は @i{u3} に 0 を返し、 @code{lib-error} で参照できるエラーメッセージをセットする。
@end format

@findex lib-error ( @var{ -- c-addr u  } ) gforth-0.7
@cindex @code{lib-error}
@kindex lib-error
@format
@code{lib-error} ( @i{-- c-addr u }) gforth-0.7 ``lib-error''
@end format
最後に失敗した @code{open-lib} または @code{lib-sym} のエラー・メッセージ。

@findex call-c ( @var{ ... w -- ...  } ) gforth-0.2
@cindex @code{call-c}
@kindex call-c
@format
@code{call-c} ( @i{... w -- ... }) gforth-0.2 ``call-c''
@end format
@i{w} が指す C言語の関数を呼び出します。 C言語関数はそれ自身でスタックにアクセスする必要があります。
スタック・ポインタはC言語の関数に渡される ptrpair 構造体にエクスポートされ、 その形式でC言語関数から返されます。


@node Automated interface generation using SWIG, Migrating the C interface from earlier Gforth, Low-Level C Interface Words, C Interface
@subsection Automated interface generation using SWIG

SWIG (Simple Wrapper Interface Generator)は、
多くのプログラミング言語でC言語インターフェイスを作成するために使用されています。  Forth モジュールで拡張された SWIG バージョンは、
@uref{https://github.com/GeraldWodni/swig,github} にあります。

@subsubsection Basic operation
C言語のヘッダーはパースされ、 前述のC言語インターフェイス関数を使用する Forth のソース・コードに変換されます。

@subsubsection Detailed operation:
@enumerate 1
@item ターゲットを選択します。 この例では @code{example.h} を使用しています。
@item ヘッダー用のインターフェイス・ファイルを作成します。 これは、 オプションと、スイッチと、変数の定義を、 渡すために使用できます。
    最も単純なケースでは、@code{example.h} のすべてを変換(translate)するよう指示するだけです:@/
@example
%module example
%insert("include")
@{
    #include "example.h"
@}
%include "example.h"
@end example
@item SWIG を使用して @code{.fsi-c} ファイルを作成します。@*
    @code{swig -forth -stackcomments -use-structs -enumcomments -o example-fsi.c
example.i}@*FSI は「Forth Source Independent」の略で、
C言語コンパイラを備えた任意のホストに転送できることを意味します。 この時点以降、 SWIG は必要ありません。
@item ターゲット・マシンで @code{.fsi-c} ファイルを @code{.fsx} にコンパイルします(x は executable(実行可能)の意味です)@*
    @code{gcc -o example.fsx example-fsi.c}@*コンパイルすると、
すべての定数(constant)がターゲット上の値(value)に解決されます。
@item 最後のステップは、 実行可能ファイルを実行し、 その出力を Forth のソース・ファイルである @code{.fs} ファイルにキャプチャすることです。@*
    @code{./example.fsx -gforth > example.fs}@*これで、
このコードはターゲット・プラットフォームで使用できるようになりました。
@end enumerate

@subsubsection Examples
いくつかの例: SWIG's
@uref{https://github.com/GeraldWodni/swig/tree/master/Examples/forth, Forth
Example section}

たくさんのインターフェイス・ファイルがこちらにあります: @uref{https://github.com/GeraldWodni/posix,
Forth Posix C-Interface} と
@uref{https://github.com/GeraldWodni/forth-c-interfaces, Forth C-Interface
Modules}

@uref{https://github.com/GeraldWodni/forth-c-interfaces, Forth C-Interface
Module repository} への貢献はいつでも歓迎です！

@node Migrating the C interface from earlier Gforth, , Automated interface generation using SWIG, C Interface
@subsection Migrating from Gforth 0.7
@cindex Must now be used inside C-LIBRARY, see C interface doc

このバージョンでは、 @code{\c} と @code{c-function} と @code{add-lib} は
@code{c-library}...@code{end-c-library} 内でのみ使用できます。 @code{add-lib} は常に
@code{c-library} 内の白紙の状態から開始されるため、 ほとんどの場合 @code{clear-libs} を使用する必要はありません。

@code{c-library}...@code{end-c-library} の外側でこれらのワードを使用するプログラムがあった場合は、 あなたは、
それらを @code{c-library}...@code{end-c-library} で囲むだけです。 ただし、 @code{add-lib}
のインスタンスをいくつか追加する必要がある場合があります。

@c -------------------------------------------------------------
@node Assembler and Code Words, Carnal words, C Interface, Words
@section Assembler and Code Words
@cindex assembler
@cindex code words

@menu
* Assembler Definitions::    Definitions in assembly language
* Common Assembler::         アセンブラ文法
* Common Disassembler::
* 386 Assembler::            逸脱(deviations)と特殊ケース
* AMD64 Assembler::
* Alpha Assembler::          逸脱(deviations)と特殊ケース
* MIPS assembler::           逸脱(deviations)と特殊ケース
* PowerPC assembler::        逸脱(deviations)と特殊ケース
* ARM Assembler::            逸脱(deviations)と特殊ケース
* Other assemblers::         アセンブラ自体の書き方
@end menu

@node Assembler Definitions, Common Assembler, Assembler and Code Words, Assembler and Code Words
@subsection Definitions in assembly language

Gforth は、 アセンブリ言語でワードを実装する方法(@code{abi-code} … @code{end-code} を使用)と、
任意の実行時の振る舞いを持つ定義ワードを定義する方法(@code{does>} のようなの)を提供し、 ここで、
この実行時の振る舞いを(@code{does>} とは異なり、) Forth ではなくアセンブリ言語で定義します。

ただし、 Gforth のマシン非依存の性質により、 いくつかの問題が生じます。 まず、 Gforth は複数のアーキテクチャ上で実行されるため、
標準のアセンブラを提供できません。 ただし、 実行されるいくつかのアーキテクチャ用のアセンブラは提供されています。  さらに言えば、 Gforth
ではシステムに依存しないアセンブラを使用したり、 @code{,} や @code{c,} を使用してマシン・コードを直接コンパイルしたりできます。

もう 1 つの問題は、Gforth の仮想マシンのレジスタ(スタック・ポインタと仮想マシン命令ポインタ)がインストールとエンジンに依存することです。
また、 どのレジスタを自由に使用できるかは、 インストールとエンジンによって異なります。  したがって、 Gforth
仮想マシンのコンテキストで実行するように記述されたコードは、 基本的に、 そのコードが開発されたインストールとエンジンに限定されます(たまたま、
他の場所でも動く可能性はありますが、 それに頼ることはできません)。

幸いなことに、 同じ呼び出し規約(ABI)を持つプラットフォーム上で実行されている Gforth に移植可能(portable)な
@code{abi-code} ワードを Gforth で定義できます。 通常、 これは同じアーキテクチャと OS の組み合わせへの移植性を意味し、
しばしば OS の境を越えることができます。

@findex assembler ( @var{ --   } ) tools-ext
@cindex @code{assembler}
@kindex assembler
@format
@code{assembler} ( @i{--  }) tools-ext ``assembler''
@end format
ボキャブラリ: 検索順序スタック(the search order)のTOSのワードリストを assembler ワードリストに置き換えます。


@findex init-asm ( @var{ --   } ) gforth-0.2
@cindex @code{init-asm}
@kindex init-asm
@format
@code{init-asm} ( @i{--  }) gforth-0.2 ``init-asm''
@end format
assembler ワードリストを検索順序スタック(the search order)にプッシュします(訳注:つまり assembler
ワードリストが検索順序スタックのTOSになる)。


@findex abi-code ( @var{ "name" -- colon-sys   } ) gforth-1.0
@cindex @code{abi-code}
@kindex abi-code
@format
@code{abi-code} ( @i{"name" -- colon-sys  }) gforth-1.0 ``abi-code''
@end format
C言語プロトタイプ(C-prototype)に対応するプラットフォームの ABI 規則を使用して呼び出されるネイティブ・コード定義を開始します:
@example
Cell *function(Cell *sp, Float **fpp);
@end example
ここで、 FP スタック・ポインタは、 FP スタック・ポインタを含むメモリ位置への参照を提供することによって渡され、 (必要な場合)変更された FP
スタック・ポインタをそこに格納することによって渡されます。


@findex ;abi-code ( @var{ --   } ) gforth-1.0
@cindex @code{;abi-code}
@kindex ;abi-code
@format
@code{;abi-code} ( @i{--  }) gforth-1.0 ``semicolon-abi-code''
@end format
コロン定義を終了しますが、 実行時に最後に定義されたワード @i{X} (@code{create}
で作られたワードである必要があります)の変更もして、 C言語プロトタイプに対応するプラットフォームの ABI
規約を使用してネイティブ・コードを呼び出します:
@example
Cell *function(Cell *sp, Float **fpp, Address body);

@end example
FP スタック・ポインタは、 FP スタック・ポインタを含むメモリ位置への参照を提供することによって渡され、 変更された FP
スタック・ポインタをそこに格納することによって渡されます(必要な場合)。  パラメータ @i{body} は @i{X} の本体です。


@findex end-code ( @var{ colon-sys --   } ) gforth-0.2
@cindex @code{end-code}
@kindex end-code
@format
@code{end-code} ( @i{colon-sys --  }) gforth-0.2 ``end-code''
@end format
コード定義を終了します。  ABI 呼び出しからの戻り(@code{abi-code} の場合)、 または次の VM
命令へのディスパッチ(@code{code} および @code{;code} の場合)を自分でアセンブルする必要があることに注意してください。


@findex code ( @var{ "name" -- colon-sys   } ) tools-ext
@cindex @code{code}
@kindex code
@format
@code{code} ( @i{"name" -- colon-sys  }) tools-ext ``code''
@end format
Gforth 仮想マシン(エンジン)のコンテキストで実行されるネイティブ・ード定義を開始します。  このような定義は Gforth
インストール間で移植できないため、 @code{code} の代わりに @code{abi-code} を使用することをお勧めします。
@code{code} 定義は、 次の仮想マシン命令へのディスパッチで終了する必要があります。


@findex ;code ( @var{ compilation. colon-sys1 -- colon-sys2   } ) tools-ext
@cindex @code{;code}
@kindex ;code
@format
@code{;code} ( @i{compilation. colon-sys1 -- colon-sys2  }) tools-ext ``semicolon-code''
@end format
@code{;code} の後のコードが、 最後に定義されたワード(@code{create} されたワードである必要があります)
の振る舞いになります。  @code{code} の場合と同じ注意事項が適用されるため、 代わりに @code{;abi-code}
を使用することをお勧めします。


@findex flush-icache ( @var{ c-addr u --  } ) gforth-0.2
@cindex @code{flush-icache}
@kindex flush-icache
@format
@code{flush-icache} ( @i{c-addr u -- }) gforth-0.2 ``flush-icache''
@end format
プロセッサの命令キャッシュ(存在する場合)の @i{c-addr} と @i{u} バイト以降に古いデータが含まれていないことを確認してください。
@code{END-CODE} は @code{flush-icache} を自動的に実行します。 注意(Caveat):
@code{flush-icache} はあなたのインストール環境では機能しない可能性があります。 これは通常、
マシンでダイレクト・スレッドがサポートされておらず(@file{machine.h} を確認してください)、
マシンに別個の命令キャッシュがある場合に当てはまります。 このような場合、 @code{flush-icache}
は命令キャッシュをフラッシュする代わりに何も行いません。



@code{flush-icache} が正しく動作しない場合、 @code{abi-code} ワードなども(まず確実に)動作しません。

これらのワードの一般的な使用法は、 同等の高レベルの定義ワードから類推することで最も簡単に示すことができます:

@example
: foo                              abi-code foo
   <high-level Forth words>              <assembler>
;                                  end-code
                                
: bar                              : bar
   <high-level Forth words>           <high-level Forth words>
   CREATE                             CREATE
      <high-level Forth words>           <high-level Forth words>
   DOES>                              ;code
      <high-level Forth words>           <assembler>
;                                  end-code
@end example

@code{abi-code} を使用する場合は、 あなたのプラットフォームの ABI ドキュメントを参照して、
パラメーターがどのように渡されるか(スタック・ポインターをどこで取得するかがわかります)、
戻り値がどのように渡されるか(データ・スタック・ポインタがどこに返されるかがわかります)を確認してください。 ABI のドキュメントでは、
どのレジスタが呼び出し元によって保存されるか(caller-saved)や、 コード内で自由に破棄できるかや、
どのレジスタが呼び出されたワードによって保存される必要があるか(callee-saved)についても説明されています。
あなたはそれらを使用する前に保存し、 後で復元します。  一部のアーキテクチャと OS
については、適切なセクションで呼び出し規約の各部分の短い概要を示します。  リバース・エンジニアリング志向の人々は、 @code{see
abi-call} を通じてスタック・ポインタの受け渡しと戻りについて知ることもできます。

ほとんどの ABI はレジスタを介してパラメータを渡しますが、 一部の ABI(特に最も一般的な 386 (別名 IA-32) 呼び出し規約)
はアーキテクチャ・スタック上でパラメータを渡します。  共通の ABI はすべてレジスタで戻り値を渡します。

@code{abi-code} を使用する際に知っておく必要があるその他のことは、 Gforth ではデータと FP
スタックの両方が下方向(下位アドレスに向かって)に成長し、 セルあたりのサイズは @code{1 cells} になり、 FP 値ごとのサイズは
@code{1 floats} になるということです。

386 アーキテクチャで @code{abi-code} を使用する例を以下に示します:

@example
abi-code my+ ( n1 n2 -- n )
4 sp d) ax mov \ sp into return reg
ax )    cx mov \ tos
4 #     ax add \ update sp (pop)
cx    ax ) add \ sec = sec+tos
ret            \ return from my+
end-code
@end example

この例の AMD64 バリエーションは @ref{AMD64 Assembler} にあります。

386 で FP 値を扱う例を以下に示します:

@example
abi-code my-f+ ( r1 r2 -- r )
8 sp d) cx mov  \ load address of fp
cx )    dx mov  \ load fp
.fl dx )   fld  \ r2
8 #     dx add  \ update fp
.fl dx )   fadd \ r1+r2
.fl dx )   fstp \ store r
dx    cx ) mov  \ store new fp
4 sp d) ax mov  \ sp into return reg
ret             \ return from my-f+
end-code
@end example


@node Common Assembler, Common Disassembler, Assembler Definitions, Assembler and Code Words
@subsection Common Assembler

Gforth のアセンブラは通常、 後置構文(postfix syntax)を使用します。 つまり、命令名がオペランドの後に続きます。

オペランドは通常の順序(アーキテクチャのマニュアルで使用されている順序と同じ)で渡されます。  これらはすべて Forth ワードであるため、
スペースで区切る必要があります。 Forth ワードを使用してオペランドを計算することもできます。

通常、 命令名は @code{,} で終わります。  これにより、 複数の命令を 1 行に配置した場合に、 命令を視覚的に分離しやすくなります。 また、
他の Forth ワード (例: @code{and}) が紛れてしまう(shadowing)のも回避します。

レジスタは通常、 番号で指定します。 たとえば、 (10 進数の) @code{11} は、 Alpha アーキテクチャ上のレジスタ R11 および
F11 を指定します(どちらかは命令によって異なります)。  通常の名前も使用できます(例: Alpha の R11 の @code{s2})。

制御フローは、 通常の Forth コード(@pxref{Arbitrary control structures})と同様に、 @code{if,},
@code{ahead,}, @code{then,}, @code{begin,}, @code{until,}, @code{again,},
@code{cs-roll}, @code{cs-pick}, @code{else,}, @code{while,}, @code{repeat,}
で指定します。 条件は各アセンブラに固有の方法で指定されます。

このセクションの残りの部分は、 (移植性の高い @code{abi-code} ワードではなく、)主に @code{code}
ワードを定義したい人にとって興味深いものです。

注意: Gforth エンジンのレジスタ割り当ては、 Gforth バージョン間、 または同じ Gforth
バージョンの異なるコンパイル間でも変更される可能性があることに注意してください(たとえば、 異なる GCC バージョンを使用する場合)。
@code{ABI-CODE} の代わりに @code{CODE} を使用していて、 Gforth のレジスター (スタック・ポインターや TOS
など) を参照したい場合は、 これらのレジスターを参照するための独自のワードを定義して使用することをお勧めします。 そうすれば、
変更されたレジスタ割り当てに適応できます。

これらのレジスタの最も一般的な使用法は、 @code{code} 定義を次のワードへのディスパッチ(@code{next}
ルーチン)で終了することです。  これを行う移植可能な方法は、@code{' noop >code-address} にジャンプすることです(もちろん、
これは @code{next} コードを統合して適切にスケジュールするほど効率的ではありません)。  @code{ABI-CODE} を使用する場合は、
通常のサブルーチンの戻り値をアセンブルするだけです(ただし、 必ずデータ・スタック・ポインターを返すようにしてください)。

Gforth バージョン間のもう 1 つの違いは、 ほとんどのプラットフォームではスタックの最上位が @code{gforth} のメモリに保持され、
@code{gforth-fast} ではレジスタに保持されることです。  @code{ABI-CODE} 定義の場合、
スタック・キャッシュ・レジスタは必ずスタックにフラッシュされるため、 メモリ内のスタックの先頭に確実にアクセスできます。

@node Common Disassembler, 386 Assembler, Common Assembler, Assembler and Code Words
@subsection Common Disassembler
@cindex disassembler, general
@cindex gdb disassembler

@code{code} ワードは @code{see} で逆アセンブルできます(@pxref{Debugging})。
以下を使用してメモリのセクションを逆アセンブルできます

@findex discode ( @var{ addr u --   } ) gforth-0.2
@cindex @code{discode}
@kindex discode
@format
@code{discode} ( @i{addr u --  }) gforth-0.2 ``discode''
@end format
逆アセンブラのフック: addr から u バイトのコードを逆アセンブルします。



Gforth には 2 種類の逆アセンブラがあります。 Forth 逆アセンブラ(一部の CPU で利用可能) と gdb
逆アセンブラ(@command{gdb} および @command{mktemp} を備えたプラットフォームで利用可能)です。
両方が使用可能な場合は、 Forth 逆アセンブラがデフォルトで使用されます。  gdb 逆アセンブラを使いたい場合は、 以下のようにします

@example
' disasm-gdb is discode
@end example

どちらも使用できない場合は、@code{discode} が @code{dump} を実行します。

Forth 逆アセンブラは通常、 アセンブラに入力できる出力(つまり、同じ構文など)を生成します。 コメントには追加情報も含まれます。  特に、
命令のアドレスは命令の前のコメントで示されます。

gdb 逆アセンブラは、 デフォルトの形式(flavour)(386 および AMD64 アーキテクチャの AT&T 構文)で、 gdb
@code{disassemble} コマンドと同じ形式で出力を生成します(@pxref{Machine Code,,Source and
machine code,gdb,Debugging with GDB})。

@code{see} は、 コードの終わりの認識が信頼できないため、 ワードの実際のコードより多めに表示したり少なめに表示したりする場合があります。
十分に表示されない場合は、 @code{discode} を使用できます。  コード・ワードの直後に名前付きワードが続かない場合は、
さらに表示される可能性があります。  他に何かがある場合は、 ワードの後に @code{align latest ,} を付けると、
末尾が認識されるようになります。

@node 386 Assembler, AMD64 Assembler, Common Disassembler, Assembler and Code Words
@subsection 386 Assembler

Gforth に含まれる 386 アセンブラは Bernd Paysan によって書かれ、 GPL の下で入手可能で、 元々は bigFORTH
の一部でした。

Gforth に含まれる 386 逆アセンブラは Andrew McKewan によって作成され、 パブリック・ドメインです。

逆アセンブラは、 Intel のようなプレフィックス構文(Intel-like prefix syntax)でコードを表示します。

アセンブラは、 AT&T スタイルのパラメータ順序(つまり、宛先が最後;destination last)で後置構文(postfix
syntax)を使用します。

アセンブラには、 Athlon のすべての命令、 つまり 486 コア命令や、Pentium および PPro
拡張機能や、浮動小数点、MMX、3Dnow! が含まれていますが、 ISSE は含まれていません。 これは、16 ビットおよび 32
ビットの統合アセンブラです。デフォルトは 32 ビットですが、 @code{.86} で 16 ビットに切り替え、@code{.386} で 32
ビットに戻すことができます。

異なる操作サイズを切り替えるためのプレフィックスがいくつかあります。 バイト・アクセスの場合は @code{.b} 、 ワード・アクセスの場合は
@code{.w} 、 ダブルワード・アクセスの場合は @code{.d} です。 アドレッシング・モードは、 16 ビットアドレスの場合は
@code{.wa} 、32 ビットアドレスの場合は @code{.da} で切り替えることができます。 (@code{AL} など、
)バイト・レジスタ名のプレフィックスは必要ありません 。

浮動小数点演算の場合、 プレフィックスは @code{.fs} (IEEE single)、@code{.fl} (IEEE
double)、@code{.fx} (extended)、@code{.fw} (word)、 @code{.fd} (double-word)、
@code{.fq} (quad-word)。  デフォルトは @code{.fx} であるため、 Gforth FP 値を扱うときは
@code{.fl} を明示的に指定する必要があります。

MMX オペコードにはサイズのプレフィックスはなく、 Intel アセンブラと同じように記述されます。 メモリ間での移動の代わりに、 PLDQ/PLDD
と PSTQ/PSTD があります。

レジスタには「e」接頭辞がありません。 32 ビット モードでも、 eax は ax と呼ばれます。  即値は、@code{#}
を接尾辞として付けることによって示されます(例: @code{3 #})。  以下に、 さまざまな構文でのアドレス指定モードの例をいくつか示します:

@example
Gforth          Intel (NASM)   AT&T (gas)      Name
.w ax           ax             %ax             register (16 bit)
ax              eax            %eax            register (32 bit)
3 #             offset 3       $3              immediate
1000 #)         byte ptr 1000  1000            displacement
bx )            [ebx]          (%ebx)          base
100 di d)       100[edi]       100(%edi)       base+displacement
20 ax *4 i#)    20[eax*4]      20(,%eax,4)     (index*scale)+displacement
di ax *4 i)     [edi][eax*4]   (%edi,%eax,4)   base+(index*scale)
4 bx cx di)     4[ebx][ecx]    4(%ebx,%ecx)    base+index+displacement
12 sp ax *2 di) 12[esp][eax*2] 12(%esp,%eax,2) base+(index*scale)+displacement
@end example

@code{D)} と @code{DI)} の代わりに @code{L)} と @code{LI)} を使用して、32 ビット
displacement フィールドを強制できます(後のパッチ適用に役立ちます)。

いくつかの命令の例は以下のとおりです:

@example
ax bx mov             \ move ebx,eax
3 # ax mov            \ mov eax,3
100 di d) ax mov      \ mov eax,100[edi]
4 bx cx di) ax mov    \ mov eax,4[ebx][ecx]
.w ax bx mov          \ mov bx,ax
@end example

バイナリ命令では以下の形式がサポートされています:

@example
<reg> <reg> <inst>
<n> # <reg> <inst>
<mem> <reg> <inst>
<reg> <mem> <inst>
<n> # <mem> <inst>
@end example

シフト/ローテート の構文は以下のとおりです:

@example
<reg/mem> 1 # shl \ shortens to shift without immediate
<reg/mem> 4 # shl
<reg/mem> cl shl
@end example

バイト・バージョンを取得するには、 (@code{movs} などの)文字列命令(string instructions)の前に @code{.b}
を付けます。

制御構造ワードの @code{IF} や @code{UNTIL} などの前に、 次の条件のいずれかを指定する必要があります: @code{vs vc
u< u>= 0= 0<> u<= u> 0< 0>= ps pc < >= <= >} (注意: @code{code} ワードなど、 検索パス内で
@code{assembler} が @code{forth} の前にある場合、 これらのワードのほとんどは Forth
ワードの一部を隠してしまう事に注意してください)。  現在、 制御構造ワードは 1 つのスタック項目を使用しているため、 それらをいじるには
@code{cs-roll} の代わりに @code{roll} を使用する必要があります(@code{swap} などを使用することもできます)。

Intel ABI (Linux で使用)に基づいて、@code{abi-code} ワードは @code{4 sp d)}
でデータ・スタック・ポインターを見つけ、 @code{8 sp d)} で FP スタック・ポインターのアドレスを見つけることができます;
データ・スタック・ポインタは @code{ax} で返されます。 @code{Ax} や @code{cx} や @code{dx}
は呼び出し元で保存されるため、 ワード内に値を保存する必要はありません。  @code{ret} を使用してワードから戻ることができます。
パラメータは呼び出し元によってクリーンアップされます。

386 の @code{abi-code} ワードの例については、 @ref{Assembler Definitions}


@node AMD64 Assembler, Alpha Assembler, 386 Assembler, Assembler and Code Words
@subsection AMD64 (x86_64) Assembler

AMD64 アセンブラは、 386 アセンブラをわずかに変更したバージョンであり、 構文の大部分を共有しています。  2 つの新しい接頭辞
@code{.q} と @code{.qa} が、 それぞれ 64 ビット・サイズのオペランドやアドレスを選択するために提供されています。  64
ビット・サイズがデフォルトであるため、 通常は他のプレフィックスを使用するだけで済みます。  また、 追加のレジスタ・オペランド @code{R8} ～
@code{R15} もあります。

レジスタには「e」または「r」プレフィックスがありません。 64 ビット・モードでも、 @code{rax} は @code{ax} と呼ばれます。
すべてのレジスタで最下位バイトを参照するために追加のレジスタ・オペランドを使用できます: @code{R8L} 〜 -@code{R15L},
@code{SPL},  @code{BPL},  @code{SIL},  @code{DIL}

@c source: https://en.wikipedia.org/wiki/X86_calling_conventions#AMD64_ABI_convention
Linux-AMD64 の呼び出し規則では、 最初の 6 つの整数パラメーターを rdi, rsi, rdx, rcx, r8, r9 で渡し、 結果を
rax , rdx で返します。 最初の 8 つの FP パラメータを xmm0 ～ xmm7 に渡し、 FP 結果を xmm0 ～ xmm1
に返します。  したがって、@code{abi-code} ワードは、 @code{di} でデータ・スタック・ポインタを取得し、 @code{si}
で FP スタック・ポインタのアドレスを取得し、 リターン時は @code{ax} にデータ・スタック ポインタをセットします。
呼び出し元が保存する他のレジスタは、 r10, r11 xmm8 ～ xmm15 です。 この呼び出し規約は、 Microsoft 以外の他の OS
でも使用されていると報告されています。

@c source: http://msdn.microsoft.com/en-us/library/9b372w95(v=VS.90).aspx
Windows x64 は、 最初の 4 つの整数パラメータを rcx, rdx, r8, r9 に渡し、 整数の結果を rax に返します。
他の、呼び出し元保存レジスタは r10 と r11 です。

@url{https://uclibc.org/docs/psABI-x86_64.pdf} の  21ページによると、 Linux
プラットフォームでは、 レジスタ AX CX DX SI DI R8 R9 R10 R11 が自由(scratch)に使えます。

AMD64 のアドレッシング・モードは以下のとおりです:

@example
\ ご注意: ワード A を実行すると、レジスタが初期化されていないため、 メモリ・エラーが発生します ;-)
ABI-CODE A  ( -- )
    500        #               AX  MOV     \ immediate
        DX              AX  MOV     \ register
        200             AX  MOV     \ direct addressing
        DX  )           AX  MOV     \ indirect addressing
    40  DX  D)          AX  MOV     \ base with displacement
        DX  CX      I)  AX  MOV     \ scaled index
        DX  CX  *4  I)  AX  MOV     \ scaled index
    40  DX  CX  *4  DI) AX  MOV     \ scaled index with displacement

        DI              AX  MOV     \ SP Out := SP in
                            RET
END-CODE
@end example

AMD64 @code{abi-code} ワードの例をいくつか示します:

@example
abi-code my+  ( n1 n2 -- n3 )
\ SP passed in di, returned in ax,  address of FP passed in si
8 di d) ax lea        \ compute new sp in result reg ( 結果として di+8 → ax つまり drop と同じ)
di )    dx mov        \ get old tos ( [di] つまり n2   → dx )
dx    ax ) add        \ add to new tos ( dx + [ax] → [ax]
ret
end-code
@end example

@example
\ Do nothing
ABI-CODE aNOP  ( -- )
       DI  )       AX      LEA          \ SP out := SP in  
                           RET
END-CODE
@end example


@example
\ Drop TOS
ABI-CODE aDROP  ( n -- )
   8   DI  D)      AX      LEA          \ SPout := SPin - 1
                           RET
END-CODE
@end example


@example
\ Push 5 on the data stack
ABI-CODE aFIVE   ( -- 5 )
   -8  DI  D)      AX      LEA          \ SPout := SPin + 1
   5   #           AX  )   MOV          \ TOS := 5
                           RET
END-CODE
@end example


@example
\ Push 10 and 20 into data stack
ABI-CODE aTOS2  ( -- n n )
   -16 DI  D)      AX      LEA          \ SPout := SPin + 2
   10  #       8   AX  D)  MOV          \ TOS - 1 := 10
   20  #           AX  )   MOV          \ TOS := 20
                           RET
END-CODE
@end example


@example
\ Get Time Stamp Counter as two 32 bit integers
\ The TSC is incremented every CPU clock pulse
ABI-CODE aRDTSC   ( -- TSCl TSCh )
                           RDTSC        \ DX:AX := TSC
   $FFFFFFFF #     AX      AND          \ Clear upper 32 bit AX
  0xFFFFFFFF #     DX      AND          \ Clear upper 32 bit DX
       AX          R8      MOV          \ Tempory save AX
   -16 DI  D)      AX      LEA          \ SPout := SPin + 2
       R8      8   AX  D)  MOV          \ TOS-1 := saved AX = TSC low
       DX          AX  )   MOV          \ TOS := Dx = TSC high
                           RET
END-CODE
@end example


@example
\ Get Time Stamp Counter as 64 bit integer
ABI-CODE RDTSC   ( -- TSC )
                           RDTSC        \ DX:AX := TSC
   $FFFFFFFF #     AX      AND          \ Clear upper 32 bit AX
   32  #           DX      SHL          \ Move lower 32 bit DX to upper 32 bit
       AX          DX      OR           \ Combine AX wit DX in DX
   -8  DI  D)      AX      LEA          \ SPout := SPin + 1
       DX          AX  )   MOV          \ TOS := DX
                           RET
END-CODE
@end example


@example
VARIABLE V

\ Assign 4 to variable V
ABI-CODE V=4 ( -- )
       BX                  PUSH         \ Save BX, used by gforth
   V   #           BX      MOV          \ BX := address of V
   4   #           BX )    MOV          \ Write 4 to V
       BX                  POP          \ Restore BX
       DI  )       AX      LEA          \ SPout := SPin
                           RET
END-CODE
@end example


@example
VARIABLE V

\ Assign 5 to variable V
ABI-CODE V=5 ( -- )
   V   #           CX      MOV          \ CX := address of V
   5   #           CX )    MOV          \ Write 5 to V
   DI )            AX      LEA          \ SPout := SPin
                           RET
END-CODE
@end example


@example
ABI-CODE TEST2  ( -- n n )
   -16 DI  D)  AX          LEA          \ SPout := SPin + 2
   5   #       CX          MOV          \ CX := 5
   5   #       CX          CMP
   0= IF
       1   #   8   AX  D)      MOV      \ If CX = 5 then TOS - 1 := 1  <--
   ELSE
       2   #   8   AX  D)      MOV      \ else TOS - 1 := 2
   THEN
   6   #       CX          CMP
   0= IF
       3   #       AX  )       MOV      \ If CX = 6 then TOS := 3
   ELSE
       4   #       AX  )       MOV      \ else TOS := 4  <--
   THEN
                           RET
END-CODE
@end example


@example
\ Do four loops. Expect : ( 4 3 2 1 -- )
ABI-CODE LOOP4  ( -- n n n n )
       DI          AX      MOV          \ SPout := SPin
   4   #           DX      MOV          \ DX := 4  loop counter
   BEGIN
       8   #           AX      SUB      \ SP := SP + 1
           DX          AX  )   MOV      \ TOS := DX
       1   #           DX      SUB      \ DX := DX - 1
   0= UNTIL
                           RET
END-CODE
@end example

以下は、FP 値を扱う AMD64 用の例です:

@example
abi-code my-f+  ( r1 r2 -- r )
\ SP passed in di, returned in ax,  address of FP passed in si
si )       dx mov         \ load fp
8 dx d)  xmm0 movsd       \ r2
dx )     xmm0 addsd       \ r1+r2
xmm0  8 dx d) movsd       \ store r
8 #      si ) add         \ update fp
di         ax mov         \ sp into return reg
ret
end-code
@end example

@node Alpha Assembler, MIPS assembler, AMD64 Assembler, Assembler and Code Words
@subsection Alpha Assembler

Alpha アセンブラと逆アセンブラは、もともとは Bernd Thallner によって書かれました。

レジスタ名 @code{a0}〜@code{a5} は、 16 進数を隠してしまう(shadowing)のを避けるために使用できません。

算術命令の即時形式は、 @code{,} の直前の @code{#} によって区別されます(例: @code{and#,})(注:
@code{lda,} は算術命令としてカウントされません)。

他のアセンブラがオプションとみなすオペランドも含めて、 命令にすべてのオペランドを指定する必要があります。 たとえば、@code{br,}
の宛先レジスタ、 または @code{jmp,} の宛先レジスタとヒントです。

@code{if,} の条件を指定するには、 対応する名前のブランチから最初の @code{b} と末尾の @code{,} を削除します。
たとえば、以下のようにします:

@example
11 fgt if, \ if F11>0e
  ...
endif,
@end example

@code{fbgt,} は @code{fgt} になります。  

@node MIPS assembler, PowerPC assembler, Alpha Assembler, Assembler and Code Words
@subsection MIPS assembler

MIPS アセンブラは、もともとは Christian Pirker によって書かれました。

現在、 アセンブラと逆アセンブラは MIPS32 アーキテクチャの大部分をカバーしていますが、 FP 命令はサポートしていません。

レジスタ名 @code{$a0}〜@code{$a3} は、 16 進数を隠してしまう(shadowing)のを避けるために使用できません。
代わりにレジスタ番号 @code{$4}〜@code{$7} を使用してください。

レジスタと即値を区別するものはありません。  即値引数を持つ命令には、 @code{i} 接尾辞を付けた明示的なオペコード名を使用します。  例えば。
@code{addu,} の代わりに @code{addiu,} です。

アーキテクチャ・マニュアルで命令の形式が複数指定されている場合(例: @code{jalr,}
の場合)、より多くの引数を持つ形式(つまり、@code{jalr,} の場合は 2 つ)を使用してください。  疑問がある場合は、 正しい使用例について
@code{arch/mips/testasm.fs} を参照してください。

MIPS アーキテクチャの分岐とジャンプには遅延スロット(delay slot)があります。  手動で入力する必要があります(最も簡単な方法は
@code{nop,} を使用することです)。 アセンブラは(@command{as} とは異なり)自動的に入力しません。 @code{if,},
@code{ahead,}, @code{until,}, @code{again,}, @code{while,}, @code{else,},
@code{repeat,} でも遅延スロットが必要です。 @code{begin,} と @code{then,}
は分岐ターゲットを指定するだけなので影響を受けません。  ブランチの場合、 ターゲットを指定する引数は相対アドレスです。
遅延スロットのアドレスを追加して絶対アドレスを取得します。

注意: 遅延スロットに分岐やジャンプ(または制御フロー命令)を入れてはいけないことに注意してください。  また、@code{li,}
などの疑似演算を遅延スロットに入れることは、 複数の命令に拡張される可能性があるため、お勧めできません。  MIPS I
アーキテクチャにもロード遅延スロットがあり、 新しい MIPS では依然として @code{mfhi,} および @code{mflo,}
の使用に制限があります。  これらの制限を満たすように注意してください。 アセンブラが自動的に制限を満たしてくれるわけではありません。

いくつかの命令の例は以下のとおりです:

@example
$ra  12 $sp  sw,         \ sw    ra,12(sp)
$4    8 $s0  lw,         \ lw    a0,8(s0)
$v0  $0  lui,            \ lui   v0,0x0
$s0  $s4  $12  addiu,    \ addiu s0,s4,0x12
$s0  $s4  $4  addu,      \ addu  s0,s4,$a0
$ra  $t9  jalr,          \ jalr  t9
@end example

@code{if,} などの条件を指定するには、 条件分岐を実行し、 先頭の @code{b} と末尾の @code{,} を省略します。
例えば以下のようにします:

@example
4 5 eq if,
  ... \ do something if $4 equals $5
then,
@end example

32 ビット MIPS マシンの呼び出し規則では、 最初の 4 つの引数をレジスタ @code{$4}〜@code{$7} に渡し、 戻り値に
@code{$v0}〜@code{$v1} を使用します。 これらのレジスタに加えて、 レジスタ @code{$t0} ～ @code{$t8}
は保存・復元せずに上書きしても問題ありません。

@code{jalr,} を使用してダイナミック・ライブラリ・ルーチンを呼び出す場合は、 最初に呼び出される関数のアドレスを @code{$t9}
にロードする必要があります。 これは、 相対メモリ・アクセスを行うために位置間接コード(position-indirect
code)によって使用されます。

MIPS32 @code{abi-code} ワードの例を以下に示します:

@example
abi-code my+  ( n1 n2 -- n3 )
  \ SP passed in $4, returned in $v0
  $t0  4 $4  lw,         \ load n1, n2 from stack
  $t1  0 $4  lw,    
  $t0  $t0  $t1  addu,   \ add n1+n2, result in $t0
  $t0  4 $4  sw,         \ store result (overwriting n1)
  $ra  jr,               \ return to caller
  $v0  $4  4  addiu,     \ (delay slot) return uptated SP in $v0
end-code
@end example

@node PowerPC assembler, ARM Assembler, MIPS assembler, Assembler and Code Words
@subsection PowerPC assembler

PowerPC アセンブラと逆アセンブラは、 Michal Revucky の貢献に依ります。

このアセンブラは、 ニーモニック名を「,」で終了する規則に従っていないため、 一部のニーモニック名は通常の Forth ワード (特に:
@code{and or xor fabs}) を隠し(shadow)ます。 そのため、 Forth ワードを使用したい場合は、 最初に、 たとえば
@code{ also forward} を使用して、 Forth ワードを表示できるようにする必要があります。

レジスタは番号によって参照されます。 たとえば、@code{9} は、 (命令に応じて、)整数レジスタ 9 または FP レジスタ 9  を意味します。

レジスタと即値を区別する方法がないため、 @code{add,} だけでなく @code{add,}
などの即値用の命令を明示的に使用する必要があります。

アセンブラと逆アセンブラは通常、 最も一般的な形式の命令をサポートしますが、 通常は短い形式(特に分岐)はサポートしません。


@node ARM Assembler, Other assemblers, PowerPC assembler, Assembler and Code Words
@subsection ARM Assembler

ARM アセンブラには、 ARM アーキテクチャ・バージョン 4 のすべての命令と、 アーキテクチャ・バージョン 5 の BLX 命令が含まれています。
Thumb 命令は (まだ) サポートされていません。  また、 コ・プロセッサーもサポートされていません。

アセンブラは、 「ARM Architecture Reference
Manual」で使用されているのと同じオペランド順序を持つ後置構文(postfix syntax)を使用します。
ニーモニックにはカンマが付けられます。

レジスタは @code{r0}〜@code{r15} までの名前で指定され、別名は @code{pc}, @code{lr}, @code{sp},
@code{ip}, @code{fp} で、これらは利便性のために提供されています。  @code{ip}
は「プロシージャ内呼び出しスクラッチ・レジスタ」(intra procedure call scratch register)(注意:
@code{r12}) を指し、 命令ポインタを指すわけではないことに注意してください。  @code{sp} は、 Forth
のスタック・ポインターではなく、 ARM ABI スタック・ポインター (@code{r13}) を指します。

条件コードは命令内のどこにでも指定できますが、 ニーモニックの直前に指定すると最も読みやすくなります。  「S」フラグは別個のワードではなく、
命令ニーモニックにエンコードされます。 ステータス・レジスタを更新したい場合は、 @code{add,} の代わりに @code{adds,}
を使用してください。

以下の表に、 一般的な命令のオペランドの構文を示します:

@example
Gforth          normal assembler      description
123 #           #123                  immediate
r12             r12                   register
r12 4 #LSL      r12, LSL #4           shift left by immediate
r12 r1 LSL      r12, LSL r1           shift left by register
r12 4 #LSR      r12, LSR #4           shift right by immediate
r12 r1 LSR      r12, LSR r1           shift right by register
r12 4 #ASR      r12, ASR #4           arithmetic shift right
r12 r1 ASR      r12, ASR r1           ... by register
r12 4 #ROR      r12, ROR #4           rotate right by immediate
r12 r1 ROR      r12, ROR r1           ... by register
r12 RRX         r12, RRX              rotate right with extend by 1
@end example

メモリ・オペランドの構文を以下の表に示します:

@example
Gforth            normal assembler      description
r4 ]              [r4]                  register
r4 4 #]           [r4, #+4]             register with immediate offset
r4 -4 #]          [r4, #-4]             with negative offset
r4 r1 +]          [r4, +r1]             register with register offset
r4 r1 -]          [r4, -r1]             with negated register offset
r4 r1 2 #LSL -]   [r4, -r1, LSL #2]     with negated and shifted offset
r4 4 #]!          [r4, #+4]!            immediate preincrement
r4 r1 +]!         [r4, +r1]!            register preincrement
r4 r1 -]!         [r4, +r1]!            register predecrement
r4 r1 2 #LSL +]!  [r4, +r1, LSL #2]!    shifted preincrement
r4 -4 ]#          [r4], #-4             immediate postdecrement
r4 r1 ]+          [r4], r1              register postincrement
r4 r1 ]-          [r4], -r1             register postdecrement
r4 r1 2 #LSL ]-   [r4], -r1, LSL #2     shifted postdecrement
' xyz >body [#]   xyz                   PC-relative addressing
@end example

複数のロード/ストア命令のレジスタ・リストは、 それぞれ @code{@{} および @code{@}} というワードを使用して開始および終了します。
@code{@{} 〜 @code{@}}  の間に、 レジスタ名を 1 つずつリストすることも、 後置演算子 @code{r-r}
を使用してレジスタ範囲を形成することもできます。  @code{^} フラグはレジスタ・リスト・オペランドではエンコードされませんが、
命令ニーモニックに直接エンコードされます。 つまり、 @code{^ldm,} と @code{^stm,} を使用します。

複数のロード/ストアのアドレッシング・モードは命令接尾辞としてエンコードされず、 代わりにアドレッシング・モードのように指定されます。
@code{DA}, @code{IA}, @code{DB}, @code{IB}, @code{DA!}, @code{IA!},
@code{DB!}, @code{IB!} のいずれかを使います。

以下の表にいくつかの例を示します:

@example
Gforth                           normal assembler
r4 ia  @{ r0 r7 r8 @}  stm,        stmia    r4, @{r0,r7,r8@}
r4 db!  @{ r0 r7 r8 @}  ldm,       ldmdb    r4!, @{r0,r7,r8@}
sp ia!  @{ r0 r15 r-r @}  ^ldm,    ldmfd    sp!, @{r0-r15@}^
@end example

Forth アセンブラに典型的な制御構造ワードが利用可能です: @code{if,}, @code{ahead,}, @code{then,},
@code{else,}, @code{begin,}, @code{until,}, @code{again,}, @code{while,},
@code{repeat,}, @code{repeat-until,} 。 条件は以下のワードの前に指定します:

@example
r1 r2 cmp,    \ compare r1 and r2
eq if,        \ equal?
   ...          \ code executed if r1 == r2
then,
@end example

ARM アセンブラを使用した定義の例:

@example
abi-code my+ ( n1 n2 --  n3 )
   \ arm abi: r0=SP, r1=&FP, r2,r3,r12 saved by caller
   r0 IA!  @{ r2 r3 @}  ldm,     \ pop r2 = n2, r3 = n1
   r3  r2  r3         add,     \ r3 = n1+n1
   r3  r0 -4 #]!      str,     \ push r3
   pc  lr             mov,     \ return to caller, new SP in r0
end-code
@end example

@c !! ARM64
@c !! RISC-V

@node Other assemblers, , ARM Assembler, Assembler and Code Words
@subsection Other assemblers

別のアセンブラ/逆アセンブラを提供したい場合は、
そのようなアセンブラがすでに存在するかどうかを確認するために著者達(@email{anton@@mips.complang.tuwien.ac.at})までご連絡ください。
これらを最初から作成する場合は、 著者たちが使用しているものと同様の構文スタイルを使用してください(つまり、 後置や命令名の末尾のカンマ
@pxref{Common Assembler})。 逆アセンブラの出力をアセンブラの有効な入力にし、使用したスタイルと同様のスタイルを維持します。

実装に関するヒント: 最も重要なのは、 すべての手順を含む優れたテスト・スイートを用意することです。  それができたら、 あとは簡単です。
実際のコーディングについては、 @file{arch/mips/disasm.fs} を参照して、 アセンブラと逆アセンブラの両方でデータを使用し、
冗長性や潜在的なバグを回避する方法についてアイデアを得ることができます。  また、そのファイル (および @pxref{Advanced does>
usage example}) を見て、 逆アセンブラーをファクタリングする方法のアイデアを得ることができます。

逆アセンブラから始めます。 逆アセンブラからのデータをアセンブラで再利用する方が、 その逆よりも簡単だからです。

アセンブラについては、 @file{arch/alpha/asm.fs} を見てください。 これがいかに簡単であるかを示しています。




@c -------------------------------------------------------------
@node Carnal words, Passing Commands to the OS, Assembler and Code Words, Words
@section Carnal words

これらのワードは Gforth の仕組み(Forth サークルでは Forth システムの「肉体的知識」(carnal
knowledge)と呼ばれる)を扱っていますが、 著者等は文書化するに当たって、 これらが十分安定(stable)していると考えています。

@menu
* Header fields::
* Header methods::
* Threading Words::          
@end menu

@node Header fields, Header methods, Carnal words, Carnal words
@subsection Header fields
@cindex header fields

Gforth 1.0 では、 新しいワード・ヘッダー・レイアウトに切り替えられました。  詳細な説明については、 Bernd Paysan and
M. Anton Ertl.
@cite{@uref{http://www.euroforth.org/ef19/papers/paysan.pdf,The new Gforth
header}} を参照してください。  この論文の公開以後に、xt と nt
は本体(body)のようにパラメーター・フィールドを指すように変更されましたが、 それ以外は依然としてこの文献が最新です。

このセクションでは、 データ構造とそれにアクセスするために使用されるワードについてのみ説明します。  ヘッダーには以下のフィールドがあります:

@example
name
>f+c
>link
>cfa
>namehm
>body
@end example

現在、 Gforth には xt/nt/body から各フィールドに到達するために上に示した名前がありますが、 標準の @code{>body}
を除けば、 これらは定着した Gforth ワードではありません。  これらの代わりアクセス用ワードを提供しています。
注意:文書化されたアクセス・ワードはヘッダー・レイアウトの再編成後も生き残ることに注意してください。

ワードの中には nt を期待するものもあれば、 xt を期待するものもあります。  nt と xt が両方ともワードの本体を指しているとすると、
その違いは何でしょうか？ ほとんどのワードでは、xt と nt は同一ヘッダーを使用するので、 nt=xt となり、 同じ場所を指します。  ただし、
同義語(synonym)(@pxref{Aliases})では違いがあります。 以下の例で考えてみましょう

@example
create x
synonym y x
synonym z y
@end example

この場合、@code{z} の nt は @code{z} の本体を指し、 @code{z} の xt は @code{x} の本体を指します。
@code{alias} または @code{forward} (@pxref{Forward}) で定義されたワードも、 nt と異なる xt
を持ちます。

名前フィールドは可変長で、 @code{name>string} (@pxref{Name token}) でアクセスします。

@code{>f+c} フィールドには、フラグと名前の長さ(カウント)が含まれます。 @code{name>string} でカウントを読み取り、
以下でフラグを読み取ります。

@findex compile-only? ( @var{ nt -- flag   } ) gforth-1.0
@cindex @code{compile-only?}
@kindex compile-only?
@format
@code{compile-only?} ( @i{nt -- flag  }) gforth-1.0 ``compile-only?''
@end format
@i{nt} がコンパイル専用(compile-only)としてマークされている場合は true 。



@code{>link} フィールドには、 同じワードリスト内の前のワードへのリンクが含まれます。  @code{name>link}
(@pxref{Name token}) で読み取ることができます。

name と @code{>f+c} と @code{>link} フィールドは @code{noname} ワードには存在しませんが、 それでも
@code{name>string} と @code{name>link} は機能し、 @code{name>string} は 0 0 を返し、
@code{name>link} は 0 を返します。

@code{>cfa} フィールド(別名 コード・フィールド) には、 ワードを @code{execute}
するために使用されるコード・アドレスが含まれます。  @code{>code-address} で読み取り、 @code{code-address!}
(@pxref{Threading Words}) で書き込むことができます。

@code{>namehm} フィールドには、 後述するするヘッダー・メソッド・テーブルのアドレスが含まれます。  これにアクセスするには、
ヘッダー・メソッド (@pxref{Header methods}) を実行するか、または、 ヘッダー・メソッドにアクセスします。

@code{>body} (別名 パラメーター・フィールド)には、 ワードの種類に固有のデータまたはスレッド化コードが含まれます。
その長さはワードの種類によって異なります。  たとえば、 @code{constant} の場合、 定数の値を含むセルが含まれます。
@code{>body} (@pxref{CREATE..DOES> details}) を通じてアクセスできますが、 これは標準の
@code{create} で定義したワードのみです。

@node Header methods, Threading Words, Header fields, Carnal words
@subsection Header methods
@cindex header methods

新しい Gforth ワード・ヘッダーはオブジェクト指向であり、 以下のメソッド(メソッド・セレクター)をサポートします:

@example
.hm label method          overrider        field
          execute         set-execute      >cfa
opt:      opt-compile,    set-optimizer    >hmcompile,
to:       (to)            set-to           >hmto
extra:                                     >hmextra
>int:     name>interpret  set->int         >hm>int
>comp:    name>compile    set->comp        >hm>comp
>string:  name>string     set-name>string  >hm>string
>link:    name>link       set-name>link    >hm>link
@end example

これらのワードの多くは定着(stable)した Gforth ワードではありませんが、 Gforth には後述する定着した高レベルのワードがあります。

以下を使用すると、 ワードのヘッダー・メソッドを確認できます

@findex .hm ( @var{ nt --   } ) gforth-1.0
@cindex @code{.hm}
@kindex .hm
@format
@code{.hm} ( @i{nt --  }) gforth-1.0 ``dot-h-m''
@end format
@i{nt} のヘッダー・メソッドを出力します



オーバーライダー(overrider)(セッター)ワードは、 最新の定義のメソッド実装を変更します。  クォーテーションまたはクロージャーは、
完了時に以前の最新の定義を復元するため、 最新のものとはみなされず、 以下のようなことができます:

@example
: my2dup over over ;
[: drop ]] over over [[ ;] set-optimizer
@end example

@code{execute} メソッドは、 パフォーマンス上の理由から、 実際にはヘッダー・メソッド・テーブルではなくヘッダーの @code{>cfa}
フィールドに格納されます。 また、 他のメソッドは xt を呼び出すことによって実装されますが、 ネイティブ・コード・アドレスを通じて実装されます。
このメソッドを設定する大まかな方法​​は以下のとおりです

@findex set-execute ( @var{ ca --   } ) gforth-1.0
@cindex @code{set-execute}
@kindex set-execute
@format
@code{set-execute} ( @i{ca --  }) gforth-1.0 ``set-execute''
@end format
@i{ca} のネイティブ・コードにジャンプするように現在のワードを変更します。  また、 @code{compile,}
実装を最も一般的な(そして最も遅い)実装に変更します。  より効率的な @code{compile,} 実装が必要な場合は、 後で
@code{set-optimizer} を呼び出します。



@code{set-execute} で使用するコード・アドレスを取得するには、 @code{docol:} または
@code{>code-address} などのワードを使用できます。 @xref{Threading Words}

@code{set-execute} の代わりに、 xt を受け取る @code{set-does>} (@pxref{User-defined
Defining Words})もあります。

さらに、 低レベルの @code{code-address!} と @code{definer!} があります。 (@pxref{Threading
Words})

@code{opt-compile,} メソッドは、 ほとんどの Gforth エンジンで動く @code{compile,}
です(@code{gforth-itc} は代わりに @code{,} を使用します)。  @code{set-optimizer} を使用して、
現在のワードに対する @code{compile,} のより効率的な実装を定義できます((@pxref{User-defined
compile-comma}))。 注意: 最終結果は @code{postpone literal postpone execute}
と同等でなければならないことに注意してください。

@code{set-optimizer} の使用例として、 以下の @code{constant} の定義を考えてみましょう:

@example
: constant ( n "name" -- ; name: -- n )
  create ,
  ['] @@ set-does>
;

5 constant five
: foo five ; see foo
@end example

Forth システムは、 定数の値を変更してはならないことを認識せず、 単に @code{create} されたワード (@code{>body}
で変更可能)として見て、 @code{foo} は最初に @code{five} のボティのアドレスをスタックにプッシュし、
その次にそこから値を取得します。 @code{set-optimizer} を使用すると、 @code{constant}
の定義を以下のように最適化できます:

@example
: constant ( n "name" -- ; name: -- n )
  create ,
  ['] @@ set-does>
  [: >body @@ postpone literal ;] set-optimizer
;
@end example

いまや、 @code{foo} には、 @code{five} の呼び出しではなく、 即値(literal)の 5 が含まれるようになりました。

注意: @code{set-execute} と @code{set-does>} は、@code{execute} と @code{compile,}
が一致していることを確認するために、 @code{set-optimizer} 自体を実行することに注意してください。
あなた独自のオプティマイザーを追加するには、 後で追加する必要があります。

@code{defer!} (別名 @code{(to)} メソッド(@pxref{User-defined TO and DEFER@@})は、
@code{defer} で定義されたワードおよび類似のワードに対して @code{defer!} を実装します。 ですが、 これは @code{to}
の核心(core)でもあります。 @code{defer!}/@code{(to)} メソッドの一般的なスタック効果は @code{( val xt
-- )} です。 ここで @i{xt} は格納されているワードを示し、 @i{val} はそこに格納されている(適切な型の)値です。

たとえば、 以下のように @code{fvalue} を実装できます:

@example
: fvalue-to ( r xt -- ) >body f! ;

: fvalue ( r -- )
  create f,
  ['] f@@ set-does>
  ['] fvalue-to set-to ;

5e fvalue foo
: bar foo 1e f+ to foo ;
see bar
@end example

@code{set-optimizer} を使用して、 生成されたコードを改善できます:

@example
: compile-fvalue-to ( xt-value-to -- )
  drop ]] >body f! [[ ;
  
: fvalue-to ( r xt -- ) >body f! ;
' compile-fvalue-to set-optimizer

: fvalue ( r -- )
  create f,
  ['] f@@ set-does>
  [: >body ]] literal f@@ [[ ;] set-optimizer
  ['] fvalue-to set-to ;

5e fvalue foo
: bar foo 1e f+ to foo ;
see bar
@end example

実際には、 Gforth には、 @code{+TO} など、 実装するための追加の工夫がいくつかあります。

@code{Set-defer@@} (@pxref{User-defined TO and DEFER@@}) を使用すると、
@code{defer} のようなワードに対して @code{defer@@} (@pxref{Deferred Words})
メソッドのバリエーションを実装できます。

@code{>hmextra} フィールドは、 追加のデータをヘッダー・メソッド・テーブルに保存する必要がある場合に使用されます。  特に、 それは
@code{set-does>} に渡す xt を保存し(そして @code{does>} は @code{set-does>} を呼び出し)、
そして、 @code{;abi-code} の後のコードのアドレスを保存します。

これらのメソッドはすべて、 nt ではなく xt を使用しますが、 オーバーライド・ワード(override words)は最新の定義で機能します。
これは、 たとえば、 同義語(synonym)に対して @code{set-optimizer} を使用した場合、
その効果はおそらくあなたが意図したものとは異なることを意味します。 ワードの xt を @code{compile,} する場合、
新たに設定された同義語(synonym)ではなく、 元のワードの @code{opt-compile,} 実装が使用されます。

以下のメソッド達は nt を消費します。

@code{name>interpret} メソッドは、 同義語(synonym)や類似のワードを除くほとんどのワードに対して noop
として実装されます。

@findex set->int ( @var{ xt --   } ) gforth-1.0
@cindex @code{set->int}
@kindex set->int
@format
@code{set->int} ( @i{xt --  }) gforth-1.0 ``set-to-int''
@end format
現在のワードの @code{name>interpret (nt -- xt2 )} メソッドの実装を @i{xt} に設定します。



@code{name>compile} メソッドは、 nt のコンパイル機能(compilation semantics)を生成します。
@code{set->comp} で変更することでコンパイル機能を変更できますが、 @code{name>compile} のスタック効果のため、
目的のコンパイル機能の xt をプッシュするだけというほど単純ではありません。  一般に、 コンパイル機能の変更は避ける必要があり、 変更する場合は、
@code{immediate} または @code{interpret/compile:}
などの高レベル・ワードを使用してください(@xref{Combined words})。

@findex set->comp ( @var{ xt --   } ) gforth-1.0
@cindex @code{set->comp}
@kindex set->comp
@format
@code{set->comp} ( @i{xt --  }) gforth-1.0 ``set-to-comp''
@end format
現在のワードの @code{name>compile ( nt -- w xt2 )} メソッドの実装を @i{xt} に設定します。


@findex immediate? ( @var{ nt -- flag   } ) gforth-1.0
@cindex @code{immediate?}
@kindex immediate?
@format
@code{immediate?} ( @i{nt -- flag  }) gforth-1.0 ``immediate?''
@end format
ワード @i{nt} がデフォルト以外のコンパイル機能(compilation semantics)を持っている場合は true
(これは即時性(immediacy)の定義と完全には一致しませんが、
多くの人はワード語を「即時」(immediate)と呼ぶときはこれを意味しています)。



@code{Name>string} および @code{Name>link} は、 noname ヘッダーから  name と @code{>f+c}
と @code{link} フィールドを削除できるようにするためのメソッドです。 これらのワードを使用すると意味のある結果が得られます。  通常、
@code{noname} を使用する場合を除き、 これらのメソッドの実装を変更することはありませんが、
あなたがそれでも必要とするなら以下をご覧ください

@findex set-name>string ( @var{ xt --   } ) gforth-1.0
@cindex @code{set-name>string}
@kindex set-name>string
@format
@code{set-name>string} ( @i{xt --  }) gforth-1.0 ``set-name-to-string''
@end format
現在のワードの @code{name>string ( nt -- addr u )} メソッドの実装を @i{xt} に設定します。


@findex set-name>link ( @var{ xt --   } ) gforth-1.0
@cindex @code{set-name>link}
@kindex set-name>link
@format
@code{set-name>link} ( @i{xt --  }) gforth-1.0 ``set-name-to-link''
@end format
現在のワードの @code{name>link (nt1 -- nt2|0 )} メソッドの実装を @i{xt} に設定します。



@node Threading Words, , Header methods, Carnal words
@subsection Threading Words
@cindex threading words

@cindex code field
@cindex CFA
@cindex code address
ここで使用される用語は、 間接スレッド Forth システム(indirect threaded Forth systems)に由来しています。
間接スレッド Forth システムでは、 ワードの XT はワードの CFA (コード・フィールド・アドレス) によって表されます。 CFA は、
コード・アドレスを含むセルを指します。  コード・アドレスは、 ワードを呼び出すj実行時のアクションを実行するマシン・コードのアドレスです(たとえば、
@code{dovar:} ルーチンは、 ワード(変数)の本体のアドレスをスタックにプッシュします)。

以下のワード群は、 Gforth のコード・フィールドやコード・アドレスやその他のスレッド機能へのアクセスを提供します。
これにより、直接スレッドと間接スレッドの違いは、 多かれ少なかれ抽象化されます。

Gforth 0.7 までは、 ワードの種類を知るのに、 コード・アドレス(さらに、 @code{does>} で定義されたワードの場合は、
@code{>does-code} によって返されるアドレス)で十分でした。  ただし、 Gforth-1.0 以降、 少なくとも、
@code{compile,} や @code{name>compile} のようなワードの振る舞いや実装は、 @ref{Header methods}
で説明されているように独立して決定できます。

以下のワード達は、 コード・フィールドを作成し、 そして、 同時にヘッダー・メソッドを初期化します:

@findex hmcopy, ( @var{ xt --   } ) gforth-experimental
@cindex @code{hmcopy,}
@kindex hmcopy,
@format
@code{hmcopy,} ( @i{xt --  }) gforth-experimental ``hmcopy-comma''
@end format
ヘッダーの構築中に、 コード・フィールドを割り当て、 コード・フィールドとヘッダー・メソッドを設定するためのプロトタイプとして @i{xt}
を使用します。


@findex docol, ( @var{ --   } ) gforth-1.0
@cindex @code{docol,}
@kindex docol,
@format
@code{docol,} ( @i{--  }) gforth-1.0 ``docol,''
@end format
コロン定義のコード・アドレスを書き込む。


@findex docon, ( @var{ --   } ) gforth-1.0
@cindex @code{docon,}
@kindex docon,
@format
@code{docon,} ( @i{--  }) gforth-1.0 ``docon,''
@end format
@code{CONSTANT} のコード・アドレスを書き込む。


@findex dovar, ( @var{ --   } ) gforth-1.0
@cindex @code{dovar,}
@kindex dovar,
@format
@code{dovar,} ( @i{--  }) gforth-1.0 ``dovar,''
@end format
@code{CREATE} されたワードのコード・アドレスを書き込む。


@findex douser, ( @var{ --   } ) gforth-1.0
@cindex @code{douser,}
@kindex douser,
@format
@code{douser,} ( @i{--  }) gforth-1.0 ``douser,''
@end format
@code{USER} 変数のコード・アドレスを書き込む。


@findex dodefer, ( @var{ --   } ) gforth-1.0
@cindex @code{dodefer,}
@kindex dodefer,
@format
@code{dodefer,} ( @i{--  }) gforth-1.0 ``dodefer,''
@end format
@code{defer} されたワードのコード・アドレスを書き込む。


@findex dofield, ( @var{ --   } ) gforth-1.0
@cindex @code{dofield,}
@kindex dofield,
@format
@code{dofield,} ( @i{--  }) gforth-1.0 ``dofield,''
@end format
@code{field} のコード・アドレスを書き込む。


@findex dovalue, ( @var{ --   } ) gforth-1.0
@cindex @code{dovalue,}
@kindex dovalue,
@format
@code{dovalue,} ( @i{--  }) gforth-1.0 ``dovalue,''
@end format
@code{CONSTANT} のコード・アドレスを書き込む。


@findex doabicode, ( @var{ --   } ) gforth-1.0
@cindex @code{doabicode,}
@kindex doabicode,
@format
@code{doabicode,} ( @i{--  }) gforth-1.0 ``doabicode,''
@end format
@code{ABI-CODE} 定義のコード・アドレスを書き込む。



@code{does>} で定義されたワードの場合、 @code{hmcopy,} を使用してください。

または、 @code{create-from} のような高レベルのワードを使用します(@pxref{Creating from a
prototype})。

以下のワード群はヘッダー・メソッドが導入される前に設計されたものであるため、 Gforth
でさまざまなワード・タイプを処理する最良の(推奨される)方法ではありません。

間接スレッド Forth では、 @code{' @i{name} @@} を使用して @i{name} のコード・アドレスを取得できます。
Gforth では、 スレッド化方式とは関係なく、 @code{' @i{name} >code-address} で取得できます。

@findex threading-method ( @var{ -- n  } ) gforth-0.2
@cindex @code{threading-method}
@kindex threading-method
@format
@code{threading-method} ( @i{-- n }) gforth-0.2 ``threading-method''
@end format
エンジンが直接スレッドの場合は 0。 注意: これはイメージの存続期間中(lifetime)に変更される可能性があることに注意してください。

@findex >code-address ( @var{ xt -- c_addr   } ) gforth-0.2
@cindex @code{>code-address}
@kindex >code-address
@format
@code{>code-address} ( @i{xt -- c_addr  }) gforth-0.2 ``>code-address''
@end format
@i{c-addr} は、 ワード @i{xt} のコード・アドレスです。


@findex code-address! ( @var{ c_addr xt --   } ) gforth-obsolete
@cindex @code{code-address!}
@kindex code-address!
@format
@code{code-address!} ( @i{c_addr xt --  }) gforth-obsolete ``code-address!''
@end format
コード・アドレス @i{c-addr} のコード・フィールドを @i{xt} に変更します。



さまざまな定義ワードによって生成されるコード・アドレスは、 以下のワード群によって生成されます:

@findex docol: ( @var{ -- addr   } ) gforth-0.2
@cindex @code{docol:}
@kindex docol:
@format
@code{docol:} ( @i{-- addr  }) gforth-0.2 ``docol:''
@end format
コロン定義のコード・アドレスを書き込む。


@findex docon: ( @var{ -- addr   } ) gforth-0.2
@cindex @code{docon:}
@kindex docon:
@format
@code{docon:} ( @i{-- addr  }) gforth-0.2 ``docon:''
@end format
@code{CONSTANT} のコード・アドレスを書き込む。


@findex dovar: ( @var{ -- addr   } ) gforth-0.2
@cindex @code{dovar:}
@kindex dovar:
@format
@code{dovar:} ( @i{-- addr  }) gforth-0.2 ``dovar:''
@end format
@code{CREATE} されたワードのコード・アドレスを書き込む。


@findex douser: ( @var{ -- addr   } ) gforth-0.2
@cindex @code{douser:}
@kindex douser:
@format
@code{douser:} ( @i{-- addr  }) gforth-0.2 ``douser:''
@end format
@code{USER} 変数のコード・アドレスを書き込む。


@findex dodefer: ( @var{ -- addr   } ) gforth-0.2
@cindex @code{dodefer:}
@kindex dodefer:
@format
@code{dodefer:} ( @i{-- addr  }) gforth-0.2 ``dodefer:''
@end format
@code{defer} されたワードのコード・アドレスを書き込む。


@findex dofield: ( @var{ -- addr   } ) gforth-0.2
@cindex @code{dofield:}
@kindex dofield:
@format
@code{dofield:} ( @i{-- addr  }) gforth-0.2 ``dofield:''
@end format
@code{field} のコード・アドレスを書き込む。


@findex dovalue: ( @var{ -- addr   } ) gforth-0.7
@cindex @code{dovalue:}
@kindex dovalue:
@format
@code{dovalue:} ( @i{-- addr  }) gforth-0.7 ``dovalue:''
@end format
@code{CONSTANT} のコード・アドレスを書き込む。


@findex dodoes: ( @var{ -- addr   } ) gforth-0.6
@cindex @code{dodoes:}
@kindex dodoes:
@format
@code{dodoes:} ( @i{-- addr  }) gforth-0.6 ``dodoes:''
@end format
@code{DOES>} で定義されたワードのコード・アドレス。


@findex doabicode: ( @var{ -- addr   } ) gforth-1.0
@cindex @code{doabicode:}
@kindex doabicode:
@format
@code{doabicode:} ( @i{-- addr  }) gforth-1.0 ``doabicode:''
@end format
@code{ABI-CODE} 定義のコード・アドレスを書き込む。



@cindex @code{does>}-code
@code{set-does>} で定義されたワード @i{X} の場合、 コード・アドレスは @code{dodoes:} を指し、 そして、
ヘッダー・メソッドの @code{>hmextra} フィールドには、 @i{X} の本体(body)アドレスをプッシュした後に呼び出されるワードの
@i{xt} が含まれます。

ワードが @code{DOES>} で定義されたワードであるかどうか、 そしてそのワードが @i{execute} する Forth
コードを知りたい場合は、@code{>does-code} で以下のことがわかります:

@findex >does-code ( @var{ xt1 -- xt2   } ) gforth-0.2
@cindex @code{>does-code}
@kindex >does-code
@format
@code{>does-code} ( @i{xt1 -- xt2  }) gforth-0.2 ``>does-code''
@end format
@i{xt1} が @code{set-does>} で定義されたワードの子の実行トークンである場合、 @i{xt2} は
@code{set-does>} に渡される xt 、 つまり @i{xt1} 実行時に実行されるワードの xt です(ただし、 最初に @i{xt1}
の本体(body)アドレスがプッシュされます)。 @i{xt1} が @code{set-does>} で定義されたワードに属していない場合、
@i{xt2} は 0 です。



結果の @i{xt2} を @code{set-does>} (推奨) とともに使用して、 もっとも最新のワードを変更するか以下を使用して変更できます

@findex does-code! ( @var{ xt2 xt1 --   } ) gforth-0.2
@cindex @code{does-code!}
@kindex does-code!
@format
@code{does-code!} ( @i{xt2 xt1 --  }) gforth-0.2 ``does-code!''
@end format
@i{xt1} を @code{@i{xt2} set-does>} で定義されたワードに変更します。



任意のワードを変更するためには…

@cindex definer
以下の 2 つのワードは、 @code{>code-address} や @code{>does-code} や
@code{code-address!} や @code{does-code!} を一般化します:

@findex >definer ( @var{ xt -- definer   } ) gforth-0.2
@cindex @code{>definer}
@kindex >definer
@format
@code{>definer} ( @i{xt -- definer  }) gforth-0.2 ``>definer''
@end format
@var{definer} (definer;定義者)は、 @var{xt} の定義方法を示す一意の識別子です。  異なる @code{does>}
コードで定義されたワードには、 異なる definer が存在します。  definer は比較や @code{definer!} で使用できます。


@findex definer! ( @var{ definer xt --   } ) gforth-obsolete
@cindex @code{definer!}
@kindex definer!
@format
@code{definer!} ( @i{definer xt --  }) gforth-obsolete ``definer!''
@end format
@var{xt} で表されるワードは、 その振る舞いを @var{definer} に関連付けられた振る舞いに変更します。



@code{Code-address!} や @code{does-code!} や @code{definer!} は、
@code{opt-compile,} メソッドをそのワード型用のやや汎用的なコンパイラーに更新します(特に、 プリミティブに対しては、
プリミティブ固有の @code{peephole-compile,} (peephole-compile;のぞき穴最適化コンパイル)ではなく、 遅い
@code{general-compile,} (一般コンパイル)メソッドが使用されます)。

@c -------------------------------------------------------------
@node Passing Commands to the OS, Keeping track of Time, Carnal words, Words
@section Passing Commands to the Operating System
@cindex operating system - passing commands
@cindex shell commands

Gforth を使用すると、
(そのようなものが存在する場合、)ホスト・オペレーティング・システムのシェルで実行するための任意の文字列をシェルに渡すことができます。

@findex sh ( @var{ "..." --   } ) gforth-0.2
@cindex @code{sh}
@kindex sh
@format
@code{sh} ( @i{"..." --  }) gforth-0.2 ``sh''
@end format
行(コマンド・ライン)の残りの部分をシェルコマンドとして実行します。  その後、 ワード @code{$?}
によってコマンドの終了ステータスを取得します。


@findex system ( @var{ c-addr u --   } ) gforth-0.2
@cindex @code{system}
@kindex system
@format
@code{system} ( @i{c-addr u --  }) gforth-0.2 ``system''
@end format
@var{c-addr u} で指定された文字列をホスト・オペレーティング・システムに渡し、 サブ・シェルで実行します。  その後、 ワード
@code{$?} によってコマンドの終了ステータスが生成されます。 環境変数 @code{GFORTHSYSTEMPREFIX} の値
(またはそのデフォルト値) が文字列の先頭に付加されます(主に、 Cygwin がデフォルトで使用するシェルではなく、 Windows のシェルとして
@code{command.com} の使用をサポートするためです。)。 @pxref{Environment variables}


@findex sh-get ( @var{ c-addr u -- c-addr2 u2   } ) gforth-1.0
@cindex @code{sh-get}
@kindex sh-get
@format
@code{sh-get} ( @i{c-addr u -- c-addr2 u2  }) gforth-1.0 ``sh-get''
@end format
シェル・コマンド @i{addr u} を実行します。  @i{c-addr2 u2} はコマンドの出力です。  終了コードは @code{$?}
にあります。 コマンドの出力は @code{sh$ 2@@} にもあります。


@findex $? ( @var{ -- n   } ) gforth-0.2
@cindex @code{$?}
@kindex $?
@format
@code{$?} ( @i{-- n  }) gforth-0.2 ``dollar-question''
@end format
Value -- 最後に実行された @code{system} コマンドによって返された終了ステータス。


@findex getenv ( @var{ c-addr1 u1 -- c-addr2 u2  } ) gforth-0.2
@cindex @code{getenv}
@kindex getenv
@format
@code{getenv} ( @i{c-addr1 u1 -- c-addr2 u2 }) gforth-0.2 ``getenv''
@end format
文字列 @i{c-addr1 u1} は環境変数名を指定します。 文字列 @i{c-addr2 u2} は、 ホスト・オペレーティング・システムによる、
その環境変数の展開結果です。 環境変数が存在しない場合、 @i{c-addr2 u2} は長さ 0 文字の文字列を返します(訳注:
存在しない:c-addr2,u2 = 0, 0  存在するけど中身が空: 【有効なアドレス】, 0)


@c -------------------------------------------------------------
@node Keeping track of Time, Miscellaneous Words, Passing Commands to the OS, Words
@section Keeping track of Time
@cindex time-related words

@findex ms ( @var{ n --   } ) facility-ext
@cindex @code{ms}
@kindex ms
@format
@code{ms} ( @i{n --  }) facility-ext ``ms''@*\ 訳注: 指定のミリ秒ウエイトします(エポックでカウントします)。
@end format

@findex ns ( @var{ d --   } ) gforth-1.0
@cindex @code{ns}
@kindex ns
@format
@code{ns} ( @i{d --  }) gforth-1.0 ``ns''@*\ 訳注: 指定のナノ秒ウエイトします(エポックでカウントします)
@end format

@findex time&date ( @var{ -- nsec nmin nhour nday nmonth nyear   } ) facility-ext
@cindex @code{time&date}
@kindex time&date
@format
@code{time&date} ( @i{-- nsec nmin nhour nday nmonth nyear  }) facility-ext ``time-and-date''
@end format
現在の時刻を報告します。 nsec 、 nmin、 nhour は 0 から数えます。 nmonth は 1 から数えます。


@findex >time&date&tz ( @var{ udtime -- nsec nmin nhour nday nmonth nyear fdst ndstoff c-addrtz utz  } ) gforth-1.0
@cindex @code{>time&date&tz}
@kindex >time&date&tz
@format
@code{>time&date&tz} ( @i{udtime -- nsec nmin nhour nday nmonth nyear fdst ndstoff c-addrtz utz }) gforth-1.0 ``to-time-and-date''
@end format
1970 年 1 月 1 日 0:00Z からの時間を秒単位で現在の時刻に変換します。 nsec、 nmin、 nhourは 0 から数えます。
nmonth は 1 から数えます(訳注: 使い方: 秒単位の値を与える必要があるので、 例えば @code{utime #1000000 ud/mod
rot drop >time&date&tz} とする。 fdst: 夏時間を 採用しているときに負数 、採用していないときに
0、この情報が得られないときに正数。 ndstoff : GMTからのオフセット(秒単位)、 c-addrtz utz : タイムゾーン文字列(例:
JST))

@findex utime ( @var{ -- dtime  } ) gforth-0.5
@cindex @code{utime}
@kindex utime
@format
@code{utime} ( @i{-- dtime }) gforth-0.5 ``utime''
@end format
エポック(some epoch)以降の現在時刻をマイクロ秒単位で報告します。  @code{#1000000 um/mod nip}
を使用して秒に変換します

@findex ntime ( @var{ -- dtime  } ) gforth-1.0
@cindex @code{ntime}
@kindex ntime
@format
@code{ntime} ( @i{-- dtime }) gforth-1.0 ``ntime''
@end format
エポック(some epoch)以降の現在時刻をナノ秒単位で報告します。

@findex cputime ( @var{ -- duser dsystem  } ) gforth-0.5
@cindex @code{cputime}
@kindex cputime
@format
@code{cputime} ( @i{-- duser dsystem }) gforth-0.5 ``cputime''
@end format
duser と dsystem は、 Forth システムの開始以降に使用されたユーザー・レベルとシステム・レベルの CPU
時間(子プロセスを除く)をマイクロ秒単位で表したものです(ただし、 粒度はさらに粗くなる可能性があります)。  getrusage
コールのないプラットフォームでは、 duser については経過時間(エポック)が報告され、 dsystem については 0 が報告されます。



@c -------------------------------------------------------------
@node Miscellaneous Words, , Keeping track of Time, Words
@section Miscellaneous Words
@cindex miscellaneous words

@comment TODO find homes for these

このセクションでは、 このマニュアルの他の場所で説明されていない標準 Forth のワードをリストします。 いつかは、
これらのワードはそれぞれ適切なセクションに配置されることになるでしょう。

@findex quit ( @var{ ?? -- ??   } ) core
@cindex @code{quit}
@kindex quit
@format
@code{quit} ( @i{?? -- ??  }) core ``quit''
@end format
リターン・スタックを空にし、 ユーザー入力デバイスを入力ソースにして、 インタプリタ状態にして、 テキスト・ インタプリタを開始します。



以下の標準 Forth のワードは現在、 Gforth ではサポートされていません(@pxref{Standard conformance}):

@code{EDITOR} @code{EMIT?} @code{FORGET} (訳注: forth で書かれたラインエディタである EDITOR
ボキャブラリはありません。 @i{FORGET} はありません。任意の箇所で「忘れる」ことはできません。代わりに @code{marker name}
で忘れるポイントを「マーク」しておきます。 @i{name} を実行するとそのポイントまで「忘れ」ます。) 

@c ******************************************************************
@node Error messages, Tools, Words, Top
@chapter Error messages
@cindex error messages
@cindex backtrace

Gforth の典型的なエラー・メッセージは以下のようになります:

@example
in file included from \evaluated string/:-1
in file included from ./yyy.fs:1
./xxx.fs:4: Invalid memory address
>>>bar<<<
Backtrace:
$400E664C @@
$400E6664 foo
@end example

エラーを特定するメッセージは @code{Invalid memory address} です。  そのエラーはファイル @file{./xxx.fs}
の 4 行目をテキスト解釈(text-interpreting)しているときに発生しました。 その行のエラーが発生したワードを(@code{>>>} と
@code{<<<} で囲んで)指摘します。

エラーを含むファイルは @file{./yyy.fs} の 1 行目でインクルード(included)されており、 @file{yyy.fs}
はファイル以外からインクルードされています(この場合、 @file{yyy.fs} を Gforth へのコマンドライン
パラメータとして指定することにより)。

エラー・メッセージの最後には、 バックトレースとして解釈できるリターン・スタック・ダンプが表示されます(空の可能性があります)。 その一番上の行には
@code{throw} が発生したときのリターン・スタックのTOSが表示され、
その一番下の行には最上位のテキスト・インタプリタのリターン・スタックのすぐ上にあるリターン・スタック・エントリが表示されます。

ほとんどのリターン・スタック・エントリの右側には、 そのリターン・スタック・エントリをリターン・アドレスとしてプッシュしたワードを推測して表示します。
これによりバックトレースが得られます。 この例では、 @code{bar} が @code{foo} を呼び出し、 @code{foo} が
@code{@@} を呼び出していることがわかります(そして、 この @code{@@} には 「Invalid Memory
address」例外がありました)。

注意: バックトレースは完璧では無いことに注意してください。 どのリターン・スタック・エントリがリターン・アドレスであるかは知りません(そのため、
誤検知が発生する可能性があります)。 また、 (@code{abort"} など、)場合によっては、 リターン・アドレスからはリターン・
アドレスをプッシュしたワードを特定できないため、 リターン・アドレスによってはリターン・スタック・ダンプに名前が表示されません。

@cindex @code{catch} and backtraces
リターン・スタック・ダンプは、 特定の @code{throw} が execute されたときのリターン・スタックを表します。
@code{catch} を使用するプログラムでは、 リターン・スタック・ダンプにどの @code{throw}
を使用する必要があるかが必ずしも明確ではありません(たとえば、 エラーを示すある @code{throw} がキャッチされ、
そのリカバリ中に別のエラーが発生したとすると、 スタック・ダンプにはどの @code{throw} のを使用するべきでしょうか？)。 Gforth は、
最後に execute された(そして、 その execute からまだ返ってきていない状態で、 ) @code{catch} または
@code{nothrow} の後の最初の @code{throw} のリターン・スタック・ダンプを表示します: 通常、 これはうまく機能します。
正しいバック・トレースを取得するためには、 通常、 エラーが再 throw されない場合は @code{catch} の後に
@code{nothrow} または @code{['] false catch 2drop} を挿入します。

@cindex @code{gforth-fast} and backtraces
@cindex @code{gforth-fast}, difference from @code{gforth}
@cindex backtraces with @code{gforth-fast}
@cindex return stack dump with @code{gforth-fast}
@code{gforth} エンジン(訳注: OSコマンドラインから @i{gforth} で起動)は、 プリミティブが生成した throw
のリターン・スタック・ダンプを行えます(例: invalid memory address(不正なメモリアクセス), stack
empty(スタックが空) 等)。 @code{gforth-fast} エンジン(訳注: OSコマンドラインから @i{gforth-fast}
で起動)は、 直接呼び出された @code{throw} (@code{abort} などを含む)
からのリターン・スタック・ダンプのみを行うことができます。 @code{gforth-fast} エンジンのプリミティブによって例外が発生した場合、
通常はリターン・スタック・ダンプは全く見れません。 しかしながら、 @code{catch} によって例外がキャッチされ(たとえば、
何らかの状態を復元するため)、 その後再び @code{throw} が返される場合、 最初の @code{throw}
に対するリターン・スタック・ダンプは見れます。

また、 @code{gforth-fast} は、 ゼロ除算と除算オーバーフローを区別しようとしません。 これは、
どの除算も時間が掛かる処理だからです。

@c ******************************************************************
@node Tools, Standard conformance, Error messages, Top
@chapter Tools

@menu
* Standard Report::          使用されたワードをワードセットごとにソートして報告します
* Stack depth changes::      このスタック値はどこから来たのか?
@end menu

こちらもご覧ください @ref{Emacs and Gforth}

@node Standard Report, Stack depth changes, Tools, Tools
@section @file{ans-report.fs}: Report the words used, sorted by wordset
@cindex @file{ans-report.fs}
@cindex report the words used in your program
@cindex words used in your program

Forth プログラムを標準プログラムとしてラベル付けしたい場合は、 プログラムがどのワードセットを使用するかを文書化する必要があります。

@file{ans-report.fs} ツールを使用すると、アプリケーションでどのワードセットのどのワードが使用されているか、
どの非標準ワードが使用されているかを簡単に判断できます。 チェックしたいプログラムをロードする前に @file{ans-report.fs}
をインクルードするだけです。 プログラムをロードした後、 @code{print-ans-report} を使用してレポートを取得できます。
一般的な使用法は、 以下のようにこれをバッチ・ジョブとして実行することです:
@example
gforth ans-report.fs myprog.fs -e "print-ans-report bye"
@end example

出力は以下のようになります (@file{compat/control.fs} の場合):
@example
The program uses the following words
from CORE :
: POSTPONE THEN ; immediate ?dup IF 0= 
from BLOCK-EXT :
\ 
from FILE :
( 
@end example

@file{ans-report.fs} は、 Forth-94 と Forth-2012 の両方のワードセットをレポートします。
両方の標準に含まれるワードについては、 接尾辞なしでワードセットが報告されます(例: @code{CORE-EXT})。  Forth-2012
専用のワードの場合、@code{-2012} 接尾辞が付いたワードセットが報告されます(例: @code{CORE-EXT-2012})。
Forth-94 のみのワード(つまり、Forth-2012 で削除されたワード)についても同様です。

@subsection Caveats

注意: @file{ans-report.fs} は、 どのワードが使用されているかをチェックするだけで、
標準に準拠した方法で使用されているかどうかをチェックするわけではないことに注意してください。

一部のワードは、 標準で複数のワードセットで定義されています。 @file{ans-report.fs} は、 それらのワードセットのうちの 1
つについてのみレポートし、 それは必ずしもあなたが期待したワードセットとは限りません。 どのワードセットを指定するのが適切かは、
用途によって異なります。 たとえば、@code{S"} のコンパイル機能(compilation semantics)のみを使用する場合、それは
CORE ワードです。 インタプリタ機能(interpretation semantics)も使用する場合、 それは FILE ワードです。


@node Stack depth changes, , Standard Report, Tools
@section Stack depth changes during interpretation
@cindex @file{depth-changes.fs}
@cindex depth changes during interpretation
@cindex stack depth changes during interpretation
@cindex items on the stack after interpretation

ファイルをロードした後、 スタックに項目が残っていることに気づくことがあります。  @file{ Depth-changes.fs}
ツールを使用すると、 これらのスタック項目がファイル内のどこから来たのかをすばやく見つけることができます。

@file{ Depth-changes.fs} を使用する最も簡単な方法は、 チェックするファイルの前にこれをインクルードすることです。 例:

@example
gforth depth-changes.fs my-file.fs
@end example

これにより、 すべての空行(インタプリタ状態)でのデータ・スタックの深さと FP スタックの深さが、
最後の空行(インタプリタ状態)での深さと比較されます。 深さが等しくない場合は、 ファイル内の位置とスタックの内容が @code{~~}
(@pxref{Debugging}) で出力されます。  これは、
指摘行より前の空ではない行内の段落(paragraph)でスタックの深さの変更が発生したことを示します。  ファイルの最後に空行を残しておいて、
最後の段落もチェックされるようにすることをお勧めします。

通常、 空行のみをチェックするのはうまく機能しますが、 空行ではない大きなブロックが存在する場合(大きなテーブルを構築する場合など)、
このブロックのどこでスタックの深さが変更されたのかを知りたい場合があります。 以下を使用すると、
解釈(interpret)されたすべての行をチェックできます

@example
gforth depth-changes.fs -e "' all-lines is depth-changes-filter" my-file.fs
@end example

これにより、 各行末ごとにスタックの深さがチェックされます。  したがって、 深さの変更は @code{~~}
によって報告された行で発生しています(それより前の行ではありません)。

注意: これにより、 スタックの深さが変更される場所を示す精度が向上しますが、 多くの、 意図した、
スタックの深さの変更が報告されることが多いことに注意してください(たとえば、 解釈(interpret)された計算が複数の行にまたがる場合)。
一部の行のチェックを抑制するには、 これらの行の末尾にバックスラッシュを置き(その後に空白は続きません)、 以下を使用します

@example
gforth depth-changes.fs -e "' most-lines is depth-changes-filter" my-file.fs
@end example

@c ******************************************************************
@node Standard conformance, Standard vs Extensions, Tools, Top
@chapter Standard conformance
@cindex Standard conformance of Gforth

(標準適合度)私達の知る限り、 Gforth は…

ANS Forth システムと Forth-2012 システムに関しては
@itemize @bullet
@item Core Extensions ワード・セットを提供します
@item Block  ワード・セットを提供します
@item Block Extensions ワード・セットを提供します
@item Double-Number ワード・セットを提供します
@item Double-Number Extensions ワード・セットを提供します
@item Exception ワード・セットを提供します
@item Exception Extensions ワード・セットを提供します
@item Facility ワード・セットを提供します
@item Facility Extensions  ワード・セットを提供します(@code{EMIT?} を除く)
@item File Access ワード・セットを提供します
@item File Access Extensions ワード・セットを提供します
@item Floating-Point ワード・セットを提供します
@item Floating-Point Extensions ワード・セットを提供します
@item Locals ワード・セットを提供します
@item Locals Extensions ワード・セットを提供します
@item Memory-Allocation ワード・セットを提供します
@item Memory-Allocation Extensions ワード・セットを提供します
@item Programming-Tools ワード・セットを提供します
@item Programming-Tools Extensions ワード・セットを提供します(@code{EDITOR} と @code{FORGET} を除く)
@item Search-Order ワード・セットを提供します
@item Search-Order Extensions ワード・セットを提供します
@item String ワード・セットを提供します
@item String Extensions ワード・セットを提供します
@item Extended-Character ワード・セットを提供します
@end itemize

Gforth には以下の環境的制限(environmental restrictions)があります:

@cindex environmental restrictions
@itemize @bullet
@item
OS コマンド・ラインの処理中に例外がキャッチされなかった場合、 Gforth は QUIT を実行する代わりにゼロ以外の終了コード(exit
code)で終了(exit)します。

@item
@code{query} の後に @code{throw} が実行される場合、 Gforth は対応する @code{catch}
で有効な入力ソース仕様を常に復元するとは限りません。

@end itemize


@cindex system documentation
さらに、 標準 Forth システムでは、 特定の実装での選択を文書化する必要があります。 この章では、 Forth-94
標準のこれらの要件を満たすことを試みます。  Forth-2012 標準については、 需要がある場合にのみ追加のドキュメントを作成することにしました。
したがって、 このドキュメントで本当に足りないという場合は、 著者達までご連絡ください。

多くの場合、 以下のドキュメント群においては、 特に、 情報がプロセッサに依存する場合、
オペレーティング・システムまたは選択したインストール・オプション、 または、 Gforth のメンテナンス中に変更される可能性があるかどうについては、
情報を直接提供する代わりに、 システムに情報を要求する方法が説明されています。

@comment The framework for the rest has been taken from pfe.

@menu
* The Core Words::
* The optional Block word set::
* The optional Double Number word set::
* The optional Exception word set::
* The optional Facility word set::
* The optional File-Access word set::
* The optional Floating-Point word set::
* The optional Locals word set::
* The optional Memory-Allocation word set::
* The optional Programming-Tools word set::
* The optional Search-Order word set::  
@end menu


@c =====================================================================
@node The Core Words, The optional Block word set, Standard conformance, Standard conformance
@comment  node-name,  next,  previous,  up
@section The Core Words
@c =====================================================================
@cindex core words, system documentation
@cindex system documentation, core words

@menu
* core-idef::                実装毎オプション(Implementation Defined 
                               Options;idef)
* core-ambcond::             あいまいな条件
* core-other::               その他のシステム・ドキュメント                  
@end menu

@c ---------------------------------------------------------------------
@node core-idef, core-ambcond, The Core Words, The Core Words
@subsection 実装毎オプション(Implementation Defined Options;idef)
@c ---------------------------------------------------------------------
@cindex core words, implementation-defined options
@cindex implementation-defined options, core words


@table @i
@item セル単位に整列されたアドレス:
@cindex cell-aligned addresses
@cindex aligned addresses
プロセッサ依存です。 Gforth の整列(alignment)ワードは自然な整列(natural alignment)を実行します(たとえば、 サイズ
8 のデータに対して整列されたアドレスは 8 で割り切れます)。 通常、 非整列アクセス(unaligned accesses)では @code{-23
THROW} が発生します。

@item @code{EMIT} と非表示文字:
@cindex @code{EMIT} and non-graphic characters
@cindex non-graphic characters and @code{EMIT}
文字(character)は C 言語のライブラリ関数(実際にはマクロ) @code{putc} を使用して出力されます。

@item @code{ACCEPT} と @code{EXPECT} の文字編集:
@cindex character editing of @code{ACCEPT} and @code{EXPECT}
@cindex editing in @code{ACCEPT} and @code{EXPECT}
@cindex @code{ACCEPT}, editing
@cindex @code{EXPECT}, editing
これは、 Emacs のようなキー・バインディングを備えた GNU readline ライブラリ(@pxref{Readline
Interaction, , Command Line Editing, readline, The GNU Readline
Library})をモデルにしています。 @kbd{Tab} を入力するたびに
(すべての補完に共通のプレフィックスを生成するのではなく)完全なワード語補完を生成するという点で少し異なります。 @xref{Command-line
editing}

@item 文字セット:
@cindex character set
あなたのコンピュータと表示デバイスの文字セット。 Gforth は 8 ビットクリーンです(ただし、
システム内の他のコンポーネントが問題を引き起こす可能性があります)。

@item 文字単位に整列されたアドレスの要件:
@cindex character-aligned address requirements
インストールに依存します。 現在、 文字は C言語の @code{unsigned char} で表されます。 (リクエストへのコメントですけども、
)将来的には @code{wchar_t} に切り替える可能性があります。

@item 文字セット拡張と名前の照合:
@cindex character-set extensions and matching of names
@cindex case-sensitivity for name lookup
@cindex name lookup, case-sensitivity
@cindex locale and case-sensitivity
ASCII NUL 文字を除く任意の文字を名前に使用できます。 照合では大文字と小文字が区別されません(@code{TABLE} を除く)。 照合は C
言語ライブラリ関数 @code{strncasecmp} を使用して実行されますが、 その関数はおそらくロケールの影響を受けます。
たとえば、@code{C} ロケールではアクセントとウムラウトが認識されないため、 そのロケールでは大文字と小文字が区別されて照合されます。
移植性の理由から、 @code{C} ロケールで動作するようにプログラムを作成することが最善です。 そうすれば、 ポーランド人のプログラマ(ISO
Latin-2 でエンコードされた文字を含むワードを使用する可能性がある)と、 フランスのプログラマ(ISO
Latin-1)が作成したライブラリを同じプログラム内で使用できます(もちろん、 @code{WORDS}
は一部のワードに対して愉快な結果を生成します(どのワードでそうなるかは、 使用しているフォントによって異なります))。 また、
あなたのご希望のロケールが他のオペレーティング・システムでは利用できない場合もあります。 Unicode
がいつかこれらの問題を解決してくれることを願っています。

@item 制御文字がスペース区切り文字と一致する条件:
@cindex space delimiters
@cindex control characters as delimiters
@code{word} がスペース文字を区切り文字として使用して呼び出された場合、 すべての空白文字(C 言語マクロ @code{isspace()}
で識別される)が区切り文字になります。 一方、 @code{parse} はスペースを他の区切り文字と同様に扱います。
@code{parse-name} はデフォルトで外部インタープリター (別名テキスト・インタープリター) によって使用され、
すべての空白文字を区切り文字として扱います。

@item 制御フロースタックの形式:
@cindex control-flow stack, format
データ・スタックは制御フロー・スタックとして使用されます。 制御フロー・スタック項目のセル単位でのサイズは、 constant
@code{cs-item-size} によって与えられます。 この記事の執筆時点では、 制御フロー・スタック項目はローカル変数リスト(3番目)、
コード内のアドレス(2 番目)、 アイテムを識別するためのタグ(TOS) で構成されています。 タグとして次のタグが使用されています:
@code{defstart}, @code{live-orig}, @code{dead-orig}, @code{dest},
@code{do-dest}, @code{scopestart}

@item 35を超える「数字」の変換
@cindex digits > 35
文字 @code{[\]^_'} は、 10 進数値で 36〜41 の「数字」として解釈されます(訳注: 基数による)。
それより大きな「数字」の多くは(直接)入力する方法がありません。

@item @code{ACCEPT} および @code{EXPECT} で入力が終了した後の表示:
@cindex @code{EXPECT}, display after end of input
@cindex @code{ACCEPT}, display after end of input
入力した文字列の末尾にカーソルが移動します。  @kbd{Return} キーを使用して入力を終了する場合は、 スペースが入力されます。

@item @code{ABORT"} の 例外中止(exception abort)シーケンス:
@cindex exception abort sequence of @code{ABORT"}
@cindex @code{ABORT"}, exception abort sequence
エラー文字列は変数 @code{"error} に保存され、 @code{-2 throw} が実行されます。

@item 入力行終端文字:
@cindex input line terminator
@cindex line terminator on input
@cindex newline character on input
対話入力の場合は、 @kbd{C-m} (CR) および @kbd{C-j} (LF) で行を終了します。 通常、 これらの文字は、
@kbd{Enter} キーまたは @kbd{Return} キーを入力したときに生成されます。

@item カウンタ付き文字列の最大サイズ:
@cindex maximum size of a counted string
@cindex counted string, maximum size
@code{s" /counted-string" environment? drop .} で得られます。 現在、 すべてのプラットフォームで 255
文字ですが、 これは変更される可能性があります。

@item パースされる字列の最大サイズ:
@cindex maximum size of a parsed string
@cindex parsed string, maximum size
constant @code{/line} によって与えられます。 現在 255 文字です。

@item 定義名の最大サイズ(文字単位):
@cindex maximum size of a definition name, in characters
@cindex name, maximum length
MAX-U / 8 (@code{s" max-u" environment? drop 8 u/ u.})

@item @code{ENVIRONMENT?} の最大文字列長(文字単位):
@cindex maximum string length for @code{ENVIRONMENT?}, in characters
@cindex @code{ENVIRONMENT?} string length, maximum
MAX-U / 8 (@code{s" max-u" environment? drop 8 u/ u.})

@item ユーザー入力デバイスを選択する方法:
@cindex user input device, method of selecting
ユーザー入力デバイスは標準入力です。 現時点では、 Gforth 内から変更する方法はありません。 ただし、 入力は通常、Gforth
を起動するOSコマンド・ラインでリダイレクトできます。

@item ユーザー出力デバイスを選択する方法:
@cindex user output device, method of selecting
@code{EMIT} および @code{TYPE} は、値 @code{outfile-id} (デフォルトでは @code{stdout})
に格納されているファイル ID に出力します。 Gforth は、ユーザー出力デバイスが端末の場合はバッファなしの出力を使用します。 それ以外の場合、
出力はバッファリングされます。

@item ディクショナリのコンパイル方法:
わざわざここで文書化する必要ある？(What are we expected to document here?)

@item アドレス単位 1 つ分のビット数:
@cindex number of bits in one address unit
@cindex address unit, size in bits
@code{s" address-units-bits" environment? drop .} で得られます。 現在はすべてのプラットフォームで 8

@item 数値の表現と算術演算:
@cindex number representation and arithmetic
プロセッサに依存します。 現在のすべてのプラットフォームでは 2 進数は 2 の補数表現です。

@item 整数型の範囲:
@cindex ranges for integer types
@cindex integer types, ranges
インストールに依存します。  @code{MAX-N} と @code{MAX-U} と @code{MAX-D} と @code{MAX-UD}
の環境クエリ(environmental queries)を作成します。 符号なし(および正)型の下限は 0 です。 2 の補数マシンおよび 1
の補数マシンの符号付き型の下限は、 その上限に 1 を加算することで計算できます。

@item 読み取り専用データ空間領域:
@cindex read-only data space regions
@cindex data-space, read-only regions
Forth データ空間全体が書き込み可能です。

@item @code{WORD} のバッファのサイズ:
@cindex size of buffer at @code{WORD}
@cindex @code{WORD} buffer size
@code{PAD HERE - .} で得られます。 32 ビット マシンでは 104 文字。 バッファは、 数値表示出力文字列(pictured
numeric output string)と共有されます。  @code{PAD} の上書きが許容される場合、
そのサイズは残りの辞書スペースと同じになりますが、 実用になるのはカウンタ付き文字列に収まる範囲程度です。

@item アドレス単位での 1 セルのサイズ:
@cindex cell size
@code{1 cells .} で得られます。

@item アドレス単位での 1 文字のサイズ:
@cindex char size
@code{1 chars .} で得られます。 現在のすべてのプラットフォームで 1

@item キーボード・ターミナル・バッファのサイズ:
@cindex size of the keyboard terminal buffer
@cindex terminal buffer, size
さまざまです。  @code{lp@@ tib - .} を使用して、 特定の時点でのサイズを確認できます。 これは、
現在のファイルを含むファイルのローカル変数スタックおよび TIB と共有されます。 コマンド・ライン・オプション @code{-l} を使用して、
Gforth 起動時に TIB とローカル変数スタックのスペースの量を変更できます。

@item 表示数値出力(pictured numeric output)バッファのサイズ:
@cindex size of the pictured numeric output buffer
@cindex pictured numeric output buffer, size
@code{PAD HERE - .} で得られます。 32 ビット マシンでは 104 文字。 バッファは @code{WORD} と共有されます。

@item @code{PAD} によって返されるスクラッチ領域のサイズ:
@cindex size of the scratch area returned by @code{PAD}
@cindex @code{PAD} size
ディクショナリ・スペースの残りまるごと。 @code{unused pad here - - .} で得られます。

@item システムが英大文字・小文字を区別するか(case-sensitivity characteristics):
@cindex case-sensitivity characteristics
ディクショナリの検索では大文字と小文字が区別されません(@code{TABLE} を除く)。 ただし、 上記 @i{character-set
extensions} で説明したように、 非 ASCII 文字のマッチングは使用しているロケールによって決まります。 デフォルトの @code{C}
ロケールでは、 すべての非 ASCII 文字は大文字と小文字を区別して照合されます。

@item システムのプロンプト:
@cindex system prompt
@cindex prompt
インタプリタ状態では @code{ ok} で、 コンパイル状態では @code{ compiled} です。

@item 除算の四捨五入(division rounding):
@cindex division rounding
通常の除算ワード @code{/ mod /mod */ */mod} は、フロア除算(floored division)を実行します (Gforth
のデフォルトのインストールを使用の場合)。  @code{s" floored" environment? drop .} でこれを確認できます。
特定の除算の四捨五入が必要なプログラムを作成する場合は、 移植性を高めるために @code{fm/mod} または @code{sm/rem}
を使用するのが最適です。

@item true の場合の @code{STATE} の値:
@cindex @code{STATE} values
-1.

@item 算術オーバーフロー後に返される値:
2 の補数マシンでは、 1倍長の場合は 2**bits-per-cell 、 2倍長の場合はセルあたり 4**bits-per-cell
を法として演算(modulo)が実行されます(符号付き型では適切なマッピングを使用)。 ゼロによる除算は通常、 @code{-55 throw}
(Floating-point unidentified fault) または @code{-10 throw} (divide by zero)
を引き起こします。  整数除算のオーバーフローにより、 @code{-55 throw} や @code{-10 throw} 、 または
@code{-11 throw} が発生する可能性があります。 @code{gforth-fast} エンジン(OSコマンドラインから
@code{gforth-fast} で起動)の除算オーバーフローやゼロ除算では、 例外が生成されずに偽の結果が返される可能性があります。

@item 現在の定義(current definition)が @code{DOES>} の後ろで見つかる(可視)かどうか:
@cindex @t{DOES>}, visibility of current definition
いいえ(No)。

@end table

@c ---------------------------------------------------------------------
@node core-ambcond, core-other, core-idef, The Core Words
@subsection Ambiguous conditions
@c ---------------------------------------------------------------------
@cindex core words, ambiguous conditions
@cindex ambiguous conditions, core words

@table @i

@item ワードでも数字でもない名前:
@cindex name not found
@cindex undefined word
@code{-13 throw} (Undefined word)

@item 定義名が許可される最大長を超えています:
@cindex word name too long
@code{-19 throw} (Word name too long)

@item forth システムのさまざまなデータ空間内で無い領域をアドレス指定しようとした:
@cindex Invalid memory address
スタックやコード・スペースやヘッダー・スペースはアクセス可能です。 マシン・コード空間は通常、読み取り可能です。 他のアドレスにアクセスすると、
オペレーティング・システムに応じた結果が得られます。 まともなシステムの場合: @code{-9 throw} (Invalid memory
address)

@item 引数の型がパラメータと互換性がありません:
@cindex argument type mismatch
これは通常はキャッチされません。 一部のワード(制御フロー・ワードなど)はチェックを実行し、 @code{ABORT"} または @code{-12
THROW} (Argument type mismatch) となります。

@item 実行機能(execution semantics)が未定義であるワードの実行トークンを取得しようとしています:
@cindex compile-only warning, for @code{'} etc.
@cindex execution token of words with undefined execution semantics
実行トークンは、 ワードのインタプリタ機能(interpretation semantics)を表します。  Gforth
はすべてのワードのインタプリタ機能を定義します。 標準でインタプリタ機能が定義されていないが、 実行機能(execution
semantics)が定義されているワード(@code{LEAVE} を除く)については、 インタプリタ機能が実行機能を実行します。
標準でインタプリタ機能が定義されていないが、 コンパイル機能(compilation semantics)(および
@code{LEAVE})が定義されているワードの場合、 インタプリタ機能はコンパイル機能を実行します。
一部の単語はコンパイル専用(compile-only)としてマークされており、 @code{'} はこれらのワードに対して警告を出します。

@item ゼロ除算:
@cindex dividing by zero
@cindex floating point unidentified fault, integer division
一部のプラットフォームでは、 これにより @code{-10 throw} (Division by zero) が生成されます。 他のシステムでは、
通常、 これにより @code{-55 throw} (Floating-point unidentified fault) が生成されます。

@item データ・スタックのスペースまたはリターン・スタックのスペースが不十分:
@cindex insufficient data stack or return stack space
@cindex stack overflow
@cindex address alignment exception, stack overflow
@cindex Invalid memory address, stack overflow
オペレーティング・システムやインストール時の設定や Gforth の起動時の設定に応じて、 これはメモリ管理ハードウェアによって、
チェックされたり、チェックされなかったり。 これがチェックされている場合、 通常はオーバーフローが発生するするやいなや、
(プラットフォームとオーバーフローを達成した方法によって異なりますが、) @code{-3 throw} (Stack overflow) または
@code{-5 throw} (Return stack overflow) または @code{-9 throw} (Invalid memory
address) を受け取ります。 これがチェックされていない場合、 オーバーフローは通常、 原因不明の不正なメモリ・アクセスを引き起こし、
@code{-9 throw} (Invalid memory address) または @code{-23 throw} (Address
alignment exception) を生成します。 また、@code{ALLOCATE} とそのファミリーの内部データ構造も破壊し、
これらのワードにさまざまなエラーが発生する可能性があります。

@item ループ制御パラメータ用のスペース不足:
@cindex insufficient space for loop control parameters
他のリターン・スタック・オーバーフローと同様。

@item ディクショナリのスペースが不足:
@cindex insufficient space in the dictionary
@cindex dictionary overflow
ディクショナリで利用可能なメモリを超えるメモリを(@code{allot} で直接、 または @code{,} や @code{create}
などで間接的に)割り当てようとすると、 @code{-8 throw} (Dictionary overflow) が発生します。
ディクショナリの末尾を超えてメモリにアクセスしようとすると、 結果はスタック・オーバーフローと同様になります。

@item 未定義のインタプリタ機能(interpretation semantics)でワードを解釈(interpret):
@cindex interpreting a word with undefined interpretation semantics
@cindex Interpreting a compile-only word
Gforth は全てのワードのインタプリタ機能(interpretation semantics)を定義します。 標準で実行機能(execution
semantics)が定義されているワード(@code{LEAVE} を除く)については、 インタプリタ機能が実行機能を実行します。
標準ではインタプリタ機能が定義されていないが、 コンパイル機能(compilation semantics)(および
@code{LEAVE})が定義されているワードの場合、 インタプリタ機能はコンパイル機能。
一部のワードはコンパイル専用(compile-only)としてマークされており、
テキスト解釈(text-interpreting)すると警告が表示されます。

@item 入力バッファまたは文字列リテラルの内容を変更:
@cindex modifying the contents of the input buffer or a string literal
これらは書き込み可能なメモリに配置されており、 変更することができます。

@item 表示数値出力文字列(pictured numeric output string)のオーバーフロー:
@cindex overflow of the pictured numeric output string
@cindex pictured numeric output string, overflow
@code{-17 throw} (Pictured numeric ouput string overflow)

@item パースする文字列のオーバーフロー:
@cindex parsed string overflow
@code{PARSE} はオーバーフロー不可能です。 @code{WORD} はオーバーフローをチェックしません。

@item 範囲外の結果の生成:
@cindex result out of range
2 の補数マシンでは、 1倍長演算の場合は 2**bits-per-cell 、2倍長演算の場合は 4**bits-per-cell
を法(modulo)として演算が実行されます(符号付き型は適切なマッピングを使用)。 ゼロ除算は通常、@code{-10 throw} (divide
by zero) または @code{-55 throw} (floating point unidentified fault) を引き起こします。
除算のオーバーフローにより、 @code{-10 throw} (divide by zero) または @code{-55 throw}
(floating point unidentified fault) が発生したり、 @code{-11 throw} (result out of
range) が発生したりする可能性があります。  @code{Gforth-fast} エンジン(訳注: OSコマンドラインから
@code{Gforth-fast} で起動)では、 除算のオーバーフローまたはゼロによる除算の際に、 暗黙的に偽の結果を生成する可能性があります。
@code{Convert} と @code{>number} は現在、 何も警告を出さずにオーバーフローします。

@item 空のデータ・スタックまたは空のリターン・スタックからの読み取り:
@cindex stack empty
@cindex stack underflow
@cindex return stack underflow
データ・スタックは、 各ワード execute 後、 外部インタプリタ(別名 テキスト・インタプリタ)によってチェックされます。
アンダーフローした場合は、 @code{-4 throw} (Stack underflow) が発出されます。 それとは別に、
オペレーティング・システムやインストール時の設定や(OSからの gforth)起動時の設定に応じて、 スタックがチェックされるかどうかが異なります。
チェックで検出された場合、 通常は、プラットフォームや、 どのスタックがどの程度アンダーフローしたかに応じて、 通常は @code{-4 throw}
(Stack underflow) または @code{-6 throw} (Return stack underflow) または @code{-9
throw} (Invalid memory address) が発生します。 注意: システムが(MMU を介した)チェックを使用している場合でも、
リアクションをトリガーするには、 プログラムがかなりの数のスタック項目をアンダーフローする必要がある場合があることに注意してください(その理由は、
MMU 絡みチェックがページ・サイズの粒度で動作するためです)。
チェックが行われない場合、アンダーフローによる症状はオーバーフローによる症状と似ています。  アンバランスなリターン スタック エラーは
@code{-9 throw} (Invalid memory address) や不正な命令(通常は @code{-260
throw})など、さまざまな症状を引き起こす可能性があります。

@item 予期せず入力バッファの終わりに達したため、 長さ 0 の文字列を名前として使用しようとした:
@cindex unexpected end of the input buffer
@cindex zero-length string as a name
@cindex Attempt to use zero-length string as a name
@code{Create} とその子孫は  @code{-16 throw} (Attempt to use zero-length string as
a name;長さ 0 の文字列を名前として使用しようとします)を発出します。 @code{'}
のようなワードは検索しても見つからない可能性があります。  注意: @code{nextname}
を使用して長さゼロの名前を作成できることに注意してください(ホントにそうすべきかどうかをよく確認してください)。

@item @code{>IN} が指し示す値が入力バッファの長さより大きい:
@cindex @code{>IN} greater than input buffer
次にパース・ワードを呼び出すと、 長さ 0 の文字列が返されます。

@item @code{RECURSE} が @code{DOES>} の後に現れた:
@cindex @code{RECURSE} appears after @code{DOES>}
@code{DOES>} の後のコードへの再帰呼び出しをコンパイルします。

@item @code{RESTORE-INPUT} の引数の入力ソースが現在の入力ソースと異なります:
@cindex argument input source different than current input source for @code{RESTORE-INPUT}
@cindex argument type mismatch, @code{RESTORE-INPUT}
@cindex @code{RESTORE-INPUT}, Argument type mismatch
@code{-12 THROW} 注意: 入力ファイルが閉じられると(たとえば、 ファイルの終わりに達したため、 その source-id
は再利用される可能性があることに注意してください。 したがって、 閉じられたファイルを参照する入力ソース仕様(input source
specification)を復元(restore)すると、 @code{-12 THROW} ではなく、 予期しない結果が発生する可能性があります。

将来的には、 Gforth は現在の入力ソース以外から入力ソースの仕様を復元(input source
specifications)できるようになる可能性があります。

@item 定義を含むデータス・ペースの割り当てを解除:
@cindex data space containing definitions gets de-allocated
@code{allot} による割り当て解除はチェックされません。 これにより、通常、 メモリ・アクセス・フォールト(memory access
faults)や不正な命令の実行(execution of illegal instructions)が発生します。

@item 不正なアライメント(alignment)によるデータ空間の 読み取り/書き込み:
@cindex data space read/write with incorrect alignment
@cindex alignment faults
@cindex address alignment exception
プロセッサに依存します。 通常、 @code{-23 throw} (Address alignment exception) が発生します。
アライメントがオンになっている 486 以降のプロセッサ上の Linux-Intel では、 アライメントが正しくないと @code{-9 throw}
(Invalid memory address) が発生します。 報告によると、
アライメント制限があるのに違反を報告しない一部のプロセッサがあるとのことです。

@item データ空間ポインタが正しくアライメントされていない @code{,}, @code{C,}:
@cindex data space pointer not properly aligned, @code{,}, @code{C,}
他のアライメント・エラーと同様。

@item u+2 未満のスタック項目で @code{PICK} および @code{ROLL} を実行:
他のスタック・アンダーフローと同様。

@item ループ制御パラメータが無効:
@cindex loop control parameters not available
チェックされていません。 カウンタ付きループのワード群は、 リターン・スタック項目の先頭がループ制御パラメータであると単純に想定し、
それに応じて動作します。

@item 最新の定義は名前を持っていません(@code{IMMEDIATE}):
@cindex most recent definition does not have a name (@code{IMMEDIATE})
@cindex last word was headerless
@code{abort" last word was headerless"}.

@item @code{TO} で使用される @code{VALUE} で名前が定義されていません:
@cindex name not defined by @code{VALUE} used by @code{TO}
@cindex @code{TO} on non-@code{VALUE}s
@cindex Invalid name argument, @code{TO}
@code{-32 throw} (Invalid name argument) (名前がローカル変数であるか、 @code{CONSTANT}
によって定義されている場合を除きます。 後者の場合は、 定数が変更されるだけです)。

@item 名前が見つかりません(@code{'}, @code{POSTPONE}, @code{[']}, @code{[COMPILE]}):
@cindex name not found (@code{'}, @code{POSTPONE}, @code{[']}, @code{[COMPILE]})
@cindex undefined word, @code{'}, @code{POSTPONE}, @code{[']}, @code{[COMPILE]}
@code{-13 throw} (Undefined word)

@item パラメータが同じ型(type)ではありません(@code{DO}, @code{?DO}, @code{WITHIN}):
@cindex parameters are not of the same type (@code{DO}, @code{?DO}, @code{WITHIN})
Gforth は、 それらが同じタイプであるかのように振る舞います。 つまり、 あなたは、
すべてのパラメータを符号付きなどとして解釈することで、振る舞いを予測できます。

@item @code{POSTPONE} または @code{[COMPILE]} が @code{TO} に適用されました:
@cindex @code{POSTPONE} or @code{[COMPILE]} applied to @code{TO}
@code{: X POSTPONE TO ; IMMEDIATE} と仮定します。 @code{X} は @code{TO}
のコンパイル機能(compilation semantics)を実行します。

@item @code{WORD} によって返されるカウンタ付き文字列よりも長い文字列:
@cindex string longer than a counted string returned by @code{WORD}
@cindex @code{WORD}, string overflow
チェックされていません。 文字列は問題ありませんが、 当然ながら、 そのカウントにはその長さの最下位ビット達のみが含まれます。

@item 指定の u がセル内のビット数以上(@code{LSHIFT}、@code{RSHIFT}):
@cindex @code{LSHIFT}, large shift counts
@cindex @code{RSHIFT}, large shift counts
プロセッサに依存します。 一般的な振る舞いは、 0 を返し、 シフト・カウントの下位ビット達のみを使用することです。

@item @code{CREATE} によって定義されたワードではない:
@cindex @code{>BODY} of non-@code{CREATE}d words
@code{>BODY} は、 ワードの定義方法に関係なく、 ワードの PFA を生成します。

@cindex @code{CREATE} されたワード以外の @code{DOES>}
@code{DOES>} は、 定義方法に関係なく、 最後に定義されたワードの実行機能(execution semantics)を変更します。
たとえば、 @code{CONSTANT DOES>} は @code{CREATE , DOES>} と同等です。

@item @code{<#} 〜 @code{#>} の外で不適切に使用されているワード:
チェックされていません。 いつものように、 メモリ障害が発生することが予想されます。

@end table


@c ---------------------------------------------------------------------
@node core-other, , core-ambcond, The Core Words
@subsection Other system documentation
@c ---------------------------------------------------------------------
@cindex other system documentation, core words
@cindex core words, other system documentation

@table @i
@item @code{PAD} を使用した非標準ワード:
@cindex @code{PAD} use by nonstandard words
無し。

@item 利用可能なオペレータの端末設備(operator's terminal facilities):
@cindex operator's terminal facilities available
OS のコマンド・ライン処理後、 Gforth は対話モードになり、 Gforth に対話的にコマンドを与えることができます。
実際に利用できる機能は、Gforth の呼び出し方法によって異なります。

@item 利用可能なプログラム・データ空間:
@cindex program data space available
@cindex data space available
@code{UNUSED .} は残りのディクショナリ空間を与えます。 合計ディクショナリ空間は、 Gforth の起動時に @code{-m}
スイッチで指定できます(@pxref{Invoking Gforth})。

@item 使用可能なリターン・スタック空間:
@cindex return stack space available
@code{s" RETURN-STACK-CELLS" environment? drop .} を使用して、
セル単位での合計リターン・スタック空間を計算できます。 あなたは gforth 起動時に @code{-r}
スイッチを使用して指定できます(@pxref{Invoking Gforth})。

@item 利用可能なデータ・スタック空間:
@cindex stack space available
@code{s" STACK-CELLS" environment? drop .} を使用して、 セル単位での合計データ・スタック空間を計算できます。
あなたは gforth 起動時に @code{-d} スイッチを使用して指定できます(@pxref{Invoking Gforth})。

@item 必要なシステム・ディクショナリ空間(アドレス単位;aus):
@cindex system dictionary space required, in address units
起動直後に @code{here first-start - .} と入力します。 この記事の執筆時点では、 32 ビット システムでは 80080
(バイト) になります(訳注: Gforth 0.7.9_20240418 amd64 では 649000 aus(address unit))
@end table


@c =====================================================================
@node The optional Block word set, The optional Double Number word set, The Core Words, Standard conformance
@section The optional Block word set
@c =====================================================================
@cindex system documentation, block words
@cindex block words, system documentation

@menu
* block-idef::               実装毎オプション(Implementation Defined 
                               Options;idef)
* block-ambcond::            あいまいな条件
* block-other::              その他のシステム・ドキュメント                 
@end menu


@c ---------------------------------------------------------------------
@node block-idef, block-ambcond, The optional Block word set, The optional Block word set
@subsection 実装毎オプション(Implementation Defined Options;idef)
@c ---------------------------------------------------------------------
@cindex implementation-defined options, block words
@cindex block words, implementation-defined options

@table @i
@item @code{LIST} 使用時の表示書式:
@cindex @code{LIST} display format
最初にスクリーン番号が表示され、次に 1 行当たり 64 文字からなる 16 行が表示され、 各行の前に行番号が表示されます。

@item @code{\} の影響を受ける行の長さ:
@cindex length of a line affected by @code{\}
@cindex @code{\}, line length in blocks
64 文字。
@end table


@c ---------------------------------------------------------------------
@node block-ambcond, block-other, block-idef, The optional Block word set
@subsection Ambiguous conditions
@c ---------------------------------------------------------------------
@cindex block words, ambiguous conditions
@cindex ambiguous conditions, block words

@table @i
@item ブロックを正常に読み取りできませんでした:
@cindex block read not possible
通常、 OS 由来の値 (-512 ～ -2048) の @code{throw} が返されます。 ブロック・ファイルの長さが十分でない場合、
足りない部分は空白を返します。

@item ブロックの転送時の I/O 例外:
@cindex I/O exception in block transfer
@cindex block transfer, I/O exception
通常、 OS 由来の値 (-512 ～ -2048) の @code{throw} が返されます。

@item 不正なブロック番号:
@cindex invalid block number
@cindex block number invalid
@code{-35 throw} (Invalid block number)

@item プログラムが @code{BLK} の値を直接書き換えた場合:
@cindex @code{BLK}, altering @code{BLK}
入力ストリームは、 同じ位置で別のブロックに切り替えられます。 非ブロック入力の解釈(interpret)時に @code{BLK}
への値の格納が行われた場合、 ブロックの終了時にシステムがかなり混乱することでしょう。

@item current block buffer が無い状態で @code{UPDATE} を実行した:
@cindex @code{UPDATE}, no current block buffer
@code{UPDATE} は何もしません。

@end table

@c ---------------------------------------------------------------------
@node block-other, , block-ambcond, The optional Block word set
@subsection Other system documentation
@c ---------------------------------------------------------------------
@cindex other system documentation, block words
@cindex block words, other system documentation

@table @i
@item マルチ・プログラミング・システムがバッファ・アドレスの使用に課す制限:
(今のところ) 制限はありません。

@item ソース・コードとデータに使用できるブロックの数:
あなたのディスク容量によります。

@end table


@c =====================================================================
@node The optional Double Number word set, The optional Exception word set, The optional Block word set, Standard conformance
@section The optional Double Number word set
@c =====================================================================
@cindex system documentation, double words
@cindex double words, system documentation

@menu
* double-ambcond::           あいまいな条件              
@end menu


@c ---------------------------------------------------------------------
@node double-ambcond, , The optional Double Number word set, The optional Double Number word set
@subsection Ambiguous conditions
@c ---------------------------------------------------------------------
@cindex double words, ambiguous conditions
@cindex ambiguous conditions, double words

@table @i
@item @code{D>S} において、 @i{d} が @i{n} の範囲を超えている:
@cindex @code{D>S}, @i{d} out of range of @i{n}
@i{d} の最下位セルだけを使います。

@end table


@c =====================================================================
@node The optional Exception word set, The optional Facility word set, The optional Double Number word set, Standard conformance
@section The optional Exception word set
@c =====================================================================
@cindex system documentation, exception words
@cindex exception words, system documentation

@menu
* exception-idef::           実装毎オプション(Implementation Defined 
                               Options;idef)              
@end menu


@c ---------------------------------------------------------------------
@node exception-idef, , The optional Exception word set, The optional Exception word set
@subsection 実装毎オプション(Implementation Defined Options;idef)
@c ---------------------------------------------------------------------
@cindex implementation-defined options, exception words
@cindex exception words, implementation-defined options

@table @i
@item @code{THROW} コード値:
@cindex @code{THROW}-codes used in the system
コード -256〜-511 は、 シグナルに使用されます。 OS シグナル番号から throw
コードへのマッピングは、-256@minus{}@i{signal} です。 コード -512〜-2047 は、OS
エラー(ファイルおよびメモリ割り当て操作)に使用されます。 OS エラー番号から throw
コードへのマッピングは、-512@minus{}@code{errno} です。 このマッピングの副作用の 1 つは、 未定義の OS エラーにより、
奇妙な番号のメッセージが生成されることです。 例: @code{-1000 THROW} の場合、 私のシステムでは @code{Unknown
error 488} が発生します。
@end table

@c =====================================================================
@node The optional Facility word set, The optional File-Access word set, The optional Exception word set, Standard conformance
@section The optional Facility word set
@c =====================================================================
@cindex system documentation, facility words
@cindex facility words, system documentation

@menu
* facility-idef::            実装毎オプション(Implementation Defined 
                               Options;idef)
* facility-ambcond::         あいまいな条件            
@end menu


@c ---------------------------------------------------------------------
@node facility-idef, facility-ambcond, The optional Facility word set, The optional Facility word set
@subsection 実装毎オプション(Implementation Defined Options;idef)
@c ---------------------------------------------------------------------
@cindex implementation-defined options, facility words
@cindex facility words, implementation-defined options

@table @i
@item キーボード・イベントのエンコード (@code{EKEY}):
@cindex keyboard events, encoding in @code{EKEY}
@cindex @code{EKEY}, encoding of keyboard events
ASCII 文字に対応するキーは ASCII 文字としてエンコードされます。 他のキーは次の定数でエンコードされます: @code{k-left},
@code{k-right}, @code{k-up}, @code{k-down}, @code{k-home}, @code{k-end},
@code{k1}, @code{k2}, @code{k3}, @code{k4}, @code{k5}, @code{k6}, @code{k7},
@code{k8}, @code{k9}, @code{k10}, @code{k11}, @code{k12}, @code{k-winch},
@code{k-eof}


@item システム・クロック・ティックの間隔:
@cindex duration of a system clock tick
@cindex clock tick duration
システムに依存します。  ワード @code{MS} に関しては、 時間はマイクロ秒単位で指定されます。 OS
とハードウェアがこれをどの程度うまく実装するかは別の問題です。

@item ワード @code{MS} の execute で期待される再現性:
@cindex repeatability to be expected from the execution of @code{MS}
@cindex @code{MS}, repeatability to be expected
システムに依存します。 Unix では、多くのことが負荷に依存します。 システムの負荷が軽く、 Gforth
がスワップアウトされないほど遅延が短い場合、 パフォーマンスは許容範囲内です。 MS-DOS
やその他のシングルタスク・システムではパフォーマンスは良好です。

@end table


@c ---------------------------------------------------------------------
@node facility-ambcond, , facility-idef, The optional Facility word set
@subsection Ambiguous conditions
@c ---------------------------------------------------------------------
@cindex facility words, ambiguous conditions
@cindex ambiguous conditions, facility words

@table @i
@item @code{AT-XY} は、 あなたの出力デバイスでは実行できませんした:
@cindex @code{AT-XY} can't be performed on user output device
主に端末に依存します。 引数の範囲チェックは行われません。 エラーは報告されません。 ゴミが表示される場合もあれば、 何も起こらない場合もあります。

@end table


@c =====================================================================
@node The optional File-Access word set, The optional Floating-Point word set, The optional Facility word set, Standard conformance
@section The optional File-Access word set
@c =====================================================================
@cindex system documentation, file words
@cindex file words, system documentation

@menu
* file-idef::                実装毎オプション(Implementation Defined 
                               Options;idef)
* file-ambcond::             あいまいな条件                
@end menu

@c ---------------------------------------------------------------------
@node file-idef, file-ambcond, The optional File-Access word set, The optional File-Access word set
@subsection 実装毎オプション(Implementation Defined Options;idef)
@c ---------------------------------------------------------------------
@cindex implementation-defined options, file words
@cindex file words, implementation-defined options

@table @i
@item ファイル・アクセス・モード:
@cindex file access methods used
@code{R/O} と @code{R/W} と @code{BIN} は期待どおりに機能します。 @code{W/O} は
C言語のファイル・オープニング・モード @code{w} (または @code{wb}) に変換され、 ファイルが存在する場合はクリアされ、
存在しない場合は作成されます(@code{ open-file} 、 @code{create-file} 両方とも)。  Unix では、
@code{create-file} は、 あなたの umask によって変更された 666 権限を持つファイルを作成します。

@item ファイルの例外:
@cindex file exceptions
file ワード群は例外を発出しません(たぶん、 不正なアドレスまたは不正なファイル ID を渡した場合のメモリ・アクセス失敗(memory
access faults)例外が発生します)。

@item ファイルの行末文字:
@cindex file line terminator
システムに依存します。  Gforth は C言語の改行文字を行終端文字として使用します。 実際の文字コードが何であるかはシステムによって異なります。

@item ファイル名形式:
@cindex file name format
システムに依存します。 Gforth はあなたの OS のファイル名形式を使用するだけです。

@item @code{FILE-STATUS} によって返される情報:
@cindex @code{FILE-STATUS}, returned information
@code{FILE-STATUS} は、 ファイルに許可されている最も強力なファイル・アクセス・モードを返します。 それは @code{R/O}
または @code{W/O} または @code{R/W}  のいずれかです。 ファイルにアクセスできない場合は、 @code{R/O BIN}
が返されます。 @code{BIN} は、 返されたモードと一緒に適用されます。

@item ソース・コードのインクルード時の例外後の入力ファイルの状態:
@cindex exception when including source
例外の発出により、 残されたすべてのファイルはクローズされます。

@item @i{ior} の値と意味:
@cindex @i{ior} values and meaning
@cindex @i{wior} values and meaning
ファイルおよびメモリ割り当てワード群によって返される @i{ior} は throw コードとして意図されています。 通常、これらは  OS エラーの
-512〜-2047 の範囲内にあります。 OS エラー番号から @i{ior} へのマッピングは -512@minus{}@i{errno} です。

@item ファイル入力の入れ子の最大深さ:
@cindex maximum depth of file input nesting
@cindex file input nesting, maximum depth
リターン・スタックと、 ローカル変数/TIB スタックと、 オープン可能なファイルの数によって制限されます。
この制限内である限り問題は起きないはずです。

@item 入力行の最大文字数:
@cindex maximum size of input line
@cindex input line size, maximum
@code{/line} で得られます。 現在は 255

@item ブロックの範囲をファイルにマッピングする方法:
@cindex mapping block ranges to files
@cindex files containing blocks
@cindex blocks in files
デフォルトでは、 ブロックは現在の作業ディレクトリ内のファイル @file{blocks.fb} 内でアクセスされます。 ファイルは
@code{USE} で切り替えることができます。

@item @code{S"} によって提供される文字列バッファの数:
@cindex @code{S"}, number of string buffers
利用可能なメモリ量だけ。 文字列は、 ALLOCATE で割り当てられたメモリ・ブロックに無期限に保存されます。

@item @code{S"} によって使用される文字列バッファのサイズ:
@cindex @code{S"}, size of string buffer
@code{/line} でられます。 現在 255

@end table

@c ---------------------------------------------------------------------
@node file-ambcond, , file-idef, The optional File-Access word set
@subsection Ambiguous conditions
@c ---------------------------------------------------------------------
@cindex file words, ambiguous conditions
@cindex ambiguous conditions, file words

@table @i
@item ファイル内の位置をファイルの長さを超えて設定しようとしています:
@cindex @code{REPOSITION-FILE}, outside the file's boundaries
@code{REPOSITION-FILE} は通常どおり実行されます。 その後、 @code{FILE-POSITION} は
@code{REPOSITION-FILE} で指定された値を返します(訳注: それがEOFを超えた値であっても)。

@item まだ書き込まれていないファイル内位置から読み取ろうとしています:
@cindex reading from file positions not yet written
EOF 、 つまりゼロ文字(zero characters)が読み取られ、 エラーは報告されません。

@item @i{file-id} が不正 (@code{INCLUDE-FILE}):
@cindex @code{INCLUDE-FILE}, @i{file-id} is invalid
適切な例外が throw される可能性もありますが、 メモリ障害またはその他の問題が発生する可能性の方が高いです。

@item 指定の @i{file-id} での読み取りまたはクローズでの I/O 例外(@code{INCLUDE-FILE}, @code{INCLUDED}):
@cindex @code{INCLUDE-FILE}, I/O exception reading or closing @i{file-id}
@cindex @code{INCLUDED}, I/O exception reading or closing @i{file-id}
問題を発見した操作によって生成された @i{ior} が throw されます。

@item 指定の名前のファイルを開けません (@code{INCLUDED}):
@cindex @code{INCLUDED}, named file cannot be opened
@code{open-file} によって生成された @i{ior} が throw されます。

@item マップされていないブロック番号をリクエストしています:
@cindex unmapped block numbers
マップされていない正当なブロック番号はありません。 一部のオペレーティング・システムでは、
大きな番号のブロックを書き込むとファイル・システムがオーバーフローし、 その結果エラー・メッセージが表示される場合があります。

@item @code{blk} がゼロ以外の場合に @code{source-id} を使用した:
@cindex @code{SOURCE-ID}, behaviour when @code{BLK} is non-zero
@code{source-id} は自身の機能を実行します。 通常、 ブロックをロードしたソースの ID が表示されます。
(作者たちが考えたのより良いアイデアがあれば教えてください)

@end table


@c =====================================================================
@node The optional Floating-Point word set, The optional Locals word set, The optional File-Access word set, Standard conformance
@section The optional Floating-Point word set
@c =====================================================================
@cindex system documentation, floating-point words
@cindex floating-point words, system documentation

@menu
* floating-idef::            実装毎オプション(Implementation Defined 
                               Options;idef)
* floating-ambcond::         あいまいな条件            
@end menu


@c ---------------------------------------------------------------------
@node floating-idef, floating-ambcond, The optional Floating-Point word set, The optional Floating-Point word set
@subsection 実装毎オプション(Implementation Defined Options;idef)
@c ---------------------------------------------------------------------
@cindex implementation-defined options, floating-point words
@cindex floating-point words, implementation-defined options

@table @i
@item 浮動小数点数の形式と範囲:
@cindex format and range of floating point numbers
@cindex floating point numbers, format and range
システムに依存します。 C言語の double 型 です。

@item @i{float} が範囲外の場合の @code{REPRESENT} の結果:
@cindex @code{REPRESENT}, results when @i{float} is out of range
システムに依存します。 @code{REPRESENT} は C言語のライブラリ関数 @code{ecvt()} を使用して実装されているので、
この点においてその振る舞いを継承します。

@item 浮動小数点数の丸めまたは切り捨て:
@cindex rounding of floating-point numbers
@cindex truncation of floating-point numbers
@cindex floating-point numbers, rounding or truncation
丸めの振る舞いは、 ホストしている C 言語のコンパイラから継承されます。 IEEE-FP ベースの(つまり、ほとんどの)システムは、
デフォルトで最も近い値に丸められ、 偶数に丸める(つまり、 仮数の最後のビットを 0 にする)ことによって決着させます。

@item 浮動小数点スタックのサイズ:
@cindex floating-point stack size
@code{s" FLOATING-STACK" environment? drop .} は、 浮動小数点スタックの合計サイズ(float
単位)を示します。 これは、 gforth 起動時にコマンドライン・オプション @code{-f}
を使用して指定できます(@pxref{Invoking Gforth})。

@item 浮動小数点スタックの各項目の大きさ:
@cindex floating-point stack width
@code{1 floats} で得られます。

@end table


@c ---------------------------------------------------------------------
@node floating-ambcond, , floating-idef, The optional Floating-Point word set
@subsection Ambiguous conditions
@c ---------------------------------------------------------------------
@cindex floating-point words, ambiguous conditions
@cindex ambiguous conditions, floating-point words

@table @i
@item @code{df@@} または @code{df!} が 2倍長 float にアライメントされていないアドレスで使用されています:
@cindex @code{df@@} or @code{df!} used with an address that is not double-float  aligned
システムに依存します。 通常、 他のアライメント違反と同様に @code{-23 THROW} が発生します。

@item @code{f@@} または @code{f!} が float にアライメントされてないアドレスで使用されています:
@cindex @code{f@@} used with an address that is not float aligned
@cindex @code{f!} used with an address that is not float aligned
システムに依存します。 通常、 他のアライメント違反と同様に @code{-23 THROW} が発生します。

@item 浮動小数点の結果が範囲外です:
@cindex floating-point result out of range
System-dependent. Can result in a @code{-43 throw} (floating point
overflow), @code{-54 throw} (floating point underflow), @code{-41 throw}
(floating point inexact result), @code{-55 THROW} (Floating-point
unidentified fault), or can produce a special value representing, e.g.,
Infinity.

@item @code{sf@@} or @code{sf!} used with an address that is not single-float  aligned:
@cindex @code{sf@@} or @code{sf!} used with an address that is not single-float  aligned
System-dependent. Typically results in an alignment fault like other
alignment violations.

@item @code{base} is not decimal (@code{REPRESENT}, @code{F.}, @code{FE.}, @code{FS.}):
@cindex @code{base} is not decimal (@code{REPRESENT}, @code{F.}, @code{FE.}, @code{FS.})
The floating-point number is converted into decimal nonetheless.

@item Both arguments are equal to zero (@code{FATAN2}):
@cindex @code{FATAN2}, both arguments are equal to zero
System-dependent. @code{FATAN2} is implemented using the C library function
@code{atan2()}.

@item Using @code{FTAN} on an argument @i{r1} where cos(@i{r1}) is zero:
@cindex @code{FTAN} on an argument @i{r1} where cos(@i{r1}) is zero
System-dependent. Anyway, typically the cos of @i{r1} will not be zero
because of small errors and the tan will be a very large (or very small)
but finite number.

@item @i{d} cannot be presented precisely as a float in @code{D>F}:
@cindex @code{D>F}, @i{d} cannot be presented precisely as a float
The result is rounded to the nearest float.

@item ゼロ除算:
@cindex dividing by zero, floating-point
@cindex floating-point dividing by zero
@cindex floating-point unidentified fault, FP divide-by-zero
Platform-dependent; can produce an Infinity, NaN, @code{-42 throw} (floating
point divide by zero) or @code{-55 throw} (Floating-point unidentified
fault).

@item exponent too big for conversion (@code{DF!}, @code{DF@@}, @code{SF!}, @code{SF@@}):
@cindex exponent too big for conversion (@code{DF!}, @code{DF@@}, @code{SF!}, @code{SF@@})
System dependent. On IEEE-FP based systems the number is converted into an
infinity.

@item @i{float}<1 (@code{FACOSH}):
@cindex @code{FACOSH}, @i{float}<1
@cindex floating-point unidentified fault, @code{FACOSH}
Platform-dependent; on IEEE-FP systems typically produces a NaN.

@item @i{float}<=-1 (@code{FLNP1}):
@cindex @code{FLNP1}, @i{float}<=-1
@cindex floating-point unidentified fault, @code{FLNP1}
Platform-dependent; on IEEE-FP systems typically produces a NaN (or a
negative infinity for @i{float}=-1).

@item @i{float}<=0 (@code{FLN}, @code{FLOG}):
@cindex @code{FLN}, @i{float}<=0
@cindex @code{FLOG}, @i{float}<=0
@cindex floating-point unidentified fault, @code{FLN} or @code{FLOG}
Platform-dependent; on IEEE-FP systems typically produces a NaN (or a
negative infinity for @i{float}=0).

@item @i{float}<0 (@code{FASINH}, @code{FSQRT}):
@cindex @code{FASINH}, @i{float}<0
@cindex @code{FSQRT}, @i{float}<0
@cindex floating-point unidentified fault, @code{FASINH} or @code{FSQRT}
Platform-dependent; for @code{fsqrt} this typically gives a NaN, for
@code{fasinh} some platforms produce a NaN, others a number (bug in the C
library?).

@item |@i{float}|>1 (@code{FACOS}, @code{FASIN}, @code{FATANH}):
@cindex @code{FACOS}, |@i{float}|>1
@cindex @code{FASIN}, |@i{float}|>1
@cindex @code{FATANH}, |@i{float}|>1
@cindex floating-point unidentified fault, @code{FACOS}, @code{FASIN} or @code{FATANH}
Platform-dependent; IEEE-FP systems typically produce a NaN.

@item integer part of float cannot be represented by @i{d} in @code{F>D}:
@cindex @code{F>D}, integer part of float cannot be represented by @i{d}
@cindex floating-point unidentified fault, @code{F>D}
Platform-dependent; typically, some double number is produced and no error
is reported.

@item string larger than pictured numeric output area (@code{f.}, @code{fe.}, @code{fs.}):
@cindex string larger than pictured numeric output area (@code{f.}, @code{fe.}, @code{fs.})
@code{Precision} characters of the numeric output area are used.  If
@code{precision} is too high, these words will smash the data or code close
to @code{here}.
@end table

@c =====================================================================
@node The optional Locals word set, The optional Memory-Allocation word set, The optional Floating-Point word set, Standard conformance
@section The optional Locals word set
@c =====================================================================
@cindex system documentation, locals words
@cindex locals words, system documentation

@menu
* locals-idef::              実装毎オプション(Implementation Defined 
                               Options;idef)
* locals-ambcond::           あいまいな条件              
@end menu


@c ---------------------------------------------------------------------
@node locals-idef, locals-ambcond, The optional Locals word set, The optional Locals word set
@subsection 実装毎オプション(Implementation Defined Options;idef)
@c ---------------------------------------------------------------------
@cindex implementation-defined options, locals words
@cindex locals words, implementation-defined options

@table @i
@item maximum number of locals in a definition:
@cindex maximum number of locals in a definition
@cindex locals, maximum number in a definition
@code{s" #locals" environment? drop .}. Currently 15. This is a lower bound,
e.g., on a 32-bit machine there can be 41 locals of up to 8 characters. The
number of locals in a definition is bounded by the size of locals-buffer,
which contains the names of the locals.

@end table


@c ---------------------------------------------------------------------
@node locals-ambcond, , locals-idef, The optional Locals word set
@subsection Ambiguous conditions
@c ---------------------------------------------------------------------
@cindex locals words, ambiguous conditions
@cindex ambiguous conditions, locals words

@table @i
@item executing a named local in interpretation state:
@cindex local in interpretation state
@cindex Interpreting a compile-only word, for a local
Compiles the local into the current definition (just as in compile state);
in addition text-interpreting a local in interpretation state gives an ``is
compile-only'' warning.

@item @i{name} not defined by @code{VALUE} or @code{(LOCAL)} (@code{TO}):
@cindex name not defined by @code{VALUE} or @code{(LOCAL)} used by @code{TO}
@cindex @code{TO} on non-@code{VALUE}s and non-locals
@cindex Invalid name argument, @code{TO}
@code{-32 throw} (Invalid name argument)

@end table


@c =====================================================================
@node The optional Memory-Allocation word set, The optional Programming-Tools word set, The optional Locals word set, Standard conformance
@section The optional Memory-Allocation word set
@c =====================================================================
@cindex system documentation, memory-allocation words
@cindex memory-allocation words, system documentation

@menu
* memory-idef::              実装毎オプション(Implementation Defined 
                               Options;idef)                 
@end menu


@c ---------------------------------------------------------------------
@node memory-idef, , The optional Memory-Allocation word set, The optional Memory-Allocation word set
@subsection 実装毎オプション(Implementation Defined Options;idef)
@c ---------------------------------------------------------------------
@cindex implementation-defined options, memory-allocation words
@cindex memory-allocation words, implementation-defined options

@table @i
@item values and meaning of @i{ior}:
@cindex @i{ior} values and meaning
ファイルおよびメモリ割り当てワード群によって返される @i{ior} は throw コードとして意図されています。 通常、これらは  OS エラーの
-512〜-2047 の範囲内にあります。 OS エラー番号から @i{ior} へのマッピングは -512@minus{}@i{errno} です。

@end table

@c =====================================================================
@node The optional Programming-Tools word set, The optional Search-Order word set, The optional Memory-Allocation word set, Standard conformance
@section The optional Programming-Tools word set
@c =====================================================================
@cindex system documentation, programming-tools words
@cindex programming-tools words, system documentation

@menu
* programming-idef::         実装毎オプション(Implementation Defined 
                               Options;idef)
* programming-ambcond::      あいまいな条件         
@end menu


@c ---------------------------------------------------------------------
@node programming-idef, programming-ambcond, The optional Programming-Tools word set, The optional Programming-Tools word set
@subsection 実装毎オプション(Implementation Defined Options;idef)
@c ---------------------------------------------------------------------
@cindex implementation-defined options, programming-tools words
@cindex programming-tools words, implementation-defined options

@table @i
@item ending sequence for input following @code{;CODE} and @code{CODE}:
@cindex @code{;CODE} ending sequence
@cindex @code{CODE} ending sequence
@code{END-CODE}

@item manner of processing input following @code{;CODE} and @code{CODE}:
@cindex @code{;CODE}, processing input
@cindex @code{CODE}, processing input
The @code{ASSEMBLER} vocabulary is pushed on the search order stack, and the
input is processed by the text interpreter, (starting) in interpret state.

@item search order capability for @code{EDITOR} and @code{ASSEMBLER}:
@cindex @code{ASSEMBLER}, search order capability
The Search-Order word set.

@item source and format of display by @code{SEE}:
@cindex @code{SEE}, source and format of output
The source for @code{see} is the executable code used by the inner
interpreter.  The current @code{see} tries to output Forth source code (and
on some platforms, assembly code for primitives) as well as possible.

@end table

@c ---------------------------------------------------------------------
@node programming-ambcond, , programming-idef, The optional Programming-Tools word set
@subsection Ambiguous conditions
@c ---------------------------------------------------------------------
@cindex programming-tools words, ambiguous conditions
@cindex ambiguous conditions, programming-tools words

@table @i

@item deleting the compilation word list (@code{FORGET}):
@cindex @code{FORGET}, deleting the compilation word list
Not implemented (yet).

@item fewer than @i{u}+1 items on the control-flow stack (@code{CS-PICK}, @code{CS-ROLL}):
@cindex @code{CS-PICK}, fewer than @i{u}+1 items on the control flow-stack
@cindex @code{CS-ROLL}, fewer than @i{u}+1 items on the control flow-stack
@cindex control-flow stack underflow
This typically results in an @code{abort"} with a descriptive error message
(may change into a @code{-22 throw} (Control structure mismatch)  in the
future). You may also get a memory access error. If you are unlucky, this
ambiguous condition is not caught.

@item @i{name} can't be found (@code{FORGET}):
@cindex @code{FORGET}, @i{name} can't be found
Not implemented (yet).

@item @i{name} not defined via @code{CREATE}:
@cindex @code{;CODE}, @i{name} not defined via @code{CREATE}
@code{;CODE} behaves like @code{DOES>} in this respect, i.e., it changes the
execution semantics of the last defined word no matter how it was defined.

@item @code{POSTPONE} applied to @code{[IF]}:
@cindex @code{POSTPONE} applied to @code{[IF]}
@cindex @code{[IF]} and @code{POSTPONE}
After defining @code{: X POSTPONE [IF] ; IMMEDIATE}. @code{X} is equivalent
to @code{[IF]}.

@item reaching the end of the input source before matching @code{[ELSE]} or @code{[THEN]}:
@cindex @code{[IF]}, end of the input source before matching @code{[ELSE]} or @code{[THEN]}
Continue in the same state of conditional compilation in the next outer
input source. Currently there is no warning to the user about this.

@item removing a needed definition (@code{FORGET}):
@cindex @code{FORGET}, removing a needed definition
Not implemented (yet).

@end table


@c =====================================================================
@node The optional Search-Order word set, , The optional Programming-Tools word set, Standard conformance
@section The optional Search-Order word set
@c =====================================================================
@cindex system documentation, search-order words
@cindex search-order words, system documentation

@menu
* search-idef::              実装毎オプション(Implementation Defined 
                               Options;idef)
* search-ambcond::           あいまいな条件              
@end menu


@c ---------------------------------------------------------------------
@node search-idef, search-ambcond, The optional Search-Order word set, The optional Search-Order word set
@subsection 実装毎オプション(Implementation Defined Options;idef)
@c ---------------------------------------------------------------------
@cindex implementation-defined options, search-order words
@cindex search-order words, implementation-defined options

@table @i
@item maximum number of word lists in search order:
@cindex maximum number of word lists in search order
@cindex search order, maximum depth
@code{s" wordlists" environment? drop .}. Currently 16.

@item minimum search order:
@cindex minimum search order
@cindex search order, minimum
@code{root root}.

@end table

@c ---------------------------------------------------------------------
@node search-ambcond, , search-idef, The optional Search-Order word set
@subsection Ambiguous conditions
@c ---------------------------------------------------------------------
@cindex search-order words, ambiguous conditions
@cindex ambiguous conditions, search-order words

@table @i
@item changing the compilation word list (during compilation):
@cindex changing the compilation word list (during compilation)
@cindex compilation word list, change before definition ends
The word is entered into the word list that was the compilation word list at
the start of the definition. Any changes to the name field (e.g.,
@code{immediate}) or the code field (e.g., when executing @code{DOES>})  are
applied to the latest defined word (as reported by @code{latest} or
@code{latestxt}), if possible, irrespective of the compilation word list.

@item search order empty (@code{previous}):
@cindex @code{previous}, search order empty
@cindex vocstack empty, @code{previous}
@code{abort" Vocstack empty"}.

@item too many word lists in search order (@code{also}):
@cindex @code{also}, too many word lists in search order
@cindex vocstack full, @code{also}
@code{abort" Vocstack full"}.

@end table

@c ***************************************************************
@node Standard vs Extensions, Model, Standard conformance, Top
@chapter Should I use Gforth extensions?
@cindex Gforth extensions

As you read through the rest of this manual, you will see documentation for
@i{Standard} words, and documentation for some appealing Gforth
@i{extensions}. You might ask yourself the question: @i{``Should I restrict
myself to the standard, or should I use the extensions?''}

The answer depends on the goals you have for the program you are working on:

@itemize @bullet

@item Is it just for yourself or do you want to share it with others?

@item
If you want to share it, do the others all use Gforth?

@item
If it is just for yourself, do you want to restrict yourself to Gforth?

@end itemize

If restricting the program to Gforth is ok, then there is no reason not to
use extensions.  It is still a good idea to keep to the standard where it is
easy, in case you want to reuse these parts in another program that you want
to be portable.

If you want to be able to port the program to other Forth systems, there are
the following points to consider:

@itemize @bullet

@item
Most Forth systems that are being maintained support Standard Forth.  So if
your program complies with the standard, it will be portable among many
systems.

@item
A number of the Gforth extensions can be implemented in Standard Forth using
public-domain files provided in the @file{compat/} directory. These are
mentioned in the text in passing.  There is no reason not to use these
extensions, your program will still be Standard Forth compliant; just
include the appropriate compat files with your program.

@item
The tool @file{ans-report.fs} (@pxref{Standard Report}) makes it easy to
analyse your program and determine what non-Standard words it relies upon.
However, it does not check whether you use standard words in a non-standard
way.

@item
Some techniques are not standardized by Standard Forth, and are hard or
impossible to implement in a standard way, but can be implemented in most
Forth systems easily, and usually in similar ways (e.g., accessing word
headers).  Forth has a rich historical precedent for programmers taking
advantage of implementation-dependent features of their tools (for example,
relying on a knowledge of the dictionary structure). Sometimes these
techniques are necessary to extract every last bit of performance from the
hardware, sometimes they are just a programming shorthand.

@item
Does using a Gforth extension save more work than the porting this part to
other Forth systems (if any) will cost?

@item
Is the additional functionality worth the reduction in portability and the
additional porting problems?

@end itemize

In order to perform these considerations, you need to know what's standard
and what's not.  This manual generally states if something is non-standard,
but the authoritative source is the
@uref{https://forth-standard.org/standard/words,standard document}.
Appendix A of the Standard (@var{Rationale}) provides a valuable insight
into the thought processes of the technical committee.

Note also that portability between Forth systems is not the only portability
issue; there is also the issue of portability between different platforms
(processor/OS combinations).

@c ***************************************************************
@node Model, Integrating Gforth, Standard vs Extensions, Top
@chapter Model

This chapter has yet to be written. It will contain information, on which
internal structures you can rely.

@c ***************************************************************
@node Integrating Gforth, Emacs and Gforth, Model, Top
@chapter Integrating Gforth into C programs

Several people like to use Forth as scripting language for applications that
are otherwise written in C, C++, or some other language.

The Forth system ATLAST provides facilities for embedding it into
applications; unfortunately it has several disadvantages: most importantly,
it is not based on Standard Forth, and it is apparently dead (i.e., not
developed further and not supported). The facilities provided by Gforth in
this area are inspired by ATLAST's facilities, so making the switch should
not be hard.

We also tried to design the interface such that it can easily be implemented
by other Forth systems, so that we may one day arrive at a standardized
interface. Such a standard interface would allow you to replace the Forth
system without having to rewrite C code.

You embed the Gforth interpreter by linking with the library
@code{libgforth.a} or @code{libgforth.so} (give the compiler the option
@code{-lgforth}, or for one of the other engines @code{-lgforth-fast},
@code{-lgforth-itc}, or @code{-lgforth-ditc}).  All global symbols in this
library that belong to the interface, have the prefix @code{gforth_}; if a
common interface emerges, the functions may also be available through
@code{#define}s with the prefix @code{forth_}.

You can include the declarations of Forth types, the functions and variables
of the interface with @code{#include <gforth.h>}.

You can now run a Gforth session by either calling @code{gforth_main} or
using the components:

@example
Cell gforth_main(int argc, char **argv, char **env)
@{
  Cell retvalue=gforth_start(argc, argv);

  if(retvalue == -56) @{ /* throw-code for quit */
    retvalue = gforth_bootmessage();     // show boot message
    if(retvalue == -56)
      retvalue = gforth_quit(); // run quit loop
  @}
  gforth_cleanup();
  gforth_printmetrics();
  // gforth_free_dict(); // if you want to restart, do this

  return retvalue;
@}
@end example

To interact with the Forth interpreter, there's @code{Xt gforth_find(Char *
name)} and @code{Cell gforth_execute(Xt xt)}.

More documentation needs to be put here.

@section Types

@code{Cell}, @code{UCell}: data stack elements.

@code{Float}: float stack element.

@code{Address}, @code{Xt}, @code{Label}: pointer typies to memory, Forth
words, and Forth instructions inside the VM.

@section Variables

Data and FP Stack pointer. Area sizes. Accessing the Stacks

@code{gforth_SP}, @code{gforth_FP}.

@section Functions

@example
void *gforth_engine(Xt *, stackpointers *);
Cell gforth_main(int argc, char **argv, char **env);
int gforth_args(int argc, char **argv, char **path, char **imagename);
ImageHeader* gforth_loader(char* imagename, char* path);
user_area* gforth_stacks(Cell dsize, Cell rsize, Cell fsize, Cell lsize);
void gforth_free_stacks(user_area* t);
void gforth_setstacks(user_area * t);
void gforth_free_dict();
Cell gforth_go(Xt* ip0);
Cell gforth_boot(int argc, char** argv, char* path);
void gforth_bootmessage();
Cell gforth_start(int argc, char ** argv);
Cell gforth_quit();
Xt gforth_find(Char * name);
Cell gforth_execute(Xt xt);
void gforth_cleanup();
void gforth_printmetrics();
void gforth_setwinch();
@end example

@section Signals

Gforth sets up signal handlers to catch exceptions and window size changes.
This may interfere with your C program.

@c ******************************************************************
@node Emacs and Gforth, Image Files, Integrating Gforth, Top
@chapter Emacs and Gforth
@cindex Emacs and Gforth

@cindex @file{gforth.el}
@cindex @file{forth.el}
@cindex Rydqvist, Goran
@cindex Kuehling, David
@cindex comment editing commands
@cindex @code{\}, editing with Emacs
@cindex debug tracer editing commands
@cindex @code{~~}, removal with Emacs
@cindex Forth mode in Emacs

Gforth comes with @file{gforth.el}, an improved version of @file{forth.el}
by Goran Rydqvist (included in the TILE package). The improvements are:

@itemize @bullet
@item
A better handling of indentation.
@item
A custom hilighting engine for Forth-code.
@item
Comment paragraph filling (@kbd{M-q})
@item
Commenting (@kbd{C-x \}) and uncommenting (@kbd{C-u C-x \}) of regions
@item
Removal of debugging tracers (@kbd{C-x ~}, @pxref{Debugging}).
@item
Support of the @code{info-lookup} feature for looking up the documentation
of a word.
@item
Support for reading and writing blocks files.
@end itemize

To get a basic description of these features, enter Forth mode and type
@kbd{C-h m}.

@cindex source location of error or debugging output in Emacs
@cindex error output, finding the source location in Emacs
@cindex debugging output, finding the source location in Emacs
In addition, Gforth supports Emacs quite well: The source code locations
given in error messages, debugging output (from @code{~~}) and failed
assertion messages are in the right format for Emacs' compilation mode
(@pxref{Compilation, , Running Compilations under Emacs, emacs, Emacs
Manual}) so the source location corresponding to an error or other message
is only a few keystrokes away (@kbd{C-x `} for the next error, @kbd{C-c C-c}
for the error under the cursor).

@cindex viewing the documentation of a word in Emacs
@cindex context-sensitive help
Moreover, for words documented in this manual, you can look up the glossary
entry quickly by using @kbd{C-h TAB} (@code{info-lookup-symbol},
@pxref{Documentation, ,Documentation Commands, emacs, Emacs Manual}).  This
feature requires Emacs 20.3 or later and does not work for words containing
@code{:}.

@menu
* Installing gforth.el::     Emacs に Forth を認識させる
* Emacs Tags::               ワードのソースを Emacs で閲覧
* Hilighting::               Forth コードの見栄えを良くします
* Auto-Indentation::         自動インデントのカスタマイズ
* Blocks Files::             ブロック・ファイルの読み書き
@end menu

@c ----------------------------------
@node Installing gforth.el, Emacs Tags, Emacs and Gforth, Emacs and Gforth
@section Installing gforth.el
@cindex @file{.emacs}
@cindex @file{gforth.el}, installation
@file{gforth.el} の機能を Emacs で利用できるようにするには、 @file{.emacs} ファイルに次の行を追加します(訳注:
2024年時点では .emacs.d/init.el ):

@example
(autoload 'forth-mode "gforth.el")
(setq auto-mode-alist (cons '("\\.fs\\'" . forth-mode) 
			    auto-mode-alist))
(autoload 'forth-block-mode "gforth.el")
(setq auto-mode-alist (cons '("\\.fb\\'" . forth-block-mode) 
			    auto-mode-alist))
(add-hook 'forth-mode-hook (function (lambda ()
   ;; customize variables here:
   (setq forth-indent-level 4)
   (setq forth-minor-indent-level 2)
   (setq forth-hilight-level 3)
   ;;; ...
)))

;; 訳注: とりあえずインストール( .emacs.d/init.el ):
;; /path/to/gforth-dev フォルダに gforth.el gforth.elc があるとして
(add-to-list 'load-path "/path/to/gforth-dev")
(require 'forth-mode "gforth")
@end example

@c ----------------------------------
@node Emacs Tags, Hilighting, Installing gforth.el, Emacs and Gforth
@section Emacs Tags
@cindex @file{TAGS} file
@cindex @file{etags.fs}
@cindex viewing the source of a word in Emacs
@cindex @code{require}, placement in files
@cindex @code{include}, placement in files
If you @code{require} @file{etags.fs}, a new @file{TAGS} file will be
produced (@pxref{Tags, , Tags Tables, emacs, Emacs Manual}) that contains
the definitions of all words defined afterwards. You can then find the
source for a word using @kbd{M-.}. Note that Emacs can use several tags
files at the same time (e.g., one for the Gforth sources and one for your
program, @pxref{Select Tags Table,,Selecting a Tags Table,emacs, Emacs
Manual}). The TAGS file for the preloaded words is
@file{$(datadir)/gforth/$(VERSION)/TAGS} (e.g.,
@file{/usr/local/share/gforth/0.2.0/TAGS}).  To get the best behaviour with
@file{etags.fs}, you should avoid putting definitions both before and after
@code{require} etc., otherwise you will see the same file visited several
times by commands like @code{tags-search}.

@c ----------------------------------
@node Hilighting, Auto-Indentation, Emacs Tags, Emacs and Gforth
@section Hilighting
@cindex hilighting Forth code in Emacs
@cindex highlighting Forth code in Emacs
@file{gforth.el} comes with a custom source hilighting engine.  When you
open a file in @code{forth-mode}, it will be completely parsed, assigning
faces to keywords, comments, strings etc.  While you edit the file, modified
regions get parsed and updated on-the-fly. 

Use the variable `forth-hilight-level' to change the level of decoration
from 0 (no hilighting at all) to 3 (the default).  Even if you set the
hilighting level to 0, the parser will still work in the background,
collecting information about whether regions of text are ``compiled'' or
``interpreted''.  Those information are required for auto-indentation to
work properly.  Set `forth-disable-parser' to non-nil if your computer is
too slow to handle parsing.  This will have an impact on the smartness of
the auto-indentation engine, though.

Sometimes Forth sources define new features that should be hilighted, new
control structures, defining-words etc.  You can use the variable
`forth-custom-words' to make @code{forth-mode} hilight additional words and
constructs.  See the docstring of `forth-words' for details (in Emacs, type
@kbd{C-h v forth-words}).

`forth-custom-words' is meant to be customized in your @file{.emacs} file.
To customize hilighing in a file-specific manner, set `forth-local-words' in
a local-variables section at the end of your source file (@pxref{Local
Variables in Files,, Variables, emacs, Emacs Manual}).

Example:
@example
0 [IF]
   Local Variables:
   forth-local-words:
      ((("t:") definition-starter (font-lock-keyword-face . 1)
        "[ \t\n]" t name (font-lock-function-name-face . 3))
       ((";t") definition-ender (font-lock-keyword-face . 1)))
   End:
[THEN]
@end example

@c ----------------------------------
@node Auto-Indentation, Blocks Files, Hilighting, Emacs and Gforth
@section Auto-Indentation
@cindex auto-indentation of Forth code in Emacs
@cindex indentation of Forth code in Emacs
@code{forth-mode} automatically tries to indent lines in a smart way,
whenever you type @key{TAB} or break a line with @kbd{C-m}.

Simple customization can be achieved by setting `forth-indent-level' and
`forth-minor-indent-level' in your @file{.emacs} file. For historical
reasons @file{gforth.el} indents per default by multiples of 4 columns.  To
use the more traditional 3-column indentation, add the following lines to
your @file{.emacs}:

@example
(add-hook 'forth-mode-hook (function (lambda ()
   ;; customize variables here:
   (setq forth-indent-level 3)
   (setq forth-minor-indent-level 1)
)))
@end example

If you want indentation to recognize non-default words, customize it by
setting `forth-custom-indent-words' in your @file{.emacs}.  See the
docstring of `forth-indent-words' for details (in Emacs, type @kbd{C-h v
forth-indent-words}).

To customize indentation in a file-specific manner, set
`forth-local-indent-words' in a local-variables section at the end of your
source file (@pxref{Local Variables in Files, Variables,,emacs, Emacs
Manual}).

Example:
@example
0 [IF]
   Local Variables:
   forth-local-indent-words:
      ((("t:") (0 . 2) (0 . 2))
       ((";t") (-2 . 0) (0 . -2)))
   End:
[THEN]
@end example

@c ----------------------------------
@node Blocks Files, , Auto-Indentation, Emacs and Gforth
@section Blocks Files
@cindex blocks files, use with Emacs
@code{forth-mode} Autodetects blocks files by checking whether the length of
the first line exceeds 1023 characters.  It then tries to convert the file
into normal text format.  When you save the file, it will be written to disk
as normal stream-source file.

If you want to write blocks files, use @code{forth-blocks-mode}.  It
inherits all the features from @code{forth-mode}, plus some additions:

@itemize @bullet
@item
Files are written to disk in blocks file format.
@item
Screen numbers are displayed in the mode line (enumerated beginning with the
value of `forth-block-base')
@item
Warnings are displayed when lines exceed 64 characters.
@item
The beginning of the currently edited block is marked with an overlay-arrow. 
@end itemize

There are some restrictions you should be aware of.  When you open a blocks
file that contains tabulator or newline characters, these characters will be
translated into spaces when the file is written back to disk.  If tabs or
newlines are encountered during blocks file reading, an error is output to
the echo area. So have a look at the `*Messages*' buffer, when Emacs' bell
rings during reading.

Please consult the docstring of @code{forth-blocks-mode} for more
information by typing @kbd{C-h v forth-blocks-mode}).

@c ******************************************************************
@node Image Files, Engine, Emacs and Gforth, Top
@chapter Image Files
@cindex image file
@cindex @file{.fi} files
@cindex precompiled Forth code
@cindex dictionary in persistent form
@cindex persistent form of dictionary

An image file is a file containing an image of the Forth dictionary, i.e.,
compiled Forth code and data residing in the dictionary.  By convention, we
use the extension @code{.fi} for image files.

@menu
* Image Licensing Issues::   イメージの配布条件
* Image File Background::    なぜイメージ・ファイルがあるのですか?
* Non-Relocatable Image Files::  ※これは常に機能するとは限りません
* Data-Relocatable Image Files::  ※こちらの方がよいです
* Fully Relocatable Image Files::  ※こちらの方がもっといいです
* Stack and Dictionary Sizes::  イメージでのデフォルト・サイズを設定
* Running Image Files::      @code{gforth -i @i{file}} or @i{file}.
* Modifying the Startup Sequence::  ターンキー・アプリケーションにする事もできる
@end menu

@node Image Licensing Issues, Image File Background, Image Files, Image Files
@section Image Licensing Issues
@cindex license for images
@cindex image license

An image created with @code{gforthmi} (@pxref{gforthmi}) or
@code{savesystem} (@pxref{Non-Relocatable Image Files}) includes the
original image; i.e., according to copyright law it is a derived work of the
original image.

Since Gforth is distributed under the GNU GPL, the newly created image falls
under the GNU GPL, too. In particular, this means that if you distribute the
image, you have to make all of the sources for the image available,
including those you wrote.  For details see @ref{Copying, , GNU General
Public License (Section 3)}.

If you create an image with @code{cross} (@pxref{cross.fs}), the image
contains only code compiled from the sources you gave it; if none of these
sources is under the GPL, the terms discussed above do not apply to the
image. However, if your image needs an engine (a gforth binary)  that is
under the GPL, you should make sure that you distribute both in a way that
is at most a @emph{mere aggregation}, if you don't want the terms of the GPL
to apply to the image.

@node Image File Background, Non-Relocatable Image Files, Image Licensing Issues, Image Files
@section Image File Background
@cindex image file background

Gforth consists not only of primitives (in the engine), but also of
definitions written in Forth. Since the Forth compiler itself belongs to
those definitions, it is not possible to start the system with the engine
and the Forth source alone. Therefore we provide the Forth code as an image
file in nearly executable form. When Gforth starts up, a C routine loads the
image file into memory, optionally relocates the addresses, then sets up the
memory (stacks etc.) according to information in the image file, and
(finally) starts executing Forth code.

The default image file is @file{gforth.fi} (in the @code{GFORTHPATH}).  You
can use a different image by using the @code{-i}, @code{--image-file} or
@code{--appl-image} options (@pxref{Invoking Gforth}), e.g.:

@example
gforth-fast -i myimage.fi
@end example

There are different variants of image files, and they represent different
compromises between the goals of making it easy to generate image files and
making them portable.

@cindex relocation at run-time
Win32Forth 3.4 and Mitch Bradley's @code{cforth} use relocation at
run-time. This avoids many of the complications discussed below (image files
are data relocatable without further ado), but costs performance (one
addition per memory access) and makes it difficult to pass addresses between
Forth and library calls or other programs.

@cindex relocation at load-time
By contrast, the Gforth loader performs relocation at image load time. The
loader also has to replace tokens that represent primitive calls with the
appropriate code-field addresses (or code addresses in the case of direct
threading).

There are three kinds of image files, with different degrees of
relocatability: non-relocatable, data-relocatable, and fully relocatable
image files.

@cindex image file loader
@cindex relocating loader
@cindex loader for image files
These image file variants have several restrictions in common; they are
caused by the design of the image file loader:

@itemize @bullet
@item
There is only one segment; in particular, this means, that an image file
cannot represent @code{ALLOCATE}d memory chunks (and pointers to them). The
contents of the stacks are not represented, either.

@item
The only kinds of relocation supported are: adding the same offset to all
cells that represent data addresses; and replacing special tokens with code
addresses or with pieces of machine code.

If any complex computations involving addresses are performed, the results
cannot be represented in the image file. Several applications that use such
computations come to mind:

@itemize @minus
@item
Hashing addresses (or data structures which contain addresses) for table
lookup. If you use Gforth's @code{table}s or @code{wordlist}s for this
purpose, you will have no problem, because the hash tables are recomputed
automatically when the system is started. If you use your own hash tables,
you will have to do something similar.

@item
There's a cute implementation of doubly-linked lists that uses @code{XOR}ed
addresses. You could represent such lists as singly-linked in the image
file, and restore the doubly-linked representation on startup.@footnote{In
my opinion, though, you should think thrice before using a doubly-linked
list (whatever implementation).}

@item
The code addresses of run-time routines like @code{docol:} cannot be
represented in the image file (because their tokens would be replaced by
machine code in direct threaded implementations). As a workaround, compute
these addresses at run-time with @code{>code-address} from the executions
tokens of appropriate words (see the definitions of @code{docol:} and
friends in @file{kernel/getdoers.fs}).

@item
On many architectures addresses are represented in machine code in some
shifted or mangled form. You cannot put @code{CODE} words that contain
absolute addresses in this form in a relocatable image file. Workarounds are
representing the address in some relative form (e.g., relative to the CFA,
which is present in some register), or loading the address from a place
where it is stored in a non-mangled form.
@end itemize
@end itemize

@node Non-Relocatable Image Files, Data-Relocatable Image Files, Image File Background, Image Files
@section Non-Relocatable Image Files
@cindex non-relocatable image files
@cindex image file, non-relocatable

These files are simple memory dumps of the dictionary. They are specific to
the executable (i.e., @file{gforth} file) they were created with. What's
worse, they are specific to the place on which the dictionary resided when
the image was created. Now, there is no guarantee that the dictionary will
reside at the same place the next time you start Gforth, so there's no
guarantee that a non-relocatable image will work the next time (Gforth will
complain instead of crashing, though).  Indeed, on OSs with (enabled)
address-space randomization non-relocatable images are unlikely to work.

You can create a non-relocatable image file with @code{savesystem}, e.g.:

@example
gforth app.fs -e "savesystem app.fi bye"
@end example

@findex savesystem ( @var{ "image" --   } ) gforth-0.2
@cindex @code{savesystem}
@kindex savesystem
@format
@code{savesystem} ( @i{"image" --  }) gforth-0.2 ``savesystem''
@end format



@node Data-Relocatable Image Files, Fully Relocatable Image Files, Non-Relocatable Image Files, Image Files
@section Data-Relocatable Image Files
@cindex data-relocatable image files
@cindex image file, data-relocatable

These files contain relocatable data addresses, but fixed code addresses
(instead of tokens). They are specific to the executable (i.e.,
@file{gforth} file) they were created with.  Also, they disable dynamic
native code generation (typically a factor of 2 in speed).  You get a
data-relocatable image, if you pass the engine you want to use through the
@code{GFORTHD} environment variable to @file{gforthmi} (@pxref{gforthmi}),
e.g.

@example
GFORTHD="/usr/bin/gforth-fast --no-dynamic" gforthmi myimage.fi source.fs
@end example

Note that the @code{--no-dynamic} is required here for the image to work
(otherwise it will contain references to dynamically generated code that is
not saved in the image).


@node Fully Relocatable Image Files, Stack and Dictionary Sizes, Data-Relocatable Image Files, Image Files
@section Fully Relocatable Image Files
@cindex fully relocatable image files
@cindex image file, fully relocatable

@cindex @file{kern*.fi}, relocatability
@cindex @file{gforth.fi}, relocatability
These image files have relocatable data addresses, and tokens for code
addresses. They can be used with different binaries (e.g., with and without
debugging) on the same machine, and even across machines with the same data
formats (byte order, cell size, floating point format), and they work with
dynamic native code generation.  However, they are usually specific to the
version of Gforth they were created with. The files @file{gforth.fi} and
@file{kernl*.fi} are fully relocatable.

There are two ways to create a fully relocatable image file:

@menu
* gforthmi::                 通常の方法
* cross.fs::                 困難な方法
@end menu

@node gforthmi, cross.fs, Fully Relocatable Image Files, Fully Relocatable Image Files
@subsection @file{gforthmi}
@cindex @file{comp-i.fs}
@cindex @file{gforthmi}

You will usually use @file{gforthmi}. If you want to create an image
@i{file} that contains everything you would load by invoking Gforth with
@code{gforth @i{options}}, you simply say:
@example
gforthmi @i{file} @i{options}
@end example

E.g., if you want to create an image @file{asm.fi} that has the file
@file{asm.fs} loaded in addition to the usual stuff, you could do it like
this:

@example
gforthmi asm.fi asm.fs
@end example

@file{gforthmi} is implemented as a sh script and works like this: It
produces two non-relocatable images for different addresses and then
compares them. Its output reflects this: first you see the output (if any)
of the two Gforth invocations that produce the non-relocatable image files,
then you see the output of the comparing program: It displays the offset
used for data addresses and the offset used for code addresses; moreover,
for each cell that cannot be represented correctly in the image files, it
displays a line like this:

@example
     78DC         BFFFFA50         BFFFFA40
@end example

This means that at offset $78dc from @code{forthstart}, one input image
contains $bffffa50, and the other contains $bffffa40. Since these cells
cannot be represented correctly in the output image, you should examine
these places in the dictionary and verify that these cells are dead (i.e.,
not read before they are written).

@cindex --application, @code{gforthmi} option
If you insert the option @code{--application} in front of the image file
name, you will get an image that uses the @code{--appl-image} option instead
of the @code{--image-file} option (@pxref{Invoking Gforth}). When you
execute such an image on Unix (by typing the image name as command), the
Gforth engine will pass all options to the image instead of trying to
interpret them as engine options.

If you type @file{gforthmi} with no arguments, it prints some usage
instructions.

@cindex @code{savesystem} during @file{gforthmi}
@cindex @code{bye} during @file{gforthmi}
@cindex doubly indirect threaded code
@cindex environment variables
@cindex @code{GFORTHD} -- environment variable
@cindex @code{GFORTH} -- environment variable
@cindex @code{gforth-ditc}
There are a few wrinkles: After processing the passed @i{options}, the words
@code{savesystem} and @code{bye} must be visible. A special doubly indirect
threaded version of the @file{gforth} executable is used for creating the
non-relocatable images; you can pass the exact filename of this executable
through the environment variable @code{GFORTHD} (default:
@file{gforth-ditc}); if you pass a version that is not doubly indirect
threaded, you will not get a fully relocatable image, but a data-relocatable
image (@pxref{Data-Relocatable Image Files}), because there is no code
address offset). The normal @file{gforth} executable is used for creating
the relocatable image; you can pass the exact filename of this executable
through the environment variable @code{GFORTH}.

@node cross.fs, , gforthmi, Fully Relocatable Image Files
@subsection @file{cross.fs}
@cindex @file{cross.fs}
@cindex cross-compiler
@cindex metacompiler
@cindex target compiler

You can also use @code{cross}, a batch compiler that accepts a Forth-like
programming language (@pxref{Cross Compiler}).

@code{cross} allows you to create image files for machines with different
data sizes and data formats than the one used for generating the image
file. You can also use it to create an application image that does not
contain a Forth compiler. These features are bought with restrictions and
inconveniences in programming. E.g., addresses have to be stored in memory
with special words (@code{A!}, @code{A,}, etc.) in order to make the code
relocatable.


@node Stack and Dictionary Sizes, Running Image Files, Fully Relocatable Image Files, Image Files
@section Stack and Dictionary Sizes
@cindex image file, stack and dictionary sizes
@cindex dictionary size default
@cindex stack size default

If you invoke Gforth with a command line flag for the size (@pxref{Invoking
Gforth}), the size you specify is stored in the dictionary. If you save the
dictionary with @code{savesystem} or create an image with @file{gforthmi},
this size will become the default for the resulting image file. E.g., the
following will create a fully relocatable version of @file{gforth.fi} with a
1MB dictionary:

@example
gforthmi gforth.fi -m 1M
@end example

In other words, if you want to set the default size for the dictionary and
the stacks of an image, just invoke @file{gforthmi} with the appropriate
options when creating the image.

@cindex stack size, cache-friendly
Note: For cache-friendly behaviour (i.e., good performance), you should make
the sizes of the stacks modulo, say, 2K, somewhat different. E.g., the
default stack sizes are: data: 16k (mod 2k=0); fp: 15.5k (mod 2k=1.5k);
return: 15k(mod 2k=1k); locals: 14.5k (mod 2k=0.5k).

@node Running Image Files, Modifying the Startup Sequence, Stack and Dictionary Sizes, Image Files
@section Running Image Files
@cindex running image files
@cindex invoking image files
@cindex image file invocation

@cindex -i, invoke image file
@cindex --image file, invoke image file
You can invoke Gforth with an image file @i{image} instead of the default
@file{gforth.fi} with the @code{-i} flag (@pxref{Invoking Gforth}):
@example
gforth -i @i{image}
@end example

@cindex executable image file
@cindex image file, executable
If your operating system supports starting scripts with a line of the form
@code{#! ...}, you just have to type the image file name to start Gforth
with this image file (note that the file extension @code{.fi} is just a
convention). I.e., to run Gforth with the image file @i{image}, you can just
type @i{image} instead of @code{gforth -i @i{image}}.  This works because
every @code{.fi} file starts with a line of this format:

@example
#! /usr/local/bin/gforth-0.4.0 -i
@end example

The file and pathname for the Gforth engine specified on this line is the
specific Gforth executable that it was built against; i.e. the value of the
environment variable @code{GFORTH} at the time that @file{gforthmi} was
executed.

You can make use of the same shell capability to make a Forth source file
into an executable. For example, if you place this text in a file:

@example
#! /usr/local/bin/gforth

." Hello, world" CR
bye
@end example

@noindent
and then make the file executable (chmod +x in Unix), you can run it
directly from the command line. The sequence @code{#!} is used in two ways;
firstly, it is recognised as a ``magic sequence'' by the operating
system@footnote{The Unix kernel actually recognises two types of files:
executable files and files of data, where the data is processed by an
interpreter that is specified on the ``interpreter line'' -- the first line
of the file, starting with the sequence #!. There may be a small limit
(e.g., 32) on the number of characters that may be specified on the
interpreter line.} secondly it is treated as a comment character by
Gforth. Because of the second usage, a space is required between @code{#!}
and the path to the executable (moreover, some Unixes require the sequence
@code{#! /}).

Most Unix systems (including Linux) support exactly one option after the
binary name.  If that is not enough, you can use the following trick:

@example
#! /bin/sh
: ## ; 0 [if]
exec gforth -m 10M -d 1M $0 "$@@"
[then]
." Hello, world" cr
bye \ caution: this prevents (further) processing of "$@@"
@end example

First this script is interpreted as shell script, which treats the first two
lines as (mostly) comments, then performs the third line, which invokes
gforth with this script (@code{$0}) as parameter and its parameters as
additional parameters (@code{"$@@"}).  Then this script is interpreted as
Forth script, which first defines a colon definition @code{##}, then ignores
everything up to @code{[then]} and finally processes the following Forth
code.  You can also use

@example
#0 [if]
@end example

in the second line, but this works only in Gforth-0.7.0 and later.

The @file{gforthmi} approach is the fastest one, the shell-based one is
slowest (needs to start an additional shell).  An additional advantage of
the shell approach is that it is unnecessary to know where the Gforth binary
resides, as long as it is in the @code{$PATH}.

@findex #! ( @var{ --   } ) gforth-0.2
@cindex @code{#!}
@kindex #!
@format
@code{#!} ( @i{--  }) gforth-0.2 ``hash-bang''
@end format
An alias for @code{\}




@node Modifying the Startup Sequence, , Running Image Files, Image Files
@section Modifying the Startup Sequence
@cindex startup sequence for image file
@cindex image file initialization sequence
@cindex initialization sequence of image file

You can add your own initialization to the startup sequence of an image
through the deferred word @code{'cold}. @code{'cold} is invoked just before
the image-specific command line processing (i.e., loading files and
evaluating (@code{-e}) strings) starts.

A sequence for adding your initialization usually looks like this:

@example
:noname
    Defers 'cold \ do other initialization stuff (e.g., rehashing wordlists)
    ... \ your stuff
; IS 'cold
@end example

After @code{'cold}, Gforth processes the image options (@pxref{Invoking
Gforth}), and then it performs @code{bootmessage}, another deferred word.
This normally prints Gforth's startup message and does nothing else.

@cindex turnkey image files
@cindex image file, turnkey applications
So, if you want to make a turnkey image (i.e., an image for an application
instead of an extended Forth system), you can do this in several ways:

@itemize @bullet

@item
If you want to do your interpretation of the OS command-line arguments, hook
into @code{'cold}.  In that case you probably also want to build the image
with @code{gforthmi --application} (@pxref{gforthmi}) to keep the engine
from processing OS command line options.  You can then do your own
command-line processing with @code{next-arg} 

@item
If you want to have the normal Gforth processing of OS command-line
arguments, but specify your own command-line options, hook into
@code{process-option}.

@item
If you want to have more options in addition to the ones that come with
Gforth, define words into the @code{options} vocabulary.

@item
If you want to display your own boot message, hook into @code{bootmessage}.

@end itemize

In either case, you probably do not want the word that you execute in these
hooks to exit normally, but use @code{bye} or @code{throw}.  Otherwise the
Gforth startup process would continue and eventually present the Forth
command line to the user.

@findex 'cold ( @var{ --   } ) gforth-0.2
@cindex @code{'cold}
@kindex 'cold
@format
@code{'cold} ( @i{--  }) gforth-0.2 ``tick-cold''
@end format
Hook (deferred word) for things to do right before interpreting the OS
command-line arguments.  Normally does some initializations that you also
want to perform.


@findex bootmessage ( @var{ --   } ) gforth-0.4
@cindex @code{bootmessage}
@kindex bootmessage
@format
@code{bootmessage} ( @i{--  }) gforth-0.4 ``bootmessage''
@end format
Hook (deferred word) executed right after interpreting the OS command-line
arguments.  Normally prints the Gforth startup message.


doc-'quit
@findex process-option ( @var{ addr u -- true / addr u false   } ) gforth-0.7
@cindex @code{process-option}
@kindex process-option
@format
@code{process-option} ( @i{addr u -- true / addr u false  }) gforth-0.7 ``process-option''
@end format
Process an option @var{addr u}, return true, if the option is processed;
unprocessed options are loaded as files throu @code{required}.



@c ******************************************************************
@node Engine, Cross Compiler, Image Files, Top
@chapter Engine
@cindex engine
@cindex virtual machine

Reading this chapter is not necessary for programming with Gforth. It may be
helpful for finding your way in the Gforth sources.

The ideas in this section have also been published in the following papers:
Bernd Paysan, @cite{ANS fig/GNU/??? Forth} (in German), Forth-Tagung '93;
M. Anton Ertl,
@cite{@uref{https://www.complang.tuwien.ac.at/papers/ertl93.ps.Z, A Portable
Forth Engine}}, EuroForth '93; M. Anton Ertl,
@cite{@uref{https://www.complang.tuwien.ac.at/papers/ertl02.ps.gz, Threaded
code variations and optimizations (extended version)}}, Forth-Tagung '02.

@menu
* Portability::
* Threading::
* Primitives::
* Performance::              
@end menu

@node Portability, Threading, Engine, Engine
@section Portability
@cindex engine portability

An important goal of the Gforth Project is availability across a wide range
of personal machines. fig-Forth, and, to a lesser extent, F83, achieved this
goal by manually coding the engine in assembly language for several
then-popular processors. This approach is very labor-intensive and the
results are short-lived due to progress in computer architecture.

@cindex C, using C for the engine
Others have avoided this problem by coding in C, e.g., Mitch Bradley
(cforth), Mikael Patel (TILE) and Dirk Zoller (pfe). This approach is
particularly popular for UNIX-based Forths due to the large variety of
architectures of UNIX machines. Unfortunately an implementation in C does
not mix well with the goals of efficiency and with using traditional
techniques: Indirect or direct threading cannot be expressed in C, and
switch threading, the fastest technique available in C, is significantly
slower. Another problem with C is that it is very cumbersome to express
double integer arithmetic.

@cindex GNU C for the engine
@cindex long long
Fortunately, there is a portable language that does not have these
limitations: GNU C, the version of C processed by the GNU C compiler
(@pxref{C Extensions, , Extensions to the C Language Family, gcc, GNU C
Manual}). Its labels as values feature (@pxref{Labels as Values, , Labels as
Values, gcc, GNU C Manual}) makes direct and indirect threading possible,
its @code{long long} type (@pxref{Long Long, , Double-Word Integers, gcc,
GNU C Manual}) corresponds to Forth's double numbers on many systems.  GNU C
is freely available on all important (and many unimportant) UNIX machines,
VMS, 80386s running MS-DOS, the Amiga, and the Atari ST, so a Forth written
in GNU C can run on all these machines.

Writing in a portable language has the reputation of producing code that is
slower than assembly. For our Forth engine we repeatedly looked at the code
produced by the compiler and eliminated most compiler-induced inefficiencies
by appropriate changes in the source code.

@cindex explicit register declarations
@cindex --enable-force-reg, configuration flag
@cindex -DFORCE_REG
However, register allocation cannot be portably influenced by the
programmer, leading to some inefficiencies on register-starved machines. We
use explicit register declarations (@pxref{Explicit Reg Vars, , Variables in
Specified Registers, gcc, GNU C Manual}) to improve the speed on some
machines. They are turned on by using the configuration flag
@code{--enable-force-reg} (@code{gcc} switch
@code{-DFORCE_REG}). Unfortunately, this feature not only depends on the
machine, but also on the compiler version: On some machines some compiler
versions produce incorrect code when certain explicit register declarations
are used. So by default @code{-DFORCE_REG} is not used.

@node Threading, Primitives, Portability, Engine
@section Threading
@cindex inner interpreter implementation
@cindex threaded code implementation

@cindex labels as values
GNU C's labels as values extension (available since @code{gcc-2.0},
@pxref{Labels as Values, , Labels as Values, gcc, GNU C Manual})  makes it
possible to take the address of @i{label} by writing @code{&&@i{label}}.
This address can then be used in a statement like @code{goto
*@i{address}}. I.e., @code{goto *&&x} is the same as @code{goto x}.

@cindex @code{NEXT}, indirect threaded
@cindex indirect threaded inner interpreter
@cindex inner interpreter, indirect threaded
With this feature an indirect threaded @code{NEXT} looks like:
@example
cfa = *ip++;
ca = *cfa;
goto *ca;
@end example
@cindex instruction pointer
For those unfamiliar with the names: @code{ip} is the Forth instruction
pointer; the @code{cfa} (code-field address) corresponds to Standard Forth's
execution token and points to the code field of the next word to be
executed; The @code{ca} (code address) fetched from there points to some
executable code, e.g., a primitive or the colon definition handler
@code{docol}.

@cindex @code{NEXT}, direct threaded
@cindex direct threaded inner interpreter
@cindex inner interpreter, direct threaded
Direct threading is even simpler:
@example
ca = *ip++;
goto *ca;
@end example

Of course we have packaged the whole thing neatly in macros called
@code{NEXT} and @code{NEXT1} (the part of @code{NEXT} after fetching the
cfa).

@menu
* Scheduling::
* Direct or Indirect Threaded?::
* Dynamic Superinstructions::
* DOES>::                    
@end menu

@node Scheduling, Direct or Indirect Threaded?, Threading, Threading
@subsection Scheduling
@cindex inner interpreter optimization

There is a little complication: Pipelined and superscalar processors, i.e.,
RISC and some modern CISC machines can process independent instructions
while waiting for the results of an instruction. The compiler usually
reorders (schedules) the instructions in a way that achieves good usage of
these delay slots. However, on our first tries the compiler did not do well
on scheduling primitives. E.g., for @code{+} implemented as
@example
n=sp[0]+sp[1];
sp++;
sp[0]=n;
NEXT;
@end example
the @code{NEXT} comes strictly after the other code, i.e., there is nearly
no scheduling. After a little thought the problem becomes clear: The
compiler cannot know that @code{sp} and @code{ip} point to different
addresses (and the version of @code{gcc} we used would not know it even if
it was possible), so it could not move the load of the cfa above the store
to the TOS. Indeed the pointers could be the same, if code on or very near
the top of stack were executed. In the interest of speed we chose to forbid
this probably unused ``feature'' and helped the compiler in scheduling:
@code{NEXT} is divided into several parts: @code{NEXT_P0}, @code{NEXT_P1}
and @code{NEXT_P2}). @code{+} now looks like:
@example
NEXT_P0;
n=sp[0]+sp[1];
sp++;
NEXT_P1;
sp[0]=n;
NEXT_P2;
@end example

There are various schemes that distribute the different operations of NEXT
between these parts in several ways; in general, different schemes perform
best on different processors.  We use a scheme for most architectures that
performs well for most processors of this architecture; in the future we may
switch to benchmarking and chosing the scheme on installation time.


@node Direct or Indirect Threaded?, Dynamic Superinstructions, Scheduling, Threading
@subsection Direct or Indirect Threaded?
@cindex threading, direct or indirect?

Threaded forth code consists of references to primitives (simple machine
code routines like @code{+}) and to non-primitives (e.g., colon definitions,
variables, constants); for a specific class of non-primitives (e.g.,
variables) there is one code routine (e.g., @code{dovar}), but each variable
needs a separate reference to its data.

Traditionally Forth has been implemented as indirect threaded code, because
this allows to use only one cell to reference a non-primitive (basically you
point to the data, and find the code address there).

@cindex primitive-centric threaded code
However, threaded code in Gforth (since 0.6.0) uses two cells for
non-primitives, one for the code address, and one for the data address; the
data pointer is an immediate argument for the virtual machine instruction
represented by the code address.  We call this @emph{primitive-centric}
threaded code, because all code addresses point to simple primitives.  E.g.,
for a variable, the code address is for @code{lit} (also used for integer
literals like @code{99}).

Primitive-centric threaded code allows us to use (faster) direct threading
as dispatch method, completely portably (direct threaded code in Gforth
before 0.6.0 required architecture-specific code).  It also eliminates the
performance problems related to I-cache consistency that 386 implementations
have with direct threaded code, and allows additional optimizations.

@cindex hybrid direct/indirect threaded code
There is a catch, however: the @var{xt} parameter of @code{execute} can
occupy only one cell, so how do we pass non-primitives with their code
@emph{and} data addresses to them? Our answer is to use indirect threaded
dispatch for @code{execute} and other words that use a single-cell xt.  So,
normal threaded code in colon definitions uses direct threading, and
@code{execute} and similar words, which dispatch to xts on the data stack,
use indirect threaded code.  We call this @emph{hybrid direct/indirect}
threaded code.

@cindex engines, gforth vs.@: gforth-fast vs.@: gforth-itc
@cindex gforth engine
@cindex gforth-fast engine
The engines @command{gforth} and @command{gforth-fast} use hybrid
direct/indirect threaded code.  This means that with these engines you
cannot use @code{,} to compile an xt.  Instead, you have to use
@code{compile,}.

@cindex gforth-itc engine
If you want to compile xts with @code{,}, use @command{gforth-itc}.  This
engine uses plain old indirect threaded code.  It still compiles in a
primitive-centric style, so you cannot use @code{compile,} instead of
@code{,} (e.g., for producing tables of xts with @code{] word1 word2
... [}).  If you want to do that, you have to use @command{gforth-itc} and
execute @code{' , is compile,}.  Your program can check if it is running on
a hybrid direct/indirect threaded engine or a pure indirect threaded engine
with @code{threading-method} (@pxref{Threading Words}).


@node Dynamic Superinstructions, DOES>, Direct or Indirect Threaded?, Threading
@subsection Dynamic Superinstructions
@cindex Dynamic superinstructions with replication
@cindex Superinstructions
@cindex Replication

The engines @command{gforth} and @command{gforth-fast} use another
optimization: Dynamic superinstructions with replication.  As an example,
consider the following colon definition:

@example
: squared ( n1 -- n2 )
  dup * ;
@end example

Gforth compiles this into the threaded code sequence

@example
dup
*
;s
@end example

Use @code{simple-see} (@pxref{Examining compiled code}) to see the threaded
code of a colon definition.

In normal direct threaded code there is a code address occupying one cell
for each of these primitives.  Each code address points to a machine code
routine, and the interpreter jumps to this machine code in order to execute
the primitive.  The routines for these three primitives are (in
@command{gforth-fast} on the 386):

@example
Code dup  
( $804B950 )  add     esi , # -4  \ $83 $C6 $FC 
( $804B953 )  add     ebx , # 4  \ $83 $C3 $4 
( $804B956 )  mov     dword ptr 4 [esi] , ecx  \ $89 $4E $4 
( $804B959 )  jmp     dword ptr FC [ebx]  \ $FF $63 $FC 
end-code
Code *  
( $804ACC4 )  mov     eax , dword ptr 4 [esi]  \ $8B $46 $4 
( $804ACC7 )  add     esi , # 4  \ $83 $C6 $4 
( $804ACCA )  add     ebx , # 4  \ $83 $C3 $4 
( $804ACCD )  imul    ecx , eax  \ $F $AF $C8 
( $804ACD0 )  jmp     dword ptr FC [ebx]  \ $FF $63 $FC 
end-code
Code ;s  
( $804A693 )  mov     eax , dword ptr [edi]  \ $8B $7 
( $804A695 )  add     edi , # 4  \ $83 $C7 $4 
( $804A698 )  lea     ebx , dword ptr 4 [eax]  \ $8D $58 $4 
( $804A69B )  jmp     dword ptr FC [ebx]  \ $FF $63 $FC 
end-code
@end example

With dynamic superinstructions and replication the compiler does not just
lay down the threaded code, but also copies the machine code fragments,
usually without the jump at the end.

@example
( $4057D27D )  add     esi , # -4  \ $83 $C6 $FC 
( $4057D280 )  add     ebx , # 4  \ $83 $C3 $4 
( $4057D283 )  mov     dword ptr 4 [esi] , ecx  \ $89 $4E $4 
( $4057D286 )  mov     eax , dword ptr 4 [esi]  \ $8B $46 $4 
( $4057D289 )  add     esi , # 4  \ $83 $C6 $4 
( $4057D28C )  add     ebx , # 4  \ $83 $C3 $4 
( $4057D28F )  imul    ecx , eax  \ $F $AF $C8 
( $4057D292 )  mov     eax , dword ptr [edi]  \ $8B $7 
( $4057D294 )  add     edi , # 4  \ $83 $C7 $4 
( $4057D297 )  lea     ebx , dword ptr 4 [eax]  \ $8D $58 $4 
( $4057D29A )  jmp     dword ptr FC [ebx]  \ $FF $63 $FC 
@end example

Only when a threaded-code control-flow change happens (e.g., in @code{;s}),
the jump is appended.  This optimization eliminates many of these jumps and
makes the rest much more predictable.  The speedup depends on the processor
and the application; on the Athlon and Pentium III this optimization
typically produces a speedup by a factor of 2.

The code addresses in the direct-threaded code are set to point to the
appropriate points in the copied machine code, in this example like this:

@example
primitive  code address
   dup       $4057D27D
   *         $4057D286
   ;s        $4057D292
@end example

Thus there can be threaded-code jumps to any place in this piece of code.
This also simplifies decompilation quite a bit.

@code{See-code} (@pxref{Examining compiled code}) shows the threaded code
intermingled with the native code of dynamic superinstructions.  These days
some additional optimizations are applied for the dynamically-generated
native code, so the output of @code{see-code squared} on @code{gforth-fast}
on one particular AMD64 installation looks like this:

@example
$7FB689C678C8 dup    1->2 
7FB68990C1B2:   mov     r15,r8
$7FB689C678D0 *    2->1 
7FB68990C1B5:   imul    r8,r15
$7FB689C678D8 ;s    1->1 
7FB68990C1B9:   mov     rbx,[r14]
7FB68990C1BC:   add     r14,$08
7FB68990C1C0:   mov     rax,[rbx]
7FB68990C1C3:   jmp     eax
@end example

@cindex --no-dynamic command-line option
@cindex --no-super command-line option
You can disable this optimization with @option{--no-dynamic}.  You can use
the copying without eliminating the jumps (i.e., dynamic replication, but
without superinstructions) with @option{--no-super}; this gives the branch
prediction benefit alone; the effect on performance depends on the CPU; on
the Athlon and Pentium III the speedup is a little less than for dynamic
superinstructions with replication.

@cindex patching threaded code
One use of these options is if you want to patch the threaded code.  With
superinstructions, many of the dispatch jumps are eliminated, so patching
often has no effect.  These options preserve all the dispatch jumps.

@cindex --dynamic command-line option
On some machines dynamic superinstructions are disabled by default, because
it is unsafe on these machines.  However, if you feel adventurous, you can
enable it with @option{--dynamic}.

@node DOES>, , Dynamic Superinstructions, Threading
@subsection DOES>
@cindex @code{DOES>} implementation

@cindex @code{dodoes} routine
@cindex @code{DOES>}-code
One of the most complex parts of a Forth engine is @code{dodoes}, i.e., the
chunk of code executed by every word defined by a
@code{CREATE}...@code{DOES>} pair; actually with primitive-centric code,
this is only needed if the xt of the word is @code{execute}d. The main
problem here is: How to find the Forth code to be executed, i.e. the code
after the @code{DOES>} (the @code{DOES>}-code)? There are two solutions:

In fig-Forth the code field points directly to the @code{dodoes} and the
@code{DOES>}-code address is stored in the cell after the code address
(i.e. at @code{@i{CFA} cell+}). It may seem that this solution is illegal in
the Forth-79 and all later standards, because in fig-Forth this address lies
in the body (which is illegal in these standards). However, by making the
code field larger for all words this solution becomes legal again.  We use
this approach.  Leaving a cell unused in most words is a bit wasteful, but
on the machines we are targeting this is hardly a problem.


@node Primitives, Performance, Threading, Engine
@section Primitives
@cindex primitives, implementation
@cindex virtual machine instructions, implementation

@menu
* Automatic Generation::
* TOS Optimization::
* Produced code::            
@end menu

@node Automatic Generation, TOS Optimization, Primitives, Primitives
@subsection Automatic Generation
@cindex primitives, automatic generation

@cindex @file{prims2x.fs}

Since the primitives are implemented in a portable language, there is no
longer any need to minimize the number of primitives. On the contrary,
having many primitives has an advantage: speed. In order to reduce the
number of errors in primitives and to make programming them easier, we
provide a tool, the primitive generator (@file{prims2x.fs} aka Vmgen,
@pxref{Top, Vmgen, Introduction, vmgen, Vmgen}), that automatically
generates most (and sometimes all) of the C code for a primitive from the
stack effect notation.  The source for a primitive has the following form:

@cindex primitive source format
@format
@i{Forth-name}  ( @i{stack-effect} )        @i{category}    [@i{pronounc.}]
[@code{""}@i{glossary entry}@code{""}]
@i{C code}
[@code{:}
@i{Forth code}]
@end format

The items in brackets are optional. The category and glossary fields are
there for generating the documentation, the Forth code is there for manual
implementations on machines without GNU C. E.g., the source for the
primitive @code{+} is:
@example
+    ( n1 n2 -- n )   core    plus
n = n1+n2;
@end example

This looks like a specification, but in fact @code{n = n1+n2} is C code. Our
primitive generation tool extracts a lot of information from the stack
effect notations@footnote{We use a one-stack notation, even though we have
separate data and floating-point stacks; The separate notation can be
generated easily from the unified notation.}: The number of items popped
from and pushed on the stack, their type, and by what name they are referred
to in the C code. It then generates a C code prelude and postlude for each
primitive. The final C code for @code{+} looks like this:

@example
I_plus: /* + ( n1 n2 -- n ) */  /* label, stack effect */
/*  */                          /* documentation */
NAME("+")                       /* debugging output (with -DDEBUG) */
@{
DEF_CA                          /* definition of variable ca (indirect threading) */
Cell n1;                        /* definitions of variables */
Cell n2;
Cell n;
NEXT_P0;                        /* NEXT part 0 */
n1 = (Cell) sp[1];              /* input */
n2 = (Cell) TOS;
sp += 1;                        /* stack adjustment */
@{
n = n1+n2;                      /* C code taken from the source */
@}
NEXT_P1;                        /* NEXT part 1 */
TOS = (Cell)n;                  /* output */
NEXT_P2;                        /* NEXT part 2 */
@}
@end example

This looks long and inefficient, but the GNU C compiler optimizes quite well
and produces optimal code for @code{+} on, e.g., the R3000 and the HP RISC
machines: Defining the @code{n}s does not produce any code, and using them
as intermediate storage also adds no cost.

There are also other optimizations that are not illustrated by this example:
assignments between simple variables are usually for free (copy
propagation). If one of the stack items is not used by the primitive (e.g.
in @code{drop}), the compiler eliminates the load from the stack (dead code
elimination). On the other hand, there are some things that the compiler
does not do, therefore they are performed by @file{prims2x.fs}: The compiler
does not optimize code away that stores a stack item to the place where it
just came from (e.g., @code{over}).

While programming a primitive is usually easy, there are a few cases where
the programmer has to take the actions of the generator into account, most
notably @code{?dup}, but also words that do not (always)  fall through to
@code{NEXT}.

For more information

@node TOS Optimization, Produced code, Automatic Generation, Primitives
@subsection TOS Optimization
@cindex TOS optimization for primitives
@cindex primitives, keeping the TOS in a register

An important optimization for stack machine emulators, e.g., Forth engines,
is keeping one or more of the top stack items in registers.  If a word has
the stack effect @i{in1}...@i{inx} @code{--} @i{out1}...@i{outy}, keeping
the top @i{n} items in registers
@itemize @bullet
@item
is better than keeping @i{n-1} items, if @i{x>=n} and @i{y>=n}, due to fewer
loads from and stores to the stack.
@item is slower than keeping @i{n-1} items, if @i{x<>y} and @i{x<n} and
@i{y<n}, due to additional moves between registers.
@end itemize

@cindex -DUSE_TOS
@cindex -DUSE_NO_TOS
In particular, keeping one item in a register is never a disadvantage, if
there are enough registers. Keeping two items in registers is a disadvantage
for frequent words like @code{?branch}, constants, variables, literals and
@code{i}. Therefore our generator only produces code that keeps zero or one
items in registers. The generated C code covers both cases; the selection
between these alternatives is made at C-compile time using the switch
@code{-DUSE_TOS}. @code{TOS} in the C code for @code{+} is just a simple
variable name in the one-item case, otherwise it is a macro that expands
into @code{sp[0]}. Note that the GNU C compiler tries to keep simple
variables like @code{TOS} in registers, and it usually succeeds, if there
are enough registers.

@cindex -DUSE_FTOS
@cindex -DUSE_NO_FTOS
The primitive generator performs the TOS optimization for the floating-point
stack, too (@code{-DUSE_FTOS}). For floating-point operations the benefit of
this optimization is even larger: floating-point operations take quite long
on most processors, but can be performed in parallel with other operations
as long as their results are not used. If the FP-TOS is kept in a register,
this works. If it is kept on the stack, i.e., in memory, the store into
memory has to wait for the result of the floating-point operation,
lengthening the execution time of the primitive considerably.

The TOS optimization makes the automatic generation of primitives a bit more
complicated. Just replacing all occurrences of @code{sp[0]} by @code{TOS} is
not sufficient. There are some special cases to consider:
@itemize @bullet
@item In the case of @code{dup ( w -- w w )} the generator must not
eliminate the store to the original location of the item on the stack, if
the TOS optimization is turned on.
@item Primitives with stack effects of the form @code{--}
@i{out1}...@i{outy} must store the TOS to the stack at the start.  Likewise,
primitives with the stack effect @i{in1}...@i{inx} @code{--} must load the
TOS from the stack at the end. But for the null stack effect @code{--} no
stores or loads should be generated.
@end itemize

@node Produced code, , TOS Optimization, Primitives
@subsection Produced code
@cindex primitives, assembly code listing

@cindex @file{engine.s}
To see what assembly code is produced for the primitives on your machine
with your compiler and your flag settings, type @code{make engine.s} and
look at the resulting file @file{engine.s}.  Alternatively, you can also
disassemble the code of primitives with @code{see} on some architectures.

@node Performance, , Primitives, Engine
@section Performance
@cindex performance of some Forth interpreters
@cindex engine performance
@cindex benchmarking Forth systems
@cindex Gforth performance

On RISCs the Gforth engine is very close to optimal; i.e., it is usually
impossible to write a significantly faster threaded-code engine.

On register-starved machines like the 386 architecture processors
improvements are possible, because @code{gcc} does not utilize the registers
as well as a human, even with explicit register declarations; e.g., Bernd
Beuster wrote a Forth system fragment in assembly language and hand-tuned it
for the 486; this system is 1.19 times faster on the Sieve benchmark on a
486DX2/66 than Gforth compiled with @code{gcc-2.6.3} with
@code{-DFORCE_REG}.  The situation has improved with gcc-2.95 and
gforth-0.4.9; now the most important virtual machine registers fit in real
registers (and we can even afford to use the TOS optimization), resulting in
a speedup of 1.14 on the sieve over the earlier results.  And dynamic
superinstructions provide another speedup (but only around a factor 1.2 on
the 486).

@cindex Win32Forth performance
@cindex NT Forth performance
@cindex eforth performance
@cindex ThisForth performance
@cindex PFE performance
@cindex TILE performance
The potential advantage of assembly language implementations is not
necessarily realized in complete Forth systems: We compared Gforth-0.5.9
(direct threaded, compiled with @code{gcc-2.95.1} and @code{-DFORCE_REG})
with Win32Forth 1.2093 (newer versions are reportedly much faster), LMI's NT
Forth (Beta, May 1994) and Eforth (with and without peephole (aka pinhole)
optimization of the threaded code); all these systems were written in
assembly language. We also compared Gforth with three systems written in C:
PFE-0.9.14 (compiled with @code{gcc-2.6.3} with the default configuration
for Linux: @code{-O2 -fomit-frame-pointer -DUSE_REGS -DUNROLL_NEXT}),
ThisForth Beta (compiled with @code{gcc-2.6.3 -O3 -fomit-frame-pointer};
ThisForth employs peephole optimization of the threaded code) and TILE
(compiled with @code{make opt}). We benchmarked Gforth, PFE, ThisForth and
TILE on a 486DX2/66 under Linux. Kenneth O'Heskin kindly provided the
results for Win32Forth and NT Forth on a 486DX2/66 with similar memory
performance under Windows NT. Marcel Hendrix ported Eforth to Linux, then
extended it to run the benchmarks, added the peephole optimizer, ran the
benchmarks and reported the results.

We used four small benchmarks: the ubiquitous Sieve; bubble-sorting and
matrix multiplication come from the Stanford integer benchmarks and have
been translated into Forth by Martin Fraeman; we used the versions included
in the TILE Forth package, but with bigger data set sizes; and a recursive
Fibonacci number computation for benchmarking calling performance. The
following table shows the time taken for the benchmarks scaled by the time
taken by Gforth (in other words, it shows the speedup factor that Gforth
achieved over the other systems).

@example
relative       Win32-    NT       eforth       This-      
time     Gforth Forth Forth eforth  +opt   PFE Forth  TILE
sieve      1.00  2.16  1.78   2.16  1.32  2.46  4.96 13.37
bubble     1.00  1.93  2.07   2.18  1.29  2.21        5.70
matmul     1.00  1.92  1.76   1.90  0.96  2.06        5.32
fib        1.00  2.32  2.03   1.86  1.31  2.64  4.55  6.54
@end example

You may be quite surprised by the good performance of Gforth when compared
with systems written in assembly language. One important reason for the
disappointing performance of these other systems is probably that they are
not written optimally for the 486 (e.g., they use the @code{lods}
instruction). In addition, Win32Forth uses a comfortable, but costly method
for relocating the Forth image: like @code{cforth}, it computes the actual
addresses at run time, resulting in two address computations per @code{NEXT}
(@pxref{Image File Background}).

The speedup of Gforth over PFE, ThisForth and TILE can be easily explained
with the self-imposed restriction of the latter systems to standard C, which
makes efficient threading impossible (however, the measured implementation
of PFE uses a GNU C extension: @pxref{Global Reg Vars, , Defining Global
Register Variables, gcc, GNU C Manual}).  Moreover, current C compilers have
a hard time optimizing other aspects of the ThisForth and the TILE source.

The performance of Gforth on 386 architecture processors varies widely with
the version of @code{gcc} used. E.g., @code{gcc-2.5.8} failed to allocate
any of the virtual machine registers into real machine registers by itself
and would not work correctly with explicit register declarations, giving a
significantly slower engine (on a 486DX2/66 running the Sieve) than the one
measured above.

Note that there have been several releases of Win32Forth since the release
presented here, so the results presented above may have little predictive
value for the performance of Win32Forth today (results for the current
release on an i486DX2/66 are welcome).

@cindex @file{Benchres}
In
@cite{@uref{https://www.complang.tuwien.ac.at/papers/ertl&maierhofer95.ps.gz,
Translating Forth to Efficient C}} by M. Anton Ertl and Martin Maierhofer
(presented at EuroForth '95), an indirect threaded version of Gforth is
compared with Win32Forth, NT Forth, PFE, ThisForth, and several native code
systems; that version of Gforth is slower on a 486 than the version used
here. You can find a newer version of these measurements at
@uref{https://www.complang.tuwien.ac.at/forth/performance.html}. You can
find numbers for Gforth on various machines in @file{Benchres}.

@c ******************************************************************
@c @node Binding to System Library, Cross Compiler, Engine, Top
@c @chapter Binding to System Library

@c ****************************************************************
@node Cross Compiler, MINOS2, Engine, Top
@chapter Cross Compiler
@cindex @file{cross.fs}
@cindex cross-compiler
@cindex metacompiler
@cindex target compiler

The cross compiler is used to bootstrap a Forth kernel. Since Gforth is
mostly written in Forth, including crucial parts like the outer interpreter
and compiler, it needs compiled Forth code to get started. The cross
compiler allows to create new images for other architectures, even running
under another Forth system.

@menu
* Using the Cross Compiler::
* How the Cross Compiler Works::  
@end menu

@node Using the Cross Compiler, How the Cross Compiler Works, Cross Compiler, Cross Compiler
@section Using the Cross Compiler

The cross compiler uses a language that resembles Forth, but isn't. The main
difference is that you can execute Forth code after definition, while you
usually can't execute the code compiled by cross, because the code you are
compiling is typically for a different computer than the one you are
compiling on.

@c anton: This chapter is somewhat different from waht I would expect: I
@c would expect an explanation of the cross language and how to create an
@c application image with it.  The section explains some aspects of
@c creating a Gforth kernel.

The Makefile is already set up to allow you to create kernels for new
architectures with a simple make command. The generic kernels using the GCC
compiled virtual machine are created in the normal build process with
@code{make}. To create a embedded Gforth executable for e.g. the 8086
processor (running on a DOS machine), type

@example
make kernl-8086.fi
@end example

This will use the machine description from the @file{arch/8086} directory to
create a new kernel. A machine file may look like that:

@example
\ Parameter for target systems                         06oct92py

    4 Constant cell             \ cell size in bytes
    2 Constant cell<<           \ cell shift to bytes
    5 Constant cell>bit         \ cell shift to bits
    8 Constant bits/char        \ bits per character
    8 Constant bits/byte        \ bits per byte [default: 8]
    8 Constant float            \ bytes per float
    8 Constant /maxalign        \ maximum alignment in bytes
false Constant bigendian        \ byte order
( true=big, false=little )

include machpc.fs               \ feature list
@end example

This part is obligatory for the cross compiler itself, the feature list is
used by the kernel to conditionally compile some features in and out,
depending on whether the target supports these features.

There are some optional features, if you define your own primitives, have an
assembler, or need special, nonstandard preparation to make the boot process
work. @code{asm-include} includes an assembler, @code{prims-include}
includes primitives, and @code{>boot} prepares for booting.

@example
: asm-include    ." Include assembler" cr
  s" arch/8086/asm.fs" included ;

: prims-include  ." Include primitives" cr
  s" arch/8086/prim.fs" included ;

: >boot          ." Prepare booting" cr
  s" ' boot >body into-forth 1+ !" evaluate ;
@end example

These words are used as sort of macro during the cross compilation in the
file @file{kernel/main.fs}. Instead of using these macros, it would be
possible --- but more complicated --- to write a new kernel project file,
too.

@file{kernel/main.fs} expects the machine description file name on the
stack; the cross compiler itself (@file{cross.fs}) assumes that either
@code{mach-file} leaves a counted string on the stack, or
@code{machine-file} leaves an address, count pair of the filename on the
stack.

The feature list is typically controlled using @code{SetValue}, generic
files that are used by several projects can use @code{DefaultValue}
instead. Both functions work like @code{Value}, when the value isn't
defined, but @code{SetValue} works like @code{to} if the value is defined,
and @code{DefaultValue} doesn't set anything, if the value is defined.

@example
\ generic mach file for pc gforth                       03sep97jaw

true DefaultValue NIL  \ relocating

>ENVIRON

true DefaultValue file          \ controls the presence of the
                                \ file access wordset
true DefaultValue OS            \ flag to indicate a operating system

true DefaultValue prims         \ true: primitives are c-code

true DefaultValue floating      \ floating point wordset is present

true DefaultValue glocals       \ gforth locals are present
                                \ will be loaded
true DefaultValue dcomps        \ double number comparisons

true DefaultValue hash          \ hashing primitives are loaded/present

true DefaultValue xconds        \ used together with glocals,
                                \ special conditionals supporting gforths'
                                \ local variables
true DefaultValue header        \ save a header information

true DefaultValue backtrace     \ enables backtrace code

false DefaultValue ec
false DefaultValue crlf

cell 2 = [IF] &32 [ELSE] &256 [THEN] KB DefaultValue kernel-size

&16 KB          DefaultValue stack-size
&15 KB &512 +   DefaultValue fstack-size
&15 KB          DefaultValue rstack-size
&14 KB &512 +   DefaultValue lstack-size
@end example

@node How the Cross Compiler Works, , Using the Cross Compiler, Cross Compiler
@section How the Cross Compiler Works

@node MINOS2, Bugs, Cross Compiler, Top
@chapter MINOS2, a GUI library

@menu
* MINOS2 object framework::
* MINOS2 tutorial::          
@end menu

@node MINOS2 object framework, MINOS2 tutorial, MINOS2, MINOS2
@section MINOS2 object framework

@menu
* actor methods::
* widget methods::           
@end menu

MINOS2 is a GUI library, written in @file{mini-oof2.fs}'s object model.  It
has two main class hierarchies:

@findex actor ( @var{ -- class   } ) minos2
@cindex @code{actor}
@kindex actor
@format
@code{actor} ( @i{-- class  }) minos2 ``actor''
@end format
class for the actions bound to a component.


@findex widget ( @var{ -- class   } ) minos2
@cindex @code{widget}
@kindex widget
@format
@code{widget} ( @i{-- class  }) minos2 ``widget''
@end format
class for visual components



@node actor methods, widget methods, MINOS2 object framework, MINOS2 object framework
@subsection @code{actor} methods:

@findex caller-w ( @var{ -- optr   } ) minos2
@cindex @code{caller-w}
@kindex caller-w
@format
@code{caller-w} ( @i{-- optr  }) minos2 ``caller-w''
@end format
pointer back to the widget embedding the actor


@findex active-w ( @var{ -- optr   } ) minos2
@cindex @code{active-w}
@kindex active-w
@format
@code{active-w} ( @i{-- optr  }) minos2 ``active-w''
@end format
pointer to the active subwidget embedding the actor


@findex act-name$ ( @var{ -- addr u   } ) minos2
@cindex @code{act-name$}
@kindex act-name$
@format
@code{act-name$} ( @i{-- addr u  }) minos2 ``act-name-string''
@end format
Debugging aid: name of the actor


@findex clicked ( @var{ rx ry bmask n --   } ) minos2
@cindex @code{clicked}
@kindex clicked
@format
@code{clicked} ( @i{rx ry bmask n --  }) minos2 ``clicked''
@end format
processed clicks


@findex scrolled ( @var{ axis dir --   } ) minos2
@cindex @code{scrolled}
@kindex scrolled
@format
@code{scrolled} ( @i{axis dir --  }) minos2 ``scrolled''
@end format
process scrolling


@findex touchdown ( @var{ $rxy*n bmask --   } ) minos2
@cindex @code{touchdown}
@kindex touchdown
@format
@code{touchdown} ( @i{$rxy*n bmask --  }) minos2 ``touchdown''
@end format
raw click down


@findex touchup ( @var{ $rxy*n bmask --   } ) minos2
@cindex @code{touchup}
@kindex touchup
@format
@code{touchup} ( @i{$rxy*n bmask --  }) minos2 ``touchup''
@end format
raw click up


@findex ukeyed ( @var{ addr u --   } ) minos2
@cindex @code{ukeyed}
@kindex ukeyed
@format
@code{ukeyed} ( @i{addr u --  }) minos2 ``ukeyed''
@end format
key event, string of printable unicode characters


@findex ekeyed ( @var{ ekey --   } ) minos2
@cindex @code{ekeyed}
@kindex ekeyed
@format
@code{ekeyed} ( @i{ekey --  }) minos2 ``ekeyed''
@end format
key event, non-printable key


@findex ?inside ( @var{ rx ry -- act / 0   } ) minos2
@cindex @code{?inside}
@kindex ?inside
@format
@code{?inside} ( @i{rx ry -- act / 0  }) minos2 ``query-inside''
@end format
check if coordinates are inside the widget


@findex focus ( @var{ --   } ) minos2
@cindex @code{focus}
@kindex focus
@format
@code{focus} ( @i{--  }) minos2 ``focus''
@end format
put widget into focus


@findex defocus ( @var{ --   } ) minos2
@cindex @code{defocus}
@kindex defocus
@format
@code{defocus} ( @i{--  }) minos2 ``defocus''
@end format
put widget out of focus


@findex entered ( @var{ --   } ) minos2
@cindex @code{entered}
@kindex entered
@format
@code{entered} ( @i{--  }) minos2 ``entered''
@end format
react on cursor entering the widget area


@findex left ( @var{ --   } ) minos2
@cindex @code{left}
@kindex left
@format
@code{left} ( @i{--  }) minos2 ``left''
@end format
react on cursor leaving the widget area


@findex show ( @var{ --   } ) minos2
@cindex @code{show}
@kindex show
@format
@code{show} ( @i{--  }) minos2 ``show''
@end format
widget is shown


@findex hide ( @var{ --   } ) minos2
@cindex @code{hide}
@kindex hide
@format
@code{hide} ( @i{--  }) minos2 ``hide''
@end format
widget is hidden


@findex get ( @var{ -- something   } ) minos2
@cindex @code{get}
@kindex get
@format
@code{get} ( @i{-- something  }) minos2 ``get''
@end format
getter for the value behind the widget


@findex set ( @var{ something --   } ) minos2
@cindex @code{set}
@kindex set
@format
@code{set} ( @i{something --  }) minos2 ``set''
@end format
setter for the value behind the widget


@findex show-you ( @var{ --   } ) minos2
@cindex @code{show-you}
@kindex show-you
@format
@code{show-you} ( @i{--  }) minos2 ``show-you''
@end format
make widget visible



@node widget methods, , actor methods, MINOS2 object framework
@subsection @code{widget} methods:

@findex parent-w ( @var{ -- optr   } ) minos2
@cindex @code{parent-w}
@kindex parent-w
@format
@code{parent-w} ( @i{-- optr  }) minos2 ``parent-w''
@end format
pointer to parent widget


@findex act ( @var{ -- optr   } ) minos2
@cindex @code{act}
@kindex act
@format
@code{act} ( @i{-- optr  }) minos2 ``act''
@end format
pointer to actor


@findex name$ ( @var{ -- addr u   } ) minos2
@cindex @code{name$}
@kindex name$
@format
@code{name$} ( @i{-- addr u  }) minos2 ``name-string''
@end format
Widget name for debugging and searching


@findex x ( @var{ -- r   } ) minos2
@cindex @code{x}
@kindex x
@format
@code{x} ( @i{-- r  }) minos2 ``x''
@end format
widget x coordinate


@findex y ( @var{ -- r   } ) minos2
@cindex @code{y}
@kindex y
@format
@code{y} ( @i{-- r  }) minos2 ``y''
@end format
widget y coordinate


@findex w ( @var{ -- r   } ) minos2
@cindex @code{w}
@kindex w
@format
@code{w} ( @i{-- r  }) minos2 ``w''
@end format
widget width


@findex h ( @var{ -- r   } ) minos2
@cindex @code{h}
@kindex h
@format
@code{h} ( @i{-- r  }) minos2 ``h''
@end format
widget height above baseline


@findex d ( @var{ -- r   } ) minos2
@cindex @code{d}
@kindex d
@format
@code{d} ( @i{-- r  }) minos2 ``d''
@end format
widget depth below baseline


@findex gap ( @var{ -- r   } ) minos2
@cindex @code{gap}
@kindex gap
@format
@code{gap} ( @i{-- r  }) minos2 ``gap''
@end format
gap between lines


@findex baseline ( @var{ -- r   } ) minos2
@cindex @code{baseline}
@kindex baseline
@format
@code{baseline} ( @i{-- r  }) minos2 ``baseline''
@end format
minimun skip per line


@findex kerning ( @var{ -- r   } ) minos2
@cindex @code{kerning}
@kindex kerning
@format
@code{kerning} ( @i{-- r  }) minos2 ``kerning''
@end format
add kerning


@findex raise ( @var{ -- r   } ) minos2
@cindex @code{raise}
@kindex raise
@format
@code{raise} ( @i{-- r  }) minos2 ``raise''
@end format
raise/lower box


@findex border ( @var{ -- r   } ) minos2
@cindex @code{border}
@kindex border
@format
@code{border} ( @i{-- r  }) minos2 ``border''
@end format
surrounding border, all directions


@findex borderv ( @var{ -- r   } ) minos2
@cindex @code{borderv}
@kindex borderv
@format
@code{borderv} ( @i{-- r  }) minos2 ``borderv''
@end format
vertical border offset


@findex bordert ( @var{ -- r   } ) minos2
@cindex @code{bordert}
@kindex bordert
@format
@code{bordert} ( @i{-- r  }) minos2 ``bordert''
@end format
top border offset


@findex borderl ( @var{ -- r   } ) minos2
@cindex @code{borderl}
@kindex borderl
@format
@code{borderl} ( @i{-- r  }) minos2 ``borderl''
@end format
left border offset


@findex w-color ( @var{ -- r   } ) minos2
@cindex @code{w-color}
@kindex w-color
@format
@code{w-color} ( @i{-- r  }) minos2 ``w-color''
@end format
widget color index (into color map), if any


@findex draw-init ( @var{ --   } ) minos2
@cindex @code{draw-init}
@kindex draw-init
@format
@code{draw-init} ( @i{--  }) minos2 ``draw-init''
@end format
init draw


@findex draw ( @var{ --   } ) minos2
@cindex @code{draw}
@kindex draw
@format
@code{draw} ( @i{--  }) minos2 ``draw''
@end format
draw widget


@findex split ( @var{ firstflag rstart1 rx -- o rstart2   } ) minos2
@cindex @code{split}
@kindex split
@format
@code{split} ( @i{firstflag rstart1 rx -- o rstart2  }) minos2 ``split''
@end format
split a widget into parts for typesetting paragraphs


@findex lastfit ( @var{ --   } ) minos2
@cindex @code{lastfit}
@kindex lastfit
@format
@code{lastfit} ( @i{--  }) minos2 ``lastfit''
@end format
fit last widget element in a box


@findex hglue ( @var{ -- rtyp rsub radd   } ) minos2
@cindex @code{hglue}
@kindex hglue
@format
@code{hglue} ( @i{-- rtyp rsub radd  }) minos2 ``hglue''
@end format
calculate horizontal glue


@findex dglue ( @var{ -- rtyp rsub radd   } ) minos2
@cindex @code{dglue}
@kindex dglue
@format
@code{dglue} ( @i{-- rtyp rsub radd  }) minos2 ``dglue''
@end format
calculate vertical glue below baseline


@findex vglue ( @var{ -- rtyp rsub radd   } ) minos2
@cindex @code{vglue}
@kindex vglue
@format
@code{vglue} ( @i{-- rtyp rsub radd  }) minos2 ``vglue''
@end format
calculate vertical glue above baseline


@findex hglue@@ ( @var{ -- rtyp rsub radd   } ) minos2
@cindex @code{hglue@@}
@kindex hglue@@
@format
@code{hglue@@} ( @i{-- rtyp rsub radd  }) minos2 ``hglue-fetch''
@end format
cached variant of @code{hglue}


@findex dglue@@ ( @var{ -- rtyp rsub radd   } ) minos2
@cindex @code{dglue@@}
@kindex dglue@@
@format
@code{dglue@@} ( @i{-- rtyp rsub radd  }) minos2 ``dglue-fetch''
@end format
cached variant of @code{dglue}


@findex vglue@@ ( @var{ -- rtyp rsub radd   } ) minos2
@cindex @code{vglue@@}
@kindex vglue@@
@format
@code{vglue@@} ( @i{-- rtyp rsub radd  }) minos2 ``vglue-fetch''
@end format
cached variant of @code{vglue}


@findex xywh ( @var{ -- rx0 ry0 rw rh   } ) minos2
@cindex @code{xywh}
@kindex xywh
@format
@code{xywh} ( @i{-- rx0 ry0 rw rh  }) minos2 ``xywh''
@end format
widget bounding box, starting at the top left corner


@findex xywhd ( @var{ -- rx ry rw rh rd   } ) minos2
@cindex @code{xywhd}
@kindex xywhd
@format
@code{xywhd} ( @i{-- rx ry rw rh rd  }) minos2 ``xywhd''
@end format
widget bounding box, starting at the left baseline point


@findex !resize ( @var{ rx ry rw rh rd --   } ) minos2
@cindex @code{!resize}
@kindex !resize
@format
@code{!resize} ( @i{rx ry rw rh rd --  }) minos2 ``store-resize''
@end format
resize a widget


@findex !size ( @var{ --   } ) minos2
@cindex @code{!size}
@kindex !size
@format
@code{!size} ( @i{--  }) minos2 ``store-size''
@end format
let the widget self-determine its size


@findex dispose-widget ( @var{ --   } ) minos2
@cindex @code{dispose-widget}
@kindex dispose-widget
@format
@code{dispose-widget} ( @i{--  }) minos2 ``dispose-widget''
@end format
get rid of a widget


@findex .widget ( @var{ --   } ) minos2
@cindex @code{.widget}
@kindex .widget
@format
@code{.widget} ( @i{--  }) minos2 ``print-widget''
@end format
debugging: Print informations about the widget


@findex par-split ( @var{ rw --   } ) minos2
@cindex @code{par-split}
@kindex par-split
@format
@code{par-split} ( @i{rw --  }) minos2 ``par-split''
@end format
split a paragraph by width @var{rw}


@findex resized ( @var{ --   } ) minos2
@cindex @code{resized}
@kindex resized
@format
@code{resized} ( @i{--  }) minos2 ``resized''
@end format
widget is resized



Components are composed using a boxes&glue model similar to @LaTeX{},
including paragraph breaking.  For the sake of simplicity and portability,
MINOS2 only supports a single window, and uses OpenGL for rendering.

MINOS2 furthermore supports animations with the @code{animation} class.  A
color index texture is used for different color schemes, and transition
between neighboring schemes can also be animated.

@findex >animate ( @var{ rdelta addr xt --   } ) minos2
@cindex @code{>animate}
@kindex >animate
@format
@code{>animate} ( @i{rdelta addr xt --  }) minos2 ``to-animate''
@end format
create a new animation, calling @var{xt} with stack effect @code{( addr
r0..1 -- )} repeatedly, until the @var{rdelta} timeout expired; last call is
always with argument @var{1e} for the time.



You can create named color indexes and assign them color values for the
currently active color scheme.

@findex color: ( @var{ rgba "name" --   } ) minos2
@cindex @code{color:}
@kindex color:
@format
@code{color:} ( @i{rgba "name" --  }) minos2 ``color:''
@end format
Create a (possibly shared) color index initialized with @var{rgba}


@findex new-color: ( @var{ rgba "name" --   } ) minos2
@cindex @code{new-color:}
@kindex new-color:
@format
@code{new-color:} ( @i{rgba "name" --  }) minos2 ``new-color:''
@end format
Create a unique color index initialized with @var{rgba}


@findex text-color: ( @var{ rgba "name" --   } ) minos2
@cindex @code{text-color:}
@kindex text-color:
@format
@code{text-color:} ( @i{rgba "name" --  }) minos2 ``text-color:''
@end format
Create a unique text color index initialized with @var{rgba}, the
corresponding emoji color is set to white.


@findex text-emoji-color: ( @var{ rgbatext rgbaemoji "name" --   } ) minos2
@cindex @code{text-emoji-color:}
@kindex text-emoji-color:
@format
@code{text-emoji-color:} ( @i{rgbatext rgbaemoji "name" --  }) minos2 ``text-emoji-color:''
@end format
Create a unique text color index initialized with @var{rgbatext}, the
corresponding emoji color is set to @var{rgbaemoji}.


@findex fade-color: ( @var{ rgba1 rgba2 "name" --   } ) minos2
@cindex @code{fade-color:}
@kindex fade-color:
@format
@code{fade-color:} ( @i{rgba1 rgba2 "name" --  }) minos2 ``fade-color:''
@end format
Create a unique pair of text color index initialized with @var{rgba1} and
@var{rgba2}, the corresponding emoji color is set to white. By slowly
shifting the index from one to the next index, the object will shift its
color using a linear interpolation when redrawn.


@findex text-emoji-fade-color: ( @var{ rgbatext1 ~2 rgbaemoji1 ~2 "name" --   } ) minos2
@cindex @code{text-emoji-fade-color:}
@kindex text-emoji-fade-color:
@format
@code{text-emoji-fade-color:} ( @i{rgbatext1 ~2 rgbaemoji1 ~2 "name" --  }) minos2 ``text-emoji-fade-color:''
@end format
Create a unique pair of text color index initialized with @var{rgbatext1}
and @var{~2}, the corresponding emoji color pair is set to @var{rgbaemoji1}
to @var{~2}. By slowly shifting the index from one to the next index, the
object will shift its color using a linear interpolation when redrawn.


@findex re-color ( @var{ rgba "name" --   } ) minos2
@cindex @code{re-color}
@kindex re-color
@format
@code{re-color} ( @i{rgba "name" --  }) minos2 ``re-color''
@end format
assign the named color index @var{"name"} in the current color scheme with
the value @var{rgba}.


@findex re-text-color ( @var{ rgba "name" --   } ) minos2
@cindex @code{re-text-color}
@kindex re-text-color
@format
@code{re-text-color} ( @i{rgba "name" --  }) minos2 ``re-text-color''
@end format
assign the named text color index @var{"name"} in the current color scheme
with the value @var{rgba}.


@findex re-emoji-color ( @var{ rgbatext rgbaemoji "name" --   } ) minos2
@cindex @code{re-emoji-color}
@kindex re-emoji-color
@format
@code{re-emoji-color} ( @i{rgbatext rgbaemoji "name" --  }) minos2 ``re-emoji-color''
@end format
assign the named text and emoji color index @var{"name"} in the current
color scheme with the value @var{rgbatext} and @var{rgbaemoji}.


@findex re-fade-color ( @var{ rgba1 rgba2 "name" --   } ) minos2
@cindex @code{re-fade-color}
@kindex re-fade-color
@format
@code{re-fade-color} ( @i{rgba1 rgba2 "name" --  }) minos2 ``re-fade-color''
@end format
assign the named color index pair @var{"name"} in the current color scheme
with the value @var{rgba1} and @var{rgba2}.


@findex re-text-emoji-fade-color ( @var{ rgbatext1 ~2 rgbaemoji1 ~2 "name" --   } ) minos2
@cindex @code{re-text-emoji-fade-color}
@kindex re-text-emoji-fade-color
@format
@code{re-text-emoji-fade-color} ( @i{rgbatext1 ~2 rgbaemoji1 ~2 "name" --  }) minos2 ``re-text-emoji-fade-color''
@end format
assign the named color index pair @var{"name"} in the current color scheme
with the value @var{rgbatext1} and @var{~2} resp. @var{rgbaemoji1} and
@var{~2}.



For a number of specific objects, there are early bound methods, that only
work on these objects

@itemize @bullet
@item Viewport

@findex vp-top ( @var{ o:vp --   } ) minos2
@cindex @code{vp-top}
@kindex vp-top
@format
@code{vp-top} ( @i{o:vp --  }) minos2 ``vp-top''
@end format
scroll viewport to top


@findex vp-bottom ( @var{ o:vp --   } ) minos2
@cindex @code{vp-bottom}
@kindex vp-bottom
@format
@code{vp-bottom} ( @i{o:vp --  }) minos2 ``vp-bottom''
@end format
scroll viewport to bottom


@findex vp-left ( @var{ o:vp --   } ) minos2
@cindex @code{vp-left}
@kindex vp-left
@format
@code{vp-left} ( @i{o:vp --  }) minos2 ``vp-left''
@end format
scroll viewport to left


@findex vp-right ( @var{ o:vp --   } ) minos2
@cindex @code{vp-right}
@kindex vp-right
@format
@code{vp-right} ( @i{o:vp --  }) minos2 ``vp-right''
@end format
scroll viewport to right


@findex vp-reslide ( @var{ o:vp --   } ) minos2
@cindex @code{vp-reslide}
@kindex vp-reslide
@format
@code{vp-reslide} ( @i{o:vp --  }) minos2 ``vp-reslide''
@end format
Adjust the sliders of a viewport after scrolling


@findex vp-needed ( @var{ xt --   } ) minos2
@cindex @code{vp-needed}
@kindex vp-needed
@format
@code{vp-needed} ( @i{xt --  }) minos2 ``vp-needed''
@end format
collect needs in viewport's vp-need



@end itemize

@node MINOS2 tutorial, , MINOS2 object framework, MINOS2
@section MINOS2 tutorial

Tutorials are small files, each showing a bit of MINOS2.  For the common
framework, the file @file{minos2/tutorial/tutorial.fs} needs to be loaded
first; all other tutorials in the command line argument are included from
within that file.  Scroll wheel or previous/next mouse buttons as well as
clicking on the left or right edge of the window allow navigation between
the different tutorials loaded.

I.e. to load the buttons tutorial, you start Gforth with

@example
gforth minos2/tutorial/tutorial.fs buttons.fs
@end example

Available tutorials:

@itemize @bullet
@item
@file{buttons.fs}: Clickable buttons

@item
@file{plots.fs}: Plot functions

@item
@file{markdown.fs}: Markdown document viewer

@item
@file{screenshot.fs}: Screenshot function
@end itemize

@node Bugs, Origin, MINOS2, Top
@appendix Bugs
@cindex bug reporting

Known bugs are described in the file @file{BUGS} in the Gforth distribution.

If you find a bug, please submit a bug report through
@uref{https://savannah.gnu.org/bugs/?func=addbug&group=gforth}.

@itemize @bullet
@item
A program (or a sequence of keyboard commands) that reproduces the bug.
@item
A description of what you think constitutes the buggy behaviour.
@item
The Gforth version used (it is announced at the start of an interactive
Gforth session).
@item
The machine and operating system (on Unix systems @code{uname -a} will
report this information).
@item
The installation options (you can find the configure options at the start of
@file{config.status}) and configuration (@code{configure} output or
@file{config.cache}).
@item
A complete list of changes (if any) you (or your installer) have made to the
Gforth sources.
@end itemize

For a thorough guide on reporting bugs read @ref{Bug Reporting, , How to
Report Bugs, gcc, GNU C Manual}.


@node Origin, Forth-related information, Bugs, Top
@appendix Authors and Ancestors of Gforth

@section Authors and Contributors
@cindex authors of Gforth
@cindex contributors to Gforth

The Gforth project was started in mid-1992 by Bernd Paysan and Anton
Ertl. The third major author was Jens Wilke.  Neal Crook contributed a lot
to the manual.  Assemblers and disassemblers were contributed by Andrew
McKewan, Christian Pirker, Bernd Thallner, and Michal Revucky.  Lennart
Benschop (who was one of Gforth's first users, in mid-1993)  and Stuart
Ramsden inspired us with their continuous feedback. Lennart Benshop
contributed @file{glosgen.fs}, while Stuart Ramsden has been working on
automatic support for calling C libraries. Helpful comments also came from
Paul Kleinrubatscher, Christian Pirker, Dirk Zoller, Marcel Hendrix, John
Wavrik, Barrie Stott, Marc de Groot, Jorge Acerada, Bruce Hoyt, Robert
Epprecht, Dennis Ruffer and David N. Williams. Since the release of
Gforth-0.2.1 there were also helpful comments from many others; thank you
all, sorry for not listing you here (but digging through my mailbox to
extract your names is on my to-do list).

Gforth also owes a lot to the authors of the tools we used (GCC, CVS, and
autoconf, among others), and to the creators of the Internet: Gforth was
developed across the Internet, and its authors did not meet physically for
the first 4 years of development.

@section Pedigree
@cindex pedigree of Gforth

Gforth descends from bigFORTH (1993) and fig-Forth.  Of course, a
significant part of the design of Gforth was prescribed by Standard Forth.

Bernd Paysan wrote bigFORTH, a descendent from TurboForth, an unreleased 32
bit native code version of VolksForth for the Atari ST, written mostly by
Dietrich Weineck.

VolksForth was written by Klaus Schleisiek, Bernd Pennemann, Georg Rehfeld
and Dietrich Weineck for the C64 (called UltraForth there) in the mid-80s
and ported to the Atari ST in 1986.  It descends from fig-Forth.

@c Henry Laxen and Mike Perry wrote F83 as a model implementation of the
@c Forth-83 standard. !! Pedigree? When?

A team led by Bill Ragsdale implemented fig-Forth on many processors in
1979. Robert Selzer and Bill Ragsdale developed the original implementation
of fig-Forth for the 6502 based on microForth.

The principal architect of microForth was Dean Sanderson. microForth was
FORTH, Inc.'s first off-the-shelf product. It was developed in 1976 for the
1802, and subsequently implemented on the 8080, the 6800 and the Z80.

All earlier Forth systems were custom-made, usually by Charles Moore, who
discovered (as he puts it) Forth during the late 60s. The first full Forth
existed in 1971.

A part of the information in this section comes from
@cite{@uref{https://www.forth.com/resources/evolution/index.html,The
Evolution of Forth}} by Elizabeth D. Rather, Donald R. Colburn and Charles
H. Moore, presented at the HOPL-II conference and preprinted in SIGPLAN
Notices 28(3), 1993.  You can find more historical and genealogical
information about Forth there.  For a more general (and graphical) Forth
family tree look see
@cite{@uref{https://www.complang.tuwien.ac.at/forth/family-tree/}, Forth
Family Tree and Timeline}.

@c ------------------------------------------------------------------
@node Forth-related information, Licenses, Origin, Top
@appendix Other Forth-related information
@cindex Forth-related information

@c anton: I threw most of this stuff out, because it can be found through
@c the FAQ and the FAQ is more likely to be up-to-date.

@cindex comp.lang.forth
@cindex frequently asked questions
There is an active news group (comp.lang.forth) discussing Forth (including
Gforth) and Forth-related issues. Its
@uref{https://www.complang.tuwien.ac.at/forth/faq/faq-general-2.html,FAQs}
(frequently asked questions and their answers) contains a lot of information
on Forth.  You should read it before posting to comp.lang.forth.

The Forth standard is most usable in its @uref{https://forth-standard.org/,
HTML form}.

@c ---------------------------------------------------
@node Licenses, Word Index, Forth-related information, Top
@appendix Licenses

@menu
* GNU Free Documentation License::  このマニュアルのコピー時のライセンス
* Copying::                  GPL (このソフトウェアのコピー用)
@end menu

@node GNU Free Documentation License, Copying, Licenses, Licenses
@appendixsec GNU Free Documentation License
@include fdl.texi

@node Copying, , GNU Free Documentation License, Licenses
@appendixsec GNU GENERAL PUBLIC LICENSE
@include gpl.texi



@c ------------------------------------------------------------------
@node Word Index, Concept Index, Licenses, Top
@unnumbered Word Index

This index is a list of Forth words that have ``glossary'' entries within
this manual. Each word is listed with its stack effect and wordset.

@printindex fn

@c anton: the name index seems superfluous given the word and concept indices.

@c @node Name Index, Concept Index, Word Index, Top
@c @unnumbered Name Index

@c This index is a list of Forth words that have ``glossary'' entries
@c within this manual.

@c @printindex ky

@c -------------------------------------------------------
@node Concept Index, , Word Index, Top
@unnumbered Concept and Word Index

Not all entries listed in this index are present verbatim in the text. This
index also duplicates, in abbreviated form, all of the words listed in the
Word Index (only the names are listed for the words here).

@printindex cp

@bye



