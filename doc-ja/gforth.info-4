This is gforth.info, produced by makeinfo version 6.8 from gforth.texi.

このマニュアルは、 標準 Forth 言語の高速で移植可能な実装である Gforth (バ
ージョン 0.7.9_20240418, April 18, 2024)用です。 これはリファレンス・マ
ニュアルとして機能しますが、 Forth の概要と Forth チュートリアルも含まれ
ています。

   Authors: Bernd Paysan, Anton Ertl, Gerald Wodni Copyright © 1995,
1996, 1997, 1998, 2000, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
2011, 2012, 2013, 2014,2015,2016,2017,2018,2019,2020,2021,2022,2023 Free
Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover texts
     being “A GNU Manual,” and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by the
     Free Software Foundation raise funds for GNU development.”
INFO-DIR-SECTION Software development
START-INFO-DIR-ENTRY
* Gforth: (gforth).          forth言語のための高速インタプリタ
END-INFO-DIR-ENTRY


File: gforth.info,  Node: Assembler and Code Words,  Next: Carnal words,  Prev: C Interface,  Up: Words

6.29 Assembler and Code Words
=============================

* Menu:

* Assembler Definitions::    Definitions in assembly language
* Common Assembler::         アセンブラ文法
* Common Disassembler::
* 386 Assembler::            逸脱(deviations)と特殊ケース
* AMD64 Assembler::
* Alpha Assembler::          逸脱(deviations)と特殊ケース
* MIPS assembler::           逸脱(deviations)と特殊ケース
* PowerPC assembler::        逸脱(deviations)と特殊ケース
* ARM Assembler::            逸脱(deviations)と特殊ケース
* Other assemblers::         アセンブラ自体の書き方


File: gforth.info,  Node: Assembler Definitions,  Next: Common Assembler,  Prev: Assembler and Code Words,  Up: Assembler and Code Words

6.29.1 Definitions in assembly language
---------------------------------------

Gforth は、 アセンブリ言語でワードを実装する方法(‘abi-code’ … ‘end-code’
を使用)と、 任意の実行時の振る舞いを持つ定義ワードを定義する方法(‘does>’
のようなの)を提供し、 ここで、 この実行時の振る舞いを(‘does>’ とは異なり
、) Forth ではなくアセンブリ言語で定義します。

   ただし、 Gforth のマシン非依存の性質により、 いくつかの問題が生じます
。 まず、 Gforth は複数のアーキテクチャ上で実行されるため、 標準のアセン
ブラを提供できません。 ただし、 実行されるいくつかのアーキテクチャ用のア
センブラは提供されています。 さらに言えば、 Gforth ではシステムに依存し
ないアセンブラを使用したり、 ‘,’ や ‘c,’ を使用してマシン・コードを直接
コンパイルしたりできます。

   もう 1 つの問題は、Gforth の仮想マシンのレジスタ(スタック・ポインタと
仮想マシン命令ポインタ)がインストールとエンジンに依存することです。 また
、 どのレジスタを自由に使用できるかは、 インストールとエンジンによって異
なります。 したがって、 Gforth 仮想マシンのコンテキストで実行するように
記述されたコードは、 基本的に、 そのコードが開発されたインストールとエン
ジンに限定されます(たまたま、 他の場所でも動く可能性はありますが、 それ
に頼ることはできません)。

   幸いなことに、 同じ呼び出し規約(ABI)を持つプラットフォーム上で実行さ
れている Gforth に移植可能(portable)な ‘abi-code’ ワードを Gforth で定義
できます。 通常、 これは同じアーキテクチャと OS の組み合わせへの移植性を
意味し、 しばしば OS の境を越えることができます。

‘assembler’ ( –  ) tools-ext “assembler”
   ボキャブラリ: 検索順序スタック(the search order)のTOSのワードリストを
assembler ワードリストに置き換えます。

‘init-asm’ ( –  ) gforth-0.2 “init-asm”
   assembler ワードリストを検索順序スタック(the search order)にプッシュ
します(訳注:つまり assembler ワードリストが検索順序スタックのTOSになる
)。

‘abi-code’ ( "name" – colon-sys  ) gforth-1.0 “abi-code”
   C言語プロトタイプ(C-prototype)に対応するプラットフォームの ABI 規則を
使用して呼び出されるネイティブ・コード定義を開始します:
     Cell *function(Cell *sp, Float **fpp);
   ここで、 FP スタック・ポインタは、 FP スタック・ポインタを含むメモリ
位置への参照を提供することによって渡され、 (必要な場合)変更された FP ス
タック・ポインタをそこに格納することによって渡されます。

‘;abi-code’ ( –  ) gforth-1.0 “semicolon-abi-code”
   コロン定義を終了しますが、 実行時に最後に定義されたワード X (‘create’
で作られたワードである必要があります)の変更もして、 C言語プロトタイプに
対応するプラットフォームの ABI 規約を使用してネイティブ・コードを呼び出
します:
     Cell *function(Cell *sp, Float **fpp, Address body);

   FP スタック・ポインタは、 FP スタック・ポインタを含むメモリ位置への参
照を提供することによって渡され、 変更された FP スタック・ポインタをそこ
に格納することによって渡されます(必要な場合)。 パラメータ body は X の本
体です。

‘end-code’ ( colon-sys –  ) gforth-0.2 “end-code”
   コード定義を終了します。 ABI 呼び出しからの戻り(‘abi-code’ の場合)、
または次の VM 命令へのディスパッチ(‘code’ および ‘;code’ の場合)を自分で
アセンブルする必要があることに注意してください。

‘code’ ( "name" – colon-sys  ) tools-ext “code”
   Gforth 仮想マシン(エンジン)のコンテキストで実行されるネイティブ・ード
定義を開始します。 このような定義は Gforth インストール間で移植できない
ため、 ‘code’ の代わりに ‘abi-code’ を使用することをお勧めします。
‘code’ 定義は、 次の仮想マシン命令へのディスパッチで終了する必要がありま
す。

‘;code’ ( compilation. colon-sys1 – colon-sys2  ) tools-ext “semicolon-code”
   ‘;code’ の後のコードが、 最後に定義されたワード(‘create’ されたワード
である必要があります) の振る舞いになります。 ‘code’ の場合と同じ注意事項
が適用されるため、 代わりに ‘;abi-code’ を使用することをお勧めします。

‘flush-icache’ ( c-addr u – ) gforth-0.2 “flush-icache”
   プロセッサの命令キャッシュ(存在する場合)の c-addr と u バイト以降に古
いデータが含まれていないことを確認してください。 ‘END-CODE’ は
‘flush-icache’ を自動的に実行します。 注意(Caveat): ‘flush-icache’ はあ
なたのインストール環境では機能しない可能性があります。 これは通常、 マシ
ンでダイレクト・スレッドがサポートされておらず(‘machine.h’ を確認してく
ださい)、 マシンに別個の命令キャッシュがある場合に当てはまります。 この
ような場合、 ‘flush-icache’ は命令キャッシュをフラッシュする代わりに何も
行いません。

   ‘flush-icache’ が正しく動作しない場合、 ‘abi-code’ ワードなども(まず
確実に)動作しません。

   これらのワードの一般的な使用法は、 同等の高レベルの定義ワードから類推
することで最も簡単に示すことができます:

     : foo                              abi-code foo
        <high-level Forth words>              <assembler>
     ;                                  end-code

     : bar                              : bar
        <high-level Forth words>           <high-level Forth words>
        CREATE                             CREATE
           <high-level Forth words>           <high-level Forth words>
        DOES>                              ;code
           <high-level Forth words>           <assembler>
     ;                                  end-code

   ‘abi-code’ を使用する場合は、 あなたのプラットフォームの ABI ドキュメ
ントを参照して、 パラメーターがどのように渡されるか(スタック・ポインター
をどこで取得するかがわかります)、 戻り値がどのように渡されるか(データ・
スタック・ポインタがどこに返されるかがわかります)を確認してください。
ABI のドキュメントでは、 どのレジスタが呼び出し元によって保存されるか
(caller-saved)や、 コード内で自由に破棄できるかや、 どのレジスタが呼び出
されたワードによって保存される必要があるか(callee-saved)についても説明さ
れています。 あなたはそれらを使用する前に保存し、 後で復元します。 一部
のアーキテクチャと OS については、適切なセクションで呼び出し規約の各部分
の短い概要を示します。 リバース・エンジニアリング志向の人々は、 ‘see
abi-call’ を通じてスタック・ポインタの受け渡しと戻りについて知ることもで
きます。

   ほとんどの ABI はレジスタを介してパラメータを渡しますが、 一部の
ABI(特に最も一般的な 386 (別名 IA-32) 呼び出し規約) はアーキテクチャ・ス
タック上でパラメータを渡します。 共通の ABI はすべてレジスタで戻り値を渡
します。

   ‘abi-code’ を使用する際に知っておく必要があるその他のことは、 Gforth
ではデータと FP スタックの両方が下方向(下位アドレスに向かって)に成長し、
セルあたりのサイズは ‘1 cells’ になり、 FP 値ごとのサイズは ‘1 floats’ に
なるということです。

   386 アーキテクチャで ‘abi-code’ を使用する例を以下に示します:

     abi-code my+ ( n1 n2 -- n )
     4 sp d) ax mov \ sp into return reg
     ax )    cx mov \ tos
     4 #     ax add \ update sp (pop)
     cx    ax ) add \ sec = sec+tos
     ret            \ return from my+
     end-code

   この例の AMD64 バリエーションは *note AMD64 Assembler:: にあります。

   386 で FP 値を扱う例を以下に示します:

     abi-code my-f+ ( r1 r2 -- r )
     8 sp d) cx mov  \ load address of fp
     cx )    dx mov  \ load fp
     .fl dx )   fld  \ r2
     8 #     dx add  \ update fp
     .fl dx )   fadd \ r1+r2
     .fl dx )   fstp \ store r
     dx    cx ) mov  \ store new fp
     4 sp d) ax mov  \ sp into return reg
     ret             \ return from my-f+
     end-code


File: gforth.info,  Node: Common Assembler,  Next: Common Disassembler,  Prev: Assembler Definitions,  Up: Assembler and Code Words

6.29.2 Common Assembler
-----------------------

Gforth のアセンブラは通常、 後置構文(postfix syntax)を使用します。 つま
り、命令名がオペランドの後に続きます。

   オペランドは通常の順序(アーキテクチャのマニュアルで使用されている順序
と同じ)で渡されます。 これらはすべて Forth ワードであるため、 スペースで
区切る必要があります。 Forth ワードを使用してオペランドを計算することも
できます。

   通常、 命令名は ‘,’ で終わります。 これにより、 複数の命令を 1 行に配
置した場合に、 命令を視覚的に分離しやすくなります。 また、 他の Forth ワ
ード (例: ‘and’) が隠されてしまう(shadowing)のも回避します。

   レジスタは通常、 番号で指定します。 たとえば、 (10 進数の) ‘11’ は、
Alpha アーキテクチャ上のレジスタ R11 および F11 を指定します(どちらかは
命令によって異なります)。 通常の名前も使用できます(例: Alpha の R11 の
‘s2’)。

   制御フローは、 通常の Forth コード(*note Arbitrary control
structures::)と同様に、 ‘if,’, ‘ahead,’, ‘then,’, ‘begin,’, ‘until,’,
‘again,’, ‘cs-roll’, ‘cs-pick’, ‘else,’, ‘while,’, ‘repeat,’ で指定しま
す。 条件は各アセンブラに固有の方法で指定されます。

   このセクションの残りの部分は、 (移植性の高い ‘abi-code’ ワードではな
く、)主に ‘code’ ワードを定義したい人にとって興味深いものです。

   注意: Gforth エンジンのレジスタ割り当ては、 Gforth バージョン間、 ま
たは同じ Gforth バージョンの異なるコンパイル間でも変更される可能性がある
ことに注意してください(たとえば、 異なる GCC バージョンを使用する場合)。
‘ABI-CODE’ の代わりに ‘CODE’ を使用していて、 Gforth のレジスター (スタ
ック・ポインターや TOS など) を参照したい場合は、 これらのレジスターを参
照するための独自のワードを定義して使用することをお勧めします。 そうすれ
ば、 変更されたレジスタ割り当てに適応できます。

   これらのレジスタの最も一般的な使用法は、 ‘code’ 定義を次のワードへの
ディスパッチ(‘next’ ルーチン)で終了することです。 これを行う移植可能な方
法は、‘' noop >code-address’ にジャンプすることです(もちろん、 これは
‘next’ コードを統合して適切にスケジュールするほど効率的ではありません)。
‘ABI-CODE’ を使用する場合は、 通常のサブルーチンの戻り値をアセンブルする
だけです(ただし、 必ずデータ・スタック・ポインターを返すようにしてくださ
い)。

   Gforth バージョン間のもう 1 つの違いは、 ほとんどのプラットフォームで
はスタックの最上位が ‘gforth’ のメモリに保持され、 ‘gforth-fast’ ではレ
ジスタに保持されることです。 ‘ABI-CODE’ 定義の場合、 スタック・キャッシ
ュ・レジスタは必ずスタックにフラッシュされるため、 メモリ内のスタックの
先頭に確実にアクセスできます。


File: gforth.info,  Node: Common Disassembler,  Next: 386 Assembler,  Prev: Common Assembler,  Up: Assembler and Code Words

6.29.3 Common Disassembler
--------------------------

‘code’ ワードは ‘see’ で逆アセンブルできます(*note Debugging::)。 以下を
使用してメモリのセクションを逆アセンブルできます

‘discode’ ( addr u –  ) gforth-0.2 “discode”
   逆アセンブラのフック: addr から u バイトのコードを逆アセンブルします
。

   Gforth には 2 種類の逆アセンブラがあります。 Forth 逆アセンブラ(一部
の CPU で利用可能) と gdb 逆アセンブラ(‘gdb’ および ‘mktemp’ を備えたプ
ラットフォームで利用可能)です。 両方が使用可能な場合は、 Forth 逆アセン
ブラがデフォルトで使用されます。 gdb 逆アセンブラを使いたい場合は、 以下
のようにします

     ' disasm-gdb is discode

   どちらも使用できない場合は、‘discode’ が ‘dump’ を実行します。

   Forth 逆アセンブラは通常、 アセンブラに入力できる出力(つまり、同じ構
文など)を生成します。 コメントには追加情報も含まれます。 特に、 命令のア
ドレスは命令の前のコメントで示されます。

   gdb 逆アセンブラは、 デフォルトの形式(flavour)(386 および AMD64 アー
キテクチャの AT&T 構文)で、 gdb ‘disassemble’ コマンドと同じ形式で出力を
生成します(*note Source and machine code: (gdb)Machine Code.)。

   ‘see’ は、 コードの終わりの認識が信頼できないため、 ワードの実際のコ
ードより多めに表示したり少なめに表示したりする場合があります。 十分に表
示されない場合は、 ‘discode’ を使用できます。 コード・ワードの直後に名前
付きワードが続かない場合は、 さらに表示される可能性があります。 他に何か
がある場合は、 ワードの後に ‘align latest ,’ を付けると、 末尾が認識され
るようになります。


File: gforth.info,  Node: 386 Assembler,  Next: AMD64 Assembler,  Prev: Common Disassembler,  Up: Assembler and Code Words

6.29.4 386 Assembler
--------------------

Gforth に含まれる 386 アセンブラは Bernd Paysan によって書かれ、 GPL の
下で入手可能で、 元々は bigFORTH の一部でした。

   Gforth に含まれる 386 逆アセンブラは Andrew McKewan によって作成され
、 パブリック・ドメインです。

   逆アセンブラは、 Intel のようなプレフィックス構文(Intel-like prefix
syntax)でコードを表示します。

   アセンブラは、 AT&T スタイルのパラメータ順序(つまり、宛先が最後
;destination last)で後置構文(postfix syntax)を使用します。

   アセンブラには、 Athlon のすべての命令、 つまり 486 コア命令や、
Pentium および PPro 拡張機能や、浮動小数点、MMX、3Dnow!  が含まれていま
すが、 ISSE は含まれていません。 これは、16 ビットおよび 32 ビットの統合
アセンブラです。デフォルトは 32 ビットですが、 ‘.86’ で 16 ビットに切り
替え、‘.386’ で 32 ビットに戻すことができます。

   異なる操作サイズを切り替えるためのプレフィックスがいくつかあります。
バイト・アクセスの場合は ‘.b’ 、 ワード・アクセスの場合は ‘.w’ 、 ダブル
ワード・アクセスの場合は ‘.d’ です。 アドレッシング・モードは、 16 ビッ
トアドレスの場合は ‘.wa’ 、32 ビットアドレスの場合は ‘.da’ で切り替える
ことができます。 (‘AL’ など、 )バイト・レジスタ名のプレフィックスは必要
ありません 。

   浮動小数点演算の場合、 プレフィックスは ‘.fs’ (IEEE single)、‘.fl’
(IEEE double)、‘.fx’ (extended)、‘.fw’ (word)、 ‘.fd’ (double-word)、
‘.fq’ (quad-word)。 デフォルトは ‘.fx’ であるため、 Gforth FP 値を扱うと
きは ‘.fl’ を明示的に指定する必要があります。

   MMX オペコードにはサイズのプレフィックスはなく、 Intel アセンブラと同
じように記述されます。 メモリ間での移動の代わりに、 PLDQ/PLDD と
PSTQ/PSTD があります。

   レジスタには「e」接頭辞がありません。 32 ビット モードでも、 eax は
ax と呼ばれます。 即値は、‘#’ を接尾辞として付けることによって示されます
(例: ‘3 #’)。 以下に、 さまざまな構文でのアドレス指定モードの例をいくつ
か示します:

     Gforth          Intel (NASM)   AT&T (gas)      Name
     .w ax           ax             %ax             register (16 bit)
     ax              eax            %eax            register (32 bit)
     3 #             offset 3       $3              immediate
     1000 #)         byte ptr 1000  1000            displacement
     bx )            [ebx]          (%ebx)          base
     100 di d)       100[edi]       100(%edi)       base+displacement
     20 ax *4 i#)    20[eax*4]      20(,%eax,4)     (index*scale)+displacement
     di ax *4 i)     [edi][eax*4]   (%edi,%eax,4)   base+(index*scale)
     4 bx cx di)     4[ebx][ecx]    4(%ebx,%ecx)    base+index+displacement
     12 sp ax *2 di) 12[esp][eax*2] 12(%esp,%eax,2) base+(index*scale)+displacement

   ‘D)’ と ‘DI)’ の代わりに ‘L)’ と ‘LI)’ を使用して、32 ビット
displacement フィールドを強制できます(後のパッチ適用に役立ちます)。

   いくつかの命令の例は以下のとおりです:

     ax bx mov             \ move ebx,eax
     3 # ax mov            \ mov eax,3
     100 di d) ax mov      \ mov eax,100[edi]
     4 bx cx di) ax mov    \ mov eax,4[ebx][ecx]
     .w ax bx mov          \ mov bx,ax

   バイナリ命令では以下の形式がサポートされています:

     <reg> <reg> <inst>
     <n> # <reg> <inst>
     <mem> <reg> <inst>
     <reg> <mem> <inst>
     <n> # <mem> <inst>

   シフト/ローテート の構文は以下のとおりです:

     <reg/mem> 1 # shl \ shortens to shift without immediate
     <reg/mem> 4 # shl
     <reg/mem> cl shl

   バイト・バージョンを取得するには、 (‘movs’ などの)文字列命令(string
instructions)の前に ‘.b’ を付けます。

   制御構造ワードの ‘IF’ や ‘UNTIL’ などの前に、 次の条件のいずれかを指
定する必要があります: ‘vs vc u< u>= 0= 0<> u<= u> 0< 0>= ps pc < >= <=
>’ (注意: ‘code’ ワードなど、 検索パス内で ‘assembler’ が ‘forth’ の前に
ある場合、 これらのワードのほとんどは Forth ワードの一部を隠してしまう事
に注意してください)。 現在、 制御構造ワードは 1 つのスタック項目を使用し
ているため、 それらをいじるには ‘cs-roll’ の代わりに ‘roll’ を使用する必
要があります(‘swap’ などを使用することもできます)。

   Intel ABI (Linux で使用)に基づいて、‘abi-code’ ワードは ‘4 sp d)’ で
データ・スタック・ポインターを見つけ、 ‘8 sp d)’ で FP スタック・ポイン
ターのアドレスを見つけることができます; データ・スタック・ポインタは
‘ax’ で返されます。 ‘Ax’ や ‘cx’ や ‘dx’ は呼び出し元で保存されるため、
ワード内に値を保存する必要はありません。 ‘ret’ を使用してワードから戻る
ことができます。 パラメータは呼び出し元によってクリーンアップされます。

   386 の ‘abi-code’ ワードの例については、 *note Assembler
Definitions::


File: gforth.info,  Node: AMD64 Assembler,  Next: Alpha Assembler,  Prev: 386 Assembler,  Up: Assembler and Code Words

6.29.5 AMD64 (x86_64) Assembler
-------------------------------

AMD64 アセンブラは、 386 アセンブラをわずかに変更したバージョンであり、
構文の大部分を共有しています。 2 つの新しい接頭辞 ‘.q’ と ‘.qa’ が、 そ
れぞれ 64 ビット・サイズのオペランドやアドレスを選択するために提供されて
います。 64 ビット・サイズがデフォルトであるため、 通常は他のプレフィッ
クスを使用するだけで済みます。 また、 追加のレジスタ・オペランド ‘R8’ ～
‘R15’ もあります。

   レジスタには「e」または「r」プレフィックスがありません。 64 ビット・
モードでも、 ‘rax’ は ‘ax’ と呼ばれます。 すべてのレジスタで最下位バイト
を参照するために追加のレジスタ・オペランドを使用できます: ‘R8L’ 〜
-‘R15L’, ‘SPL’, ‘BPL’, ‘SIL’, ‘DIL’

   Linux-AMD64 の呼び出し規則では、 最初の 6 つの整数パラメーターを rdi,
rsi, rdx, rcx, r8, r9 で渡し、 結果を rax , rdx で返します。 最初の 8 つ
の FP パラメータを xmm0 ～ xmm7 に渡し、 FP 結果を xmm0 ～ xmm1 に返しま
す。 したがって、‘abi-code’ ワードは、 ‘di’ でデータ・スタック・ポインタ
を取得し、 ‘si’ で FP スタック・ポインタのアドレスを取得し、 リターン時
は ‘ax’ にデータ・スタック ポインタをセットします。 呼び出し元が保存する
他のレジスタは、 r10, r11 xmm8 ～ xmm15 です。 この呼び出し規約は、
Microsoft 以外の他の OS でも使用されていると報告されています。

   Windows x64 は、 最初の 4 つの整数パラメータを rcx, rdx, r8, r9 に渡
し、 整数の結果を rax に返します。 他の、呼び出し元保存レジスタは r10 と
r11 です。

   <https://uclibc.org/docs/psABI-x86_64.pdf> の 21ページによると、
Linux プラットフォームでは、 レジスタ AX CX DX SI DI R8 R9 R10 R11 が自
由(scratch)に使えます。

   AMD64 のアドレッシング・モードは以下のとおりです:

     \ ご注意: ワード A を実行すると、レジスタが初期化されていないため、 メモリ・エラーが発生します ;-)
     ABI-CODE A  ( -- )
         500        #               AX  MOV     \ immediate
             DX              AX  MOV     \ register
             200             AX  MOV     \ direct addressing
             DX  )           AX  MOV     \ indirect addressing
         40  DX  D)          AX  MOV     \ base with displacement
             DX  CX      I)  AX  MOV     \ scaled index
             DX  CX  *4  I)  AX  MOV     \ scaled index
         40  DX  CX  *4  DI) AX  MOV     \ scaled index with displacement

             DI              AX  MOV     \ SP Out := SP in
                                 RET
     END-CODE

   AMD64 ‘abi-code’ ワードの例をいくつか示します:

     abi-code my+  ( n1 n2 -- n3 )
     \ SP passed in di, returned in ax,  address of FP passed in si
     8 di d) ax lea        \ compute new sp in result reg ( 結果として di+8 → ax つまり drop と同じ)
     di )    dx mov        \ get old tos ( [di] つまり n2   → dx )
     dx    ax ) add        \ add to new tos ( dx + [ax] → [ax]
     ret
     end-code

     \ Do nothing
     ABI-CODE aNOP  ( -- )
            DI  )       AX      LEA          \ SP out := SP in
                                RET
     END-CODE

     \ Drop TOS
     ABI-CODE aDROP  ( n -- )
        8   DI  D)      AX      LEA          \ SPout := SPin - 1
                                RET
     END-CODE

     \ Push 5 on the data stack
     ABI-CODE aFIVE   ( -- 5 )
        -8  DI  D)      AX      LEA          \ SPout := SPin + 1
        5   #           AX  )   MOV          \ TOS := 5
                                RET
     END-CODE

     \ Push 10 and 20 into data stack
     ABI-CODE aTOS2  ( -- n n )
        -16 DI  D)      AX      LEA          \ SPout := SPin + 2
        10  #       8   AX  D)  MOV          \ TOS - 1 := 10
        20  #           AX  )   MOV          \ TOS := 20
                                RET
     END-CODE

     \ Get Time Stamp Counter as two 32 bit integers
     \ The TSC is incremented every CPU clock pulse
     ABI-CODE aRDTSC   ( -- TSCl TSCh )
                                RDTSC        \ DX:AX := TSC
        $FFFFFFFF #     AX      AND          \ Clear upper 32 bit AX
       0xFFFFFFFF #     DX      AND          \ Clear upper 32 bit DX
            AX          R8      MOV          \ Tempory save AX
        -16 DI  D)      AX      LEA          \ SPout := SPin + 2
            R8      8   AX  D)  MOV          \ TOS-1 := saved AX = TSC low
            DX          AX  )   MOV          \ TOS := Dx = TSC high
                                RET
     END-CODE

     \ Get Time Stamp Counter as 64 bit integer
     ABI-CODE RDTSC   ( -- TSC )
                                RDTSC        \ DX:AX := TSC
        $FFFFFFFF #     AX      AND          \ Clear upper 32 bit AX
        32  #           DX      SHL          \ Move lower 32 bit DX to upper 32 bit
            AX          DX      OR           \ Combine AX wit DX in DX
        -8  DI  D)      AX      LEA          \ SPout := SPin + 1
            DX          AX  )   MOV          \ TOS := DX
                                RET
     END-CODE

     VARIABLE V

     \ Assign 4 to variable V
     ABI-CODE V=4 ( -- )
            BX                  PUSH         \ Save BX, used by gforth
        V   #           BX      MOV          \ BX := address of V
        4   #           BX )    MOV          \ Write 4 to V
            BX                  POP          \ Restore BX
            DI  )       AX      LEA          \ SPout := SPin
                                RET
     END-CODE

     VARIABLE V

     \ Assign 5 to variable V
     ABI-CODE V=5 ( -- )
        V   #           CX      MOV          \ CX := address of V
        5   #           CX )    MOV          \ Write 5 to V
        DI )            AX      LEA          \ SPout := SPin
                                RET
     END-CODE

     ABI-CODE TEST2  ( -- n n )
        -16 DI  D)  AX          LEA          \ SPout := SPin + 2
        5   #       CX          MOV          \ CX := 5
        5   #       CX          CMP
        0= IF
            1   #   8   AX  D)      MOV      \ If CX = 5 then TOS - 1 := 1  <--
        ELSE
            2   #   8   AX  D)      MOV      \ else TOS - 1 := 2
        THEN
        6   #       CX          CMP
        0= IF
            3   #       AX  )       MOV      \ If CX = 6 then TOS := 3
        ELSE
            4   #       AX  )       MOV      \ else TOS := 4  <--
        THEN
                                RET
     END-CODE

     \ Do four loops. Expect : ( 4 3 2 1 -- )
     ABI-CODE LOOP4  ( -- n n n n )
            DI          AX      MOV          \ SPout := SPin
        4   #           DX      MOV          \ DX := 4  loop counter
        BEGIN
            8   #           AX      SUB      \ SP := SP + 1
                DX          AX  )   MOV      \ TOS := DX
            1   #           DX      SUB      \ DX := DX - 1
        0= UNTIL
                                RET
     END-CODE

   以下は、FP 値を扱う AMD64 用の例です:

     abi-code my-f+  ( r1 r2 -- r )
     \ SP passed in di, returned in ax,  address of FP passed in si
     si )       dx mov         \ load fp
     8 dx d)  xmm0 movsd       \ r2
     dx )     xmm0 addsd       \ r1+r2
     xmm0  8 dx d) movsd       \ store r
     8 #      si ) add         \ update fp
     di         ax mov         \ sp into return reg
     ret
     end-code


File: gforth.info,  Node: Alpha Assembler,  Next: MIPS assembler,  Prev: AMD64 Assembler,  Up: Assembler and Code Words

6.29.6 Alpha Assembler
----------------------

Alpha アセンブラと逆アセンブラは、もともとは Bernd Thallner によって書か
れました。

   レジスタ名 ‘a0’〜‘a5’ は、 16 進数を隠してしまう(shadowing)のを避ける
ために使用できません。

   算術命令の即時形式は、 ‘,’ の直前の ‘#’ によって区別されます(例:
‘and#,’)(注: ‘lda,’ は算術命令としてカウントされません)。

   他のアセンブラがオプションとみなすオペランドも含めて、 命令にすべての
オペランドを指定する必要があります。 たとえば、‘br,’ の宛先レジスタ、 ま
たは ‘jmp,’ の宛先レジスタとヒントです。

   ‘if,’ の条件を指定するには、 対応する名前のブランチから最初の ‘b’ と
末尾の ‘,’ を削除します。 たとえば、以下のようにします:

     11 fgt if, \ if F11>0e
       ...
     endif,

   ‘fbgt,’ は ‘fgt’ になります。


File: gforth.info,  Node: MIPS assembler,  Next: PowerPC assembler,  Prev: Alpha Assembler,  Up: Assembler and Code Words

6.29.7 MIPS assembler
---------------------

MIPS アセンブラは、もともとは Christian Pirker によって書かれました。

   現在、 アセンブラと逆アセンブラは MIPS32 アーキテクチャの大部分をカバ
ーしていますが、 FP 命令はサポートしていません。

   レジスタ名 ‘$a0’〜‘$a3’ は、 16 進数を隠してしまう(shadowing)のを避け
るために使用できません。 代わりにレジスタ番号 ‘$4’〜‘$7’ を使用してくだ
さい。

   レジスタと即値を区別するものはありません。 即値引数を持つ命令には、
‘i’ 接尾辞を付けた明示的なオペコード名を使用します。 例えば。 ‘addu,’ の
代わりに ‘addiu,’ です。

   アーキテクチャ・マニュアルで命令の形式が複数指定されている場合(例:
‘jalr,’ の場合)、より多くの引数を持つ形式(つまり、‘jalr,’ の場合は 2 つ
)を使用してください。 疑問がある場合は、 正しい使用例について
‘arch/mips/testasm.fs’ を参照してください。

   MIPS アーキテクチャの分岐とジャンプには遅延スロット(delay slot)があり
ます。 手動で入力する必要があります(最も簡単な方法は ‘nop,’ を使用するこ
とです)。 アセンブラは(‘as’ とは異なり)自動的に入力しません。 ‘if,’,
‘ahead,’, ‘until,’, ‘again,’, ‘while,’, ‘else,’, ‘repeat,’ でも遅延スロ
ットが必要です。 ‘begin,’ と ‘then,’ は分岐ターゲットを指定するだけなの
で影響を受けません。 ブランチの場合、 ターゲットを指定する引数は相対アド
レスです。 遅延スロットのアドレスを追加して絶対アドレスを取得します。

   注意: 遅延スロットに分岐やジャンプ(または制御フロー命令)を入れてはい
けないことに注意してください。 また、‘li,’ などの疑似演算を遅延スロット
に入れることは、 複数の命令に拡張される可能性があるため、お勧めできませ
ん。 MIPS I アーキテクチャにもロード遅延スロットがあり、 新しい MIPS で
は依然として ‘mfhi,’ および ‘mflo,’ の使用に制限があります。 これらの制
限を満たすように注意してください。 アセンブラが自動的に制限を満たしてく
れるわけではありません。

   いくつかの命令の例は以下のとおりです:

     $ra  12 $sp  sw,         \ sw    ra,12(sp)
     $4    8 $s0  lw,         \ lw    a0,8(s0)
     $v0  $0  lui,            \ lui   v0,0x0
     $s0  $s4  $12  addiu,    \ addiu s0,s4,0x12
     $s0  $s4  $4  addu,      \ addu  s0,s4,$a0
     $ra  $t9  jalr,          \ jalr  t9

   ‘if,’ などの条件を指定するには、 条件分岐を実行し、 先頭の ‘b’ と末尾
の ‘,’ を省略します。 例えば以下のようにします:

     4 5 eq if,
       ... \ do something if $4 equals $5
     then,

   32 ビット MIPS マシンの呼び出し規則では、 最初の 4 つの引数をレジスタ
‘$4’〜‘$7’ に渡し、 戻り値に ‘$v0’〜‘$v1’ を使用します。 これらのレジス
タに加えて、 レジスタ ‘$t0’ ～ ‘$t8’ は保存・復元せずに上書きしても問題
ありません。

   ‘jalr,’ を使用してダイナミック・ライブラリ・ルーチンを呼び出す場合は
、 最初に呼び出される関数のアドレスを ‘$t9’ にロードする必要があります。
これは、 相対メモリ・アクセスを行うために位置間接コード
(position-indirect code)によって使用されます。

   MIPS32 ‘abi-code’ ワードの例を以下に示します:

     abi-code my+  ( n1 n2 -- n3 )
       \ SP passed in $4, returned in $v0
       $t0  4 $4  lw,         \ load n1, n2 from stack
       $t1  0 $4  lw,
       $t0  $t0  $t1  addu,   \ add n1+n2, result in $t0
       $t0  4 $4  sw,         \ store result (overwriting n1)
       $ra  jr,               \ return to caller
       $v0  $4  4  addiu,     \ (delay slot) return uptated SP in $v0
     end-code


File: gforth.info,  Node: PowerPC assembler,  Next: ARM Assembler,  Prev: MIPS assembler,  Up: Assembler and Code Words

6.29.8 PowerPC assembler
------------------------

PowerPC アセンブラと逆アセンブラは、 Michal Revucky の貢献に依ります。

   このアセンブラは、 ニーモニック名を「,」で終了する規則に従っていない
ため、 一部のニーモニック名は通常の Forth ワード (特に: ‘and or xor
fabs’) を隠し(shadow)ます。 そのため、 Forth ワードを使用したい場合は、
最初に、 たとえば ‘ also forward’ を使用して、 Forth ワードを表示できる
ようにする必要があります。

   レジスタは番号によって参照されます。 たとえば、‘9’ は、 (命令に応じて
、)整数レジスタ 9 または FP レジスタ 9 を意味します。

   レジスタと即値を区別する方法がないため、 ‘add,’ だけでなく ‘add,’ な
どの即値用の命令を明示的に使用する必要があります。

   アセンブラと逆アセンブラは通常、 最も一般的な形式の命令をサポートしま
すが、 通常は短い形式(特に分岐)はサポートしません。


File: gforth.info,  Node: ARM Assembler,  Next: Other assemblers,  Prev: PowerPC assembler,  Up: Assembler and Code Words

6.29.9 ARM Assembler
--------------------

ARM アセンブラには、 ARM アーキテクチャ・バージョン 4 のすべての命令と、
アーキテクチャ・バージョン 5 の BLX 命令が含まれています。 Thumb 命令は
(まだ) サポートされていません。 また、 コ・プロセッサーもサポートされて
いません。

   アセンブラは、 「ARM Architecture Reference Manual」で使用されている
のと同じオペランド順序を持つ後置構文(postfix syntax)を使用します。 ニー
モニックにはカンマが付けられます。

   レジスタは ‘r0’〜‘r15’ までの名前で指定され、別名は ‘pc’, ‘lr’, ‘sp’,
‘ip’, ‘fp’ で、これらは利便性のために提供されています。 ‘ip’ は「プロシ
ージャ内呼び出しスクラッチ・レジスタ」(intra procedure call scratch
register)(注意: ‘r12’) を指し、 命令ポインタを指すわけではないことに注意
してください。 ‘sp’ は、 Forth のスタック・ポインターではなく、 ARM ABI
スタック・ポインター (‘r13’) を指します。

   条件コードは命令内のどこにでも指定できますが、 ニーモニックの直前に指
定すると最も読みやすくなります。 「S」フラグは別個のワードではなく、 命
令ニーモニックにエンコードされます。 ステータス・レジスタを更新したい場
合は、 ‘add,’ の代わりに ‘adds,’ を使用してください。

   以下の表に、 一般的な命令のオペランドの構文を示します:

     Gforth          normal assembler      description
     123 #           #123                  immediate
     r12             r12                   register
     r12 4 #LSL      r12, LSL #4           shift left by immediate
     r12 r1 LSL      r12, LSL r1           shift left by register
     r12 4 #LSR      r12, LSR #4           shift right by immediate
     r12 r1 LSR      r12, LSR r1           shift right by register
     r12 4 #ASR      r12, ASR #4           arithmetic shift right
     r12 r1 ASR      r12, ASR r1           ... by register
     r12 4 #ROR      r12, ROR #4           rotate right by immediate
     r12 r1 ROR      r12, ROR r1           ... by register
     r12 RRX         r12, RRX              rotate right with extend by 1

   メモリ・オペランドの構文を以下の表に示します:

     Gforth            normal assembler      description
     r4 ]              [r4]                  register
     r4 4 #]           [r4, #+4]             register with immediate offset
     r4 -4 #]          [r4, #-4]             with negative offset
     r4 r1 +]          [r4, +r1]             register with register offset
     r4 r1 -]          [r4, -r1]             with negated register offset
     r4 r1 2 #LSL -]   [r4, -r1, LSL #2]     with negated and shifted offset
     r4 4 #]!          [r4, #+4]!            immediate preincrement
     r4 r1 +]!         [r4, +r1]!            register preincrement
     r4 r1 -]!         [r4, +r1]!            register predecrement
     r4 r1 2 #LSL +]!  [r4, +r1, LSL #2]!    shifted preincrement
     r4 -4 ]#          [r4], #-4             immediate postdecrement
     r4 r1 ]+          [r4], r1              register postincrement
     r4 r1 ]-          [r4], -r1             register postdecrement
     r4 r1 2 #LSL ]-   [r4], -r1, LSL #2     shifted postdecrement
     ' xyz >body [#]   xyz                   PC-relative addressing

   複数のロード/ストア命令のレジスタ・リストは、 それぞれ ‘{’ および ‘}’
というワードを使用して開始および終了します。 ‘{’ 〜 ‘}’ の間に、 レジス
タ名を 1 つずつリストすることも、 後置演算子 ‘r-r’ を使用してレジスタ範
囲を形成することもできます。 ‘^’ フラグはレジスタ・リスト・オペランドで
はエンコードされませんが、 命令ニーモニックに直接エンコードされます。 つ
まり、 ‘^ldm,’ と ‘^stm,’ を使用します。

   複数のロード/ストアのアドレッシング・モードは命令接尾辞としてエンコー
ドされず、 代わりにアドレッシング・モードのように指定されます。 ‘DA’,
‘IA’, ‘DB’, ‘IB’, ‘DA!’, ‘IA!’, ‘DB!’, ‘IB!’ のいずれかを使います。

   以下の表にいくつかの例を示します:

     Gforth                           normal assembler
     r4 ia  { r0 r7 r8 }  stm,        stmia    r4, {r0,r7,r8}
     r4 db!  { r0 r7 r8 }  ldm,       ldmdb    r4!, {r0,r7,r8}
     sp ia!  { r0 r15 r-r }  ^ldm,    ldmfd    sp!, {r0-r15}^

   Forth アセンブラに典型的な制御構造ワードが利用可能です: ‘if,’,
‘ahead,’, ‘then,’, ‘else,’, ‘begin,’, ‘until,’, ‘again,’, ‘while,’,
‘repeat,’, ‘repeat-until,’ 。 条件は以下のワードの前に指定します:

     r1 r2 cmp,    \ compare r1 and r2
     eq if,        \ equal?
        ...          \ code executed if r1 == r2
     then,

   ARM アセンブラを使用した定義の例:

     abi-code my+ ( n1 n2 --  n3 )
        \ arm abi: r0=SP, r1=&FP, r2,r3,r12 saved by caller
        r0 IA!  { r2 r3 }  ldm,     \ pop r2 = n2, r3 = n1
        r3  r2  r3         add,     \ r3 = n1+n1
        r3  r0 -4 #]!      str,     \ push r3
        pc  lr             mov,     \ return to caller, new SP in r0
     end-code


File: gforth.info,  Node: Other assemblers,  Prev: ARM Assembler,  Up: Assembler and Code Words

6.29.10 Other assemblers
------------------------

別のアセンブラ/逆アセンブラを提供したい場合は、 そのようなアセンブラがす
でに存在するかどうかを確認するために著者達
(<anton@mips.complang.tuwien.ac.at>)までご連絡ください。 これらを最初か
ら作成する場合は、 著者たちが使用しているものと同様の構文スタイルを使用
してください(つまり、 後置や命令名の末尾のカンマ *note Common
Assembler::)。 逆アセンブラの出力をアセンブラの有効な入力にし、使用した
スタイルと同様のスタイルを維持します。

   実装に関するヒント: 最も重要なのは、 すべての手順を含む優れたテスト・
スイートを用意することです。 それができたら、 あとは簡単です。 実際のコ
ーディングについては、 ‘arch/mips/disasm.fs’ を参照して、 アセンブラと逆
アセンブラの両方でデータを使用し、 冗長性や潜在的なバグを回避する方法に
ついてアイデアを得ることができます。 また、そのファイル (および *note
Advanced does> usage example::) を見て、 逆アセンブラーをファクタリング
する方法のアイデアを得ることができます。

   逆アセンブラから始めます。 逆アセンブラからのデータをアセンブラで再利
用する方が、 その逆よりも簡単だからです。

   アセンブラについては、 ‘arch/alpha/asm.fs’ を見てください。 これがい
かに簡単であるかを示しています。


File: gforth.info,  Node: Carnal words,  Next: Passing Commands to the OS,  Prev: Assembler and Code Words,  Up: Words

6.30 Carnal words
=================

これらのワードは Gforth の仕組み(Forth サークルでは Forth システムの「肉
体的知識」(carnal knowledge)と呼ばれる)を扱っていますが、 著者等は文書化
するに当たって、 これらが十分安定(stable)していると考えています。

* Menu:

* Header fields::
* Header methods::
* Threading Words::


File: gforth.info,  Node: Header fields,  Next: Header methods,  Prev: Carnal words,  Up: Carnal words

6.30.1 Header fields
--------------------

Gforth 1.0 では、 新しいワード・ヘッダー・レイアウトに切り替えられました
。 詳細な説明については、 Bernd Paysan and M. Anton Ertl.  ‘The new
Gforth header (http://www.euroforth.org/ef19/papers/paysan.pdf)’ を参照
してください。 この論文の公開以後に、xt と nt は本体(body)のようにパラメ
ーター・フィールドを指すように変更されましたが、 それ以外は依然としてこ
の文献が最新です。

   このセクションでは、 データ構造とそれにアクセスするために使用されるワ
ードについてのみ説明します。 ヘッダーには以下のフィールドがあります:

     name
     >f+c
     >link
     >cfa
     >namehm
     >body

   現在、 Gforth には xt/nt/body から各フィールドに到達するために上に示
した名前がありますが、 標準の ‘>body’ を除けば、 これらは定着した Gforth
ワードではありません。 これらの代わりアクセス用ワードを提供しています。
注意:文書化されたアクセス・ワードはヘッダー・レイアウトの再編成後も生き
残ることに注意してください。

   ワードの中には nt を期待するものもあれば、 xt を期待するものもありま
す。 nt と xt が両方ともワードの本体を指しているとすると、 その違いは何
でしょうか？ ほとんどのワードでは、xt と nt は同一ヘッダーを使用するので
、 nt=xt となり、 同じ場所を指します。 ただし、 同義語(synonym)(*note
Aliases::)では違いがあります。 以下の例で考えてみましょう

     create x
     synonym y x
     synonym z y

   この場合、‘z’ の nt は ‘z’ の本体を指し、 ‘z’ の xt は ‘x’ の本体を指
します。 ‘alias’ または ‘forward’ (*note Forward::) で定義されたワードも
、 nt と異なる xt を持ちます。

   名前フィールドは可変長で、 ‘name>string’ (*note Name token::) でアク
セスします。

   ‘>f+c’ フィールドには、フラグと名前の長さ(カウント)が含まれます。
‘name>string’ でカウントを読み取り、 以下でフラグを読み取ります。

‘compile-only?’ ( nt – flag  ) gforth-1.0 “compile-only?”
   nt がコンパイル専用(compile-only)としてマークされている場合は true 。

   ‘>link’ フィールドには、 同じワードリスト内の前のワードへのリンクが含
まれます。 ‘name>link’ (*note Name token::) で読み取ることができます。

   name と ‘>f+c’ と ‘>link’ フィールドは ‘noname’ ワードには存在しませ
んが、 それでも ‘name>string’ と ‘name>link’ は機能し、 ‘name>string’ は
0 0 を返し、 ‘name>link’ は 0 を返します。

   ‘>cfa’ フィールド(別名 コード・フィールド) には、 ワードを ‘execute’
するために使用されるコード・アドレスが含まれます。 ‘>code-address’ で読
み取り、 ‘code-address!’ (*note Threading Words::) で書き込むことができ
ます。

   ‘>namehm’ フィールドには、 後述するするヘッダー・メソッド・テーブルの
アドレスが含まれます。 これにアクセスするには、 ヘッダー・メソッド
(*note Header methods::) を実行するか、または、 ヘッダー・メソッドにアク
セスします。

   ‘>body’ (別名 パラメーター・フィールド)には、 ワードの種類に固有のデ
ータまたはスレッド化コードが含まれます。 その長さはワードの種類によって
異なります。 たとえば、 ‘constant’ の場合、 定数の値を含むセルが含まれま
す。 ‘>body’ (*note CREATE..DOES> details::) を通じてアクセスできますが
、 これは標準の ‘create’ で定義したワードのみです。


File: gforth.info,  Node: Header methods,  Next: Threading Words,  Prev: Header fields,  Up: Carnal words

6.30.2 Header methods
---------------------

新しい Gforth ワード・ヘッダーはオブジェクト指向であり、 以下のメソッド
(メソッド・セレクター)をサポートします:

     .hm label method          overrider        field
               execute         set-execute      >cfa
     opt:      opt-compile,    set-optimizer    >hmcompile,
     to:       (to)            set-to           >hmto
     extra:                                     >hmextra
     >int:     name>interpret  set->int         >hm>int
     >comp:    name>compile    set->comp        >hm>comp
     >string:  name>string     set-name>string  >hm>string
     >link:    name>link       set-name>link    >hm>link

   これらのワードの多くは定着(stable)した Gforth ワードではありませんが
、 Gforth には後述する定着した高レベルのワードがあります。

   以下を使用すると、 ワードのヘッダー・メソッドを確認できます

‘.hm’ ( nt –  ) gforth-1.0 “dot-h-m”
   nt のヘッダー・メソッドを出力します

   オーバーライダー(overrider)(セッター)ワードは、 最新の定義のメソッド
実装を変更します。 クォーテーションまたはクロージャーは、 完了時に以前の
最新の定義を復元するため、 最新のものとはみなされず、 以下のようなことが
できます:

     : my2dup over over ;
     [: drop ]] over over [[ ;] set-optimizer

   ‘execute’ メソッドは、 パフォーマンス上の理由から、 実際にはヘッダー
・メソッド・テーブルではなくヘッダーの ‘>cfa’ フィールドに格納されます。
また、 他のメソッドは xt を呼び出すことによって実装されますが、 ネイティ
ブ・コード・アドレスを通じて実装されます。 このメソッドを設定する大まか
な方法​​は以下のとおりです

‘set-execute’ ( ca –  ) gforth-1.0 “set-execute”
   ca のネイティブ・コードにジャンプするように現在のワードを変更します。
また、 ‘compile,’ 実装を最も一般的な(そして最も遅い)実装に変更します。 よ
り効率的な ‘compile,’ 実装が必要な場合は、 後で ‘set-optimizer’ を呼び出
します。

   ‘set-execute’ で使用するコード・アドレスを取得するには、 ‘docol:’ ま
たは ‘>code-address’ などのワードを使用できます。 *Note Threading
Words::

   ‘set-execute’ の代わりに、 xt を受け取る ‘set-does>’ (*note
User-defined Defining Words::)もあります。

   さらに、 低レベルの ‘code-address!’ と ‘definer!’ があります。 (*note
Threading Words::)

   ‘opt-compile,’ メソッドは、 ほとんどの Gforth エンジンで動く
‘compile,’ です(‘gforth-itc’ は代わりに ‘,’ を使用します)。
‘set-optimizer’ を使用して、 現在のワードに対する ‘compile,’ のより効率
的な実装を定義できます((*note User-defined compile-comma::))。 注意: 最
終結果は ‘postpone literal postpone execute’ と同等でなければならないこ
とに注意してください。

   ‘set-optimizer’ の使用例として、 以下の ‘constant’ の定義を考えてみま
しょう:

     : constant ( n "name" -- ; name: -- n )
       create ,
       ['] @ set-does>
     ;

     5 constant five
     : foo five ; see foo

   Forth システムは、 定数の値を変更してはならないことを認識せず、 単に
‘create’ されたワード (‘>body’ で変更可能)として見て、 ‘foo’ は最初に
‘five’ のボティのアドレスをスタックにプッシュし、 その次にそこから値を取
得します。 ‘set-optimizer’ を使用すると、 ‘constant’ の定義を以下のよう
に最適化できます:

     : constant ( n "name" -- ; name: -- n )
       create ,
       ['] @ set-does>
       [: >body @ postpone literal ;] set-optimizer
     ;

   いまや、 ‘foo’ には、 ‘five’ の呼び出しではなく、 即値(literal)の 5 が
含まれるようになりました。

   注意: ‘set-execute’ と ‘set-does>’ は、‘execute’ と ‘compile,’ が一致
していることを確認するために、 ‘set-optimizer’ 自体を実行することに注意
してください。 あなた独自のオプティマイザーを追加するには、 後で追加する
必要があります。

   ‘defer!’ (別名 ‘(to)’ メソッド(*note User-defined TO and DEFER@::)は
、 ‘defer’ で定義されたワードおよび類似のワードに対して ‘defer!’ を実装
します。 ですが、 これは ‘to’ の核心(core)でもあります。 ‘defer!’/‘(to)’
メソッドの一般的なスタック効果は ‘( val xt -- )’ です。 ここで xt は格納
されているワードを示し、 val はそこに格納されている(適切な型の)値です。

   たとえば、 以下のように ‘fvalue’ を実装できます:

     : fvalue-to ( r xt -- ) >body f! ;

     : fvalue ( r -- )
       create f,
       ['] f@ set-does>
       ['] fvalue-to set-to ;

     5e fvalue foo
     : bar foo 1e f+ to foo ;
     see bar

   ‘set-optimizer’ を使用して、 生成されたコードを改善できます:

     : compile-fvalue-to ( xt-value-to -- )
       drop ]] >body f! [[ ;

     : fvalue-to ( r xt -- ) >body f! ;
     ' compile-fvalue-to set-optimizer

     : fvalue ( r -- )
       create f,
       ['] f@ set-does>
       [: >body ]] literal f@ [[ ;] set-optimizer
       ['] fvalue-to set-to ;

     5e fvalue foo
     : bar foo 1e f+ to foo ;
     see bar

   実際には、 Gforth には、 ‘+TO’ など、 実装するための追加の工夫がいく
つかあります。

   ‘Set-defer@’ (*note User-defined TO and DEFER@::) を使用すると、
‘defer’ のようなワードに対して ‘defer@’ (*note Deferred Words::) メソッ
ドのバリエーションを実装できます。

   ‘>hmextra’ フィールドは、 追加のデータをヘッダー・メソッド・テーブル
に保存する必要がある場合に使用されます。 特に、 それは ‘set-does>’ に渡
す xt を保存し(そして ‘does>’ は ‘set-does>’ を呼び出し)、 そして、
‘;abi-code’ の後のコードのアドレスを保存します。

   これらのメソッドはすべて、 nt ではなく xt を使用しますが、 オーバーラ
イド・ワード(override words)は最新の定義で機能します。 これは、 たとえば
、 同義語(synonym)に対して ‘set-optimizer’ を使用した場合、 その効果はお
そらくあなたが意図したものとは異なることを意味します。 ワードの xt を
‘compile,’ する場合、 新たに設定された同義語(synonym)ではなく、 元のワー
ドの ‘opt-compile,’ 実装が使用されます。

   以下のメソッド達は nt を消費します。

   ‘name>interpret’ メソッドは、 同義語(synonym)や類似のワードを除くほと
んどのワードに対して noop として実装されます。

‘set->int’ ( xt –  ) gforth-1.0 “set-to-int”
   現在のワードの ‘name>interpret (nt -- xt2 )’ メソッドの実装を xt に設
定します。

   ‘name>compile’ メソッドは、 nt のコンパイル機能(compilation
semantics)を生成します。 ‘set->comp’ で変更することでコンパイル機能を変
更できますが、 ‘name>compile’ のスタック効果のため、 目的のコンパイル機
能の xt をプッシュするだけというほど単純ではありません。 一般に、 コンパ
イル機能の変更は避ける必要があり、 変更する場合は、 ‘immediate’ または
‘interpret/compile:’ などの高レベル・ワードを使用してください(*Note
Combined words::)。

‘set->comp’ ( xt –  ) gforth-1.0 “set-to-comp”
   現在のワードの ‘name>compile ( nt -- w xt2 )’ メソッドの実装を xt に
設定します。

‘immediate?’ ( nt – flag  ) gforth-1.0 “immediate?”
   ワード nt がデフォルト以外のコンパイル機能(compilation semantics)を持
っている場合は true (これは即時性(immediacy)の定義と完全には一致しません
が、 多くの人はワード語を「即時」(immediate)と呼ぶときはこれを意味してい
ます)。

   ‘Name>string’ および ‘Name>link’ は、 noname ヘッダーから name と
‘>f+c’ と ‘link’ フィールドを削除できるようにするためのメソッドです。 こ
れらのワードを使用すると意味のある結果が得られます。 通常、 ‘noname’ を
使用する場合を除き、 これらのメソッドの実装を変更することはありませんが
、 あなたがそれでも必要とするなら以下をご覧ください

‘set-name>string’ ( xt –  ) gforth-1.0 “set-name-to-string”
   現在のワードの ‘name>string ( nt -- addr u )’ メソッドの実装を xt に
設定します。

‘set-name>link’ ( xt –  ) gforth-1.0 “set-name-to-link”
   現在のワードの ‘name>link (nt1 -- nt2|0 )’ メソッドの実装を xt に設定
します。


File: gforth.info,  Node: Threading Words,  Prev: Header methods,  Up: Carnal words

6.30.3 Threading Words
----------------------

ここで使用される用語は、 間接スレッド Forth システム(indirect threaded
Forth systems)に由来しています。 間接スレッド Forth システムでは、 ワー
ドの XT はワードの CFA (コード・フィールド・アドレス) によって表されます
。 CFA は、 コード・アドレスを含むセルを指します。 コード・アドレスとは
、 ワードを呼び出す実行時のアクションを実行するマシン・コードのアドレス
です(たとえば、 ‘dovar:’ ルーチンは、 ワード(変数)の本体のアドレスをスタ
ックにプッシュします)。

   以下のワード群は、 Gforth のコード・フィールドやコード・アドレスやそ
の他のスレッド機能へのアクセスを提供します。 これにより、直接スレッドと
間接スレッドの違いは、 多かれ少なかれ抽象化されます。

   Gforth 0.7 までは、 ワードの種類を知るのに、 コード・アドレス(さらに
、 ‘does>’ で定義されたワードの場合は、 ‘>does-code’ によって返されるア
ドレス)で十分でした。 ただし、 Gforth-1.0 以降、 少なくとも、 ‘compile,’
や ‘name>compile’ のようなワードの振る舞いや実装は、 *note Header
methods:: で説明されているように独立して決定できます。

   以下のワード達は、 コード・フィールドを作成し、 そして、 同時にヘッダ
ー・メソッドを初期化します:

‘hmcopy,’ ( xt –  ) gforth-experimental “hmcopy-comma”
   ヘッダーの構築中に、 コード・フィールドを割り当て、 コード・フィール
ドとヘッダー・メソッドを設定するためのプロトタイプとして xt を使用します
。

‘docol,’ ( –  ) gforth-1.0 “docol,”
   コロン定義のコード・アドレスを書き込む。

‘docon,’ ( –  ) gforth-1.0 “docon,”
   ‘CONSTANT’ のコード・アドレスを書き込む。

‘dovar,’ ( –  ) gforth-1.0 “dovar,”
   ‘CREATE’ されたワードのコード・アドレスを書き込む。

‘douser,’ ( –  ) gforth-1.0 “douser,”
   ‘USER’ 変数のコード・アドレスを書き込む。

‘dodefer,’ ( –  ) gforth-1.0 “dodefer,”
   ‘defer’ されたワードのコード・アドレスを書き込む。

‘dofield,’ ( –  ) gforth-1.0 “dofield,”
   ‘field’ のコード・アドレスを書き込む。

‘dovalue,’ ( –  ) gforth-1.0 “dovalue,”
   ‘CONSTANT’ のコード・アドレスを書き込む。

‘doabicode,’ ( –  ) gforth-1.0 “doabicode,”
   ‘ABI-CODE’ 定義のコード・アドレスを書き込む。

   ‘does>’ で定義されたワードの場合、 ‘hmcopy,’ を使用してください。

   または、 ‘create-from’ のような高レベルのワードを使用します(*note
Creating from a prototype::)。

   以下のワード群はヘッダー・メソッドが導入される前に設計されたものであ
るため、 Gforth でさまざまなワード・タイプを処理する最良の(推奨される)方
法ではありません。

   間接スレッド Forth では、 ‘' name @’ を使用して name のコード・アドレ
スを取得できます。 Gforth では、 スレッド化方式とは関係なく、 ‘' name
>code-address’ で取得できます。

‘threading-method’ ( – n ) gforth-0.2 “threading-method”
   エンジンが直接スレッドの場合は 0。 注意: これはイメージの存続期間中
(lifetime)に変更される可能性があることに注意してください。

‘>code-address’ ( xt – c_addr  ) gforth-0.2 “>code-address”
   c-addr は、 ワード xt のコード・アドレスです。

‘code-address!’ ( c_addr xt –  ) gforth-obsolete “code-address!”
   コード・アドレス c-addr のコード・フィールドを xt に変更します。

   さまざまな定義ワードによって生成されるコード・アドレスは、 以下のワー
ド群によって生成されます:

‘docol:’ ( – addr  ) gforth-0.2 “docol:”
   コロン定義のコード・アドレスを書き込む。

‘docon:’ ( – addr  ) gforth-0.2 “docon:”
   ‘CONSTANT’ のコード・アドレスを書き込む。

‘dovar:’ ( – addr  ) gforth-0.2 “dovar:”
   ‘CREATE’ されたワードのコード・アドレスを書き込む。

‘douser:’ ( – addr  ) gforth-0.2 “douser:”
   ‘USER’ 変数のコード・アドレスを書き込む。

‘dodefer:’ ( – addr  ) gforth-0.2 “dodefer:”
   ‘defer’ されたワードのコード・アドレスを書き込む。

‘dofield:’ ( – addr  ) gforth-0.2 “dofield:”
   ‘field’ のコード・アドレスを書き込む。

‘dovalue:’ ( – addr  ) gforth-0.7 “dovalue:”
   ‘CONSTANT’ のコード・アドレスを書き込む。

‘dodoes:’ ( – addr  ) gforth-0.6 “dodoes:”
   ‘DOES>’ で定義されたワードのコード・アドレス。

‘doabicode:’ ( – addr  ) gforth-1.0 “doabicode:”
   ‘ABI-CODE’ 定義のコード・アドレスを書き込む。

   ‘set-does>’ で定義されたワード X の場合、 コード・アドレスは
‘dodoes:’ を指し、 そして、 ヘッダー・メソッドの ‘>hmextra’ フィールドに
は、 X の本体(body)アドレスをプッシュした後に呼び出されるワードの xt が
含まれます。

   ワードが ‘DOES>’ で定義されたワードであるかどうか、 そしてそのワード
が execute する Forth コードを知りたい場合は、‘>does-code’ で以下のこと
がわかります:

‘>does-code’ ( xt1 – xt2  ) gforth-0.2 “>does-code”
   xt1 が ‘set-does>’ で定義されたワードの子の実行トークンである場合、
xt2 は ‘set-does>’ に渡される xt 、 つまり xt1 実行時に実行されるワード
の xt です(ただし、 最初に xt1 の本体(body)アドレスがプッシュされます)。
xt1 が ‘set-does>’ で定義されたワードに属していない場合、 xt2 は 0 です
。

   結果の xt2 を ‘set-does>’ (推奨) とともに使用して、 もっとも最新のワ
ードを変更するか以下を使用して変更できます

‘does-code!’ ( xt2 xt1 –  ) gforth-0.2 “does-code!”
   xt1 を ‘xt2 set-does>’ で定義されたワードに変更します。

   任意のワードを変更するためには…

   以下の 2 つのワードは、 ‘>code-address’ や ‘>does-code’ や
‘code-address!’ や ‘does-code!’ を一般化します:

‘>definer’ ( xt – definer  ) gforth-0.2 “>definer”
   DEFINER (definer;定義者)は、 XT の定義方法を示す一意の識別子です。 異
なる ‘does>’ コードで定義されたワードには、 異なる definer が存在します
。 definer は比較や ‘definer!’ で使用できます。

‘definer!’ ( definer xt –  ) gforth-obsolete “definer!”
   XT で表されるワードは、 その振る舞いを DEFINER に関連付けられた振る舞
いに変更します。

   ‘Code-address!’ や ‘does-code!’ や ‘definer!’ は、 ‘opt-compile,’ メ
ソッドをそのワード型用のやや汎用的なコンパイラーに更新します(特に、 プリ
ミティブに対しては、 プリミティブ固有の ‘peephole-compile,’
(peephole-compile;のぞき穴最適化コンパイル)ではなく、 遅い
‘general-compile,’ (一般コンパイル)メソッドが使用されます)。


File: gforth.info,  Node: Passing Commands to the OS,  Next: Keeping track of Time,  Prev: Carnal words,  Up: Words

6.31 Passing Commands to the Operating System
=============================================

Gforth を使用すると、 (そのようなものが存在する場合、)ホスト・オペレーテ
ィング・システムのシェルで実行するための任意の文字列をシェルに渡すことが
できます。

‘sh’ ( "..." –  ) gforth-0.2 “sh”
   行(コマンド・ライン)の残りの部分をシェルコマンドとして実行します。 そ
の後、 ワード ‘$?’ によってコマンドの終了ステータスを取得します。

‘system’ ( c-addr u –  ) gforth-0.2 “system”
   C-ADDR U で指定された文字列をホスト・オペレーティング・システムに渡し
、 サブ・シェルで実行します。 その後、 ワード ‘$?’ によってコマンドの終
了ステータスが生成されます。 環境変数 ‘GFORTHSYSTEMPREFIX’ の値 (または
そのデフォルト値) が文字列の先頭に付加されます(主に、 Cygwin がデフォル
トで使用するシェルではなく、 Windows のシェルとして ‘command.com’ の使用
をサポートするためです。)。 *note Environment variables::

‘sh-get’ ( c-addr u – c-addr2 u2  ) gforth-1.0 “sh-get”
   シェル・コマンド addr u を実行します。 c-addr2 u2 はコマンドの出力で
す。 終了コードは ‘$?’ にあります。 コマンドの出力は ‘sh$ 2@’ にもありま
す。

‘$?’ ( – n  ) gforth-0.2 “dollar-question”
   Value – 最後に実行された ‘system’ コマンドによって返された終了ステー
タス。

‘getenv’ ( c-addr1 u1 – c-addr2 u2 ) gforth-0.2 “getenv”
   文字列 c-addr1 u1 は環境変数名を指定します。 文字列 c-addr2 u2 は、 ホ
スト・オペレーティング・システムによる、 その環境変数の展開結果です。 環
境変数が存在しない場合、 c-addr2 u2 は長さ 0 文字の文字列を返します(訳注
: 存在しない:c-addr2,u2 = 0, 0 存在するけど中身が空: 【有効なアドレス】,
0)


File: gforth.info,  Node: Keeping track of Time,  Next: Miscellaneous Words,  Prev: Passing Commands to the OS,  Up: Words

6.32 Keeping track of Time
==========================

‘ms’ ( n –  ) facility-ext “ms”
\ 訳注: 指定のミリ秒ウエイトします(エポックでカウントします)。

‘ns’ ( d –  ) gforth-1.0 “ns”
\ 訳注: 指定のナノ秒ウエイトします(エポックでカウントします)

‘time&date’ ( – nsec nmin nhour nday nmonth nyear  ) facility-ext “time-and-date”
   現在の時刻を報告します。 nsec 、 nmin、 nhour は 0 から数えます。
nmonth は 1 から数えます。

‘>time&date&tz’ ( udtime – nsec nmin nhour nday nmonth nyear fdst ndstoff c-addrtz utz ) gforth-1.0 “to-time-and-date”
   1970 年 1 月 1 日 0:00Z からの時間を秒単位で現在の時刻に変換します。
nsec、 nmin、 nhourは 0 から数えます。 nmonth は 1 から数えます(訳注: 使
い方: 秒単位の値を与える必要があるので、 例えば ‘utime #1000000 ud/mod
rot drop >time&date&tz’ とする。 fdst: 夏時間を 採用しているときに負数 、
採用していないときに 0、この情報が得られないときに正数。 ndstoff : GMTか
らのオフセット(秒単位)、 c-addrtz utz : タイムゾーン文字列(例: JST))

‘utime’ ( – dtime ) gforth-0.5 “utime”
   エポック(some epoch)以降の現在時刻をマイクロ秒単位で報告します。
‘#1000000 um/mod nip’ を使用して秒に変換します

‘ntime’ ( – dtime ) gforth-1.0 “ntime”
   エポック(some epoch)以降の現在時刻をナノ秒単位で報告します。

‘cputime’ ( – duser dsystem ) gforth-0.5 “cputime”
   duser と dsystem は、 Forth システムの開始以降に使用されたユーザー・
レベルとシステム・レベルの CPU 時間(子プロセスを除く)をマイクロ秒単位で
表したものです(ただし、 粒度はさらに粗くなる可能性があります)。
getrusage コールのないプラットフォームでは、 duser については経過時間(エ
ポック)が報告され、 dsystem については 0 が報告されます。


File: gforth.info,  Node: Miscellaneous Words,  Prev: Keeping track of Time,  Up: Words

6.33 Miscellaneous Words
========================

このセクションでは、 このマニュアルの他の場所で説明されていない標準
Forth のワードをリストします。 いつかは、 これらのワードはそれぞれ適切な
セクションに配置されることになるでしょう。

‘quit’ ( ?? – ??  ) core “quit”
   リターン・スタックを空にし、 ユーザー入力デバイスを入力ソースにして、
インタプリタ状態にして、 テキスト・ インタプリタを開始します。

   以下の標準 Forth のワードは現在、 Gforth ではサポートされていません
(*note Standard conformance::):

   ‘EDITOR’ ‘EMIT?’ ‘FORGET’ (訳注: forth で書かれたラインエディタである
EDITOR ボキャブラリはありません。 FORGET はありません。任意の箇所で「忘
れる」ことはできません。代わりに ‘marker name’ で忘れるポイントを「マー
ク」しておきます。 name を実行するとそのポイントまで「忘れ」ます。)


File: gforth.info,  Node: Error messages,  Next: Tools,  Prev: Words,  Up: Top

7 Error messages
****************

Gforth の典型的なエラー・メッセージは以下のようになります:

     in file included from \evaluated string/:-1
     in file included from ./yyy.fs:1
     ./xxx.fs:4: Invalid memory address
     >>>bar<<<
     Backtrace:
     $400E664C @
     $400E6664 foo

   エラーを特定するメッセージは ‘Invalid memory address’ です。 そのエラ
ーはファイル ‘./xxx.fs’ の 4 行目をテキスト解釈(text-interpreting)してい
るときに発生しました。 その行のエラーが発生したワードを(‘>>>’ と ‘<<<’ で
囲んで)指摘します。

   エラーを含むファイルは ‘./yyy.fs’ の 1 行目でインクルード(included)さ
れており、 ‘yyy.fs’ はファイル以外からインクルードされています(この場合
、 ‘yyy.fs’ を Gforth へのコマンドライン パラメータとして指定することに
より)。

   エラー・メッセージの最後には、 バックトレースとして解釈できるリターン
・スタック・ダンプが表示されます(空の可能性があります)。 その一番上の行
には ‘throw’ が発生したときのリターン・スタックのTOSが表示され、 その一
番下の行には最上位のテキスト・インタプリタのリターン・スタックのすぐ上に
あるリターン・スタック・エントリが表示されます。

   ほとんどのリターン・スタック・エントリの右側には、 そのリターン・スタ
ック・エントリをリターン・アドレスとしてプッシュしたワードを推測して表示
します。 これによりバックトレースが得られます。 この例では、 ‘bar’ が
‘foo’ を呼び出し、 ‘foo’ が ‘@’ を呼び出していることがわかります(そして
、 この ‘@’ には 「Invalid Memory address」例外がありました)。

   注意: バックトレースは完璧では無いことに注意してください。 どのリター
ン・スタック・エントリがリターン・アドレスであるかは知りません(そのため
、 誤検知が発生する可能性があります)。 また、 (‘abort"’ など、)場合によ
っては、 リターン・アドレスからはリターン・ アドレスをプッシュしたワード
を特定できないため、 リターン・アドレスによってはリターン・スタック・ダ
ンプに名前が表示されません。

   リターン・スタック・ダンプは、 特定の ‘throw’ が execute されたときの
リターン・スタックを表します。 ‘catch’ を使用するプログラムでは、 リター
ン・スタック・ダンプにどの ‘throw’ を使用する必要があるかが必ずしも明確
ではありません(たとえば、 エラーを示すある ‘throw’ がキャッチされ、 その
リカバリ中に別のエラーが発生したとすると、 スタック・ダンプにはどの
‘throw’ のを使用するべきでしょうか？)。 Gforth は、 最後に execute され
た(そして、 その execute からまだ返ってきていない状態で、 ) ‘catch’ また
は ‘nothrow’ の後の最初の ‘throw’ のリターン・スタック・ダンプを表示しま
す: 通常、 これはうまく機能します。 正しいバック・トレースを取得するため
には、 通常、 エラーが再 throw されない場合は ‘catch’ の後に ‘nothrow’ ま
たは ‘['] false catch 2drop’ を挿入します。

   ‘gforth’ エンジン(訳注: OSコマンドラインから gforth で起動)は、 プリ
ミティブが生成した throw のリターン・スタック・ダンプを行えます(例:
invalid memory address(不正なメモリアクセス), stack empty(スタックが空)
等)。 ‘gforth-fast’ エンジン(訳注: OSコマンドラインから gforth-fast で起
動)は、 直接呼び出された ‘throw’ (‘abort’ などを含む) からのリターン・ス
タック・ダンプのみを行うことができます。 ‘gforth-fast’ エンジンのプリミ
ティブによって例外が発生した場合、 通常はリターン・スタック・ダンプは全
く見れません。 しかしながら、 ‘catch’ によって例外がキャッチされ(たとえ
ば、 何らかの状態を復元するため)、 その後再び ‘throw’ が返される場合、 最
初の ‘throw’ に対するリターン・スタック・ダンプは見れます。

   また、 ‘gforth-fast’ は、 ゼロ除算と除算オーバーフローを区別しようと
しません。 これは、 どの除算も時間が掛かる処理だからです。


File: gforth.info,  Node: Tools,  Next: Standard conformance,  Prev: Error messages,  Up: Top

8 Tools
*******

* Menu:

* Standard Report::          使用されたワードをワードセットごとにソートして報告します
* Stack depth changes::      このスタック値はどこから来たのか?

こちらもご覧ください *note Emacs and Gforth::


File: gforth.info,  Node: Standard Report,  Next: Stack depth changes,  Prev: Tools,  Up: Tools

8.1 ‘ans-report.fs’: Report the words used, sorted by wordset
=============================================================

Forth プログラムを標準プログラムとしてラベル付けしたい場合は、 プログラ
ムがどのワードセットを使用するかを文書化する必要があります。

   ‘ans-report.fs’ ツールを使用すると、アプリケーションでどのワードセッ
トのどのワードが使用されているか、 どの非標準ワードが使用されているかを
簡単に判断できます。 チェックしたいプログラムをロードする前に
‘ans-report.fs’ をインクルードするだけです。 プログラムをロードした後、
‘print-ans-report’ を使用してレポートを取得できます。 一般的な使用法は、
以下のようにこれをバッチ・ジョブとして実行することです:
     gforth ans-report.fs myprog.fs -e "print-ans-report bye"

   出力は以下のようになります (‘compat/control.fs’ の場合):
     The program uses the following words
     from CORE :
     : POSTPONE THEN ; immediate ?dup IF 0=
     from BLOCK-EXT :
     \
     from FILE :
     (

   ‘ans-report.fs’ は、 Forth-94 と Forth-2012 の両方のワードセットをレ
ポートします。 両方の標準に含まれるワードについては、 接尾辞なしでワード
セットが報告されます(例: ‘CORE-EXT’)。 Forth-2012 専用のワードの場合、
‘-2012’ 接尾辞が付いたワードセットが報告されます(例: ‘CORE-EXT-2012’)。
Forth-94 のみのワード(つまり、Forth-2012 で削除されたワード)についても同
様です。

8.1.1 Caveats
-------------

注意: ‘ans-report.fs’ は、 どのワードが使用されているかをチェックするだ
けで、 標準に準拠した方法で使用されているかどうかをチェックするわけでは
ないことに注意してください。

   一部のワードは、 標準で複数のワードセットで定義されています。
‘ans-report.fs’ は、 それらのワードセットのうちの 1 つについてのみレポー
トし、 それは必ずしもあなたが期待したワードセットとは限りません。 どのワ
ードセットを指定するのが適切かは、 用途によって異なります。 たとえば、
‘S"’ のコンパイル機能(compilation semantics)のみを使用する場合、それは
CORE ワードです。 インタプリタ機能(interpretation semantics)も使用する場
合、 それは FILE ワードです。


File: gforth.info,  Node: Stack depth changes,  Prev: Standard Report,  Up: Tools

8.2 Stack depth changes during interpretation
=============================================

ファイルをロードした後、 スタックに項目が残っていることに気づくことがあ
ります。 ‘ Depth-changes.fs’ ツールを使用すると、 これらのスタック項目が
ファイル内のどこから来たのかをすばやく見つけることができます。

   ‘ Depth-changes.fs’ を使用する最も簡単な方法は、 チェックするファイル
の前にこれをインクルードすることです。 例:

     gforth depth-changes.fs my-file.fs

   これにより、 すべての空行(インタプリタ状態)でのデータ・スタックの深さ
と FP スタックの深さが、 最後の空行(インタプリタ状態)での深さと比較され
ます。 深さが等しくない場合は、 ファイル内の位置とスタックの内容が ‘~~’
(*note Debugging::) で出力されます。 これは、 指摘行より前の空ではない行
内の段落(paragraph)でスタックの深さの変更が発生したことを示します。 ファ
イルの最後に空行を残しておいて、 最後の段落もチェックされるようにするこ
とをお勧めします。

   通常、 空行のみをチェックするのはうまく機能しますが、 空行ではない大
きなブロックが存在する場合(大きなテーブルを構築する場合など)、 このブロ
ックのどこでスタックの深さが変更されたのかを知りたい場合があります。 以
下を使用すると、 解釈(interpret)されたすべての行をチェックできます

     gforth depth-changes.fs -e "' all-lines is depth-changes-filter" my-file.fs

   これにより、 各行末ごとにスタックの深さがチェックされます。 したがっ
て、 深さの変更は ‘~~’ によって報告された行で発生しています(それより前の
行ではありません)。

   注意: これにより、 スタックの深さが変更される場所を示す精度が向上しま
すが、 多くの、 意図した、 スタックの深さの変更が報告されることが多いこ
とに注意してください(たとえば、 解釈(interpret)された計算が複数の行にま
たがる場合)。 一部の行のチェックを抑制するには、 これらの行の末尾にバッ
クスラッシュを置き(その後に空白は続きません)、 以下を使用します

     gforth depth-changes.fs -e "' most-lines is depth-changes-filter" my-file.fs


File: gforth.info,  Node: Standard conformance,  Next: Standard vs Extensions,  Prev: Tools,  Up: Top

9 Standard conformance
**********************

(標準適合度)私達の知る限り、 Gforth は…

   ANS Forth システムと Forth-2012 システムに関しては
   • Core Extensions ワード・セットを提供します
   • Block ワード・セットを提供します
   • Block Extensions ワード・セットを提供します
   • Double-Number ワード・セットを提供します
   • Double-Number Extensions ワード・セットを提供します
   • Exception ワード・セットを提供します
   • Exception Extensions ワード・セットを提供します
   • Facility ワード・セットを提供します
   • Facility Extensions ワード・セットを提供します(‘EMIT?’ を除く)
   • File Access ワード・セットを提供します
   • File Access Extensions ワード・セットを提供します
   • Floating-Point ワード・セットを提供します
   • Floating-Point Extensions ワード・セットを提供します
   • Locals ワード・セットを提供します
   • Locals Extensions ワード・セットを提供します
   • Memory-Allocation ワード・セットを提供します
   • Memory-Allocation Extensions ワード・セットを提供します
   • Programming-Tools ワード・セットを提供します
   • Programming-Tools Extensions ワード・セットを提供します(‘EDITOR’ と
     ‘FORGET’ を除く)
   • Search-Order ワード・セットを提供します
   • Search-Order Extensions ワード・セットを提供します
   • String ワード・セットを提供します
   • String Extensions ワード・セットを提供します
   • Extended-Character ワード・セットを提供します

   Gforth には以下の環境的制限(environmental restrictions)があります:

   • OS コマンド・ラインの処理中に例外がキャッチされなかった場合、
     Gforth は QUIT を実行する代わりにゼロ以外の終了コード(exit code)で
     終了(exit)します。

   • ‘query’ の後に ‘throw’ が実行される場合、 Gforth は対応する ‘catch’
     で有効な入力ソース仕様を常に復元するとは限りません。

   さらに、 標準 Forth システムでは、 特定の実装での選択を文書化する必要
があります。 この章では、 Forth-94 標準のこれらの要件を満たすことを試み
ます。 Forth-2012 標準については、 需要がある場合にのみ追加のドキュメン
トを作成することにしました。 したがって、 このドキュメントで本当に足りな
いという場合は、 著者達までご連絡ください。

   多くの場合、 以下のドキュメント群においては、 特に、 情報がプロセッサ
に依存する場合、 オペレーティング・システムまたは選択したインストール・
オプション、 または、 Gforth のメンテナンス中に変更される可能性があるか
どうについては、 情報を直接提供する代わりに、 システムに情報を要求する方
法が説明されています。

* Menu:

* The Core Words::
* The optional Block word set::
* The optional Double Number word set::
* The optional Exception word set::
* The optional Facility word set::
* The optional File-Access word set::
* The optional Floating-Point word set::
* The optional Locals word set::
* The optional Memory-Allocation word set::
* The optional Programming-Tools word set::
* The optional Search-Order word set::


File: gforth.info,  Node: The Core Words,  Next: The optional Block word set,  Prev: Standard conformance,  Up: Standard conformance

9.1 The Core Words
==================

* Menu:

* core-idef::                実装毎オプション(Implementation Defined
                               Options;idef)
* core-ambcond::             あいまいな条件
* core-other::               その他のシステム・ドキュメント


File: gforth.info,  Node: core-idef,  Next: core-ambcond,  Prev: The Core Words,  Up: The Core Words

9.1.1 実装毎オプション(Implementation Defined Options;idef)
-----------------------------------------------------------

セル単位に整列されたアドレス:
     プロセッサ依存です。 Gforth の整列(alignment)ワードは自然な整列
     (natural alignment)を実行します(たとえば、 サイズ 8 のデータに対し
     て整列されたアドレスは 8 で割り切れます)。 通常、 非整列アクセス
     (unaligned accesses)では ‘-23 THROW’ が発生します。

‘EMIT’ と非表示文字:
     文字(character)は C 言語のライブラリ関数(実際にはマクロ) ‘putc’ を
     使用して出力されます。

‘ACCEPT’ と ‘EXPECT’ の文字編集:
     これは、 Emacs のようなキー・バインディングを備えた GNU readline ラ
     イブラリ(*note Command Line Editing: (readline)Readline
     Interaction.)をモデルにしています。 ‘Tab’ を入力するたびに (すべて
     の補完に共通のプレフィックスを生成するのではなく)完全なワード語補完
     を生成するという点で少し異なります。 *Note Command-line editing::

文字セット:
     あなたのコンピュータと表示デバイスの文字セット。 Gforth は 8 ビット
     クリーンです(ただし、 システム内の他のコンポーネントが問題を引き起
     こす可能性があります)。

文字単位に整列されたアドレスの要件:
     インストールに依存します。 現在、 文字は C言語の ‘unsigned char’ で
     表されます。 (リクエストへのコメントですけども、 )将来的には
     ‘wchar_t’ に切り替える可能性があります。

文字セット拡張と名前の照合:
     ASCII NUL 文字を除く任意の文字を名前に使用できます。 照合では大文字
     と小文字が区別されません(‘TABLE’ を除く)。 照合は C 言語ライブラリ
     関数 ‘strncasecmp’ を使用して実行されますが、 その関数はおそらくロ
     ケールの影響を受けます。 たとえば、‘C’ ロケールではアクセントとウム
     ラウトが認識されないため、 そのロケールでは大文字と小文字が区別され
     て照合されます。 移植性の理由から、 ‘C’ ロケールで動作するようにプ
     ログラムを作成することが最善です。 そうすれば、 ポーランド人のプロ
     グラマ(ISO Latin-2 でエンコードされた文字を含むワードを使用する可能
     性がある)と、 フランスのプログラマ(ISO Latin-1)が作成したライブラリ
     を同じプログラム内で使用できます(もちろん、 ‘WORDS’ は一部のワード
     に対して愉快な結果を生成します(どのワードでそうなるかは、 使用して
     いるフォントによって異なります))。 また、 あなたのご希望のロケール
     が他のオペレーティング・システムでは利用できない場合もあります。
     Unicode がいつかこれらの問題を解決してくれることを願っています。

制御文字がスペース区切り文字と一致する条件:
     ‘word’ がスペース文字を区切り文字として使用して呼び出された場合、 す
     べての空白文字(C 言語マクロ ‘isspace()’ で識別される)が区切り文字に
     なります。 一方、 ‘parse’ はスペースを他の区切り文字と同様に扱いま
     す。 ‘parse-name’ はデフォルトで外部インタープリター (別名テキスト
     ・インタープリター) によって使用され、 すべての空白文字を区切り文字
     として扱います。

制御フロースタックの形式:
     データ・スタックは制御フロー・スタックとして使用されます。 制御フロ
     ー・スタック項目のセル単位でのサイズは、 constant ‘cs-item-size’ に
     よって与えられます。 この記事の執筆時点では、 制御フロー・スタック
     項目はローカル変数リスト(3番目)、 コード内のアドレス(2 番目)、 アイ
     テムを識別するためのタグ(TOS) で構成されています。 タグとして次のタ
     グが使用されています: ‘defstart’, ‘live-orig’, ‘dead-orig’, ‘dest’,
     ‘do-dest’, ‘scopestart’

35を超える「数字」の変換
     文字 ‘[\]^_'’ は、 10 進数値で 36〜41 の「数字」として解釈されます
     (訳注: 基数による)。 それより大きな「数字」の多くは(直接)入力する方
     法がありません。

‘ACCEPT’ および ‘EXPECT’ で入力が終了した後の表示:
     入力した文字列の末尾にカーソルが移動します。 ‘Return’ キーを使用し
     て入力を終了する場合は、 スペースが入力されます。

‘ABORT"’ の 例外中止(exception abort)シーケンス:
     エラー文字列は変数 ‘"error’ に保存され、 ‘-2 throw’ が実行されます
     。

入力行終端文字:
     対話入力の場合は、 ‘C-m’ (CR) および ‘C-j’ (LF) で行を終了します。
     通常、 これらの文字は、 ‘Enter’ キーまたは ‘Return’ キーを入力した
     ときに生成されます。

カウンタ付き文字列の最大サイズ:
     ‘s" /counted-string" environment? drop .’ で得られます。 現在、 す
     べてのプラットフォームで 255 文字ですが、 これは変更される可能性が
     あります。

パースされる字列の最大サイズ:
     constant ‘/line’ によって与えられます。 現在 255 文字です。

定義名の最大サイズ(文字単位):
     MAX-U / 8 (‘s" max-u" environment? drop 8 u/ u.’)

‘ENVIRONMENT?’ の最大文字列長(文字単位):
     MAX-U / 8 (‘s" max-u" environment? drop 8 u/ u.’)

ユーザー入力デバイスを選択する方法:
     ユーザー入力デバイスは標準入力です。 現時点では、 Gforth 内から変更
     する方法はありません。 ただし、 入力は通常、Gforth を起動するOSコマ
     ンド・ラインでリダイレクトできます。

ユーザー出力デバイスを選択する方法:
     ‘EMIT’ および ‘TYPE’ は、値 ‘outfile-id’ (デフォルトでは ‘stdout’)
     に格納されているファイル ID に出力します。 Gforth は、ユーザー出力
     デバイスが端末の場合はバッファなしの出力を使用します。 それ以外の場
     合、 出力はバッファリングされます。

ディクショナリのコンパイル方法:
     わざわざここで文書化する必要ある？(What are we expected to document
     here?)

アドレス単位 1 つ分のビット数:
     ‘s" address-units-bits" environment? drop .’ で得られます。 現在は
     すべてのプラットフォームで 8

数値の表現と算術演算:
     プロセッサに依存します。 現在のすべてのプラットフォームでは 2 進数
     は 2 の補数表現です。

整数型の範囲:
     インストールに依存します。 ‘MAX-N’ と ‘MAX-U’ と ‘MAX-D’ と
     ‘MAX-UD’ の環境クエリ(environmental queries)を作成します。 符号なし
     (および正)型の下限は 0 です。 2 の補数マシンおよび 1 の補数マシンの
     符号付き型の下限は、 その上限に 1 を加算することで計算できます。

読み取り専用データ空間領域:
     Forth データ空間全体が書き込み可能です。

‘WORD’ のバッファのサイズ:
     ‘PAD HERE - .’ で得られます。 32 ビット マシンでは 104 文字。 バッ
     ファは、 数値表示出力文字列(pictured numeric output string)と共有さ
     れます。 ‘PAD’ の上書きが許容される場合、 そのサイズは残りの辞書ス
     ペースと同じになりますが、 実用になるのはカウンタ付き文字列に収まる
     範囲程度です。

アドレス単位での 1 セルのサイズ:
     ‘1 cells .’ で得られます。

アドレス単位での 1 文字のサイズ:
     ‘1 chars .’ で得られます。 現在のすべてのプラットフォームで 1

キーボード・ターミナル・バッファのサイズ:
     さまざまです。 ‘lp@ tib - .’ を使用して、 特定の時点でのサイズを確
     認できます。 これは、 現在のファイルを含むファイルのローカル変数ス
     タックおよび TIB と共有されます。 コマンド・ライン・オプション ‘-l’
     を使用して、 Gforth 起動時に TIB とローカル変数スタックのスペースの
     量を変更できます。

表示数値出力(pictured numeric output)バッファのサイズ:
     ‘PAD HERE - .’ で得られます。 32 ビット マシンでは 104 文字。 バッ
     ファは ‘WORD’ と共有されます。

‘PAD’ によって返されるスクラッチ領域のサイズ:
     ディクショナリ・スペースの残りまるごと。 ‘unused pad here - - .’ で
     得られます。

システムが英大文字・小文字を区別するか(case-sensitivity characteristics):
     ディクショナリの検索では大文字と小文字が区別されません(‘TABLE’ を除
     く)。 ただし、 上記 character-set extensions で説明したように、 非
     ASCII 文字のマッチングは使用しているロケールによって決まります。 デ
     フォルトの ‘C’ ロケールでは、 すべての非 ASCII 文字は大文字と小文字
     を区別して照合されます。

システムのプロンプト:
     インタプリタ状態では ‘ ok’ で、 コンパイル状態では ‘ compiled’ です
     。

除算の四捨五入(division rounding):
     通常の除算ワード ‘/ mod /mod */ */mod’ は、フロア除算(floored
     division)を実行します (Gforth のデフォルトのインストールを使用の場
     合)。 ‘s" floored" environment? drop .’ でこれを確認できます。 特定
     の除算の四捨五入が必要なプログラムを作成する場合は、 移植性を高める
     ために ‘fm/mod’ または ‘sm/rem’ を使用するのが最適です。

true の場合の ‘STATE’ の値:
     -1.

算術オーバーフロー後に返される値:
     2 の補数マシンでは、 1倍長の場合は 2**bits-per-cell 、 2倍長の場合
     はセルあたり 4**bits-per-cell を法として演算(modulo)が実行されます
     (符号付き型では適切なマッピングを使用)。 ゼロによる除算は通常、
     ‘-55 throw’ (Floating-point unidentified fault) または ‘-10 throw’
     (divide by zero) を引き起こします。 整数除算のオーバーフローにより
     、 ‘-55 throw’ や ‘-10 throw’ 、 または ‘-11 throw’ が発生する可能
     性があります。 ‘gforth-fast’ エンジン(OSコマンドラインから
     ‘gforth-fast’ で起動)の除算オーバーフローやゼロ除算では、 例外が生
     成されずに偽の結果が返される可能性があります。

現在の定義(current definition)が ‘DOES>’ の後ろで見つかる(可視)かどうか:
     いいえ(No)。


File: gforth.info,  Node: core-ambcond,  Next: core-other,  Prev: core-idef,  Up: The Core Words

9.1.2 Ambiguous conditions
--------------------------

ワードでも数字でもない名前:
     ‘-13 throw’ (Undefined word)

定義名が許可される最大長を超えています:
     ‘-19 throw’ (Word name too long)

forth システムのさまざまなデータ空間内で無い領域をアドレス指定しようとした:
     スタックやコード・スペースやヘッダー・スペースはアクセス可能です。
     マシン・コード空間は通常、読み取り可能です。 他のアドレスにアクセス
     すると、 オペレーティング・システムに応じた結果が得られます。 まと
     もなシステムの場合: ‘-9 throw’ (Invalid memory address)

引数の型がパラメータと互換性がありません:
     これは通常はキャッチされません。 一部のワード(制御フロー・ワードな
     ど)はチェックを実行し、 ‘ABORT"’ または ‘-12 THROW’ (Argument type
     mismatch) となります。

実行機能(execution semantics)が未定義であるワードの実行トークンを取得しようとしています:
     実行トークンは、 ワードのインタプリタ機能(interpretation
     semantics)を表します。 Gforth はすべてのワードのインタプリタ機能を
     定義します。 標準でインタプリタ機能が定義されていないが、 実行機能
     (execution semantics)が定義されているワード(‘LEAVE’ を除く)について
     は、 インタプリタ機能が実行機能を実行します。 標準でインタプリタ機
     能が定義されていないが、 コンパイル機能(compilation semantics)(およ
     び ‘LEAVE’)が定義されているワードの場合、 インタプリタ機能はコンパ
     イル機能を実行します。 一部の単語はコンパイル専用(compile-only)とし
     てマークされており、 ‘'’ はこれらのワードに対して警告を出します。

ゼロ除算:
     一部のプラットフォームでは、 これにより ‘-10 throw’ (Division by
     zero) が生成されます。 他のシステムでは、 通常、 これにより ‘-55
     throw’ (Floating-point unidentified fault) が生成されます。

データ・スタックのスペースまたはリターン・スタックのスペースが不十分:
     オペレーティング・システムやインストール時の設定や Gforth の起動時
     の設定に応じて、 これはメモリ管理ハードウェアによって、 チェックさ
     れたり、チェックされなかったり。 これがチェックされている場合、 通
     常はオーバーフローが発生するするやいなや、 (プラットフォームとオー
     バーフローを達成した方法によって異なりますが、) ‘-3 throw’ (Stack
     overflow) または ‘-5 throw’ (Return stack overflow) または ‘-9
     throw’ (Invalid memory address) を受け取ります。 これがチェックされ
     ていない場合、 オーバーフローは通常、 原因不明の不正なメモリ・アク
     セスを引き起こし、 ‘-9 throw’ (Invalid memory address) または ‘-23
     throw’ (Address alignment exception) を生成します。 また、
     ‘ALLOCATE’ とそのファミリーの内部データ構造も破壊し、 これらのワー
     ドにさまざまなエラーが発生する可能性があります。

ループ制御パラメータ用のスペース不足:
     他のリターン・スタック・オーバーフローと同様。

ディクショナリのスペースが不足:
     ディクショナリで利用可能なメモリを超えるメモリを(‘allot’ で直接、 ま
     たは ‘,’ や ‘create’ などで間接的に)割り当てようとすると、 ‘-8
     throw’ (Dictionary overflow) が発生します。 ディクショナリの末尾を
     超えてメモリにアクセスしようとすると、 結果はスタック・オーバーフロ
     ーと同様になります。

未定義のインタプリタ機能(interpretation semantics)でワードを解釈(interpret):
     Gforth は全てのワードのインタプリタ機能(interpretation semantics)を
     定義します。 標準で実行機能(execution semantics)が定義されているワ
     ード(‘LEAVE’ を除く)については、 インタプリタ機能が実行機能を実行し
     ます。 標準ではインタプリタ機能が定義されていないが、 コンパイル機
     能(compilation semantics)(および ‘LEAVE’)が定義されているワードの場
     合、 インタプリタ機能はコンパイル機能。 一部のワードはコンパイル専
     用(compile-only)としてマークされており、 テキスト解釈
     (text-interpreting)すると警告が表示されます。

入力バッファまたは文字列リテラルの内容を変更:
     これらは書き込み可能なメモリに配置されており、 変更することができま
     す。

表示数値出力文字列(pictured numeric output string)のオーバーフロー:
     ‘-17 throw’ (Pictured numeric ouput string overflow)

パースする文字列のオーバーフロー:
     ‘PARSE’ はオーバーフロー不可能です。 ‘WORD’ はオーバーフローをチェ
     ックしません。

範囲外の結果の生成:
     2 の補数マシンでは、 1倍長演算の場合は 2**bits-per-cell 、2倍長演算
     の場合は 4**bits-per-cell を法(modulo)として演算が実行されます(符号
     付き型は適切なマッピングを使用)。 ゼロ除算は通常、‘-10 throw’
     (divide by zero) または ‘-55 throw’ (floating point unidentified
     fault) を引き起こします。 除算のオーバーフローにより、 ‘-10 throw’
     (divide by zero) または ‘-55 throw’ (floating point unidentified
     fault) が発生したり、 ‘-11 throw’ (result out of range) が発生した
     りする可能性があります。 ‘Gforth-fast’ エンジン(訳注: OSコマンドラ
     インから ‘Gforth-fast’ で起動)では、 除算のオーバーフローまたはゼロ
     による除算の際に、 暗黙的に偽の結果を生成する可能性があります。
     ‘Convert’ と ‘>number’ は現在、 何も警告を出さずにオーバーフローし
     ます。

空のデータ・スタックまたは空のリターン・スタックからの読み取り:
     データ・スタックは、 各ワード execute 後、 外部インタプリタ(別名 テ
     キスト・インタプリタ)によってチェックされます。 アンダーフローした
     場合は、 ‘-4 throw’ (Stack underflow) が発出されます。 それとは別に
     、 オペレーティング・システムやインストール時の設定や(OSからの
     gforth)起動時の設定に応じて、 スタックがチェックされるかどうかが異
     なります。 チェックで検出された場合、 通常は、プラットフォームや、
     どのスタックがどの程度アンダーフローしたかに応じて、 通常は ‘-4
     throw’ (Stack underflow) または ‘-6 throw’ (Return stack underflow)
     または ‘-9 throw’ (Invalid memory address) が発生します。 注意: シ
     ステムが(MMU を介した)チェックを使用している場合でも、 リアクション
     をトリガーするには、 プログラムがかなりの数のスタック項目をアンダー
     フローする必要がある場合があることに注意してください(その理由は、
     MMU 絡みチェックがページ・サイズの粒度で動作するためです)。 チェッ
     クが行われない場合、アンダーフローによる症状はオーバーフローによる
     症状と似ています。 アンバランスなリターン スタック エラーは ‘-9
     throw’ (Invalid memory address) や不正な命令(通常は ‘-260 throw’)な
     ど、さまざまな症状を引き起こす可能性があります。

予期せず入力バッファの終わりに達したため、 長さ 0 の文字列を名前として使用しようとした:
     ‘Create’ とその子孫は ‘-16 throw’ (Attempt to use zero-length
     string as a name;長さ 0 の文字列を名前として使用しようとします)を発
     出します。 ‘'’ のようなワードは検索しても見つからない可能性がありま
     す。 注意: ‘nextname’ を使用して長さゼロの名前を作成できることに注
     意してください(ホントにそうすべきかどうかをよく確認してください)。

‘>IN’ が指し示す値が入力バッファの長さより大きい:
     次にパース・ワードを呼び出すと、 長さ 0 の文字列が返されます。

‘RECURSE’ が ‘DOES>’ の後に現れた:
     ‘DOES>’ の後のコードへの再帰呼び出しをコンパイルします。

‘RESTORE-INPUT’ の引数の入力ソースが現在の入力ソースと異なります:
     ‘-12 THROW’ 注意: 入力ファイルが閉じられると(たとえば、 ファイルの
     終わりに達したため、 その source-id は再利用される可能性があること
     に注意してください。 したがって、 閉じられたファイルを参照する入力
     ソース仕様(input source specification)を復元(restore)すると、 ‘-12
     THROW’ ではなく、 予期しない結果が発生する可能性があります。

     将来的には、 Gforth は現在の入力ソース以外から入力ソースの仕様を復
     元(input source specifications)できるようになる可能性があります。

定義を含むデータス・ペースの割り当てを解除:
     ‘allot’ による割り当て解除はチェックされません。 これにより、通常、
     メモリ・アクセス・フォールト(memory access faults)や不正な命令の実
     行(execution of illegal instructions)が発生します。

不正なアライメント(alignment)によるデータ空間の 読み取り/書き込み:
     プロセッサに依存します。 通常、 ‘-23 throw’ (Address alignment
     exception) が発生します。 アライメントがオンになっている 486 以降の
     プロセッサ上の Linux-Intel では、 アライメントが正しくないと ‘-9
     throw’ (Invalid memory address) が発生します。 報告によると、 アラ
     イメント制限があるのに違反を報告しない一部のプロセッサがあるとのこ
     とです。

データ空間ポインタが正しくアライメントされていない ‘,’, ‘C,’:
     他のアライメント・エラーと同様。

u+2 未満のスタック項目で ‘PICK’ および ‘ROLL’ を実行:
     他のスタック・アンダーフローと同様。

ループ制御パラメータが無効:
     チェックされていません。 カウンタ付きループのワード群は、 リターン
     ・スタック項目の先頭がループ制御パラメータであると単純に想定し、 そ
     れに応じて動作します。

最新の定義は名前を持っていません(‘IMMEDIATE’):
     ‘abort" last word was headerless"’.

‘TO’ で使用される ‘VALUE’ で名前が定義されていません:
     ‘-32 throw’ (Invalid name argument) (名前がローカル変数であるか、
     ‘CONSTANT’ によって定義されている場合を除きます。 後者の場合は、 定
     数が変更されるだけです)。

名前が見つかりません(‘'’, ‘POSTPONE’, ‘[']’, ‘[COMPILE]’):
     ‘-13 throw’ (Undefined word)

パラメータが同じ型(type)ではありません(‘DO’, ‘?DO’, ‘WITHIN’):
     Gforth は、 それらが同じタイプであるかのように振る舞います。 つまり
     、 あなたは、 すべてのパラメータを符号付きなどとして解釈することで
     、振る舞いを予測できます。

‘POSTPONE’ または ‘[COMPILE]’ が ‘TO’ に適用されました:
     ‘: X POSTPONE TO ; IMMEDIATE’ と仮定します。 ‘X’ は ‘TO’ のコンパイ
     ル機能(compilation semantics)を実行します。

‘WORD’ によって返されるカウンタ付き文字列よりも長い文字列:
     チェックされていません。 文字列は問題ありませんが、 当然ながら、 そ
     のカウントにはその長さの最下位ビット達のみが含まれます。

指定の u がセル内のビット数以上(‘LSHIFT’、‘RSHIFT’):
     プロセッサに依存します。 一般的な振る舞いは、 0 を返し、 シフト・カ
     ウントの下位ビット達のみを使用することです。

‘CREATE’ によって定義されたワードではない:
     ‘>BODY’ は、 ワードの定義方法に関係なく、 ワードの PFA を生成します
     。

     ‘DOES>’ は、 定義方法に関係なく、 最後に定義されたワードの実行機能
     (execution semantics)を変更します。 たとえば、 ‘CONSTANT DOES>’ は
     ‘CREATE , DOES>’ と同等です。

‘<#’ 〜 ‘#>’ の外で不適切に使用されているワード:
     チェックされていません。 いつものように、 メモリ障害が発生すること
     が予想されます。


File: gforth.info,  Node: core-other,  Prev: core-ambcond,  Up: The Core Words

9.1.3 Other system documentation
--------------------------------

‘PAD’ を使用した非標準ワード:
     無し。

利用可能なオペレータの端末設備(operator’s terminal facilities):
     OS のコマンド・ライン処理後、 Gforth は対話モードになり、 Gforth に
     対話的にコマンドを与えることができます。 実際に利用できる機能は、
     Gforth の呼び出し方法によって異なります。

利用可能なプログラム・データ空間:
     ‘UNUSED .’ は残りのディクショナリ空間を与えます。 合計ディクショナ
     リ空間は、 Gforth の起動時に ‘-m’ スイッチで指定できます(*note
     Invoking Gforth::)。

使用可能なリターン・スタック空間:
     ‘s" RETURN-STACK-CELLS" environment? drop .’ を使用して、 セル単位
     での合計リターン・スタック空間を計算できます。 あなたは gforth 起動
     時に ‘-r’ スイッチを使用して指定できます(*note Invoking Gforth::)。

利用可能なデータ・スタック空間:
     ‘s" STACK-CELLS" environment? drop .’ を使用して、 セル単位での合計
     データ・スタック空間を計算できます。 あなたは gforth 起動時に ‘-d’
     スイッチを使用して指定できます(*note Invoking Gforth::)。

必要なシステム・ディクショナリ空間(アドレス単位;aus):
     起動直後に ‘here first-start - .’ と入力します。 この記事の執筆時点
     では、 32 ビット システムでは 80080 (バイト) になります(訳注:
     Gforth 0.7.9_20240418 amd64 では 649000 aus(address unit))


File: gforth.info,  Node: The optional Block word set,  Next: The optional Double Number word set,  Prev: The Core Words,  Up: Standard conformance

9.2 The optional Block word set
===============================

* Menu:

* block-idef::               実装毎オプション(Implementation Defined
                               Options;idef)
* block-ambcond::            あいまいな条件
* block-other::              その他のシステム・ドキュメント


File: gforth.info,  Node: block-idef,  Next: block-ambcond,  Prev: The optional Block word set,  Up: The optional Block word set

9.2.1 実装毎オプション(Implementation Defined Options;idef)
-----------------------------------------------------------

‘LIST’ 使用時の表示書式:
     最初にスクリーン番号が表示され、次に 1 行当たり 64 文字からなる 16
     行が表示され、 各行の前に行番号が表示されます。

‘\’ の影響を受ける行の長さ:
     64 文字。


File: gforth.info,  Node: block-ambcond,  Next: block-other,  Prev: block-idef,  Up: The optional Block word set

9.2.2 Ambiguous conditions
--------------------------

ブロックを正常に読み取りできませんでした:
     通常、 OS 由来の値 (-512 ～ -2048) の ‘throw’ が返されます。 ブロッ
     ク・ファイルの長さが十分でない場合、 足りない部分は空白を返します。

ブロックの転送時の I/O 例外:
     通常、 OS 由来の値 (-512 ～ -2048) の ‘throw’ が返されます。

不正なブロック番号:
     ‘-35 throw’ (Invalid block number)

プログラムが ‘BLK’ の値を直接書き換えた場合:
     入力ストリームは、 同じ位置で別のブロックに切り替えられます。 非ブ
     ロック入力の解釈(interpret)時に ‘BLK’ への値の格納が行われた場合、
     ブロックの終了時にシステムがかなり混乱することでしょう。

current block buffer が無い状態で ‘UPDATE’ を実行した:
     ‘UPDATE’ は何もしません。


File: gforth.info,  Node: block-other,  Prev: block-ambcond,  Up: The optional Block word set

9.2.3 Other system documentation
--------------------------------

マルチ・プログラミング・システムがバッファ・アドレスの使用に課す制限:
     (今のところ) 制限はありません。

ソース・コードとデータに使用できるブロックの数:
     あなたのディスク容量によります。


File: gforth.info,  Node: The optional Double Number word set,  Next: The optional Exception word set,  Prev: The optional Block word set,  Up: Standard conformance

9.3 The optional Double Number word set
=======================================

* Menu:

* double-ambcond::           あいまいな条件


File: gforth.info,  Node: double-ambcond,  Prev: The optional Double Number word set,  Up: The optional Double Number word set

9.3.1 Ambiguous conditions
--------------------------

‘D>S’ において、 d が n の範囲を超えている:
     d の最下位セルだけを使います。


File: gforth.info,  Node: The optional Exception word set,  Next: The optional Facility word set,  Prev: The optional Double Number word set,  Up: Standard conformance

9.4 The optional Exception word set
===================================

* Menu:

* exception-idef::           実装毎オプション(Implementation Defined
                               Options;idef)


File: gforth.info,  Node: exception-idef,  Prev: The optional Exception word set,  Up: The optional Exception word set

9.4.1 実装毎オプション(Implementation Defined Options;idef)
-----------------------------------------------------------

‘THROW’ コード値:
     コード -256〜-511 は、 シグナルに使用されます。 OS シグナル番号から
     throw コードへのマッピングは、-256−signal です。 コード -512〜-2047
     は、OS エラー(ファイルおよびメモリ割り当て操作)に使用されます。 OS
     エラー番号から throw コードへのマッピングは、-512−‘errno’ です。 こ
     のマッピングの副作用の 1 つは、 未定義の OS エラーにより、 奇妙な番
     号のメッセージが生成されることです。 例: ‘-1000 THROW’ の場合、 私
     のシステムでは ‘Unknown error 488’ が発生します。


File: gforth.info,  Node: The optional Facility word set,  Next: The optional File-Access word set,  Prev: The optional Exception word set,  Up: Standard conformance

9.5 The optional Facility word set
==================================

* Menu:

* facility-idef::            実装毎オプション(Implementation Defined
                               Options;idef)
* facility-ambcond::         あいまいな条件


File: gforth.info,  Node: facility-idef,  Next: facility-ambcond,  Prev: The optional Facility word set,  Up: The optional Facility word set

9.5.1 実装毎オプション(Implementation Defined Options;idef)
-----------------------------------------------------------

キーボード・イベントのエンコード (‘EKEY’):
     ASCII 文字に対応するキーは ASCII 文字としてエンコードされます。 他
     のキーは次の定数でエンコードされます: ‘k-left’, ‘k-right’, ‘k-up’,
     ‘k-down’, ‘k-home’, ‘k-end’, ‘k1’, ‘k2’, ‘k3’, ‘k4’, ‘k5’, ‘k6’,
     ‘k7’, ‘k8’, ‘k9’, ‘k10’, ‘k11’, ‘k12’, ‘k-winch’, ‘k-eof’

システム・クロック・ティックの間隔:
     システムに依存します。 ワード ‘MS’ に関しては、 時間はマイクロ秒単
     位で指定されます。 OS とハードウェアがこれをどの程度うまく実装する
     かは別の問題です。

ワード ‘MS’ の execute で期待される再現性:
     システムに依存します。 Unix では、多くのことが負荷に依存します。 シ
     ステムの負荷が軽く、 Gforth がスワップアウトされないほど遅延が短い
     場合、 パフォーマンスは許容範囲内です。 MS-DOS やその他のシングルタ
     スク・システムではパフォーマンスは良好です。


File: gforth.info,  Node: facility-ambcond,  Prev: facility-idef,  Up: The optional Facility word set

9.5.2 Ambiguous conditions
--------------------------

‘AT-XY’ は、 あなたの出力デバイスでは実行できませんした:
     主に端末に依存します。 引数の範囲チェックは行われません。 エラーは
     報告されません。 ゴミが表示される場合もあれば、 何も起こらない場合
     もあります。


File: gforth.info,  Node: The optional File-Access word set,  Next: The optional Floating-Point word set,  Prev: The optional Facility word set,  Up: Standard conformance

9.6 The optional File-Access word set
=====================================

* Menu:

* file-idef::                実装毎オプション(Implementation Defined
                               Options;idef)
* file-ambcond::             あいまいな条件


File: gforth.info,  Node: file-idef,  Next: file-ambcond,  Prev: The optional File-Access word set,  Up: The optional File-Access word set

9.6.1 実装毎オプション(Implementation Defined Options;idef)
-----------------------------------------------------------

ファイル・アクセス・モード:
     ‘R/O’ と ‘R/W’ と ‘BIN’ は期待どおりに機能します。 ‘W/O’ は C言語の
     ファイル・オープニング・モード ‘w’ (または ‘wb’) に変換され、 ファ
     イルが存在する場合はクリアされ、 存在しない場合は作成されます(‘
     open-file’ 、 ‘create-file’ 両方とも)。 Unix では、 ‘create-file’ は
     、 あなたの umask によって変更された 666 権限を持つファイルを作成し
     ます。

ファイルの例外:
     file ワード群は例外を発出しません(たぶん、 不正なアドレスまたは不正
     なファイル ID を渡した場合のメモリ・アクセス失敗(memory access
     faults)例外が発生します)。

ファイルの行末文字:
     システムに依存します。 Gforth は C言語の改行文字を行終端文字として
     使用します。 実際の文字コードが何であるかはシステムによって異なりま
     す。

ファイル名形式:
     システムに依存します。 Gforth はあなたの OS のファイル名形式を使用
     するだけです。

‘FILE-STATUS’ によって返される情報:
     ‘FILE-STATUS’ は、 ファイルに許可されている最も強力なファイル・アク
     セス・モードを返します。 それは ‘R/O’ または ‘W/O’ または ‘R/W’ の
     いずれかです。 ファイルにアクセスできない場合は、 ‘R/O BIN’ が返さ
     れます。 ‘BIN’ は、 返されたモードと一緒に適用されます。

ソース・コードのインクルード時の例外後の入力ファイルの状態:
     例外の発出により、 残されたすべてのファイルはクローズされます。

ior の値と意味:
     ファイルおよびメモリ割り当てワード群によって返される ior は throw コ
     ードとして意図されています。 通常、これらは OS エラーの -512〜-2047
     の範囲内にあります。 OS エラー番号から ior へのマッピングは
     -512−errno です。

ファイル入力の入れ子の最大深さ:
     リターン・スタックと、 ローカル変数/TIB スタックと、 オープン可能な
     ファイルの数によって制限されます。 この制限内である限り問題は起きな
     いはずです。

入力行の最大文字数:
     ‘/line’ で得られます。 現在は 255

ブロックの範囲をファイルにマッピングする方法:
     デフォルトでは、 ブロックは現在の作業ディレクトリ内のファイル
     ‘blocks.fb’ 内でアクセスされます。 ファイルは ‘USE’ で切り替えるこ
     とができます。

‘S"’ によって提供される文字列バッファの数:
     利用可能なメモリ量だけ。 文字列は、 ALLOCATE で割り当てられたメモリ
     ・ブロックに無期限に保存されます。

‘S"’ によって使用される文字列バッファのサイズ:
     ‘/line’ でられます。 現在 255


File: gforth.info,  Node: file-ambcond,  Prev: file-idef,  Up: The optional File-Access word set

9.6.2 Ambiguous conditions
--------------------------

ファイル内の位置をファイルの長さを超えて設定しようとしています:
     ‘REPOSITION-FILE’ は通常どおり実行されます。 その後、
     ‘FILE-POSITION’ は ‘REPOSITION-FILE’ で指定された値を返します(訳注:
     それがEOFを超えた値であっても)。

まだ書き込まれていないファイル内位置から読み取ろうとしています:
     EOF 、 つまりゼロ文字(zero characters)が読み取られ、 エラーは報告さ
     れません。

file-id が不正 (‘INCLUDE-FILE’):
     適切な例外が throw される可能性もありますが、 メモリ障害またはその
     他の問題が発生する可能性の方が高いです。

指定の file-id での読み取りまたはクローズでの I/O 例外(‘INCLUDE-FILE’, ‘INCLUDED’):
     問題を発見した操作によって生成された ior が throw されます。

指定の名前のファイルを開けません (‘INCLUDED’):
     ‘open-file’ によって生成された ior が throw されます。

マップされていないブロック番号をリクエストしています:
     マップされていない正当なブロック番号はありません。 一部のオペレーテ
     ィング・システムでは、 大きな番号のブロックを書き込むとファイル・シ
     ステムがオーバーフローし、 その結果エラー・メッセージが表示される場
     合があります。

‘blk’ がゼロ以外の場合に ‘source-id’ を使用した:
     ‘source-id’ は自身の機能を実行します。 通常、 ブロックをロードした
     ソースの ID が表示されます。 (作者たちが考えたのより良いアイデアが
     あれば教えてください)


File: gforth.info,  Node: The optional Floating-Point word set,  Next: The optional Locals word set,  Prev: The optional File-Access word set,  Up: Standard conformance

9.7 The optional Floating-Point word set
========================================

* Menu:

* floating-idef::            実装毎オプション(Implementation Defined
                               Options;idef)
* floating-ambcond::         あいまいな条件


File: gforth.info,  Node: floating-idef,  Next: floating-ambcond,  Prev: The optional Floating-Point word set,  Up: The optional Floating-Point word set

9.7.1 実装毎オプション(Implementation Defined Options;idef)
-----------------------------------------------------------

浮動小数点数の形式と範囲:
     システムに依存します。 C言語の double 型 です。

float が範囲外の場合の ‘REPRESENT’ の結果:
     システムに依存します。 ‘REPRESENT’ は C言語のライブラリ関数
     ‘ecvt()’ を使用して実装されているので、 この点においてその振る舞い
     を継承します。

浮動小数点数の丸めまたは切り捨て:
     丸めの振る舞いは、 ホストしている C 言語のコンパイラから継承されま
     す。 IEEE-FP ベースの(つまり、ほとんどの)システムは、 デフォルトで
     最も近い値に丸められ、 偶数に丸める(つまり、 仮数の最後のビットを 0
     にする)ことによって決着させます。

浮動小数点スタックのサイズ:
     ‘s" FLOATING-STACK" environment? drop .’ は、 浮動小数点スタックの
     合計サイズ(float 単位)を示します。 これは、 gforth 起動時にコマンド
     ライン・オプション ‘-f’ を使用して指定できます(*note Invoking
     Gforth::)。

浮動小数点スタックの各項目の大きさ:
     ‘1 floats’ で得られます。


File: gforth.info,  Node: floating-ambcond,  Prev: floating-idef,  Up: The optional Floating-Point word set

9.7.2 Ambiguous conditions
--------------------------

‘df@’ または ‘df!’ が 2倍長 float にアライメントされていないアドレスで使用されています:
     システムに依存します。 通常、 他のアライメント違反と同様に ‘-23
     THROW’ が発生します。

‘f@’ または ‘f!’ が float にアライメントされてないアドレスで使用されています:
     システムに依存します。 通常、 他のアライメント違反と同様に ‘-23
     THROW’ が発生します。

浮動小数点の結果が範囲外です:
     システムに依存します。 ‘-43 throw’ (floating point overflow) または
     ‘-54 throw’ (floating point underflow) または ‘-41 throw’ (floating
     point inexact result;浮動小数点の不正確な結果) または ‘-55 THROW’
     (Floating-point unidentified fault;浮動小数点の未確認の障害) を発出
     する可能性があり、 または、 例えば無限大(Infinity)を表す特別な値が
     生成される可能性があります。

‘sf@’ または ‘sf!’ が1倍長浮動小数点数にアライメントされていないアドレスで使用されています:
     システムに依存します。 通常、 他のアライメント違反と同様にアライメ
     ント違反が発生します。

‘base’ が 10 進数ではありません (‘REPRESENT’、‘F.’、‘FE.’、‘FS.’):
     それでもなお、 浮動小数点数は 10 進数に変換されます。

両方の引数がゼロに等しい(‘FATAN2’):
     システムに依存します。 ‘FATAN2’ は、 C言語のライブラリ関数
     ‘atan2()’ を使用して実装されます。

引数 r1 で ‘FTAN’ を使用する場合、 cos(r1) はゼロです:
     システムに依存します。 いずれにせよ、通常、 r1 の cos は小さな誤差
     によりゼロにはならず、 tan は非常に大きい(または非常に小さい)ものの
     有限の数になります。

d は、 ワード ‘D>F’ で 2倍長整数から不動小数点数に変換しようとしますが、 浮動小数点数として正確に表すことができません:
     結果は最も近い浮動小数点数に丸められます。

ゼロ除算:
     プラットフォームに依存します。 Infinity または NaN または ‘-42
     throw’ (floating point divide by zero) または ‘-55 throw’
     (Floating-point unidentified fault) が生成される可能性があります。

変換のための指数が大きすぎます (‘DF!’、‘DF@’、‘SF!’、‘SF@’):
     システムに依存します。 IEEE-FP ベースのシステムでは、 数値は
     infinity (無限大)に変換されます。

float<1 (‘FACOSH’):
     プラットフォームに依存します。 IEEE-FP システムでは通常、 NaN が生
     成されます。

float<=-1 (‘FLNP1’):
     プラットフォームに依存します。 IEEE-FP システムでは通常、NaN (また
     は float=-1 の場合は negative infinity(負の無限大))が生成されます。

float<=0 (‘FLN’, ‘FLOG’):
     プラットフォームに依存します。 IEEE-FP システムでは通常、 NaN (また
     は float=0 の場合はnegative infinity(負の無限大))が生成されます。

float<0 (‘FASINH’, ‘FSQRT’):
     プラットフォームに依存します。 ‘fsqrt’ の場合、 これは通常 NaN を返
     します。 ‘fasinh’ の場合、一部のプラットフォームでは NaN が生成され
     、 その他のプラットフォームでは数値が生成されます(C ライブラリのバ
     グかな？)。

|float|>1 (‘FACOS’, ‘FASIN’, ‘FATANH’):
     プラットフォームに依存します。 IEEE-FP システムは通常、 NaN を生成
     します。

float の整数部分は、 ‘F>D’ の d で表すことができません:
     プラットフォームに依存します。 通常、 2倍帳の数値が生成されますが、
     エラーは報告されません。

表示数値数値出力(pictured numeric output)領域より大きい文字列(‘f.’、‘fe.’、‘fs.’):
     数値出力領域の ‘Precision’ 文字が使用されます。 ‘precision’ が高す
     ぎる場合、 これらのワードは ‘here’ に近いデータまたはコードを破壊し
     ます。


File: gforth.info,  Node: The optional Locals word set,  Next: The optional Memory-Allocation word set,  Prev: The optional Floating-Point word set,  Up: Standard conformance

9.8 The optional Locals word set
================================

* Menu:

* locals-idef::              実装毎オプション(Implementation Defined
                               Options;idef)
* locals-ambcond::           あいまいな条件


File: gforth.info,  Node: locals-idef,  Next: locals-ambcond,  Prev: The optional Locals word set,  Up: The optional Locals word set

9.8.1 実装毎オプション(Implementation Defined Options;idef)
-----------------------------------------------------------

定義内のローカル変数の最大数:
     ‘s" #locals" environment? drop .’ で得られます。 現在 15 です。 こ
     れは下限です。たとえば、 32 ビット・マシンでは、最大 8 文字のローカ
     ル変数が 41 個存在する可能性があります。 定義内のローカルの数は、 ロ
     ーカル変数の名前を含むローカル変数バッファ(locals-buffer)のサイズに
     よって制限されます。


File: gforth.info,  Node: locals-ambcond,  Prev: locals-idef,  Up: The optional Locals word set

9.8.2 Ambiguous conditions
--------------------------

名前付きローカル変数をインタプリタ状態(interpretation state)で実行:
     ローカル変数は現在の定義内コンパイルします(つまりコンパイル状態です
     )。 さらに、 ローカル変数をインタプリタ状態でテキスト解釈
     (text-interpreting)すると、 “is compile-only” という警告が表示され
     ます。

name は ‘VALUE’ または ‘(LOCAL)’ で定義されていません(‘TO’):
     ‘-32 throw’ (Invalid name argument)


File: gforth.info,  Node: The optional Memory-Allocation word set,  Next: The optional Programming-Tools word set,  Prev: The optional Locals word set,  Up: Standard conformance

9.9 The optional Memory-Allocation word set
===========================================

* Menu:

* memory-idef::              実装毎オプション(Implementation Defined
                               Options;idef)


File: gforth.info,  Node: memory-idef,  Prev: The optional Memory-Allocation word set,  Up: The optional Memory-Allocation word set

9.9.1 実装毎オプション(Implementation Defined Options;idef)
-----------------------------------------------------------

ior の値と意味:
     ファイルおよびメモリ割り当てワード群によって返される ior は throw コ
     ードとして意図されています。 通常、これらは OS エラーの -512〜-2047
     の範囲内にあります。 OS エラー番号から ior へのマッピングは
     -512−errno です。


File: gforth.info,  Node: The optional Programming-Tools word set,  Next: The optional Search-Order word set,  Prev: The optional Memory-Allocation word set,  Up: Standard conformance

9.10 The optional Programming-Tools word set
============================================

* Menu:

* programming-idef::         実装毎オプション(Implementation Defined
                               Options;idef)
* programming-ambcond::      あいまいな条件


File: gforth.info,  Node: programming-idef,  Next: programming-ambcond,  Prev: The optional Programming-Tools word set,  Up: The optional Programming-Tools word set

9.10.1 実装毎オプション(Implementation Defined Options;idef)
------------------------------------------------------------

‘;CODE’ や ‘CODE’ に続く入力シーケンスの終端:
     ‘END-CODE’

‘;CODE’ および ‘CODE’ に続く入力の処理方法:
     ‘ASSEMBLER’ ボキャブラリーが検索順序(the search order)スタックにプ
     ッシュされ、 入力はテキスト・インタプリタによって(開始時に)インタプ
     リタ状態で処理されます。

‘EDITOR’ および ‘ASSEMBLER’ の検索順序:
     Search-Order ワードセット参照

‘SEE’ による表示形式と表示ソース:
     ‘see’ のソースは、 内部インタプリタによって使用される実行可能コード
     です。 現在の ‘see’ は、 Forth ソース・コード(および一部のプラット
     フォームではプリミティブのアセンブリ・コード)を可能な限り表示しよう
     とします。


File: gforth.info,  Node: programming-ambcond,  Prev: programming-idef,  Up: The optional Programming-Tools word set

9.10.2 Ambiguous conditions
---------------------------

コンパイル済みワード・リストの削除(‘FORGET’):
     (まだ)実装されていません。

制御フロー・スタック上の項目の数が u+1 未満です(‘CS-PICK’, ‘CS-ROLL’):
     通常、 これにより、 説明的なエラー・メッセージを含む ‘abort"’ が表
     示されます(将来的には ‘-22 throw’ (Control structure mismatch) に変
     更される可能性があります)。 また、 メモリ・アクセス・エラーが発生す
     る可能性もあります。 残念なことに、 この曖昧な状態はキャッチできま
     せん。

‘FORGET’ が見つかりません:
     (まだ)実装されていません。

name は ‘CREATE’ によって定義されていません:
     この点において、 ‘;CODE’ は ‘DOES>’ と同様に動作します。 つまり、 定
     義方法に関係なく、 最後に定義されたワードの実行機能(execution
     semantics)を変更します。

‘POSTPONE’ が ‘[IF]’ に適用されました:
     ‘: X POSTPONE [IF] ; IMMEDIATE’ 定義後の ‘X’ は ‘[IF]’ と同等です。

一致する ‘[ELSE]’ または ‘[THEN]’ に到達する前に入力ソースの末尾に到達しました:
     次の外部入力ソースでも同一の条件付きコンパイル状態を継続します。 現
     時点では、 これに関するユーザーへの警告はありません。

必要とされる定義の削除(‘FORGET’):
     (まだ)実装されていません。


File: gforth.info,  Node: The optional Search-Order word set,  Prev: The optional Programming-Tools word set,  Up: Standard conformance

9.11 The optional Search-Order word set
=======================================

* Menu:

* search-idef::              実装毎オプション(Implementation Defined
                               Options;idef)
* search-ambcond::           あいまいな条件


File: gforth.info,  Node: search-idef,  Next: search-ambcond,  Prev: The optional Search-Order word set,  Up: The optional Search-Order word set

9.11.1 実装毎オプション(Implementation Defined Options;idef)
------------------------------------------------------------

検索順序内のワードリストの最大数:
     ‘s" wordlists" environment? drop .’ で得られます。 現在 16

最小の検索順序:
     ‘root root’.


File: gforth.info,  Node: search-ambcond,  Prev: search-idef,  Up: The optional Search-Order word set

9.11.2 Ambiguous conditions
---------------------------

コンパイル・ワードリストの変更(コンパイル中):
     ワードは、 定義の先頭時点でコンパイル・ワードリストであるワードリス
     トに追加されます。 名前フィールドへの変更(たとえば ‘immediate’)また
     はコード・フィールドへの変更(例えば ‘DOES>’ の execute)は、 それら
     が変更可能であれば、 コンパイル・ワードリストに関係なく、 もっとも
     最新に定義されたワードに適用されます。

検索順序が空です (‘previous’):
     ‘abort" Vocstack empty"’

検索順序内のワードリストが多すぎます(‘also’):
     ‘abort" Vocstack full"’


File: gforth.info,  Node: Standard vs Extensions,  Next: Model,  Prev: Standard conformance,  Up: Top

10 Should I use Gforth extensions?
**********************************

このマニュアルの残りの部分を読み進めると、 標準ワードのドキュメントと、
いくつかの魅力的な Gforth 拡張のドキュメントがあります。 あなたは、 「標
準に限定すべきか、 それとも gforth での拡張を使用すべきでしょうか？」
(Should I restrict myself to the standard, or should I use the
extensions?)

   その答えは、 あなたが取り組んでいるプログラムの目標(goal)によって異な
ります:

   • 自分だけのためですか、 それとも他の人と共有したいですか？

   • 共有したい場合、 他の人は全員 Gforth を使用していますか？

   • 自分だけの場合は、 Gforth に限定してもいいですか？

   プログラムを Gforth のみに制限しても問題ない場合、 Gforth 拡張を使用
しない理由はありません。 移植性を保ちたい別のプログラムでこれらのパーツ
を再利用したい場合に備えて、 標準を守るのが簡単なところでは標準を守るの
は良い考えです。

   プログラムを他の Forth システムに移植できるようにしたい場合は、 以下
の点を考慮する必要があります:

   • 保守されているほとんどの Forth システムは、 標準 Forth をサポートし
     ています。 したがって、 プログラムが標準 Forth に準拠していれば、 多
     くのシステム間で移植可能です。

   • 多くの Gforth 拡張は、 ‘compat/’ ディレクトリで提供されるパブリック
     ・ドメインのファイルを使用して標準 Forth に実装できます。 これらに
     ついてはそれぞれ本文中で触れています。 つまり、 あなたは、 これらの
     gforth 拡張を使用しない理由はありません。 プログラムは依然として標
     準 Forth に準拠できます。 つまり、 あなたはプログラムに適切な
     ‘compat/’ のファイル(達)をインクルードするだけでよいのです。

   • ‘ans-report.fs’ (*note Standard Report::)ツールを使用すると、 あな
     たのプログラムを分析し、 どの非標準ワードに依存しているかを簡単に判
     断できます。 ただし、 標準ワードを非標準的な方法で使用しているかど
     うかについてはチェックされません。

   • 一部の手法は標準 Forth によって標準化されておらず、 標準的な方法で
     実装するのは困難または不可能ですが、 ほとんどの Forth システムでは
     簡単に実装でき、 通常は同様の方法(ワード・ヘッダーへのアクセスなど
     )で実装できます。 Forth には、プログラマーがツールの実装に依存する
     機能を利用する(たとえば、 ディクショナリ構造の知識に依存するなど)歴
     史的に豊富な先例があります。 これらのテクニックは、 ハードウェアの
     性能の最後の一滴まで引き出すために必要な場合もありますが、 単なるプ
     ログラミング上の省略表現である場合もあります。

   • Gforth 拡張を使うことで、 この部分を他のForthシステムに移植するコス
     トよりも作業コストを省くことができるだろうか？

   • 追加機能には、 移植性の低下や移植に関する追加の問題を勘案するだけの
     価値があるだろうか？

   これらの考慮事項を実行するには、 何が標準で何が標準ではないかを知る必
要があります。 このマニュアルには通常、 何が非標準であるかが記載されてい
ますが、 信頼できる情報源は standard document
(https://forth-standard.org/standard/words) です。 Appendix A of the
Standard (RATIONALE) は、技術委員会の思考プロセスについての貴重な洞察を
提供します。

   注意: Forth システム間の移植性だけが移植性の問題ではないことにも注意
してください。 異なるプラットフォーム (プロセッサと OS の組み合わせ)間の
移植性の問題もあります。


File: gforth.info,  Node: Model,  Next: Integrating Gforth,  Prev: Standard vs Extensions,  Up: Top

11 Model
********

(著者達は)この章はまだ記述していません。 これには、 信頼できる内部構造に
関する情報が含まれます。


File: gforth.info,  Node: Integrating Gforth,  Next: Emacs and Gforth,  Prev: Model,  Up: Top

12 Integrating Gforth into C programs
*************************************

C または C++ またはその他の言語で書かれているアプリケーションのスクリプ
ト言語として Forth を使用することを好む人もいます。

   Forth システム ATLAST は、 Forth システムをアプリケーションに組み込む
ための機能を提供します。 残念ながら、 これにはいくつかの欠点があります。
最も重要なのは、 標準 Forth に基づいておらず、 明らかに死んでいる(つまり
、 これ以降開発されておらず、 サポートされていない)ことです。 この分野で
Gforth が提供する機能は ATLAST の機能からインスピレーションを得ているた
め、 ATLAST からの切り替えは難しくはありません。

   また、 著者達は、 いつか標準化されたインターフェイスに到達できるよう
に、 他の Forth システムで簡単に実装できるようにインターフェイスを設計す
ることも試みました。 このような標準インターフェイスを使用すると、 C 言語
のコードを書き直すことなく他の Forth システムに置き換えることができます
。

   Gforth インタプリタを埋め込むには、 ライブラリ ‘libgforth.a’ または
‘libgforth.so’ とリンクします(コンパイラにオプション ‘-lgforth’ を指定す
るか、 他のエンジンのいずれかの場合は ‘-lgforth-fast’ または
‘-lgforth-itc’ または ‘-lgforth-ditc’ を指定します)。 このライブラリ内の
インターフェイスに属するすべてのグローバル・シンボルには、 接頭辞
‘gforth_’ が付いています。 共通のインターフェイスが出現した場合、 接頭辞
‘forth_’ を付けた ‘#define’ を通じて関数を利用できる可能性もあります。

   ‘#include <gforth.h>’ を使用して、 Forth 型の宣言と、 インターフェイ
ス関数と、 変数をインクルードすることができます。

   いまや、 あなたは ‘gforth_main’ を呼び出すか、 以下のコンポーネントを
使用して、 Gforth セッションを実行できるようになりました:

     Cell gforth_main(int argc, char **argv, char **env)
     {
       Cell retvalue=gforth_start(argc, argv);

       if(retvalue == -56) { /* throw-code for quit */
         retvalue = gforth_bootmessage();     // show boot message
         if(retvalue == -56)
           retvalue = gforth_quit(); // run quit loop
       }
       gforth_cleanup();
       gforth_printmetrics();
       // gforth_free_dict(); // if you want to restart, do this

       return retvalue;
     }

   Forth インタープリタと対話するには、 ‘Xt gforth_find(Char * name)’ と
‘Cell gforth_execute(Xt xt)’ があります。

   (未記述)(さらなるドキュメントをここに置く必要があります。)

12.1 Types
==========

‘Cell’, ‘UCell’: データ・スタック項目

   ‘Float’: FPスタック項目

   ‘Address’、‘Xt’、‘Label’: メモリと、Forthワードと、VM内部のForth命令
への、 ポインタ・タイプ。

12.2 Variables
==============

データスタックポインタおよびFPスタックポインタ。 領域のサイズ。スタック
へのアクセス

   ‘gforth_SP’, ‘gforth_FP’.

12.3 Functions
==============

     void *gforth_engine(Xt *, stackpointers *);
     Cell gforth_main(int argc, char **argv, char **env);
     int gforth_args(int argc, char **argv, char **path, char **imagename);
     ImageHeader* gforth_loader(char* imagename, char* path);
     user_area* gforth_stacks(Cell dsize, Cell rsize, Cell fsize, Cell lsize);
     void gforth_free_stacks(user_area* t);
     void gforth_setstacks(user_area * t);
     void gforth_free_dict();
     Cell gforth_go(Xt* ip0);
     Cell gforth_boot(int argc, char** argv, char* path);
     void gforth_bootmessage();
     Cell gforth_start(int argc, char ** argv);
     Cell gforth_quit();
     Xt gforth_find(Char * name);
     Cell gforth_execute(Xt xt);
     void gforth_cleanup();
     void gforth_printmetrics();
     void gforth_setwinch();

12.4 Signals
============

Gforth は、 例外とウィンドウ・サイズの変更をキャッチするためにシグナル・
ハンドラーを設定します。 これにより、C言語プログラムが妨げられる可能性が
あります。


File: gforth.info,  Node: Emacs and Gforth,  Next: Image Files,  Prev: Integrating Gforth,  Up: Top

13 Emacs and Gforth
*******************

Gforth には、 Goran Rydqvist による ‘forth.el’ の改良版である
‘gforth.el’ が付属しています(TILE パッケージ を利用しています)。 改善点
は以下のとおり:

   • インデントの処理が改善されました。
   • Forth コード用のカスタム・ハイライティング・エンジン。
   • コメント段落埋め(Comment paragraph filling)(‘M-q’)
   • リージョンのコメント化 (‘C-x \’) とコメント解除 (‘C-u C-x \’)
   • デバッグ・トレーサ (‘C-x ~’ の削除 *note Debugging::)
   • ワードのドキュメントを検索するための ‘info-lookup’ 機能のサポート。
   • ブロック・ファイルの読み取りと書き込みのサポート。

   これらの機能の基本的な説明を取得するには、 ‘forth-mode’ に入り、 ‘C-h
m’ と入力します。

   さらに、 Gforth は Emacs を全力サポートします。 エラー・メッセージや
、 (‘~~’ からの)デバッグ出力や、 失敗した assert のメッセージで指定され
るソース・コードの場所は、 Emacs のコンパイル・モード(*note Running
Compilations under Emacs: (emacs)Compilation.)に適切な形式になっているた
め、 エラーまたはその他のメッセージに対応するソースの場所は数回のキース
トロークだけでアクセスできます(例えば、 次のエラーは ‘C-x `’ カーソル下
のエラーは ‘C-c C-c’)。

   さらに加えて、 このマニュアルに記載されているワードについては、 ‘C-h
TAB’ を使用して用語集のエントリをすばやく検索できます
(‘info-lookup-symbol’, *note Documentation Commands:
(emacs)Documentation.)。 この機能には Emacs 20.3 以降が必要で、 ‘:’ を含
むワードに対しては機能しません。

* Menu:

* Installing gforth.el::     Emacs に Forth を認識させる
* Emacs Tags::               ワードのソースを Emacs で閲覧
* Hilighting::               Forth コードの見栄えを良くします
* Auto-Indentation::         自動インデントのカスタマイズ
* Blocks Files::             ブロック・ファイルの読み書き


File: gforth.info,  Node: Installing gforth.el,  Next: Emacs Tags,  Prev: Emacs and Gforth,  Up: Emacs and Gforth

13.1 Installing gforth.el
=========================

‘gforth.el’ の機能を Emacs で利用できるようにするには、 ‘.emacs’ ファイ
ルに次の行を追加します(訳注: 2024年時点では .emacs.d/init.el ):

     (autoload 'forth-mode "gforth.el")
     (setq auto-mode-alist (cons '("\\.fs\\'" . forth-mode)
     			    auto-mode-alist))
     (autoload 'forth-block-mode "gforth.el")
     (setq auto-mode-alist (cons '("\\.fb\\'" . forth-block-mode)
     			    auto-mode-alist))
     (add-hook 'forth-mode-hook (function (lambda ()
        ;; customize variables here:
        (setq forth-indent-level 4)
        (setq forth-minor-indent-level 2)
        (setq forth-hilight-level 3)
        ;;; ...
     )))

     ;; 訳注: とりあえずインストール( .emacs.d/init.el ):
     ;; /path/to/gforth-dev フォルダに gforth.el gforth.elc があるとして
     (add-to-list 'load-path "/path/to/gforth-dev")
     (require 'forth-mode "gforth")


File: gforth.info,  Node: Emacs Tags,  Next: Hilighting,  Prev: Installing gforth.el,  Up: Emacs and Gforth

13.2 Emacs Tags
===============

‘etags.fs’ を ‘require’ すると、 その後に定義されるすべてのワードの定義
を含む新しい ‘TAGS’ ファイル(*note Tags Tables: (emacs)Tags.)が生成され
ます。 あなたは ‘M-.’ を使用してワードのソースを見つけることができます。
注意: Emacs は複数の TAG ファイルを同時に使用できることに注意してくださ
い(たとえば、 1 つは Gforth ソース用、 もう 1 つはあなたのプログラム用、
などです。 *note Selecting a Tags Table: (emacs)Select Tags Table.)。 事
前にロード(preload)されるワードの TAGS ファイルは
‘$(datadir)/gforth/$(VERSION)/TAGS’ です(例えば
‘/usr/local/share/gforth/0.2.0/TAGS’)。 ‘etags.fs’ で最良の動作を得るに
は、 ‘require’ などの前後の両方に定義を置かないようにすべきです。 そうし
ないと、 ‘tags-search’ のようなコマンドによって同一ファイルが何度もアク
セスされることになります。


File: gforth.info,  Node: Hilighting,  Next: Auto-Indentation,  Prev: Emacs Tags,  Up: Emacs and Gforth

13.3 Hilighting
===============

‘gforth.el’ には、カスタム・ソース・ハイライティング・エンジンが付属して
います。 ファイルを ‘forth-mode’ で開くと、 そのファイルは完全にパースさ
れ、 キーワードやコメントや文字列などに face を割り当てます。 ファイルを
編集している間、 変更されたリージョンはその場(on-the-fly)でパース・更新
されます。

   Emacs の変数 ‘forth-hilight-level’ を使用して、 装飾レベルを 0 (まっ
たく強調表示なし) から 3 (デフォルト) に変更します。 強調表示レベルを 0
に設定した場合でも、 パーサーはバックグラウンドで動作し、 テキストの領域
が「コンパイル」(compiled)されているか「解釈」(interpreted)されているか
に関する情報を収集します。 これらの情報は、 自動インデントが適切に機能す
るために必要です。 コンピュータが遅すぎてパース処理できない場合は、
Emacs の変数 ‘forth-disable-parser’ を非 nil に設定します。 ただし、 こ
れは自動インデント・エンジンのスマートさに影響します。

   しばしば Forth のソース・コードでは、 強調表示する必要がある新しい機
能として、 新しい制御構造や定義ワードなどが定義される場合があります。 変
数 ‘forth-custom-words’ を使用して、 ‘forth-mode’ で追加のワードや構造を
強調表示させることができます。 詳細については、‘forth-words’ の
docstring を参照してください(Emacs では、‘C-h v out-words’ と入力します
)。

   ‘forth-custom-words’ は ‘.emacs.d/init.el’ ファイル内でカスタマイズす
ることを目的としています。 ファイル固有の方法でハイライトをカスタマイズ
するには、 あなたのソース・ファイルの最後のEmacsローカル変数セクションで
‘forth-local-words’ を設定します(*note Variables: (emacs)Local Variables
in Files.)。

   Example:
     0 [IF]
        Local Variables:
        forth-local-words:
           ((("t:") definition-starter (font-lock-keyword-face . 1)
             "[ \t\n]" t name (font-lock-function-name-face . 3))
            ((";t") definition-ender (font-lock-keyword-face . 1)))
        End:
     [THEN]


File: gforth.info,  Node: Auto-Indentation,  Next: Blocks Files,  Prev: Hilighting,  Up: Emacs and Gforth

13.4 Auto-Indentation
=====================

<TAB> を入力するか、‘C-m’ で改行するたびに、 ‘forth-mode’ は自動的にスマ
ートな方法で行をインデントしようとします。

   簡単なカスタマイズは、 ‘.emacs.d/init.el’ ファイルで
‘forth-indent-level’ と ‘forth-minor-indent-level’ を設定することで実現
できます。 歴史的な理由により、 ‘gforth.el’ はデフォルトでは 4 の倍数の
桁数インデントされます。 より伝統的な 3 桁のインデントを使用するには、
‘.emacs.d/init.el’ に以下の行を追加します:

     (add-hook 'forth-mode-hook (function (lambda ()
        ;; customize variables here:
        (setq forth-indent-level 3)
        (setq forth-minor-indent-level 1)
     )))

   インデントでデフォルト以外のワードを認識したい場合は、
‘.emacs.d/init.el’ で ‘forth-custom-indent-words’ を設定してカスタマイズ
します。 詳細については、 ‘forth-indent-words’ の docstring を参照してく
ださい(Emacs では、‘C-h v four-indent-words’ と入力します)。

   ファイル固有の方法でインデントをカスタマイズするには、 ソースファイル
の最後のEmacsローカル変数セクションで ‘forth-local-indent-words’ を設定
します(*note Variables: (emacs)Local Variables in Files.)。

   Example:
     0 [IF]
        Local Variables:
        forth-local-indent-words:
           ((("t:") (0 . 2) (0 . 2))
            ((";t") (-2 . 0) (0 . -2)))
        End:
     [THEN]


File: gforth.info,  Node: Blocks Files,  Prev: Auto-Indentation,  Up: Emacs and Gforth

13.5 Blocks Files
=================

‘forth-mode’ は、 最初の行の長さが 1023 文字を超えているかどうかをチェッ
クして、 ブロック・ファイルを自動検出します。 次に、 ファイルを通常のテ
キスト形式に変換しようと試みます。 あなたがファイルを保存すると、 通常の
ストリーム・ソース・ファイルとしてディスクに書き込まれます。

   ブロック・ファイルへ書き込みたい場合は、 ‘forth-blocks-mode’ を使用し
ます。 これは ‘forth-mode’ からすべての機能を継承しており、 さらにいくつ
かの追加機能があります:

   • ファイルはブロック・ファイル形式でディスクに書き込まれます。
   • スクリーン番号はモードラインに表示されます(‘forth-block-base’ で始
     まる番号です。 訳注:後方互換性の為に 0 または 1 から始まります)
   • 行の長さが 64 文字を超えると警告が表示されます。
   • 現在編集されているブロックの先頭は、 オーバーレイ矢印
     (overlay-arrow)でマークされます。

   注意すべき制限がいくつかあります。 タブ文字または改行文字を含むブロッ
ク・ファイルを開くと、 ファイルがディスクに書き戻されるときに、 これらの
文字はスペースに変換されます。 ブロック・ファイルの読み取り中にタブまた
は改行が検出された場合、 エラーがエコーエリアに表示されます。 なので、 読
み取り中に Emacs のベルが鳴ったら、‘*Messages*’ バッファを見てください。

   詳細については、 ‘C-h v forth-blocks-mode’ と入力して、
‘forth-blocks-mode’ の docstring を参照してください。


File: gforth.info,  Node: Image Files,  Next: Engine,  Prev: Emacs and Gforth,  Up: Top

14 Image Files
**************

イメージ・ファイルは、 Forth のディクショナリのイメージ、 つまり、 ディ
クショナリ内に存在するコンパイルされた Forth コードとデータを含むファイ
ルです。 慣例により、 イメージ・ファイルには拡張子 ‘.fi’ を使用します。

* Menu:

* Image Licensing Issues::   イメージの配布条件
* Image File Background::    なぜイメージ・ファイルがあるのですか?
* Non-Relocatable Image Files::  ※これは常に機能するとは限りません
* Data-Relocatable Image Files::  ※こちらの方がよいです
* Fully Relocatable Image Files::  ※こちらの方がもっといいです
* Stack and Dictionary Sizes::  イメージでのデフォルト・サイズを設定
* Running Image Files::      ‘gforth -i file’ or file.
* Modifying the Startup Sequence::  ターンキー・アプリケーションにする事もできる


File: gforth.info,  Node: Image Licensing Issues,  Next: Image File Background,  Prev: Image Files,  Up: Image Files

14.1 Image Licensing Issues
===========================

‘gforthmi’ (*note gforthmi::) または ‘savesystem’ (*note Non-Relocatable
Image Files::) で作成されたイメージには、 オリジナルのイメージが含まれま
す。 つまり、 著作権法(copyright law)に従うと、 それはオリジナルのイメー
ジの派生物となります。

   Gforth は GNU GPL に基づいて配布されるため、 新しく作成されたイメージ
も GNU GPL に当てはまります。 特に、これは、 あなたがイメージを配布する
場合、 あなた自身が書いたものも含め、 あなたのイメージのすべてのソースを
利用可能にする必要があることを意味します。 詳細については、 *note GNU
General Public License (Section 3): Copying. を参照してください。

   ‘cross’ (*note cross.fs::) を使用してイメージを作成した場合、 そのイ
メージには、 指定したソースからコンパイルされたコードのみが含まれます。
これらのソースのいずれも GPL に準拠していない場合、 上記の条件はこのイメ
ージには適用されません。 ただし、 そのイメージに GPL に基づくエンジン
(gforth バイナリ)が必要な場合に、 そのイメージに GPL の条件を適用したく
ない場合、 それらが一体にならないよう、 せいぜい単なる集合体にすぎない方
法で両方を配布する必要があります。


File: gforth.info,  Node: Image File Background,  Next: Non-Relocatable Image Files,  Prev: Image Licensing Issues,  Up: Image Files

14.2 Image File Background
==========================

Gforth は、 (エンジン内の) リミティブだけでなく、 Forth で書かれた定義で
も構成されます。 Forth コンパイラ自体もこれらの定義に含まれているため、
エンジンと Forth ソースだけでシステムを起動することはできません。したが
って、 Forth コードをほぼ実行可能な形式のイメージ・ファイルとして提供し
ます。 Gforth が起動すると、 C言語のルーチンがイメージ・ファイルをメモリ
にロードし、 オプションでアドレスを再配置し、 イメージ・ファイル内の情報
に従ってメモリ(スタックなど)を設定し、 (最終的に) Forth コードの実行を開
始します。

   デフォルトのイメージ・ファイルは ‘gforth.fi’ (‘GFORTHPATH’ 上の何処か
)です。 ‘-i’ または ‘--image-file’ または ‘--appl-image’ オプションを使
用すると、 別のイメージを使用できます(*note Invoking Gforth::)。 例:

     gforth-fast -i myimage.fi

   イメージ・ファイルにはさまざまなバリエーションがあり、 イメージ・ファ
イルの生成を容易にするという目標と、 イメージ・ファイルを移植できるよう
にするという目標の間のさまざまな妥協点を表しています。

   Win32Forth 3.4 と、 Mitch Bradley の ‘cforth’ は実行時に再配置を使用
します。 これにより、 以下で説明する複雑な問題の多くが回避されます(イメ
ージ・ファイルは、 特に手間をかけることなくデータを再配置できます)が、 し
かし、 パフォーマンスが低下し(メモリ・アクセスごとに 1 回の追加)、 そし
て、 Forth とライブラリ呼び出しまたは他のプログラムの間でアドレスを渡す
ことが困難になります。

   対照的に、 Gforth ローダーはイメージのロード時に再配置を実行します。
また、 ローダーは、 プリミティブ呼び出しを表すトークンを適切なコード・フ
ィールド・アドレス(直接スレッドの場合はコード・アドレス)に置き換える必要
があります。

   イメージ・ファイルには、 再配置の程度が異なる 3 種類があります。 つま
り、 再配置不可能なイメージ・ファイルと、 データ再配置可能なイメージ・フ
ァイルと、 完全に再配置可能なイメージ・ファイルです。

   これらのイメージ・ファイルのバリエーションには、 いくつかの共通の制限
があります。 それらは、 イメージ・ファイル・ローダーの設計によって引き起
こされます:

   • セグメントは 1 つだけです。 これは、特に、 イメージ・ファイルが
     ‘ALLOCATE’ されたメモリ・チャンク(およびそれらへのポインタ)を表すこ
     とができないことを意味します。 スタックの内容も表現されません。

   • サポートされている再配置の種類は次のとおりです: データ・アドレスを
     表すすべてのセルに同じオフセットを追加します。 そして、 特別なトー
     クンをコード・アドレスまたはマシン・コードの一片に置き換えます。

     アドレスを含む複雑な計算が実行される場合、 結果はイメージ・ファイル
     で表現できません。 このような計算を使用するアプリケーションがいくつ
     か思い浮かびます:

        − テーブル・ルックアップのためのアドレス(またはアドレスを含むデ
          ータ構造)のハッシュ化。 この目的に Gforth の ‘table’ または
          ‘wordlist’ を使用する場合、 システムの起動時にハッシュ・テーブ
          ルが自動的に再計算されるため、問題はありません。 あなた独自の
          ハッシュ・テーブルを使用する場合は、 同様のことをあなた自身で
          行う必要があります。

        − ‘XOR’ されたアドレスを使用する二重リンク・リストの小さい実装が
          あります。 このようなリストをイメージ・ファイル内で単一リンク
          として表現し、 起動時に二重リンク表現を復元することもできます
          (1)。

        − ‘docol:’ のようなランタイム・ルーチンのコード・アドレスは、 イ
          メージ・ファイルでは表現できません(直接スレッド実装ではトーク
          ンがマシン・コードに置き換えられるため)。 回避策として、 実行
          時に ‘>code-address’ を使用して適切なワードの実行トークンから
          これらのアドレスを計算します(‘kernel/getdoers.fs’ の ‘docol:’
          とそのファミリーの定義を参照してください)。

        − 多くのアーキテクチャでは、 アドレスは何らかのシフトされた形式
          または切り刻んだ(mangle)形式でマシン・コードで表現されます。 こ
          の形式の絶対アドレスを含む ‘CODE’ ワードを再配置可能イメージ・
          ファイルに含めることはできません。 回避策は、アドレスを何らか
          の相対形式(たとえば、 レジ​​スタに存在する CFA を基準とした相
          対形式)で表現するか、 アドレスが切り刻んでない(mangle)形式で格
          納されている場所からロードすることです。

   ---------- Footnotes ----------

   (1) ただし、 著者の意見としては、 (実装がどうであれ)二重リンク・リス
トを使用する前によく考えるべきです。


File: gforth.info,  Node: Non-Relocatable Image Files,  Next: Data-Relocatable Image Files,  Prev: Image File Background,  Up: Image Files

14.3 Non-Relocatable Image Files
================================

これらのファイルは、 ディクショナリの単純なメモリ・ダンプです。 これらは
、 作成された実行可能ファイル(つまり、‘gforth’ ファイル)に固有のものです
。さらに悪いことに、 それらは、 イメージが作成されたときにディクショナリ
が存在していた場所に固有のものです。 ええ、はい、 次回 Gforth を起動する
ときにディクショナリが同じ場所に存在するという保証はありません。 したが
って、 再配置不可能なイメージが次回動作するという保証もありません(ただし
、 Gforth はクラッシュする代わりにエラーを出します)。 実際、 アドレス空
間のランダム化(が有効になっている) OS では、 再配置不可能なイメージが機
能する可能性は低いです。

   ‘savesystem’ を使用して、 再配置不可能なイメージ・ファイルを作成でき
ます。例:

     gforth app.fs -e "savesystem app.fi bye"

‘savesystem’ ( "image" –  ) gforth-0.2 “savesystem”


File: gforth.info,  Node: Data-Relocatable Image Files,  Next: Fully Relocatable Image Files,  Prev: Non-Relocatable Image Files,  Up: Image Files

14.4 Data-Relocatable Image Files
=================================

これらのファイルには、 再配置可能なデータ・アドレスが含まれていますが、
(トークンではなく)固定コード・アドレスが含まれています。 これらは、 作成
された実行可能ファイル(つまり、‘gforth’ ファイル)に固有のものです。 また
、 動的ネイティブ・コード生成も無効になります(通常、 速度が 2 倍になりま
す)。 ‘GFORTHD’ 環境変数を通じて使用するエンジンを ‘gforthmi’ (*note
gforthmi::) に渡すと、 データ再配置可能なイメージを取得できます。

     GFORTHD="/usr/bin/gforth-fast --no-dynamic" gforthmi myimage.fi source.fs

   注意: ここでイメージが機能するには ‘--no-dynamic’ が必要であることに
注意してください(そうしないと、 イメージに保存されていない動的に生成され
たコードへの参照が含まれてしまいます)。


File: gforth.info,  Node: Fully Relocatable Image Files,  Next: Stack and Dictionary Sizes,  Prev: Data-Relocatable Image Files,  Up: Image Files

14.5 Fully Relocatable Image Files
==================================

これらのイメージ・ファイルには、 再配置可能なデータ・アドレスとコード・
アドレスのトークンが含まれています。 これらは、 同じマシン上で異なるバイ
ナリ(デバッグの有無など)で使用でき、 同一データ形式(バイト・オーダー、 セ
ル・サイズ、 浮動小数点形式)を持つ複数のマシン間でも使用でき、 動的なネ
イティブ・コード生成で動作します。 ただし、 これらは通常、 作成された
Gforth のバージョンに固有です。 ファイル ‘gforth.fi’ と ‘kernl*.fi’ は完
全に再配置可能です。

   完全に再配置可能なイメージ・ファイルを作成するには 2 つの方法がありま
す:

* Menu:

* gforthmi::                 通常の方法
* cross.fs::                 困難な方法


File: gforth.info,  Node: gforthmi,  Next: cross.fs,  Prev: Fully Relocatable Image Files,  Up: Fully Relocatable Image Files

14.5.1 ‘gforthmi’
-----------------

通常は ‘gforthmi’ を使用します。 ‘gforth options’ で Gforth を呼び出して
ロードするすべてのものを含むイメージ file を作成したい場合は、以下のよう
に言うだけです:
     gforthmi file options

   たとえば、 通常のものに加えてファイル ‘asm.fs’ がロードされたイメージ
‘asm.fi’ を作成したい場合は、 以下のように実行できます:

     gforthmi asm.fi asm.fs

   ‘gforthmi’ は sh スクリプトとして実装され、 次のように動作します: 異
なるアドレスに対して 2 つの再配置不可能なイメージを生成し、 それらを比較
します。 その出力はこの比較を反映しています: まず、 再配置不可能なイメー
ジ・ファイルを生成する 2 つの Gforth 呼び出しの出力(存在する場合)が表示
され、 次に比較プログラムの出力が表示されます: データ・アドレスに使用さ
れるオフセットとコードアドレスに使用されるオフセットを表示します。 デー
タ・アドレスに使用されるオフセットと使用されるオフセットが表示されます。
さらに、 イメージ・ファイル内で正しく表現できないセルごとに、 以下のよう
な行が表示されます:

          78DC         BFFFFA50         BFFFFA40

   これは、 ‘forthstart’ からのオフセット $78dc に、一方の入力イメージに
は $bffffa50 が含まれ、 もう一方の入力イメージには $bffffa40 が含まれて
いることを意味します。 これらのセルは出力イメージでは正しく表現できない
ため、 ディクショナリ内のこれらの場所を調べて、 これらのセルが死んでいる
こと (つまり、書き込まれる前に読み取られていないこと)を確認する必要があ
ります。

   イメージ・ファイル名の前に ‘--application’ オプションを挿入すると、
‘--image-file’ オプションの代わりに ‘--appl-image’ オプションを使用した
イメージを取得します(*note Invoking Gforth::)。 (イメージ名をコマンドと
して入力して、 )このようなイメージを Unix 上で実行すると、 Gforth エンジ
ンは、 オプションをエンジン・オプションとして解釈しようとはせず、 すべて
のオプションをイメージに渡します。

   引数を指定せずに ‘gforthmi’ と入力すると、 いくつかの使用説明が表示さ
れます。

   ちょっとだけ説明すると、 渡された gforth-options 処理後、
‘savesystem’ と ‘bye’ というワードが現れる必要があります。 ‘gforth’ 実行
可能ファイルの特別な二重間接スレッド化(doubly indirect threaded)バージョ
ンは、 再配置不可能なイメージの作成に使用されます。 この実行可能ファイル
の正確なファイル名は、 環境変数 ‘GFORTHD’(デフォルト: ‘gforth-ditc’) を
介して渡すことができます。 二重間接スレッド化ではないバージョンを渡すと
、 完全に再配置可能なイメージではなく、 データ再配置可能なイメージ(*note
Data-Relocatable Image Files::)を取得します。 これは、 コード・アドレス
・オフセットがないためです。 通常の ‘gforth’ 実行可能ファイルは、 再配置
可能イメージの作成に使用されます。 この実行可能ファイルの正確なファイル
名は、 環境変数 ‘GFORTH’ を介して渡すことができます。


File: gforth.info,  Node: cross.fs,  Prev: gforthmi,  Up: Fully Relocatable Image Files

14.5.2 ‘cross.fs’
-----------------

‘cross’ という、 Forth風のプログラミング言語を受け入れるバッチ・コンパイ
ラーを使用することもできます(*note Cross Compiler::)。

   ‘cross’ を使用すると、 イメージ・ファイルの生成に使用したものとは異な
るデータ・サイズとデータ形式を持つマシン用のイメージ・ファイルを作成でき
ます。これを使用して、 Forth コンパイラを含まないアプリケーション・イメ
ージを作成することもできます。 これらの機能は、 プログラミング上の制限と
不便を許容することで利用可能になります。 たとえば、 コードを再配置可能に
するには、 アドレスを特別なワード (‘A!’、 ‘A,’ など) を使用してメモリに
保存する必要があります。


File: gforth.info,  Node: Stack and Dictionary Sizes,  Next: Running Image Files,  Prev: Fully Relocatable Image Files,  Up: Image Files

14.6 Stack and Dictionary Sizes
===============================

サイズのコマンド・ライン・フラグを指定して Gforth を呼び出すと(*note
Invoking Gforth::)、 指定したサイズがディクショナリに保存されます。
‘savesystem’ でディクショナリを保存するか、 ‘gforthmi’ でイメージを作成
すると、 このサイズが結果のイメージ・ファイルのデフォルトになります。 た
とえば、 以下の例では、 1MB のディクショナリを備えた完全に再配置可能なバ
ージョンの ‘gforth.fi’ が作成されます。

     gforthmi gforth.fi -m 1M

   つまり、 ディクショナリとイメージの、 スタックのデフォルト・サイズを
設定したい場合は、 イメージの作成時に適切なオプションを指定して
‘gforthmi’ を呼び出すだけです。

   注意: キャッシュに優しい振る舞い(cache-friendly behaviour)(つまり、良
好なパフォーマンス)を実現するには、 スタックのモジュロ(stacks modulo)の
サイズ、 つまり 2K、と多少異なるものにする必要があります。 たとえば、デ
フォルトのスタック・サイズは次のとおりです: データ・スタック 16k (mod
2k=0); FPスタック 15.5k (mod 2k=1.5k); リターン・スタック 15k(mod
2k=1k); ローカル変数スタック 14.5k (mod 2k=0.5k)


File: gforth.info,  Node: Running Image Files,  Next: Modifying the Startup Sequence,  Prev: Stack and Dictionary Sizes,  Up: Image Files

14.7 Running Image Files
========================

‘-i’ フラグを使用したデフォルトの ‘gforth.fi’ の代わりに、 イメージ・フ
ァイル image を使用して Gforth を呼び出すことができます(*note Invoking
Gforth::):
     gforth -i image

   オペレーティング・システムが ‘#! ...’ 形式の行によるスクリプトの開始
をサポートしている場合は、 イメージ・ファイル名を入力するだけで、 そのイ
メージ・ファイルで Gforth を起動できます(ファイル拡張子 ‘.fi’ は単なる慣
例であることに注意してください)。 つまり、 イメージ・ファイル image を使
用して Gforth を実行するには、 ‘gforth -i image’ の代わりに image と入力
するだけです。 これが機能するのは、すべての ‘.fi’ ファイルが以下の形式の
行で始まるためです:

     #! /usr/local/bin/gforth-0.4.0 -i

   この行で指定された Gforth エンジンのファイルとパス名は、 そのエンジン
がビルドされた特定の Gforth 実行可能ファイルです。 つまり、 ‘gforthmi’ が
実行されたときの環境変数 ‘GFORTH’ の値です。

   同じシェル機能を利用して、 Forth ソース・ファイルを実行可能ファイルに
できます。 たとえば、 以下のテキストをファイルに配置します:

     #! /usr/local/bin/gforth

     ." Hello, world" CR
     bye

そして、 ファイルを実行可能にすると(Unix の場合は chmod +x)、 コマンド・
ラインから直接実行できます。 シーケンス ‘#!’ は 2 つの側面から使用されま
す。 まず、 オペレーティング・システムによって「マジック・シーケンス」と
して認識され(1)、 次に Gforth によってコメント文字として扱われます。 2 番
目の使用法のため、‘#!’ と実行可能ファイルへのパスの間に空白が必要です(さ
らに、 一部の Unix ではシーケンス ‘#! /’ が必要です)。

   ほとんどの Unix システム(Linux を含む)は、 バイナリ名の後​​に 1 つの
オプションだけをサポートします。 それでも十分でない場合は、 以下のトリッ
クを使用できます:

     #! /bin/sh
     : ## ; 0 [if]
     exec gforth -m 10M -d 1M $0 "$@"
     [then]
     ." Hello, world" cr
     bye \ caution: this prevents (further) processing of "$@"

   最初に、 このスクリプトはシェル・スクリプトとして解釈され、 最初の 2
行が(ほとんど)コメントとして扱われ、 次に 3 行目が実行されると、 このス
クリプト (‘$0’) をパラメータとして、 そのパラメータを追加パラメータ
(‘"$@"’) として gforth を呼び出します。 さらに次に、 このスクリプトは
Forth スクリプトとして解釈され、 最初にコロン定義 ‘##’ が定義され、 次に
‘[then]’ までのすべてが無視され、 最後にそれに続く Forth コードが処理さ
れます。 あなたは以下を使用することもできます

     #0 [if]

   2 行目ですが、 これは Gforth-0.7.0 以降でのみ機能します。

   ‘gforthmi’ のアプローチは最も高速で、 シェル・ベースのアプローチは最
も遅くなります(追加のシェルを起動する必要があるため)。 シェル・アプロー
チの追加の利点は、 Gforth バイナリ が ‘$PATH’ 内にある限り、 Gforth バイ
ナリがどこにあるかを知る必要がないことです。

‘#!’ ( –  ) gforth-0.2 “hash-bang”
   ‘\’ の alias です。

   ---------- Footnotes ----------

   (1) Unix シェルは実際には 2 種類のファイルを認識します。 それは実行可
能ファイルとデータ・ファイルです。 データ・ファイルは「インタプリタ行」
で指定されたインタプリタによって処理されます。 このインタプリタ行は、 シ
ーケンス #!  で始まるデータ・ファイルの最初の行です。 インタプリタ行で指
定できる文字数には小さな制限(例: 32)がある場合があります。


File: gforth.info,  Node: Modifying the Startup Sequence,  Prev: Running Image Files,  Up: Image Files

14.8 Modifying the Startup Sequence
===================================

defer されたワード ‘'cold’ を使用して、 イメージの起動シーケンスに独自の
初期化を追加できます。 ‘'cold’ は、 イメージ固有のコマンドライン処理 (つ
まり、 ファイルのロードと (‘-e’) 文字列の評価)が開始される直前に呼び出さ
れます。

   初期化を追加するシーケンスは通常以下のようになります:

     :noname
         Defers 'cold \ do other initialization stuff (e.g., rehashing wordlists)
         ... \ your stuff
     ; IS 'cold

   ‘'cold’ の後、 Gforth はイメージ用のオプションを処理し(*note Invoking
Gforth::)、 別の defer されたワードである ‘bootmessage’ を実行します。 こ
れは通常は、 Gforth の起動メッセージを出力し、 他には何も行いません。

   したがって、 ターンキー・イメージ(つまり、 拡張された Forth システム
ではなくアプリケーション用のイメージ)を作成したい場合は、 以下のいくつか
の方法でこれを行うことができます:

   • OS コマンドライン引数を独自に解釈したい場合は、 ‘'cold’ にフックし
     ます。 その場合、 エンジンが OS コマンド・ライン・オプションを処理
     しないように、 ‘gforthmi --application’ (*note gforthmi::)を使用し
     てイメージをビルドすることも必要になるでしょう。 その後、
     ‘next-arg’ を使用してあなた独自のコマンドライン処理を実行できます。

   • OS コマンドライン引数を通常の Gforth 処理で処理したいが、 あなた独
     自のコマンドライン・オプションを指定する場合、 ‘process-option’ に
     フックします。

   • Gforth に付属しているオプションに加えてさらに多くのオプションが必要
     な場合は、 ‘options’ ボキャブラリでワードを定義します。

   • あなた独自のブート・メッセージを表示したい場合は、 ‘bootmessage’ に
     フックします。

   いずれの場合も、 あなたは、 おそらくこれらのフックで execute するワー
ドを普通に終了さずに、 ‘bye’ または ‘throw’ を使用したいでしょう。 そう
しないと、 Gforth 起動プロセスが続行され、 最終的に Forth コマンド・ライ
ンがユーザーに表示されます。

‘'cold’ ( –  ) gforth-0.2 “tick-cold”
   OS コマンドライン引数を解釈(interpret)する直前に何かするためのフック(
defer されたワード)。 あなたが実行したい幾つかの初期化を行うためにありま
す。 通常、 あなたが実行したいいくつかの初期化も行います。

‘bootmessage’ ( –  ) gforth-0.4 “bootmessage”
   OS コマンドライン引数を解釈(interpret)した直後のフック(deferされたワ
ード)。 通常は Gforth 起動メッセージを出力します(訳注: つまり、 あなたが
何かしらワードをセットすると起動メッセージは出力されなくなります)。

   ( ’quit :原文未記述)
‘process-option’ ( addr u – true / addr u false  ) gforth-0.7 “process-option”
   オプション ADDR U を処理し、 オプションが処理された場合は true を返し
ます。 未処理のオプションは ‘required’ を通じてファイルとしてロードされ
ます。


File: gforth.info,  Node: Engine,  Next: Cross Compiler,  Prev: Image Files,  Up: Top

15 Engine
*********

Gforth を使用したプログラミングにはこの章を読む必要はありません。 あなた
が Gforth のソース・コード内を探索するのに役立つかもしれません。

   このセクションのアイデアは次の論文にも掲載されています: Bernd Paysan,
‘ANS fig/GNU/??? Forth’ (in German), Forth-Tagung ’93; M. Anton Ertl, ‘A
Portable Forth Engine
(https://www.complang.tuwien.ac.at/papers/ertl93.ps.Z)’, EuroForth ’93;
M. Anton Ertl, ‘Threaded code variations and optimizations (extended
version) (https://www.complang.tuwien.ac.at/papers/ertl02.ps.gz)’,
Forth-Tagung ’02.

* Menu:

* Portability::
* Threading::
* Primitives::
* Performance::


File: gforth.info,  Node: Portability,  Next: Threading,  Prev: Engine,  Up: Engine

15.1 Portability
================

Gforth プロジェクトの重要な目標の一つは、 様々なPCで使えることです。
fig-Forth と、 程度は低いですが F83 は、 当時人気のあったいくつかのプロ
セッサ向けにエンジンをアセンブリ言語で手動でコーディングすることで、 こ
の目標を達成しました。 このアプローチは非常に労働集約的であり、 コンピュ
ータ・アーキテクチャの進歩につれ短命に終わってしまいます。

   たとえば Mitch Bradley (cforth)や、 Mikael Patel (TILE)や、 Dirk
Zoller (pfe) など、 C 言語でコーディングすることでこの問題を回避したモノ
もあります。 UNIX マシンのアーキテクチャは多種多様であるため、 このアプ
ローチは UNIX ベースの Forth で特に人気があります。 残念ながら、 C 言語
での実装は、 効率の目標や、 従来の手法の使用とうまく調和しません。 間接
または直接のスレッド化は C 言語では表現できず、 C 言語で利用できる最速の
手法であるスイッチ・スレッディングは大幅に遅くなります。 C 言語 のもう 1
つの問題は、 2倍長整数の演算を表現するのが非常に面倒なことです。

   幸いなことに、 これらの制限のない移植可能な言語が存在します。 それは
、GNU C 言語コンパイラによって処理される C 言語のバージョンである GNU Cで
す(*note Extensions to the C Language Family: (gcc)C Extensions.)。 値と
してのラベル機能(*note Labels as Values: (gcc)Labels as Values.)により、
直接および間接的なスレッド化が可能になり、 その ‘long long’ 型(*note
Double-Word Integers: (gcc)Long Long.)は、 多くのシステムで Forth の 2倍
長整数に対応します。 GNU C は、 すべての重要な(および多くの重要でない)
UNIX マシン や VMS や MS-DOS を実行する 80386 や Amiga や Atari ST で無
料で利用できるため、 GNU C で書かれた Forth はこれらすべてのマシンで実行
できます。

   ポータブルな言語で記述すると、 アセンブリよりも遅いコードが生成される
という評判があります。 Forth エンジンでは、 コンパイラーによって生成され
たコードを繰り返し確認し、 ソース・コードを適切に変更することで、 コンパ
イラーによって引き起こされる非効率性のほとんどを排除しています。

   しかしながら、 プログラマはレジスタ割り当てに移植可能な影響を及ぼすこ
とができないため、 レジスタが不足しているマシンでは非効率が発生します。
一部のマシンでは速度を向上させるために、 明示的なレジスタ宣言を使用して
います(*note Variables in Specified Registers: (gcc)Explicit Reg Vars.)。
これらは、 構成フラグ ‘--enable-force-reg’ (‘gcc’ スイッチ
‘-DFORCE_REG’) を使用してオンにします。 残念ながら、 この機能はマシンだ
けでなくコンパイラのバージョンにも依存します。 一部のマシンでは、 特定の
明示的なレジスタ宣言が使用されると、 一部のコンパイラ・バージョンでは不
正なコードを生成します。 したがって、 デフォルトでは ‘-DFORCE_REG’ は使
用されません。


File: gforth.info,  Node: Threading,  Next: Primitives,  Prev: Portability,  Up: Engine

15.2 Threading
==============

GNU C の「ラベルとしての値」の拡張機能(‘gcc-2.0’ 以降で有効;*note Labels
as Values: (gcc)Labels as Values.)により、 ‘&&label’ と書くことにより、
label のアドレスを取得できるようになります。 このアドレスは、 ‘goto
*address’ のようなステートメントで使用できます。 つまり、 ‘goto *&&x’ は
‘goto x’ と同じです。

   この機能を使用すると、間接スレッド化された ‘NEXT’ は以下のようになり
ます:
     cfa = *ip++;
     ca = *cfa;
     goto *ca;
   上記の言葉に馴染みのない人のために説明すると、 ‘ip’ は Forth 命令ポイ
ンタです。 ‘cfa’ (コード・フィールド・アドレス) は標準 Forth の実行トー
クンに対応するもので次に実行されるワードのコード・フィールドを指します。
そこからフェッチされた ‘ca’ (コード・アドレス)は、 プリミティブやコロン
定義ハンドラー(‘docol’)などの実行可能コードを指します。

   直接スレッド化はさらに簡単です:
     ca = *ip++;
     goto *ca;

   もちろん、 我々は、 ‘NEXT’ と ‘NEXT1’ (cfa を取得した後の ‘NEXT’ の部
分) というマクロに、 全体をきちんとパッケージ化しています。

* Menu:

* Scheduling::
* Direct or Indirect Threaded?::
* Dynamic Superinstructions::
* DOES>::


File: gforth.info,  Node: Scheduling,  Next: Direct or Indirect Threaded?,  Prev: Threading,  Up: Threading

15.2.1 Scheduling
-----------------

スケジューリングについては少々複雑です。 パイプライン・プロセッサとスー
パースカラ・プロセッサ、 つまり RISC と一部の最新の CISC マシンは、 ある
命令の結果が出るのを待つ間に別の命令を処理できます。 通常、 コンパイラは
、 これらの遅延スロットを有効に使用できるように命令を並べ替え(スケジュー
リング)します。 ただし、 我々の最初の挑戦では、 コンパイラーはプリミティ
ブのスケジューリングをうまく機能させられませんでした。 たとえば、 ‘+’ は
以下のように実装されます
     n=sp[0]+sp[1];
     sp++;
     sp[0]=n;
     NEXT;
   ‘NEXT’ は厳密に他のコードの後に配置されます。 つまり、 スケジューリン
グはまずありえません。 ちょっと考えると問題が明らかになってきます: コン
パイラは、 ‘sp’ と ‘ip’ が異なるアドレスを指していることを認識できないた
め(そして、 たとえ認識が可能だったとしても、 私たちが使用した ‘gcc’ のバ
ージョンはそれを知りません。)、 ストア上の cfa の負荷を TOS に移動できま
せんでした。 実際、 スタックのTOSまたはTOS付近に対するコードが実行された
場合、 これらのポインタは同一になる可能性があります。 速度を重視して、 私
達は、 この、 おそらく未使用の「認識機能」を禁止した上でコンパイラーのス
ケジューリングを支援します(‘NEXT’ を幾つかの部分、 すなわち、 ‘NEXT_P0’
と ‘NEXT_P1’ と ‘NEXT_P2’ に分割します): そうすると、 ‘+’ は以下のように
なります:
     NEXT_P0;
     n=sp[0]+sp[1];
     sp++;
     NEXT_P1;
     sp[0]=n;
     NEXT_P2;

   さまざまな操作を NEXT の部分間でいくつかの方法で分散するさまざまな仕
組みがあります。 一般に、 異なる仕組みは異なるプロセッサ上で最高のパフォ
ーマンスを発揮します。 私たちは、 ほとんどのアーキテクチャに対して、 そ
のアーキテクチャのほとんどのプロセッサで良好に動作する仕組みを使用してい
ます。 将来的には、 ベンチマークを実施し、 インストール時に仕組みを選択
するように切り替える可能性があります。


File: gforth.info,  Node: Direct or Indirect Threaded?,  Next: Dynamic Superinstructions,  Prev: Scheduling,  Up: Threading

15.2.2 Direct or Indirect Threaded?
-----------------------------------

スレッド化された forth コードは、 プリミティブ(‘+’ のような単純なマシン
・コード・ルーチン)と非プリミティブ(コロン定義、 変数、 定数など)への参
照で構成されます。 非プリミティブの特定の種類(変数など)では、 コード・ル
ーチン(‘dovar’ など) は 1 つだけですが、 各変数は各変数それぞれのデータ
への個別の参照が必要です。

   伝統的に、 Forth は間接スレッド化コードとして実装されてきました。 こ
れにより、 非プリミティブの参照は 1 つのセルのみの使用で済ませられるため
です(基本的に、 データをポイントし、 ポイントした先でコード・アドレスを
見つけます)。

   しかしながら Gforth (0.6.0 以降) のスレッド化コードは、 非プリミティ
ブに 2 つのセルを使用します。 1 つはコード・アドレス用で、 もう 1 つはデ
ータ・アドレス用です。 データ・ポインタは、 コード・アドレスで表される仮
想マシン命令の直接の引数です。 すべてのコード・アドレスが単純なプリミテ
ィブを指しているため、 これを「プリミティブ指向」スレッド化コードと呼び
ます。 たとえば、 変数の場合、 コード・アドレスは ‘lit’ 用です(‘99’ など
の整数リテラルにも使用されます)。

   プリミティブ指向スレッド化コードにより、 ディスパッチ手法として(より
高速な)直接スレッド化を完全に移植可能な状態で使用できます(0.6.0 より前の
Gforth の直接スレッド化コードにはアーキテクチャ固有のコードが必要でした
)。 また、386 実装で直接スレッド・コードによる I キャッシュの一貫性に関
連するパフォーマンスの問題も解消され、 追加の最適化が可能になります。

   ただし、 問題があります。 ‘execute’ の XT パラメータは 1 つのセルしか
占有できないため、 「コードとデータ・アドレス」を持つ非プリミティブをど
のように渡せばよいのでしょうか？ これに対する私達の答えは、 ‘execute’ や
単一セル xt を使用する他のワードに間接スレッド化ディスパッチを使用するこ
とです。 したがって、 コロン定義内の通常のスレッド化コードは直接スレッド
を使用し、 データ・スタック上の xt にディスパッチする ‘execute’ や同様の
ワードは間接スレッド化コードを使用します。 これを 「ハイブリッド 直接/間
接 スレッド化コード」と呼びます。

   ‘gforth’ エンジンと ‘gforth-fast’ エンジンは、 ハイブリッド 直接/間接
スレッド化コードを使用します。 つまり、 これらのエンジンでは ‘,’ を使用
して xt をコンパイルできないことを意味します。 代わりに、 ‘compile,’ を
使用する必要があります。

   ‘,’ を使用して xt をコンパイルする場合は、 ‘gforth-itc’ エンジンを使
用します。 このエンジンは、 単純な古い間接スレッド化コードを使用します。
しかし、 それでもプリミティブ指向のスタイルでコンパイルされるため、 ‘,’
の代わりに ‘compile,’ を使用することはできません(たとえば、 ‘] word1
word2 ... [’ で xt 達のテーブルを生成する場合)。 それを行いたい場合は、
‘gforth-itc’ を使用して ‘' , is compile,’ を実行する必要があります。 あ
なたのプログラムでは、 ‘threading-method’ を使用して、 ハイブリッド 直接
/間接 スレッド化エンジンで実行されているか、 純粋な間接スレッド化エンジ
ンで実行されているかを確認できます。


File: gforth.info,  Node: Dynamic Superinstructions,  Next: DOES>,  Prev: Direct or Indirect Threaded?,  Up: Threading

15.2.3 Dynamic Superinstructions
--------------------------------

‘gforth’ エンジンと ‘gforth-fast’ エンジンは、 別の最適化、 つまり、 レ
プリケーションを伴う動的スーパー命令(Dynamic superinstructions with
replication)を使用します。 例として、 以下のコロン定義について考えてみま
しょう:

     : squared ( n1 -- n2 )
       dup * ;

   Gforth はこれを以下のスレッド化コード・シーケンスにコンパイルします

     dup
     *
     ;s

   ‘simple-see’ (*note Examining compiled code::)を使用して、 コロン定義
のスレッド化コードを確認します。

   通常の直接スレッド化コードでは、 上記のプリミティブごとに 1 つのセル
を占めるコード・アドレスがあります。 各コード・アドレスはマシン・コード
・ルーチンを指し、 インタプリタはプリミティブを実行するためにこのマシン
・コードにジャンプします。 上記 3 つのプリミティブのルーチンは以下のとお
りです(386 の ‘gforth-fast’ の場合):

     Code dup
     ( $804B950 )  add     esi , # -4  \ $83 $C6 $FC
     ( $804B953 )  add     ebx , # 4  \ $83 $C3 $4
     ( $804B956 )  mov     dword ptr 4 [esi] , ecx  \ $89 $4E $4
     ( $804B959 )  jmp     dword ptr FC [ebx]  \ $FF $63 $FC
     end-code
     Code *
     ( $804ACC4 )  mov     eax , dword ptr 4 [esi]  \ $8B $46 $4
     ( $804ACC7 )  add     esi , # 4  \ $83 $C6 $4
     ( $804ACCA )  add     ebx , # 4  \ $83 $C3 $4
     ( $804ACCD )  imul    ecx , eax  \ $F $AF $C8
     ( $804ACD0 )  jmp     dword ptr FC [ebx]  \ $FF $63 $FC
     end-code
     Code ;s
     ( $804A693 )  mov     eax , dword ptr [edi]  \ $8B $7
     ( $804A695 )  add     edi , # 4  \ $83 $C7 $4
     ( $804A698 )  lea     ebx , dword ptr 4 [eax]  \ $8D $58 $4
     ( $804A69B )  jmp     dword ptr FC [ebx]  \ $FF $63 $FC
     end-code

   動的なスーパー命令とレプリケーションを使用すると、 コンパイラーはスレ
ッド化されたコードを配置しないだけでなく、 コード断片のコピーも行い、 通
常は各コード断片最後で行うジャンプを行いません。

     ( $4057D27D )  add     esi , # -4  \ $83 $C6 $FC
     ( $4057D280 )  add     ebx , # 4  \ $83 $C3 $4
     ( $4057D283 )  mov     dword ptr 4 [esi] , ecx  \ $89 $4E $4
     ( $4057D286 )  mov     eax , dword ptr 4 [esi]  \ $8B $46 $4
     ( $4057D289 )  add     esi , # 4  \ $83 $C6 $4
     ( $4057D28C )  add     ebx , # 4  \ $83 $C3 $4
     ( $4057D28F )  imul    ecx , eax  \ $F $AF $C8
     ( $4057D292 )  mov     eax , dword ptr [edi]  \ $8B $7
     ( $4057D294 )  add     edi , # 4  \ $83 $C7 $4
     ( $4057D297 )  lea     ebx , dword ptr 4 [eax]  \ $8D $58 $4
     ( $4057D29A )  jmp     dword ptr FC [ebx]  \ $FF $63 $FC

   スレッド化コードの制御フローに変更が発生した場合(‘;s’ など)にのみジャ
ンプが追加されます。 この最適化により、 これらのジャンプの多くが排除され
、 残りの部分がより予測可能になります。 高速化はプロセッサとアプリケーシ
ョンによって異なります。 Athlon および Pentium III では、 この最適化によ
り通常 2 倍の速度向上が得られます。

   直接スレッド化コード内のコード・アドレスは、 コピーされたマシン・コー
ド内の適切なポイントを指すように設定されます。 この例では以下のようにな
ります:

     primitive  code address
        dup       $4057D27D
        *         $4057D286
        ;s        $4057D292

   したがって、 このコード部分の任意の場所にスレッド化コードからのジャン
プ先が存在する可能性があります。 これにより、 逆コンパイルもかなり簡素化
されます。

   ‘See-code’ (*note Examining compiled code::)は、 動的スーパー命令
(dynamic superinstructions)のネイティブ・コードと混在するスレッド化コー
ドを示します。 最近では、 動的に生成されたネイティブ・コードに追加の最適
化が適用されているため、 特定の AMD64 インストール上の ‘gforth-fast’ で
の ‘see-code squared’ の出力は以下のようになります:

     $7FB689C678C8 dup    1->2
     7FB68990C1B2:   mov     r15,r8
     $7FB689C678D0 *    2->1
     7FB68990C1B5:   imul    r8,r15
     $7FB689C678D8 ;s    1->1
     7FB68990C1B9:   mov     rbx,[r14]
     7FB68990C1BC:   add     r14,$08
     7FB68990C1C0:   mov     rax,[rbx]
     7FB68990C1C3:   jmp     eax

   ‘--no-dynamic’ を使用してこの最適化を無効にできます。 ‘--no-super’ を
使用すると、 ジャンプを排除せずにコピーを使用できます(つまり、 動的レプ
リケーション、 しかしスーパー命令は使用しません)。 これは分岐予測のみに
利点をもたらします。 パフォーマンスへの影響は CPU によって異なります。
Athlon および Pentium III では、 レプリケーションを伴う動的スーパー命令
(dynamic superinstructions with replication)よりも高速化が若干損なわれま
す。

   これらのオプションの用途の 1 つは、 スレッド化されたコードにパッチを
適用する場合です。 スーパー命令を使用すると、 ディスパッチ・ジャンプの多
くが削除されるため、 パッチを当てても効果がなくなることがよくあります。
これらのオプションは、 すべてのディスパッチ・ジャンプを保持します。

   一部のマシンでは動的スーパー命令(dynamic superinstructions)は安全では
ないため、 デフォルトで無効になっています。 しかしながら、 あなたが冒険
してみたい場合は、 ‘--dynamic’ を使用して有効にすることができます。


File: gforth.info,  Node: DOES>,  Prev: Dynamic Superinstructions,  Up: Threading

15.2.4 DOES>
------------

Forth エンジンの最も複雑な部分の 1 つは ‘dodoes’ です。つまり、
‘CREATE’...‘DOES>’ ペアで定義されたすべてのワードによって実行されるコー
ドの塊(chunk)です。 実際のところプリミティブ指向のコードでは、
‘CREATE’...‘DOES>’ ペアで定義されたすべてのワードによって実行されるコー
ドの塊(chunk)は、 ワードの xt が ‘execute’ された場合にのみ必要です。 こ
こでの主な問題は、 実行される Forth コード、 つまり ‘DOES>’ の後のコード
(the ‘DOES>’-code) をどのようにして見つけるかということです。 この解決策
は 2 つあります:

   fig-Forth では、 コード・フィールドは ‘dodoes’ を直接指しており、
‘DOES>’ コード・アドレスはコード・アドレスの後のセル(つまり ‘CFA
cell+’)に格納されます。 この解決策は、 Forth-79 以降のすべての標準では違
法であるように見えるかもしれません。 fig-Forth ではこのアドレスがボディ
内にあるためです(標準では違法です)。 しかしながら、 すべてのワードに対し
てコード・フィールドを大きくすることで、 この解決策は再び有効になります
。 私たちはこのアプローチを採用しています。 ほとんどの場合、 セルを未使
用のままにしておくのはちょっと無駄ですが、 私たちが対象としているマシン
では、 これはほとんど問題になりません。


File: gforth.info,  Node: Primitives,  Next: Performance,  Prev: Threading,  Up: Engine

15.3 Primitives
===============

* Menu:

* Automatic Generation::
* TOS Optimization::
* Produced code::


File: gforth.info,  Node: Automatic Generation,  Next: TOS Optimization,  Prev: Primitives,  Up: Primitives

15.3.1 Automatic Generation
---------------------------

プリミティブは移植可能な言語(portable language)で実装されているため、 最
早プリミティブの数を最小限に抑える必要はありません。 逆に、 多くのプリミ
ティブを持つことには速度という利点があります。 プリミティブでのエラーの
数を減らし、 プリミティブのプログラミングを容易にするために、 プリミティ
ブ・ジェネレーター (‘prims2x.fs’ 別名 Vmgen *note Vmgen: (vmgen)Top.)と
いうツールを提供しており、 それは、 スタック効果の表記からプリミティブの
C言語コードの大部分(場合によってはすべて)を自動的に生成します。 プリミテ
ィブのソースの形式は以下のとおりです:

Forth-name  ( stack-effect )        category    [pronounc.]
[‘""’glossary entry‘""’]
C code
[‘:’
Forth code]

   角括弧(brackets)内の項目はオプションです。 カテゴリ(category)と用語集
(glossary)のフィールドはドキュメントを生成するためにあり、 Forth コード
は GNU C を持たないマシンでの手動実装のためにあります。 たとえば、 プリ
ミティブ ‘+’ のソースは以下のとおりです:
     +    ( n1 n2 -- n )   core    plus
     n = n1+n2;

   これは仕様のように見えますが、 実際には ‘n = n1+n2’ は C言語のコード
です。 私たちのプリミティブ生成ツールは、 スタック効果の表記から多くの情
報を抽出します(1): それらは、 スタックからポップされた項目とスタックにプ
ッシュされた項目の数、 その型、 および C言語のコード内で参照される名前 で
す。 その次に、 各プリミティブの C言語コードの prelude と postlude を生
成します。 ‘+’ の最終的な C言語コードは以下のようになります:

     I_plus: /* + ( n1 n2 -- n ) */  /* label, stack effect */
     /*  */                          /* documentation */
     NAME("+")                       /* debugging output (with -DDEBUG) */
     {
     DEF_CA                          /* definition of variable ca (indirect threading) */
     Cell n1;                        /* definitions of variables */
     Cell n2;
     Cell n;
     NEXT_P0;                        /* NEXT part 0 */
     n1 = (Cell) sp[1];              /* input */
     n2 = (Cell) TOS;
     sp += 1;                        /* stack adjustment */
     {
     n = n1+n2;                      /* C code taken from the source */
     }
     NEXT_P1;                        /* NEXT part 1 */
     TOS = (Cell)n;                  /* output */
     NEXT_P2;                        /* NEXT part 2 */
     }

   これは長くて非効率に見えますが、 GNU C コンパイラーは非常に適切に最適
化して、 例えば R3000 や HP RISC マシンなどで ‘+’ に最適なコードを生成し
ます。 ‘n’ 達を定義してもコードは生成されませんし、 また、 それら中間ス
トレージとして使用してもコストはかかりません。

   この例では示されていない他の最適化もあります。 単純な変数間の代入は通
常はコストがかかりません(コピー伝播)。 スタック項目の 1 つがプリミティブ
によって使用されていない場合(‘drop’ など)、 コンパイラーはスタックのその
部分の負荷を削除します(デッド・コードの削除)。 一方、 コンパイラが実行し
ない処理もいくつかあり、 そのため、 それらは ‘prims2x.fs’ によって実行さ
れます。 コンパイラは、 スタック項目を元の場所に格納するコードを最適化し
ません(例: ‘over’).

   プリミティブのプログラミングは通常は簡単ですが、 最も顕著な ‘?dup’ だ
けでなく、 ‘NEXT’ に(常に)フローが流れていかないワードについても、 プロ
グラマがジェネレーターのアクションを考慮する必要があるケースがいくつかあ
ります。

   詳細について(原文未記述)

   ---------- Footnotes ----------

   (1) データと浮動小数点スタックが別々に存在する場合でも、1 つのスタッ
ク表記法を使用します。 個別の表記は、 統一された表記から簡単に生成できま
す。


File: gforth.info,  Node: TOS Optimization,  Next: Produced code,  Prev: Automatic Generation,  Up: Primitives

15.3.2 TOS Optimization
-----------------------

Forth エンジンなどのスタック・マシン・エミュレータの重要な最適化は、 1 つ
以上の最上位側スタック項目をレジスタに保持することです。 ワードにスタッ
ク効果 ‘( in1...inx -- out1...outy )’ がある場合、 上位の n 項目をレジス
タに保持します:
   • x>=n かつ y>=n の場合、 スタックへのロードとスタックへのストアがよ
     り少なくなるため、 n 項目をレジスタに保持する方が n-1 項目をレジス
     タに保持するよりも優れています。
   • x<>y かつ x<n かつ y<n の場合、 レジスタ間の追加の移動により、 n 項
     目をレジスタに保持することは n-1 項目を保持するよりも遅くなります。

   特に、 レジスターの数が十分であれば、 1 つの項目をレジスターに保持し
ておくことは決して不利にはなりません。 ‘?branch’ や定数や変数やリテラル
や ‘i’ などの頻繁に使用されるワードにとって、 2 つの項目をレジスターに保
持することは不利になります。 したがって、 ジェネレーターは、 レジスター
に 0 個または 1 つの項目を保持するコードのみを生成します。 生成された C言
語のコードは両方のケースをカバーします。 これらの選択肢の選択は、 C言語
のコンパイル時にスイッチ ‘-DUSE_TOS’ を使用して行われます。 ‘+’ の C言語
コードの ‘TOS’ は、 1 項目の場合は単なる変数名ですが、 それ以外の場合は
‘sp[0]’ に展開されるマクロです。 注意: GNU C コンパイラは ‘TOS’ のような
単純な変数をレジスタに保持しようと試み、 十分な数のレジスタがあれば、 そ
れは通常は成功することに注意してください。

   プリミティブ・ジェネレーターは、 浮動小数点数スタックの TOS 最適化も
実行します(‘-DUSE_FTOS’)。 浮動小数点数演算の場合、 この最適化の利点はさ
らに大きくなります。 浮動小数点数演算は、 ほとんどのプロセッサで非常に時
間がかかりますが、 その結果が利用されない間は他の演算と並行して実行でき
ます。 FP-TOS がレジスターに保持されている場合、 他の演算との並行しての
実行が機能します。 スタック上、 つまりメモリ内に保持されている場合、 メ
モリへのストアは浮動小数点数演算の結果を待つ必要があり、 プリミティブの
実行時間が大幅に長くなります。

   TOS の最適化により、 プリミティブの自動生成がちょっぴり複雑になります
。 ‘sp[0]’ のすべての出現を ‘TOS’ に置き換えるだけでは十分ではありません
。 考慮すべき特殊なケースがいくつかあります:
   • ‘dup ( w -- w w )’ で、 TOS 最適化がオンになっている場合、 ジェネレ
     ーターはスタック上の項目の元の場所へのストアを削除してはなりません
     。
   • ‘(-- out1...outy)’ の形式のスタック効果を持つプリミティブは、 開始
     時に TOS をスタックに保存する必要があります。 同様に、 スタック効果
     ‘in1...inx --)’ を持つプリミティブは、 最後にスタックから TOS をロ
     ードする必要があります。 ただし、 null スタック効果 ‘--’ の場合、 ス
     トアやロードは生成されません。


File: gforth.info,  Node: Produced code,  Prev: TOS Optimization,  Up: Primitives

15.3.3 Produced code
--------------------

コンパイラとフラグ設定を使用してマシン上のプリミティブに対してどのような
アセンブリ・コードが生成されるかを確認するには、 ‘make engine.s’ と入力
し、結果のファイル ‘engine.s’ を確認します。 あるいは、 一部のアーキテク
チャでは ‘see’ を使用してプリミティブのコードを逆アセンブルすることもで
きます。


File: gforth.info,  Node: Performance,  Prev: Primitives,  Up: Engine

15.4 Performance
================

RISC では、Gforth エンジンは限りなく最適な状態に近くなります。 逆に、 通
常、 RISC以外では、 顕著に高速なスレッド化コード・エンジンを作成すること
は不可能です。

   386 アーキテクチャ・プロセッサのようにレジスタの数が不足しているマシ
ンでは、 明示的なレジスタ宣言があっても ‘gcc’ が人間ほどにはレジスタを利
用しないため、 人間による改善が可能です。 たとえば、Bernd Beuster は
Forth システムの断片をアセンブリ言語で作成し、 486 用に手動で調整しまし
た。 このシステムは、 486DX2/66 での Sieve ベンチマークでは、
‘-DFORCE_REG’ を使用して ‘gcc-2.6.3’ でコンパイルした Gforth よりも 1.19
倍高速です。 この状況は gcc-2.95 と gforth-0.4.9 で改善されました。 これ
で、 最も重要な仮想マシンのレジスタが実際のレジスタに収まるようになり(更
に、 TOS 最適化を使用する余裕さえあります)、 結果として以前の結果よりも
1.14 高速化されました。 また、動的スーパー命令によりさらに高速化が実現さ
れます(ただし、 486 では約 1.2 倍にすぎません)。

   アセンブリ言語で実装する潜在的な利点は、 Forth システムでは必ずしも現
実のモノにはなりません。 Gforth をアセンブリ言語で書かれたシステムと比較
しました: Gforth-0.5.9 (直接スレッド化、 ‘gcc-2.95.1’ 、 ‘-DFORCE_REG’ で
コンパイル)、 Gforth-0.5.9 の Win32Forth 版 1.2093 (新しいバージョンはは
るかに高速であると報告されています))、 LMI の NT Forth (1994年5月のベー
タ版)、 Eforth(スレッド化されたコードののぞき穴(別名ピンホール)最適化の
有無)。 また、Gforth を C言語で書かれた 3 つのシステムと比較しました:
PFE-0.9.14 (Linux のデフォルト構成で ‘gcc-2.6.3’ でコンパイル: ‘-O2
-fomit-frame-pointer -DUSE_REGS -DUNROLL_NEXT’)、 ThisForth Beta
(‘gcc-2.6.3 -O3 -fomit-frame-pointer’ でコンパイル; ThisForth はスレッド
化されたコードののぞき穴最適化を採用)、 TILE (‘make opt’ でコンパイル)。
Linux 上の 486DX2/66 で、 Gforth と PFE と ThisForth と TILE のベンチマ
ークを実行しました。 Kenneth O’Heskin は、 Windows NT で同様のメモリ・パ
フォーマンスを備えた 486DX2/66 上の Win32Forth と NT Forth の結果を親切
に提供してくれました。 Marcel Hendrix は Eforth を Linux に移植し、 ベン
チマークを実行できるように拡張し、 覗き穴・オプティマイザーを追加してベ
ンチマークを実行し、 結果を報告しました。

   私たちは 4 つの小さなベンチマークを使用しました。 ユビキタスのふるい
。 バブルソートと行列乗算はスタンフォード整数ベンチマーク由来で、 Martin
Fraeman によって Forth に変換されました。 TILE Forth パッケージに含まれ
ているバージョンを使用しましたが、 データ・セット・サイズが大きくなりま
した。 そして、 呼び出しパフォーマンス(calling performance)のベンチマー
クのための再帰的フィボナッチ数計算です。 以下の表は、 ベンチマークにかか
る時間を Gforth にかかった時間で換算したものです(つまり、 Gforth が他の
システムに対して達成した高速化係数を示しています)。

     relative       Win32-    NT       eforth       This-
     time     Gforth Forth Forth eforth  +opt   PFE Forth  TILE
     sieve      1.00  2.16  1.78   2.16  1.32  2.46  4.96 13.37
     bubble     1.00  1.93  2.07   2.18  1.29  2.21        5.70
     matmul     1.00  1.92  1.76   1.90  0.96  2.06        5.32
     fib        1.00  2.32  2.03   1.86  1.31  2.64  4.55  6.54

   あなたは、 アセンブリ言語で書かれたシステムと比較したとき、 Gforth の
優れたパフォーマンスに驚かれるかもしれません。 これら他のシステムのパフ
ォーマンスが期待外れである重要な理由の 1 つは、 おそらく、 それらが 486
用に最適化して書かれていないことです(たとえば、‘lods’ 命令を使用している
)。 さらに、 Win32Forth は、 Forth イメージを再配置するために快適ではあ
りますがコストのかかる方法を使用します: これは ‘cforth’ と同様に、 実行
時に実際のアドレスが計算され、 ‘NEXT’ 毎に 2 つのアドレス計算が行われま
す(*note Image File Background::)。

   PFE や ThisForth や TILE に対する Gforth の高速化は、 前者達のシステ
ムが標準 C に対して自ら課した制限によって簡単に説明できます: これにより
、 効率的なスレッド化が不可能になります(ただし、 観測された PFE の実装で
は GNU C 拡張機能が使用されています *note Defining Global Register
Variables: (gcc)Global Reg Vars.)。 さらに言えば、 現在の C コンパイラは
、 ThisForth や TILE ソースの他の側面を最適化するのに苦労しています。

   386 アーキテクチャ・プロセッサ上の Gforth のパフォーマンスは、 使用す
る ‘gcc’ のバージョンによって大きく異なります。 たとえば、‘gcc-2.5.8’ は
、 それ自身では仮想マシン・レジスタを実マシン・レジスタに割り当てること
に失敗し、 かつ、 明示的なレジスタ宣言では正しく動作しないため、 (Sieve
ベンチマークを実行している 486DX2/66 では、)上記で測定したエンジンよりも
大幅に遅いエンジンが出来上がります。

   注意: ここで紹介したリリース以降、 Win32Forth のリリースがいくつかあ
るため、 上記の結果は現在の Win32Forth のパフォーマンスを予測する値がほ
とんどない可能性があることに注意してください(i486DX2/66 での現在のリリー
スの結果報告をお待ちしています)。

   ‘Translating Forth to Efficient C
(https://www.complang.tuwien.ac.at/papers/ertl&maierhofer95.ps.gz)’ by
M. Anton Ertl and Martin Maierhofer (presented at EuroForth ’95) では、
Gforth の間接スレッド化バージョンが、 Win32Forth や NT Forth や PFE や
ThisForth や、 いくつかのネイティブ・コード・システムと比較されます。 そ
のバージョンの Gforth は、 486 ではここで使用されているバージョンよりも
遅くなります。 これらの測定値の新しいバージョンは
<https://www.complang.tuwien.ac.at/forth/performance.html> で見つけるこ
とができます。 あなたは ‘Benchres’ でさまざまなマシン上の Gforth の数値
を見つけることができます。


File: gforth.info,  Node: Cross Compiler,  Next: MINOS2,  Prev: Engine,  Up: Top

16 Cross Compiler
*****************

クロス・コンパイラは、 Forth カーネルをブート・ストラップするために使用
されます。 Gforth は、 外部インタプリタやコンパイラなどの重要な部分を含
め、 ほとんどが Forth で書かれているため、 開始するにはコンパイル済みの
Forth コードが必要です。 クロス・コンパイラを使用すると、 他のアーキテク
チャ用の新しいイメージを作成でき、 別の Forth システムで実行することもで
きます。

* Menu:

* Using the Cross Compiler::
* How the Cross Compiler Works::


File: gforth.info,  Node: Using the Cross Compiler,  Next: How the Cross Compiler Works,  Prev: Cross Compiler,  Up: Cross Compiler

16.1 Using the Cross Compiler
=============================

クロス・コンパイラは、 Forth そっくりの言語を使用しますが、 Forth ではあ
りません。 主な違いは、 Forth コードは定義後に実行できるのに対し、 cross
によってコンパイルされたコードは通常は実行できないことです。 これは、 コ
ンパイルしているコードは通常、 コンパイルしているコンピュータとは異なる
コンピュータ用であるためです。

   Makefile はすでにセットアップされており、 簡単な make コマンドで新し
いアーキテクチャ用のカーネルを作成できるようになります。 GCC でコンパイ
ルされた仮想マシンを使用する汎用カーネルは、 ‘make’ を使用した通常のビル
ド・プロセスで作成されます。 たとえば、 8086 プロセッサ用の埋め込み
Gforth 実行可能ファイル(embedded Gforth executable)(DOS マシン上で実行
)を作成するには、 以下のようにタイプします

     make kernl-8086.fi

   これにより、 ‘arch/8086’ ディレクトリのマシンの説明(machine
description)が使用されて、 新しいカーネルが作成されます。 マシン・ファイ
ルは以下のようになります:

     \ Parameter for target systems                         06oct92py

         4 Constant cell             \ cell size in bytes
         2 Constant cell<<           \ cell shift to bytes
         5 Constant cell>bit         \ cell shift to bits
         8 Constant bits/char        \ bits per character
         8 Constant bits/byte        \ bits per byte [default: 8]
         8 Constant float            \ bytes per float
         8 Constant /maxalign        \ maximum alignment in bytes
     false Constant bigendian        \ byte order
     ( true=big, false=little )

     include machpc.fs               \ feature list

   この部分はクロス・コンパイラにとって必須であり、 機能リスト(feature
list)は、 ターゲットがこれらの機能をサポートしているかどうかに応じて、 い
くつかの機能を条件付きでコンパイルしたりしなかったりするためにカーネルに
よって使用される。

   あなた独自のプリミティブを定義する場合、 またはアセンブラを使用する場
合、 またはブート・プロセスを機能させるために特別な非標準の準備が必要な
場合は、 オプションの機能(feature)がいくつかあります。 ‘asm-include’ に
はアセンブラが含まれ、 ‘prims-include’ にはプリミティブが含まれ、
‘>boot’ はブートの準備をします。

     : asm-include    ." Include assembler" cr
       s" arch/8086/asm.fs" included ;

     : prims-include  ." Include primitives" cr
       s" arch/8086/prim.fs" included ;

     : >boot          ." Prepare booting" cr
       s" ' boot >body into-forth 1+ !" evaluate ;

   これらのワードは、 ファイル ‘kernel/main.fs’ をクロス・コンパイルする
時に一種のマクロとして使用されます。 これらのマクロを使用する代わりに、
新しいカーネル・プロジェクト・ファイルを作成することも可能ですが、 より
複雑になります。

   ‘kernel/main.fs’ はスタック上にマシン記述ファイル名(machine
description file name)を期待します。 クロス・コンパイラ自体
(‘cross.fs’)は、 ‘mach-file’ がカウンタ付き文字列をスタックに残すか、 ま
たは ‘machine-file’ がファイル名のアドレスとカウントのペアをスタックに残
すかのいずれかを想定します。

   機能リスト(feature list)は通常​​ ‘SetValue’ を使用して制御されますが
、 複数のプロジェクトで使用される汎用ファイルは代わりに ‘DefaultValue’ を
使用できます。 どちらのワードも、 値が定義されていない場合は ‘Value’ の
ように動作しますが、 値が定義されている場合は ‘SetValue’ は ‘to’ のよう
に動作し、 値が定義されている場合は ‘DefaultValue’ は何も設定しません。

     \ generic mach file for pc gforth                       03sep97jaw

     true DefaultValue NIL  \ relocating

     >ENVIRON

     true DefaultValue file          \ controls the presence of the
                                     \ file access wordset
     true DefaultValue OS            \ flag to indicate a operating system

     true DefaultValue prims         \ true: primitives are c-code

     true DefaultValue floating      \ floating point wordset is present

     true DefaultValue glocals       \ gforth locals are present
                                     \ will be loaded
     true DefaultValue dcomps        \ double number comparisons

     true DefaultValue hash          \ hashing primitives are loaded/present

     true DefaultValue xconds        \ used together with glocals,
                                     \ special conditionals supporting gforths'
                                     \ local variables
     true DefaultValue header        \ save a header information

     true DefaultValue backtrace     \ enables backtrace code

     false DefaultValue ec
     false DefaultValue crlf

     cell 2 = [IF] &32 [ELSE] &256 [THEN] KB DefaultValue kernel-size

     &16 KB          DefaultValue stack-size
     &15 KB &512 +   DefaultValue fstack-size
     &15 KB          DefaultValue rstack-size
     &14 KB &512 +   DefaultValue lstack-size


File: gforth.info,  Node: How the Cross Compiler Works,  Prev: Using the Cross Compiler,  Up: Cross Compiler

16.2 How the Cross Compiler Works
=================================


File: gforth.info,  Node: MINOS2,  Next: Bugs,  Prev: Cross Compiler,  Up: Top

17 MINOS2, a GUI library
************************

* Menu:

* MINOS2 object framework::
* MINOS2 tutorial::


File: gforth.info,  Node: MINOS2 object framework,  Next: MINOS2 tutorial,  Prev: MINOS2,  Up: MINOS2

17.1 MINOS2 object framework
============================

* Menu:

* actor methods::
* widget methods::

MINOS2 is a GUI library, written in ‘mini-oof2.fs’’s object model.  It
has two main class hierarchies:

‘actor’ ( – class  ) minos2 “actor”
   class for the actions bound to a component.

‘widget’ ( – class  ) minos2 “widget”
   class for visual components


File: gforth.info,  Node: actor methods,  Next: widget methods,  Prev: MINOS2 object framework,  Up: MINOS2 object framework

17.1.1 ‘actor’ methods:
-----------------------

‘caller-w’ ( – optr  ) minos2 “caller-w”
   pointer back to the widget embedding the actor

‘active-w’ ( – optr  ) minos2 “active-w”
   pointer to the active subwidget embedding the actor

‘act-name$’ ( – addr u  ) minos2 “act-name-string”
   Debugging aid: name of the actor

‘clicked’ ( rx ry bmask n –  ) minos2 “clicked”
   processed clicks

‘scrolled’ ( axis dir –  ) minos2 “scrolled”
   process scrolling

‘touchdown’ ( $rxy*n bmask –  ) minos2 “touchdown”
   raw click down

‘touchup’ ( $rxy*n bmask –  ) minos2 “touchup”
   raw click up

‘ukeyed’ ( addr u –  ) minos2 “ukeyed”
   key event, string of printable unicode characters

‘ekeyed’ ( ekey –  ) minos2 “ekeyed”
   key event, non-printable key

‘?inside’ ( rx ry – act / 0  ) minos2 “query-inside”
   check if coordinates are inside the widget

‘focus’ ( –  ) minos2 “focus”
   put widget into focus

‘defocus’ ( –  ) minos2 “defocus”
   put widget out of focus

‘entered’ ( –  ) minos2 “entered”
   react on cursor entering the widget area

‘left’ ( –  ) minos2 “left”
   react on cursor leaving the widget area

‘show’ ( –  ) minos2 “show”
   widget is shown

‘hide’ ( –  ) minos2 “hide”
   widget is hidden

‘get’ ( – something  ) minos2 “get”
   getter for the value behind the widget

‘set’ ( something –  ) minos2 “set”
   setter for the value behind the widget

‘show-you’ ( –  ) minos2 “show-you”
   make widget visible


File: gforth.info,  Node: widget methods,  Prev: actor methods,  Up: MINOS2 object framework

17.1.2 ‘widget’ methods:
------------------------

‘parent-w’ ( – optr  ) minos2 “parent-w”
   pointer to parent widget

‘act’ ( – optr  ) minos2 “act”
   pointer to actor

‘name$’ ( – addr u  ) minos2 “name-string”
   Widget name for debugging and searching

‘x’ ( – r  ) minos2 “x”
   widget x coordinate

‘y’ ( – r  ) minos2 “y”
   widget y coordinate

‘w’ ( – r  ) minos2 “w”
   widget width

‘h’ ( – r  ) minos2 “h”
   widget height above baseline

‘d’ ( – r  ) minos2 “d”
   widget depth below baseline

‘gap’ ( – r  ) minos2 “gap”
   gap between lines

‘baseline’ ( – r  ) minos2 “baseline”
   minimun skip per line

‘kerning’ ( – r  ) minos2 “kerning”
   add kerning

‘raise’ ( – r  ) minos2 “raise”
   raise/lower box

‘border’ ( – r  ) minos2 “border”
   surrounding border, all directions

‘borderv’ ( – r  ) minos2 “borderv”
   vertical border offset

‘bordert’ ( – r  ) minos2 “bordert”
   top border offset

‘borderl’ ( – r  ) minos2 “borderl”
   left border offset

‘w-color’ ( – r  ) minos2 “w-color”
   widget color index (into color map), if any

‘draw-init’ ( –  ) minos2 “draw-init”
   init draw

‘draw’ ( –  ) minos2 “draw”
   draw widget

‘split’ ( firstflag rstart1 rx – o rstart2  ) minos2 “split”
   split a widget into parts for typesetting paragraphs

‘lastfit’ ( –  ) minos2 “lastfit”
   fit last widget element in a box

‘hglue’ ( – rtyp rsub radd  ) minos2 “hglue”
   calculate horizontal glue

‘dglue’ ( – rtyp rsub radd  ) minos2 “dglue”
   calculate vertical glue below baseline

‘vglue’ ( – rtyp rsub radd  ) minos2 “vglue”
   calculate vertical glue above baseline

‘hglue@’ ( – rtyp rsub radd  ) minos2 “hglue-fetch”
   cached variant of ‘hglue’

‘dglue@’ ( – rtyp rsub radd  ) minos2 “dglue-fetch”
   cached variant of ‘dglue’

‘vglue@’ ( – rtyp rsub radd  ) minos2 “vglue-fetch”
   cached variant of ‘vglue’

‘xywh’ ( – rx0 ry0 rw rh  ) minos2 “xywh”
   widget bounding box, starting at the top left corner

‘xywhd’ ( – rx ry rw rh rd  ) minos2 “xywhd”
   widget bounding box, starting at the left baseline point

‘!resize’ ( rx ry rw rh rd –  ) minos2 “store-resize”
   resize a widget

‘!size’ ( –  ) minos2 “store-size”
   let the widget self-determine its size

‘dispose-widget’ ( –  ) minos2 “dispose-widget”
   get rid of a widget

‘.widget’ ( –  ) minos2 “print-widget”
   debugging: Print informations about the widget

‘par-split’ ( rw –  ) minos2 “par-split”
   split a paragraph by width RW

‘resized’ ( –  ) minos2 “resized”
   widget is resized

   Components are composed using a boxes&glue model similar to LaTeX,
including paragraph breaking.  For the sake of simplicity and
portability, MINOS2 only supports a single window, and uses OpenGL for
rendering.

   MINOS2 furthermore supports animations with the ‘animation’ class.  A
color index texture is used for different color schemes, and transition
between neighboring schemes can also be animated.

‘>animate’ ( rdelta addr xt –  ) minos2 “to-animate”
   create a new animation, calling XT with stack effect ‘( addr r0..1 --
)’ repeatedly, until the RDELTA timeout expired; last call is always
with argument 1E for the time.

   You can create named color indexes and assign them color values for
the currently active color scheme.

‘color:’ ( rgba "name" –  ) minos2 “color:”
   Create a (possibly shared) color index initialized with RGBA

‘new-color:’ ( rgba "name" –  ) minos2 “new-color:”
   Create a unique color index initialized with RGBA

‘text-color:’ ( rgba "name" –  ) minos2 “text-color:”
   Create a unique text color index initialized with RGBA, the
corresponding emoji color is set to white.

‘text-emoji-color:’ ( rgbatext rgbaemoji "name" –  ) minos2 “text-emoji-color:”
   Create a unique text color index initialized with RGBATEXT, the
corresponding emoji color is set to RGBAEMOJI.

‘fade-color:’ ( rgba1 rgba2 "name" –  ) minos2 “fade-color:”
   Create a unique pair of text color index initialized with RGBA1 and
RGBA2, the corresponding emoji color is set to white.  By slowly
shifting the index from one to the next index, the object will shift its
color using a linear interpolation when redrawn.

‘text-emoji-fade-color:’ ( rgbatext1 ~2 rgbaemoji1 ~2 "name" –  ) minos2 “text-emoji-fade-color:”
   Create a unique pair of text color index initialized with RGBATEXT1
and ~2, the corresponding emoji color pair is set to RGBAEMOJI1 to ~2.
By slowly shifting the index from one to the next index, the object will
shift its color using a linear interpolation when redrawn.

‘re-color’ ( rgba "name" –  ) minos2 “re-color”
   assign the named color index "NAME" in the current color scheme with
the value RGBA.

‘re-text-color’ ( rgba "name" –  ) minos2 “re-text-color”
   assign the named text color index "NAME" in the current color scheme
with the value RGBA.

‘re-emoji-color’ ( rgbatext rgbaemoji "name" –  ) minos2 “re-emoji-color”
   assign the named text and emoji color index "NAME" in the current
color scheme with the value RGBATEXT and RGBAEMOJI.

‘re-fade-color’ ( rgba1 rgba2 "name" –  ) minos2 “re-fade-color”
   assign the named color index pair "NAME" in the current color scheme
with the value RGBA1 and RGBA2.

‘re-text-emoji-fade-color’ ( rgbatext1 ~2 rgbaemoji1 ~2 "name" –  ) minos2 “re-text-emoji-fade-color”
   assign the named color index pair "NAME" in the current color scheme
with the value RGBATEXT1 and ~2 resp.  RGBAEMOJI1 and ~2.

   For a number of specific objects, there are early bound methods, that
only work on these objects

   • Viewport

     ‘vp-top’ ( o:vp –  ) minos2 “vp-top”
     scroll viewport to top

     ‘vp-bottom’ ( o:vp –  ) minos2 “vp-bottom”
     scroll viewport to bottom

     ‘vp-left’ ( o:vp –  ) minos2 “vp-left”
     scroll viewport to left

     ‘vp-right’ ( o:vp –  ) minos2 “vp-right”
     scroll viewport to right

     ‘vp-reslide’ ( o:vp –  ) minos2 “vp-reslide”
     Adjust the sliders of a viewport after scrolling

     ‘vp-needed’ ( xt –  ) minos2 “vp-needed”
     collect needs in viewport’s vp-need


File: gforth.info,  Node: MINOS2 tutorial,  Prev: MINOS2 object framework,  Up: MINOS2

17.2 MINOS2 tutorial
====================

Tutorials are small files, each showing a bit of MINOS2.  For the common
framework, the file ‘minos2/tutorial/tutorial.fs’ needs to be loaded
first; all other tutorials in the command line argument are included
from within that file.  Scroll wheel or previous/next mouse buttons as
well as clicking on the left or right edge of the window allow
navigation between the different tutorials loaded.

   I.e.  to load the buttons tutorial, you start Gforth with

     gforth minos2/tutorial/tutorial.fs buttons.fs

   Available tutorials:

   • ‘buttons.fs’: Clickable buttons

   • ‘plots.fs’: Plot functions

   • ‘markdown.fs’: Markdown document viewer

   • ‘screenshot.fs’: Screenshot function


File: gforth.info,  Node: Bugs,  Next: Origin,  Prev: MINOS2,  Up: Top

Appendix A Bugs
***************

Known bugs are described in the file ‘BUGS’ in the Gforth distribution.

   If you find a bug, please submit a bug report through
<https://savannah.gnu.org/bugs/?func=addbug&group=gforth>.

   • A program (or a sequence of keyboard commands) that reproduces the
     bug.
   • A description of what you think constitutes the buggy behaviour.
   • The Gforth version used (it is announced at the start of an
     interactive Gforth session).
   • The machine and operating system (on Unix systems ‘uname -a’ will
     report this information).
   • The installation options (you can find the configure options at the
     start of ‘config.status’) and configuration (‘configure’ output or
     ‘config.cache’).
   • A complete list of changes (if any) you (or your installer) have
     made to the Gforth sources.

   For a thorough guide on reporting bugs read *note How to Report Bugs:
(gcc)Bug Reporting.


File: gforth.info,  Node: Origin,  Next: Forth-related information,  Prev: Bugs,  Up: Top

Appendix B Authors and Ancestors of Gforth
******************************************

B.1 Authors and Contributors
============================

The Gforth project was started in mid-1992 by Bernd Paysan and Anton
Ertl.  The third major author was Jens Wilke.  Neal Crook contributed a
lot to the manual.  Assemblers and disassemblers were contributed by
Andrew McKewan, Christian Pirker, Bernd Thallner, and Michal Revucky.
Lennart Benschop (who was one of Gforth’s first users, in mid-1993) and
Stuart Ramsden inspired us with their continuous feedback.  Lennart
Benshop contributed ‘glosgen.fs’, while Stuart Ramsden has been working
on automatic support for calling C libraries.  Helpful comments also
came from Paul Kleinrubatscher, Christian Pirker, Dirk Zoller, Marcel
Hendrix, John Wavrik, Barrie Stott, Marc de Groot, Jorge Acerada, Bruce
Hoyt, Robert Epprecht, Dennis Ruffer and David N. Williams.  Since the
release of Gforth-0.2.1 there were also helpful comments from many
others; thank you all, sorry for not listing you here (but digging
through my mailbox to extract your names is on my to-do list).

   Gforth also owes a lot to the authors of the tools we used (GCC, CVS,
and autoconf, among others), and to the creators of the Internet: Gforth
was developed across the Internet, and its authors did not meet
physically for the first 4 years of development.

B.2 Pedigree
============

Gforth descends from bigFORTH (1993) and fig-Forth.  Of course, a
significant part of the design of Gforth was prescribed by Standard
Forth.

   Bernd Paysan wrote bigFORTH, a descendent from TurboForth, an
unreleased 32 bit native code version of VolksForth for the Atari ST,
written mostly by Dietrich Weineck.

   VolksForth was written by Klaus Schleisiek, Bernd Pennemann, Georg
Rehfeld and Dietrich Weineck for the C64 (called UltraForth there) in
the mid-80s and ported to the Atari ST in 1986.  It descends from
fig-Forth.

   A team led by Bill Ragsdale implemented fig-Forth on many processors
in 1979.  Robert Selzer and Bill Ragsdale developed the original
implementation of fig-Forth for the 6502 based on microForth.

   The principal architect of microForth was Dean Sanderson.  microForth
was FORTH, Inc.’s first off-the-shelf product.  It was developed in 1976
for the 1802, and subsequently implemented on the 8080, the 6800 and the
Z80.

   All earlier Forth systems were custom-made, usually by Charles Moore,
who discovered (as he puts it) Forth during the late 60s.  The first
full Forth existed in 1971.

   A part of the information in this section comes from ‘The Evolution
of Forth (https://www.forth.com/resources/evolution/index.html)’ by
Elizabeth D. Rather, Donald R. Colburn and Charles H. Moore, presented
at the HOPL-II conference and preprinted in SIGPLAN Notices 28(3), 1993.
You can find more historical and genealogical information about Forth
there.  For a more general (and graphical) Forth family tree look see
‘<https://www.complang.tuwien.ac.at/forth/family-tree/>, Forth Family
Tree and Timeline’.


File: gforth.info,  Node: Forth-related information,  Next: Licenses,  Prev: Origin,  Up: Top

Appendix C Other Forth-related information
******************************************

There is an active news group (comp.lang.forth) discussing Forth
(including Gforth) and Forth-related issues.  Its FAQs
(https://www.complang.tuwien.ac.at/forth/faq/faq-general-2.html)
(frequently asked questions and their answers) contains a lot of
information on Forth.  You should read it before posting to
comp.lang.forth.

   The Forth standard is most usable in its HTML form
(https://forth-standard.org/).


File: gforth.info,  Node: Licenses,  Next: Word Index,  Prev: Forth-related information,  Up: Top

Appendix D Licenses
*******************

* Menu:

* GNU Free Documentation License::  このマニュアルのコピー時のライセンス
* Copying::                  GPL (このソフトウェアのコピー用)


File: gforth.info,  Node: GNU Free Documentation License,  Next: Copying,  Prev: Licenses,  Up: Licenses

D.1 GNU Free Documentation License
==================================

                      Version 1.2, November 2002

     Copyright © 2000,2001,2002 Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307, USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document “free” in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of “copyleft”, which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.  We
     recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it can
     be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     “Document”, below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as “you”.  You accept
     the license if you copy, modify or distribute the work in a way
     requiring permission under copyright law.

     A “Modified Version” of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A “Secondary Section” is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document’s overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The “Invariant Sections” are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in the
     notice that says that the Document is released under this License.
     If a section does not fit the above definition of Secondary then it
     is not allowed to be designated as Invariant.  The Document may
     contain zero Invariant Sections.  If the Document does not identify
     any Invariant Sections then there are none.

     The “Cover Texts” are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A “Transparent” copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images composed
     of pixels) generic paint programs or (for drawings) some widely
     available drawing editor, and that is suitable for input to text
     formatters or for automatic translation to a variety of formats
     suitable for input to text formatters.  A copy made in an otherwise
     Transparent file format whose markup, or absence of markup, has
     been arranged to thwart or discourage subsequent modification by
     readers is not Transparent.  An image format is not Transparent if
     used for any substantial amount of text.  A copy that is not
     “Transparent” is called “Opaque”.

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and standard-conforming
     simple HTML, PostScript or PDF designed for human modification.
     Examples of transparent image formats include PNG, XCF and JPG.
     Opaque formats include proprietary formats that can be read and
     edited only by proprietary word processors, SGML or XML for which
     the DTD and/or processing tools are not generally available, and
     the machine-generated HTML, PostScript or PDF produced by some word
     processors for output purposes only.

     The “Title Page” means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, “Title
     Page” means the text near the most prominent appearance of the
     work’s title, preceding the beginning of the body of the text.

     A section “Entitled XYZ” means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     “Acknowledgements”, “Dedications”, “Endorsements”, or “History”.)
     To “Preserve the Title” of such a section when you modify the
     Document means that it remains a section “Entitled XYZ” according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow the
     conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document’s license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the title
     equally prominent and visible.  You may add other material on the
     covers in addition.  Copying with changes limited to the covers, as
     long as they preserve the title of the Document and satisfy these
     conditions, can be treated as verbatim copying in other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a machine-readable
     Transparent copy along with each Opaque copy, or state in or with
     each Opaque copy a computer-network location from which the general
     network-using public has access to download using public-standard
     network protocols a complete Transparent copy of the Document, free
     of added material.  If you use the latter option, you must take
     reasonably prudent steps, when you begin distribution of Opaque
     copies in quantity, to ensure that this Transparent copy will
     remain thus accessible at the stated location until at least one
     year after the last time you distribute an Opaque copy (directly or
     through your agents or retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of copies,
     to give them a chance to provide you with an updated version of the
     Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with the
     Modified Version filling the role of the Document, thus licensing
     distribution and modification of the Modified Version to whoever
     possesses a copy of it.  In addition, you must do these things in
     the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of previous
          versions (which should, if there were any, be listed in the
          History section of the Document).  You may use the same title
          as a previous version if the original publisher of that
          version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document’s
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled “History”, Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on the
          Title Page.  If there is no section Entitled “History” in the
          Document, create one stating the title, year, authors, and
          publisher of the Document as given on its Title Page, then add
          an item describing the Modified Version as stated in the
          previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in the
          “History” section.  You may omit a network location for a work
          that was published at least four years before the Document
          itself, or if the original publisher of the version it refers
          to gives permission.

       K. For any section Entitled “Acknowledgements” or “Dedications”,
          Preserve the Title of the section, and preserve in the section
          all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document, unaltered
          in their text and in their titles.  Section numbers or the
          equivalent are not considered part of the section titles.

       M. Delete any section Entitled “Endorsements”.  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          “Endorsements” or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option designate
     some or all of these sections as invariant.  To do this, add their
     titles to the list of Invariant Sections in the Modified Version’s
     license notice.  These titles must be distinct from any other
     section titles.

     You may add a section Entitled “Endorsements”, provided it contains
     nothing but endorsements of your Modified Version by various
     parties—for example, statements of peer review or that the text has
     been approved by an organization as the authoritative definition of
     a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end of
     the list of Cover Texts in the Modified Version.  Only one passage
     of Front-Cover Text and one of Back-Cover Text may be added by (or
     through arrangements made by) any one entity.  If the Document
     already includes a cover text for the same cover, previously added
     by you or by arrangement made by the same entity you are acting on
     behalf of, you may not add another; but you may replace the old
     one, on explicit permission from the previous publisher that added
     the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination all
     of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     “History” in the various original documents, forming one section
     Entitled “History”; likewise combine any sections Entitled
     “Acknowledgements”, and any sections Entitled “Dedications”.  You
     must delete all sections Entitled “Endorsements.”

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the documents
     in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow this
     License in all other respects regarding verbatim copying of that
     document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of a
     storage or distribution medium, is called an “aggregate” if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation’s users beyond what the individual
     works permit.  When the Document is included in an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document’s Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warranty Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled “Acknowledgements”,
     “Dedications”, or “History”, the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided for under this License.  Any other
     attempt to copy, modify, sublicense or distribute the Document is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses terminated
     so long as such parties remain in full compliance.

  10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     <http://www.gnu.org/copyleft/>.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License “or any later version” applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If the
     Document does not specify a version number of this License, you may
     choose any version ever published (not as a draft) by the Free
     Software Foundation.

D.1.1 ADDENDUM: How to use this License for your documents
----------------------------------------------------------

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.2
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the “with...Texts.” line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

   If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of free
software license, such as the GNU General Public License, to permit
their use in free software.


File: gforth.info,  Node: Copying,  Prev: GNU Free Documentation License,  Up: Licenses

D.2 GNU GENERAL PUBLIC LICENSE
==============================

                        Version 3, 29 June 2007

     Copyright © 2007 Free Software Foundation, Inc. <http://fsf.org/>

     Everyone is permitted to copy and distribute verbatim copies of this
     license document, but changing it is not allowed.

Preamble
========

The GNU General Public License is a free, copyleft license for software
and other kinds of works.

   The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom to
share and change all versions of a program—to make sure it remains free
software for all its users.  We, the Free Software Foundation, use the
GNU General Public License for most of our software; it applies also to
any other work released this way by its authors.  You can apply it to
your programs, too.

   When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

   To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you have
certain responsibilities if you distribute copies of the software, or if
you modify it: responsibilities to respect the freedom of others.

   For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too, receive
or can get the source code.  And you must show them these terms so they
know their rights.

   Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

   For the developers’ and authors’ protection, the GPL clearly explains
that there is no warranty for this free software.  For both users’ and
authors’ sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

   Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the manufacturer
can do so.  This is fundamentally incompatible with the aim of
protecting users’ freedom to change the software.  The systematic
pattern of such abuse occurs in the area of products for individuals to
use, which is precisely where it is most unacceptable.  Therefore, we
have designed this version of the GPL to prohibit the practice for those
products.  If such problems arise substantially in other domains, we
stand ready to extend this provision to those domains in future versions
of the GPL, as needed to protect the freedom of users.

   Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish to
avoid the special danger that patents applied to a free program could
make it effectively proprietary.  To prevent this, the GPL assures that
patents cannot be used to render the program non-free.

   The precise terms and conditions for copying, distribution and
modification follow.

TERMS AND CONDITIONS
====================

  0. Definitions.

     “This License” refers to version 3 of the GNU General Public
     License.

     “Copyright” also means copyright-like laws that apply to other
     kinds of works, such as semiconductor masks.

     “The Program” refers to any copyrightable work licensed under this
     License.  Each licensee is addressed as “you”.  “Licensees” and
     “recipients” may be individuals or organizations.

     To “modify” a work means to copy from or adapt all or part of the
     work in a fashion requiring copyright permission, other than the
     making of an exact copy.  The resulting work is called a “modified
     version” of the earlier work or a work “based on” the earlier work.

     A “covered work” means either the unmodified Program or a work
     based on the Program.

     To “propagate” a work means to do anything with it that, without
     permission, would make you directly or secondarily liable for
     infringement under applicable copyright law, except executing it on
     a computer or modifying a private copy.  Propagation includes
     copying, distribution (with or without modification), making
     available to the public, and in some countries other activities as
     well.

     To “convey” a work means any kind of propagation that enables other
     parties to make or receive copies.  Mere interaction with a user
     through a computer network, with no transfer of a copy, is not
     conveying.

     An interactive user interface displays “Appropriate Legal Notices”
     to the extent that it includes a convenient and prominently visible
     feature that (1) displays an appropriate copyright notice, and (2)
     tells the user that there is no warranty for the work (except to
     the extent that warranties are provided), that licensees may convey
     the work under this License, and how to view a copy of this
     License.  If the interface presents a list of user commands or
     options, such as a menu, a prominent item in the list meets this
     criterion.

  1. Source Code.

     The “source code” for a work means the preferred form of the work
     for making modifications to it.  “Object code” means any non-source
     form of a work.

     A “Standard Interface” means an interface that either is an
     official standard defined by a recognized standards body, or, in
     the case of interfaces specified for a particular programming
     language, one that is widely used among developers working in that
     language.

     The “System Libraries” of an executable work include anything,
     other than the work as a whole, that (a) is included in the normal
     form of packaging a Major Component, but which is not part of that
     Major Component, and (b) serves only to enable use of the work with
     that Major Component, or to implement a Standard Interface for
     which an implementation is available to the public in source code
     form.  A “Major Component”, in this context, means a major
     essential component (kernel, window system, and so on) of the
     specific operating system (if any) on which the executable work
     runs, or a compiler used to produce the work, or an object code
     interpreter used to run it.

     The “Corresponding Source” for a work in object code form means all
     the source code needed to generate, install, and (for an executable
     work) run the object code and to modify the work, including scripts
     to control those activities.  However, it does not include the
     work’s System Libraries, or general-purpose tools or generally
     available free programs which are used unmodified in performing
     those activities but which are not part of the work.  For example,
     Corresponding Source includes interface definition files associated
     with source files for the work, and the source code for shared
     libraries and dynamically linked subprograms that the work is
     specifically designed to require, such as by intimate data
     communication or control flow between those subprograms and other
     parts of the work.

     The Corresponding Source need not include anything that users can
     regenerate automatically from other parts of the Corresponding
     Source.

     The Corresponding Source for a work in source code form is that
     same work.

  2. Basic Permissions.

     All rights granted under this License are granted for the term of
     copyright on the Program, and are irrevocable provided the stated
     conditions are met.  This License explicitly affirms your unlimited
     permission to run the unmodified Program.  The output from running
     a covered work is covered by this License only if the output, given
     its content, constitutes a covered work.  This License acknowledges
     your rights of fair use or other equivalent, as provided by
     copyright law.

     You may make, run and propagate covered works that you do not
     convey, without conditions so long as your license otherwise
     remains in force.  You may convey covered works to others for the
     sole purpose of having them make modifications exclusively for you,
     or provide you with facilities for running those works, provided
     that you comply with the terms of this License in conveying all
     material for which you do not control copyright.  Those thus making
     or running the covered works for you must do so exclusively on your
     behalf, under your direction and control, on terms that prohibit
     them from making any copies of your copyrighted material outside
     their relationship with you.

     Conveying under any other circumstances is permitted solely under
     the conditions stated below.  Sublicensing is not allowed; section
     10 makes it unnecessary.

  3. Protecting Users’ Legal Rights From Anti-Circumvention Law.

     No covered work shall be deemed part of an effective technological
     measure under any applicable law fulfilling obligations under
     article 11 of the WIPO copyright treaty adopted on 20 December
     1996, or similar laws prohibiting or restricting circumvention of
     such measures.

     When you convey a covered work, you waive any legal power to forbid
     circumvention of technological measures to the extent such
     circumvention is effected by exercising rights under this License
     with respect to the covered work, and you disclaim any intention to
     limit operation or modification of the work as a means of
     enforcing, against the work’s users, your or third parties’ legal
     rights to forbid circumvention of technological measures.

  4. Conveying Verbatim Copies.

     You may convey verbatim copies of the Program’s source code as you
     receive it, in any medium, provided that you conspicuously and
     appropriately publish on each copy an appropriate copyright notice;
     keep intact all notices stating that this License and any
     non-permissive terms added in accord with section 7 apply to the
     code; keep intact all notices of the absence of any warranty; and
     give all recipients a copy of this License along with the Program.

     You may charge any price or no price for each copy that you convey,
     and you may offer support or warranty protection for a fee.

  5. Conveying Modified Source Versions.

     You may convey a work based on the Program, or the modifications to
     produce it from the Program, in the form of source code under the
     terms of section 4, provided that you also meet all of these
     conditions:

       a. The work must carry prominent notices stating that you
          modified it, and giving a relevant date.

       b. The work must carry prominent notices stating that it is
          released under this License and any conditions added under
          section 7.  This requirement modifies the requirement in
          section 4 to “keep intact all notices”.

       c. You must license the entire work, as a whole, under this
          License to anyone who comes into possession of a copy.  This
          License will therefore apply, along with any applicable
          section 7 additional terms, to the whole of the work, and all
          its parts, regardless of how they are packaged.  This License
          gives no permission to license the work in any other way, but
          it does not invalidate such permission if you have separately
          received it.

       d. If the work has interactive user interfaces, each must display
          Appropriate Legal Notices; however, if the Program has
          interactive interfaces that do not display Appropriate Legal
          Notices, your work need not make them do so.

     A compilation of a covered work with other separate and independent
     works, which are not by their nature extensions of the covered
     work, and which are not combined with it such as to form a larger
     program, in or on a volume of a storage or distribution medium, is
     called an “aggregate” if the compilation and its resulting
     copyright are not used to limit the access or legal rights of the
     compilation’s users beyond what the individual works permit.
     Inclusion of a covered work in an aggregate does not cause this
     License to apply to the other parts of the aggregate.

  6. Conveying Non-Source Forms.

     You may convey a covered work in object code form under the terms
     of sections 4 and 5, provided that you also convey the
     machine-readable Corresponding Source under the terms of this
     License, in one of these ways:

       a. Convey the object code in, or embodied in, a physical product
          (including a physical distribution medium), accompanied by the
          Corresponding Source fixed on a durable physical medium
          customarily used for software interchange.

       b. Convey the object code in, or embodied in, a physical product
          (including a physical distribution medium), accompanied by a
          written offer, valid for at least three years and valid for as
          long as you offer spare parts or customer support for that
          product model, to give anyone who possesses the object code
          either (1) a copy of the Corresponding Source for all the
          software in the product that is covered by this License, on a
          durable physical medium customarily used for software
          interchange, for a price no more than your reasonable cost of
          physically performing this conveying of source, or (2) access
          to copy the Corresponding Source from a network server at no
          charge.

       c. Convey individual copies of the object code with a copy of the
          written offer to provide the Corresponding Source.  This
          alternative is allowed only occasionally and noncommercially,
          and only if you received the object code with such an offer,
          in accord with subsection 6b.

       d. Convey the object code by offering access from a designated
          place (gratis or for a charge), and offer equivalent access to
          the Corresponding Source in the same way through the same
          place at no further charge.  You need not require recipients
          to copy the Corresponding Source along with the object code.
          If the place to copy the object code is a network server, the
          Corresponding Source may be on a different server (operated by
          you or a third party) that supports equivalent copying
          facilities, provided you maintain clear directions next to the
          object code saying where to find the Corresponding Source.
          Regardless of what server hosts the Corresponding Source, you
          remain obligated to ensure that it is available for as long as
          needed to satisfy these requirements.

       e. Convey the object code using peer-to-peer transmission,
          provided you inform other peers where the object code and
          Corresponding Source of the work are being offered to the
          general public at no charge under subsection 6d.

     A separable portion of the object code, whose source code is
     excluded from the Corresponding Source as a System Library, need
     not be included in conveying the object code work.

     A “User Product” is either (1) a “consumer product”, which means
     any tangible personal property which is normally used for personal,
     family, or household purposes, or (2) anything designed or sold for
     incorporation into a dwelling.  In determining whether a product is
     a consumer product, doubtful cases shall be resolved in favor of
     coverage.  For a particular product received by a particular user,
     “normally used” refers to a typical or common use of that class of
     product, regardless of the status of the particular user or of the
     way in which the particular user actually uses, or expects or is
     expected to use, the product.  A product is a consumer product
     regardless of whether the product has substantial commercial,
     industrial or non-consumer uses, unless such uses represent the
     only significant mode of use of the product.

     “Installation Information” for a User Product means any methods,
     procedures, authorization keys, or other information required to
     install and execute modified versions of a covered work in that
     User Product from a modified version of its Corresponding Source.
     The information must suffice to ensure that the continued
     functioning of the modified object code is in no case prevented or
     interfered with solely because modification has been made.

     If you convey an object code work under this section in, or with,
     or specifically for use in, a User Product, and the conveying
     occurs as part of a transaction in which the right of possession
     and use of the User Product is transferred to the recipient in
     perpetuity or for a fixed term (regardless of how the transaction
     is characterized), the Corresponding Source conveyed under this
     section must be accompanied by the Installation Information.  But
     this requirement does not apply if neither you nor any third party
     retains the ability to install modified object code on the User
     Product (for example, the work has been installed in ROM).

     The requirement to provide Installation Information does not
     include a requirement to continue to provide support service,
     warranty, or updates for a work that has been modified or installed
     by the recipient, or for the User Product in which it has been
     modified or installed.  Access to a network may be denied when the
     modification itself materially and adversely affects the operation
     of the network or violates the rules and protocols for
     communication across the network.

     Corresponding Source conveyed, and Installation Information
     provided, in accord with this section must be in a format that is
     publicly documented (and with an implementation available to the
     public in source code form), and must require no special password
     or key for unpacking, reading or copying.

  7. Additional Terms.

     “Additional permissions” are terms that supplement the terms of
     this License by making exceptions from one or more of its
     conditions.  Additional permissions that are applicable to the
     entire Program shall be treated as though they were included in
     this License, to the extent that they are valid under applicable
     law.  If additional permissions apply only to part of the Program,
     that part may be used separately under those permissions, but the
     entire Program remains governed by this License without regard to
     the additional permissions.

     When you convey a copy of a covered work, you may at your option
     remove any additional permissions from that copy, or from any part
     of it.  (Additional permissions may be written to require their own
     removal in certain cases when you modify the work.)  You may place
     additional permissions on material, added by you to a covered work,
     for which you have or can give appropriate copyright permission.

     Notwithstanding any other provision of this License, for material
     you add to a covered work, you may (if authorized by the copyright
     holders of that material) supplement the terms of this License with
     terms:

       a. Disclaiming warranty or limiting liability differently from
          the terms of sections 15 and 16 of this License; or

       b. Requiring preservation of specified reasonable legal notices
          or author attributions in that material or in the Appropriate
          Legal Notices displayed by works containing it; or

       c. Prohibiting misrepresentation of the origin of that material,
          or requiring that modified versions of such material be marked
          in reasonable ways as different from the original version; or

       d. Limiting the use for publicity purposes of names of licensors
          or authors of the material; or

       e. Declining to grant rights under trademark law for use of some
          trade names, trademarks, or service marks; or

       f. Requiring indemnification of licensors and authors of that
          material by anyone who conveys the material (or modified
          versions of it) with contractual assumptions of liability to
          the recipient, for any liability that these contractual
          assumptions directly impose on those licensors and authors.

     All other non-permissive additional terms are considered “further
     restrictions” within the meaning of section 10.  If the Program as
     you received it, or any part of it, contains a notice stating that
     it is governed by this License along with a term that is a further
     restriction, you may remove that term.  If a license document
     contains a further restriction but permits relicensing or conveying
     under this License, you may add to a covered work material governed
     by the terms of that license document, provided that the further
     restriction does not survive such relicensing or conveying.

     If you add terms to a covered work in accord with this section, you
     must place, in the relevant source files, a statement of the
     additional terms that apply to those files, or a notice indicating
     where to find the applicable terms.

     Additional terms, permissive or non-permissive, may be stated in
     the form of a separately written license, or stated as exceptions;
     the above requirements apply either way.

  8. Termination.

     You may not propagate or modify a covered work except as expressly
     provided under this License.  Any attempt otherwise to propagate or
     modify it is void, and will automatically terminate your rights
     under this License (including any patent licenses granted under the
     third paragraph of section 11).

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly and
     finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from you
     under this License.  If your rights have been terminated and not
     permanently reinstated, you do not qualify to receive new licenses
     for the same material under section 10.

  9. Acceptance Not Required for Having Copies.

     You are not required to accept this License in order to receive or
     run a copy of the Program.  Ancillary propagation of a covered work
     occurring solely as a consequence of using peer-to-peer
     transmission to receive a copy likewise does not require
     acceptance.  However, nothing other than this License grants you
     permission to propagate or modify any covered work.  These actions
     infringe copyright if you do not accept this License.  Therefore,
     by modifying or propagating a covered work, you indicate your
     acceptance of this License to do so.

  10. Automatic Licensing of Downstream Recipients.

     Each time you convey a covered work, the recipient automatically
     receives a license from the original licensors, to run, modify and
     propagate that work, subject to this License.  You are not
     responsible for enforcing compliance by third parties with this
     License.

     An “entity transaction” is a transaction transferring control of an
     organization, or substantially all assets of one, or subdividing an
     organization, or merging organizations.  If propagation of a
     covered work results from an entity transaction, each party to that
     transaction who receives a copy of the work also receives whatever
     licenses to the work the party’s predecessor in interest had or
     could give under the previous paragraph, plus a right to possession
     of the Corresponding Source of the work from the predecessor in
     interest, if the predecessor has it or can get it with reasonable
     efforts.

     You may not impose any further restrictions on the exercise of the
     rights granted or affirmed under this License.  For example, you
     may not impose a license fee, royalty, or other charge for exercise
     of rights granted under this License, and you may not initiate
     litigation (including a cross-claim or counterclaim in a lawsuit)
     alleging that any patent claim is infringed by making, using,
     selling, offering for sale, or importing the Program or any portion
     of it.

  11. Patents.

     A “contributor” is a copyright holder who authorizes use under this
     License of the Program or a work on which the Program is based.
     The work thus licensed is called the contributor’s “contributor
     version”.

     A contributor’s “essential patent claims” are all patent claims
     owned or controlled by the contributor, whether already acquired or
     hereafter acquired, that would be infringed by some manner,
     permitted by this License, of making, using, or selling its
     contributor version, but do not include claims that would be
     infringed only as a consequence of further modification of the
     contributor version.  For purposes of this definition, “control”
     includes the right to grant patent sublicenses in a manner
     consistent with the requirements of this License.

     Each contributor grants you a non-exclusive, worldwide,
     royalty-free patent license under the contributor’s essential
     patent claims, to make, use, sell, offer for sale, import and
     otherwise run, modify and propagate the contents of its contributor
     version.

     In the following three paragraphs, a “patent license” is any
     express agreement or commitment, however denominated, not to
     enforce a patent (such as an express permission to practice a
     patent or covenant not to sue for patent infringement).  To “grant”
     such a patent license to a party means to make such an agreement or
     commitment not to enforce a patent against the party.

     If you convey a covered work, knowingly relying on a patent
     license, and the Corresponding Source of the work is not available
     for anyone to copy, free of charge and under the terms of this
     License, through a publicly available network server or other
     readily accessible means, then you must either (1) cause the
     Corresponding Source to be so available, or (2) arrange to deprive
     yourself of the benefit of the patent license for this particular
     work, or (3) arrange, in a manner consistent with the requirements
     of this License, to extend the patent license to downstream
     recipients.  “Knowingly relying” means you have actual knowledge
     that, but for the patent license, your conveying the covered work
     in a country, or your recipient’s use of the covered work in a
     country, would infringe one or more identifiable patents in that
     country that you have reason to believe are valid.

     If, pursuant to or in connection with a single transaction or
     arrangement, you convey, or propagate by procuring conveyance of, a
     covered work, and grant a patent license to some of the parties
     receiving the covered work authorizing them to use, propagate,
     modify or convey a specific copy of the covered work, then the
     patent license you grant is automatically extended to all
     recipients of the covered work and works based on it.

     A patent license is “discriminatory” if it does not include within
     the scope of its coverage, prohibits the exercise of, or is
     conditioned on the non-exercise of one or more of the rights that
     are specifically granted under this License.  You may not convey a
     covered work if you are a party to an arrangement with a third
     party that is in the business of distributing software, under which
     you make payment to the third party based on the extent of your
     activity of conveying the work, and under which the third party
     grants, to any of the parties who would receive the covered work
     from you, a discriminatory patent license (a) in connection with
     copies of the covered work conveyed by you (or copies made from
     those copies), or (b) primarily for and in connection with specific
     products or compilations that contain the covered work, unless you
     entered into that arrangement, or that patent license was granted,
     prior to 28 March 2007.

     Nothing in this License shall be construed as excluding or limiting
     any implied license or other defenses to infringement that may
     otherwise be available to you under applicable patent law.

  12. No Surrender of Others’ Freedom.

     If conditions are imposed on you (whether by court order, agreement
     or otherwise) that contradict the conditions of this License, they
     do not excuse you from the conditions of this License.  If you
     cannot convey a covered work so as to satisfy simultaneously your
     obligations under this License and any other pertinent obligations,
     then as a consequence you may not convey it at all.  For example,
     if you agree to terms that obligate you to collect a royalty for
     further conveying from those to whom you convey the Program, the
     only way you could satisfy both those terms and this License would
     be to refrain entirely from conveying the Program.

  13. Use with the GNU Affero General Public License.

     Notwithstanding any other provision of this License, you have
     permission to link or combine any covered work with a work licensed
     under version 3 of the GNU Affero General Public License into a
     single combined work, and to convey the resulting work.  The terms
     of this License will continue to apply to the part which is the
     covered work, but the special requirements of the GNU Affero
     General Public License, section 13, concerning interaction through
     a network will apply to the combination as such.

  14. Revised Versions of this License.

     The Free Software Foundation may publish revised and/or new
     versions of the GNU General Public License from time to time.  Such
     new versions will be similar in spirit to the present version, but
     may differ in detail to address new problems or concerns.

     Each version is given a distinguishing version number.  If the
     Program specifies that a certain numbered version of the GNU
     General Public License “or any later version” applies to it, you
     have the option of following the terms and conditions either of
     that numbered version or of any later version published by the Free
     Software Foundation.  If the Program does not specify a version
     number of the GNU General Public License, you may choose any
     version ever published by the Free Software Foundation.

     If the Program specifies that a proxy can decide which future
     versions of the GNU General Public License can be used, that
     proxy’s public statement of acceptance of a version permanently
     authorizes you to choose that version for the Program.

     Later license versions may give you additional or different
     permissions.  However, no additional obligations are imposed on any
     author or copyright holder as a result of your choosing to follow a
     later version.

  15. Disclaimer of Warranty.

     THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
     APPLICABLE LAW. EXCEPT WHEN OTHERWISE STATED IN WRITING THE
     COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM “AS IS”
     WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED,
     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE ENTIRE
     RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.
     SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
     NECESSARY SERVICING, REPAIR OR CORRECTION.

  16. Limitation of Liability.

     IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES
     AND/OR CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR
     DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
     CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE
     THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA
     BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
     PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
     PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF
     THE POSSIBILITY OF SUCH DAMAGES.

  17. Interpretation of Sections 15 and 16.

     If the disclaimer of warranty and limitation of liability provided
     above cannot be given local legal effect according to their terms,
     reviewing courts shall apply local law that most closely
     approximates an absolute waiver of all civil liability in
     connection with the Program, unless a warranty or assumption of
     liability accompanies a copy of the Program in return for a fee.

END OF TERMS AND CONDITIONS
===========================

How to Apply These Terms to Your New Programs
=============================================

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

   To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least the
“copyright” line and a pointer to where the full notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND A BRIEF IDEA OF WHAT IT DOES.
     Copyright (C) YEAR NAME OF AUTHOR

     This program is free software: you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation, either version 3 of the License, or (at
     your option) any later version.

     This program is distributed in the hope that it will be useful, but
     WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
     General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program.  If not, see <http://www.gnu.org/licenses/>.

   Also add information on how to contact you by electronic and paper
mail.

   If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

     PROGRAM Copyright (C) YEAR NAME OF AUTHOR
     This program comes with ABSOLUTELY NO WARRANTY; for details type ‘show w’.
     This is free software, and you are welcome to redistribute it
     under certain conditions; type ‘show c’ for details.

   The hypothetical commands ‘show w’ and ‘show c’ should show the
appropriate parts of the General Public License.  Of course, your
program’s commands might be different; for a GUI interface, you would
use an “about box”.

   You should also get your employer (if you work as a programmer) or
school, if any, to sign a “copyright disclaimer” for the program, if
necessary.  For more information on this, and how to apply and follow
the GNU GPL, see <http://www.gnu.org/licenses/>.

   The GNU General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use the
GNU Lesser General Public License instead of this License.  But first,
please read <http://www.gnu.org/philosophy/why-not-lgpl.html>.

