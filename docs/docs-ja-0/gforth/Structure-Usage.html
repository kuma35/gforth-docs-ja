<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- このマニュアルは、 標準 Forth 言語の高速で移植可能な実装である Gforth (バージョン 0.7.9_20240418,
April 18, 2024)用です。 これはリファレンス・マニュアルとして機能しますが、 Forth の概要と Forth
チュートリアルも含まれています。

Authors: Bernd Paysan, Anton Ertl, Gerald Wodni Copyright (C) 1995,
1996, 1997, 1998, 2000, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
2011, 2012, 2013, 2014,2015,2016,2017,2018,2019,2020,2021,2022,2023 Free
Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant
Sections, with the Front-Cover texts being "A GNU Manual," and with the
Back-Cover Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have freedom to copy and modify this
GNU Manual, like GNU software.  Copies published by the Free Software
Foundation raise funds for GNU development." -->
<title>Structure Usage (Gforth マニュアル)</title>

<meta name="description" content="Structure Usage (Gforth マニュアル)">
<meta name="keywords" content="Structure Usage (Gforth マニュアル)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Word-Index.html" rel="index" title="Word Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Structures.html" rel="up" title="Structures">
<link href="Structure-Naming-Convention.html" rel="next" title="Structure Naming Convention">
<link href="Why-explicit-structure-support_003f.html" rel="prev" title="Why explicit structure support?">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="gforth.css">


</head>

<body lang="en">
<div class="subsection" id="Structure-Usage">
<div class="header">
<p>
Next: <a href="Structure-Naming-Convention.html" accesskey="n" rel="next">Structure Naming Convention</a>, Previous: <a href="Why-explicit-structure-support_003f.html" accesskey="p" rel="prev">Why explicit structure support?</a>, Up: <a href="Structures.html" accesskey="u" rel="up">Structures</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Word-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Structure-Usage-1"></span><h4 class="subsection">6.23.2 Structure Usage</h4>
<span id="index-structure-usage"></span>

<span id="index-field-usage"></span>
<span id="index-struct-usage"></span>
<span id="index-end_002dstruct-usage"></span>
<p>You can define a structure for a (data-less) linked list with:
</p><div class="example">
<pre class="example">struct
    cell% field list-next
end-struct list%
</pre></div>

<p>With the address of the list node on the stack, you can compute the address
of the field that contains the address of the next node with
<code>list-next</code>. E.g., you can determine the length of a list with:
</p>
<div class="example">
<pre class="example">: list-length ( list -- n )
\ &quot;list&quot; is a pointer to the first element of a linked list
\ &quot;n&quot; is the length of the list
    0 BEGIN ( list1 n1 )
        over
    WHILE ( list1 n1 )
        1+ swap list-next @ swap
    REPEAT
    nip ;
</pre></div>

<p>You can reserve memory for a list node in the dictionary with <code>list%
%allot</code>, which leaves the address of the list node on the stack. For the
equivalent allocation on the heap you can use <code>list% %alloc</code> (or, for
an <code>allocate</code>-like stack effect (i.e., with ior), use <code>list%
%allocate</code>). You can get the the size of a list node with <code>list% %size</code>
and its alignment with <code>list% %alignment</code>.
</p>
<p>Note that in Standard Forth the body of a <code>create</code>d word is
<code>aligned</code> but not necessarily <code>faligned</code>; therefore, if you do a:
</p>
<div class="example">
<pre class="example">create <em>name</em> foo% %allot drop
</pre></div>

<p>then the memory alloted for <code>foo%</code> is guaranteed to start at the body
of <code><em>name</em></code> only if <code>foo%</code> contains only character, cell and
double fields.  Therefore, if your structure contains floats, better use
</p>
<div class="example">
<pre class="example">foo% %allot constant <em>name</em>
</pre></div>

<span id="index-structures-containing-structures"></span>
<p>You can include a structure <code>foo%</code> as a field of another structure,
like this:
</p><div class="example">
<pre class="example">struct
...
    foo% field ...
...
end-struct ...
</pre></div>

<span id="index-structure-extension"></span>
<span id="index-extended-records"></span>
<p>Instead of starting with an empty structure, you can extend an existing
structure. E.g., a plain linked list without data, as defined above, is
hardly useful; You can extend it to a linked list of integers, like
this:<a id="DOCF31" href="#FOOT31"><sup>31</sup></a>
</p>
<div class="example">
<pre class="example">list%
    cell% field intlist-int
end-struct intlist%
</pre></div>

<p><code>intlist%</code> is a structure with two fields: <code>list-next</code> and
<code>intlist-int</code>.
</p>
<span id="index-structures-containing-arrays"></span>
<p>You can specify an array type containing <em>n</em> elements of type
<code>foo%</code> like this:
</p>
<div class="example">
<pre class="example">foo% <em>n</em> *
</pre></div>

<p>You can use this array type in any place where you can use a normal type,
e.g., when defining a <code>field</code>, or with <code>%allot</code>.
</p>
<span id="index-first-field-optimization"></span>
<p>The first field is at the base address of a structure and the word for this
field (e.g., <code>list-next</code>) actually does not change the address on the
stack. You may be tempted to leave it away in the interest of run-time and
space efficiency. This is not necessary, because the structure package
optimizes this case: If you compile a first-field words, no code is
generated. So, in the interest of readability and maintainability you should
include the word for the field when accessing the field.
</p>

</div>
<div class="footnote">
<hr>
<h4 class="footnotes-heading">Footnotes</h4>

<h5><a id="FOOT31" href="#DOCF31">(31)</a></h5>
<p>This feature is also known as <em>extended records</em>. It is
the main innovation in the Oberon language; in other words, adding this
feature to Modula-2 led Wirth to create a new language, write a new compiler
etc.  Adding this feature to Forth just required a few lines of code.</p>
</div>
<hr>
<div class="header">
<p>
Next: <a href="Structure-Naming-Convention.html">Structure Naming Convention</a>, Previous: <a href="Why-explicit-structure-support_003f.html">Why explicit structure support?</a>, Up: <a href="Structures.html">Structures</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Word-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
