<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- このマニュアルは、 標準 Forth 言語の高速で移植可能な実装である Gforth (バージョン 0.7.9_20240418,
April 18, 2024)用です。 これはリファレンス・マニュアルとして機能しますが、 Forth の概要と Forth
チュートリアルも含まれています。

Authors: Bernd Paysan, Anton Ertl, Gerald Wodni Copyright (C) 1995,
1996, 1997, 1998, 2000, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
2011, 2012, 2013, 2014,2015,2016,2017,2018,2019,2020,2021,2022,2023 Free
Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant
Sections, with the Front-Cover texts being "A GNU Manual," and with the
Back-Cover Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have freedom to copy and modify this
GNU Manual, like GNU software.  Copies published by the Free Software
Foundation raise funds for GNU development." -->
<title>Special Memory Accesses (Gforth マニュアル)</title>

<meta name="description" content="Special Memory Accesses (Gforth マニュアル)">
<meta name="keywords" content="Special Memory Accesses (Gforth マニュアル)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Word-Index.html" rel="index" title="Word Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Memory.html" rel="up" title="Memory">
<link href="Address-arithmetic.html" rel="next" title="Address arithmetic">
<link href="Memory-Access.html" rel="prev" title="Memory Access">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="gforth.css">


</head>

<body lang="en">
<div class="subsection" id="Special-Memory-Accesses">
<div class="header">
<p>
Next: <a href="Address-arithmetic.html" accesskey="n" rel="next">Address arithmetic</a>, Previous: <a href="Memory-Access.html" accesskey="p" rel="prev">Memory Access</a>, Up: <a href="Memory.html" accesskey="u" rel="up">Memory</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Word-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Special-Memory-Accesses-1"></span><h4 class="subsection">6.7.5 Special Memory Accesses</h4>
<span id="index-byte-order"></span>
<span id="index-big_002dendian"></span>
<span id="index-little_002dendian"></span>
<span id="index-sign-extension"></span>
<span id="index-unaligned-memory-access"></span>

<p>This section is about memory accesses useful for communicating with other
software or other computers.  This means that the accesses are of a certain
bit width (independent of Gforth&rsquo;s cell width), are possibly not naturally
aligned and typically have a certain byte order that may be different from
the native byte order of the system that Gforth runs on.
</p>
<p>We use the following prefixes:
</p>
<dl compact="compact">
<dt><span><code>c</code></span></dt>
<dd><p>8 bits (character)
</p></dd>
<dt><span><code>w</code></span></dt>
<dd><p>16 bits
</p></dd>
<dt><span><code>l</code></span></dt>
<dd><p>32 bits
</p></dd>
<dt><span><code>x</code></span></dt>
<dd><p>64 bits represented as one cell
</p></dd>
<dt><span><code>xd</code></span></dt>
<dd><p>64 bits represented as two cells
</p></dd>
</dl>

<p>The <code>x</code>-prefix words do not work properly on 32-bit systems, so for
code that is intended to be portable to 32-bit systems you should use
<code>xd</code>-prefix words.  Note that <code>xd</code>-prefix words work on 64-bit
systems: there the upper cell is just 0 (for unsigned values)  or a sign
extension of the lower cell.
</p>
<p>The memory-access words below all work with arbitrarily (un)aligned
addresses (unlike <code>@</code>, <code>!</code>, <code>f@</code>, <code>f!</code>, which require
alignment on some hardware).
</p>
<span id="index-w_0040-_0028--c_002daddr-_002d_002d-u--_0029-gforth_002d0_002e5"></span>
<span id="index-w_0040"></span>
<span id="index-w_0040-1"></span>
<div class="format">
<pre class="format"><code>w@</code> ( <i>c-addr &ndash; u </i>) gforth-0.5 &ldquo;w-fetch&rdquo;
</pre></div>
<p><i>u</i> is the zero-extended 16-bit value stored at <i>c_addr</i>.
</p>
<span id="index-w_0021-_0028--w-c_002daddr-_002d_002d--_0029-gforth_002d0_002e7"></span>
<span id="index-w_0021"></span>
<span id="index-w_0021-1"></span>
<div class="format">
<pre class="format"><code>w!</code> ( <i>w c-addr &ndash; </i>) gforth-0.7 &ldquo;w-store&rdquo;
</pre></div>
<p>Store the bottom 16 bits of <i>w</i> at <i>c_addr</i>.
</p>
<span id="index-l_0040-_0028--c_002daddr-_002d_002d-u--_0029-gforth_002d0_002e7"></span>
<span id="index-l_0040"></span>
<span id="index-l_0040-1"></span>
<div class="format">
<pre class="format"><code>l@</code> ( <i>c-addr &ndash; u </i>) gforth-0.7 &ldquo;l-fetch&rdquo;
</pre></div>
<p><i>u</i> is the zero-extended 32-bit value stored at <i>c_addr</i>.
</p>
<span id="index-l_0021-_0028--w-c_002daddr-_002d_002d--_0029-gforth_002d0_002e7"></span>
<span id="index-l_0021"></span>
<span id="index-l_0021-1"></span>
<div class="format">
<pre class="format"><code>l!</code> ( <i>w c-addr &ndash; </i>) gforth-0.7 &ldquo;l-store&rdquo;
</pre></div>
<p>Store the bottom 32 bits of <i>w</i> at <i>c_addr</i>.
</p>
<span id="index-x_0040-_0028--c_002daddr-_002d_002d-u--_0029-gforth_002d1_002e0"></span>
<span id="index-x_0040"></span>
<span id="index-x_0040-1"></span>
<div class="format">
<pre class="format"><code>x@</code> ( <i>c-addr &ndash; u </i>) gforth-1.0 &ldquo;x-fetch&rdquo;
</pre></div>
<p><i>u</i> is the zero-extended 64-bit value stored at <i>c_addr</i>.
</p>
<span id="index-x_0021-_0028--w-c_002daddr-_002d_002d--_0029-gforth_002d1_002e0"></span>
<span id="index-x_0021"></span>
<span id="index-x_0021-1"></span>
<div class="format">
<pre class="format"><code>x!</code> ( <i>w c-addr &ndash; </i>) gforth-1.0 &ldquo;x-store&rdquo;
</pre></div>
<p>Store the bottom 64 bits of <i>w</i> at <i>c_addr</i>.
</p>
<span id="index-xd_0040-_0028--c_002daddr-_002d_002d-ud--_0029-gforth_002d1_002e0"></span>
<span id="index-xd_0040"></span>
<span id="index-xd_0040-1"></span>
<div class="format">
<pre class="format"><code>xd@</code> ( <i>c-addr &ndash; ud </i>) gforth-1.0 &ldquo;x-d-fetch&rdquo;
</pre></div>
<p><i>ud</i> is the zero-extended 64-bit value stored at <i>c_addr</i>.
</p>
<span id="index-xd_0021-_0028--ud-c_002daddr-_002d_002d--_0029-gforth_002d1_002e0"></span>
<span id="index-xd_0021"></span>
<span id="index-xd_0021-1"></span>
<div class="format">
<pre class="format"><code>xd!</code> ( <i>ud c-addr &ndash; </i>) gforth-1.0 &ldquo;x-d-store&rdquo;
</pre></div>
<p>Store the bottom 64 bits of <i>ud</i> at <i>c_addr</i>.
</p>

<p>For accesses with a specific byte order, you have to perform byte-order
adjustment immediately after a fetch (before the sign-extension), or
immediately before the store.  The results of these byte-order adjustment
words are always zero-extended.
</p>
<span id="index-wbe-_0028--u1-_002d_002d-u2--_0029-gforth_002d1_002e0"></span>
<span id="index-wbe"></span>
<span id="index-wbe-1"></span>
<div class="format">
<pre class="format"><code>wbe</code> ( <i>u1 &ndash; u2  </i>) gforth-1.0 &ldquo;wbe&rdquo;
</pre></div>
<p>Convert 16-bit value in <i>u1</i> from native byte order to big-endian or from
big-endian to native byte order (the same operation)
</p>

<span id="index-wle-_0028--u1-_002d_002d-u2--_0029-gforth_002d1_002e0"></span>
<span id="index-wle"></span>
<span id="index-wle-1"></span>
<div class="format">
<pre class="format"><code>wle</code> ( <i>u1 &ndash; u2  </i>) gforth-1.0 &ldquo;wle&rdquo;
</pre></div>
<p>Convert 16-bit value in <i>u1</i> from native byte order to little-endian or
from little-endian to native byte order (the same operation)
</p>

<span id="index-lbe-_0028--u1-_002d_002d-u2--_0029-gforth_002d1_002e0"></span>
<span id="index-lbe"></span>
<span id="index-lbe-1"></span>
<div class="format">
<pre class="format"><code>lbe</code> ( <i>u1 &ndash; u2  </i>) gforth-1.0 &ldquo;lbe&rdquo;
</pre></div>
<p>Convert 32-bit value in <i>u1</i> from native byte order to big-endian or from
big-endian to native byte order (the same operation)
</p>

<span id="index-lle-_0028--u1-_002d_002d-u2--_0029-gforth_002d1_002e0"></span>
<span id="index-lle"></span>
<span id="index-lle-1"></span>
<div class="format">
<pre class="format"><code>lle</code> ( <i>u1 &ndash; u2  </i>) gforth-1.0 &ldquo;lle&rdquo;
</pre></div>
<p>Convert 32-bit value in <i>u1</i> from native byte order to little-endian or
from little-endian to native byte order (the same operation)
</p>

<span id="index-xbe-_0028--u1-_002d_002d-u2--_0029-gforth_002d1_002e0"></span>
<span id="index-xbe"></span>
<span id="index-xbe-1"></span>
<div class="format">
<pre class="format"><code>xbe</code> ( <i>u1 &ndash; u2  </i>) gforth-1.0 &ldquo;xbe&rdquo;
</pre></div>
<p>Convert 64-bit value in <i>u1</i> from native byte order to big-endian or from
big-endian to native byte order (the same operation)
</p>

<span id="index-xle-_0028--u1-_002d_002d-u2--_0029-gforth_002d1_002e0"></span>
<span id="index-xle"></span>
<span id="index-xle-1"></span>
<div class="format">
<pre class="format"><code>xle</code> ( <i>u1 &ndash; u2  </i>) gforth-1.0 &ldquo;xle&rdquo;
</pre></div>
<p>Convert 64-bit value in <i>u1</i> from native byte order to little-endian or
from little-endian to native byte order (the same operation)
</p>

<span id="index-xdbe-_0028--ud1-_002d_002d-ud2--_0029-gforth_002d1_002e0"></span>
<span id="index-xdbe"></span>
<span id="index-xdbe-1"></span>
<div class="format">
<pre class="format"><code>xdbe</code> ( <i>ud1 &ndash; ud2  </i>) gforth-1.0 &ldquo;xdbe&rdquo;
</pre></div>
<p>Convert 64-bit value in <i>ud1</i> from native byte order to big-endian or from
big-endian to native byte order (the same operation)
</p>

<span id="index-xdle-_0028--ud1-_002d_002d-ud2--_0029-gforth_002d1_002e0"></span>
<span id="index-xdle"></span>
<span id="index-xdle-1"></span>
<div class="format">
<pre class="format"><code>xdle</code> ( <i>ud1 &ndash; ud2  </i>) gforth-1.0 &ldquo;xdle&rdquo;
</pre></div>
<p>Convert 64-bit value in <i>ud1</i> from native byte order to little-endian or
from little-endian to native byte order (the same operation)
</p>


<p>For signed fetches with a specific byte order, you have to perform a
sign-extension word after an unsigned fetch and a byte-order correction:
</p>
<span id="index-c_003es-_0028--x-_002d_002d-n--_0029-gforth_002d1_002e0"></span>
<span id="index-c_003es"></span>
<span id="index-c_003es-1"></span>
<div class="format">
<pre class="format"><code>c&gt;s</code> ( <i>x &ndash; n </i>) gforth-1.0 &ldquo;c-to-s&rdquo;
</pre></div>
<p>Sign-extend the 8-bit value in <i>x</i> to cell <i>n</i>.
</p>
<span id="index-w_003es-_0028--x-_002d_002d-n--_0029-gforth_002d1_002e0"></span>
<span id="index-w_003es"></span>
<span id="index-w_003es-1"></span>
<div class="format">
<pre class="format"><code>w&gt;s</code> ( <i>x &ndash; n </i>) gforth-1.0 &ldquo;w-to-s&rdquo;
</pre></div>
<p>Sign-extend the 16-bit value in <i>x</i> to cell <i>n</i>.
</p>
<span id="index-l_003es-_0028--x-_002d_002d-n--_0029-gforth_002d1_002e0"></span>
<span id="index-l_003es"></span>
<span id="index-l_003es-1"></span>
<div class="format">
<pre class="format"><code>l&gt;s</code> ( <i>x &ndash; n </i>) gforth-1.0 &ldquo;l-to-s&rdquo;
</pre></div>
<p>Sign-extend the 32-bit value in <i>x</i> to cell <i>n</i>.
</p>
<span id="index-x_003es-_0028--x-_002d_002d-n--_0029-gforth_002d1_002e0"></span>
<span id="index-x_003es"></span>
<span id="index-x_003es-1"></span>
<div class="format">
<pre class="format"><code>x&gt;s</code> ( <i>x &ndash; n  </i>) gforth-1.0 &ldquo;x&gt;s&rdquo;
</pre></div>
<p>Sign-extend the 64-bit value in <i>x</i> to cell <i>n</i>.
</p>

<span id="index-xd_003es-_0028--xd-_002d_002d-d--_0029-gforth_002d1_002e0"></span>
<span id="index-xd_003es"></span>
<span id="index-xd_003es-1"></span>
<div class="format">
<pre class="format"><code>xd&gt;s</code> ( <i>xd &ndash; d  </i>) gforth-1.0 &ldquo;xd&gt;s&rdquo;
</pre></div>
<p>Sign-extend the 64-bit value in <var>xd</var> to double-ceel <var>d</var>.
</p>


<p>Overall, this leads to sequences like
</p>
<div class="example">
<pre class="example">w@ wbe w&gt;s   \ 16-bit unaligned signed big-endian fetch
&gt;r lle r&gt; l! \ 32-bit unaligned little-endian store
</pre></div>

</div>
<hr>
<div class="header">
<p>
Next: <a href="Address-arithmetic.html">Address arithmetic</a>, Previous: <a href="Memory-Access.html">Memory Access</a>, Up: <a href="Memory.html">Memory</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Word-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
