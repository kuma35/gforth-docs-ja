This is gforth.info, produced by makeinfo version 6.8 from gforth.texi.

このマニュアルは、 標準 Forth 言語の高速で移植可能な実装である Gforth (バ
ージョン 0.7.9_20240418, April 18, 2024)用です。 これはリファレンス・マ
ニュアルとして機能しますが、 Forth の概要と Forth チュートリアルも含まれ
ています。

   Authors: Bernd Paysan, Anton Ertl, Gerald Wodni Copyright © 1995,
1996, 1997, 1998, 2000, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
2011, 2012, 2013, 2014,2015,2016,2017,2018,2019,2020,2021,2022,2023 Free
Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover texts
     being “A GNU Manual,” and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by the
     Free Software Foundation raise funds for GNU development.”
INFO-DIR-SECTION Software development
START-INFO-DIR-ENTRY
* Gforth: (gforth).          forth言語のための高速インタプリタ
END-INFO-DIR-ENTRY


File: gforth.info,  Node: $tring words,  Next: Counted string words,  Prev: String words,  Up: Strings and Characters

6.8.5 $tring words
------------------

以下の文字列ライブラリは、 文字列を通常のセル・サイズの変数(文字列ハンド
ル;string handle)に格納します。 これらのハンドルには、 ヒープに割り当て
られたセル・カウント文字列(cell-counted string;カウンタがセルサイズであ
るカウンタ付き文字列)へのポインタが含まれています。 この文字列ライブラリ
は bigFORTH 由来です。

   内容への恒久的な参照は 1 つだけ(ハンドル内の参照)しかないため、 未解
決の参照を恐れることなく文字列を再配置または削除できます。 これには、 プ
ログラマが、 例えば ‘$@’ 等によって生成された参照を一時的な目的でのみ使
用する必要があります。 つまり、 これらの一時的な参照は、 戻り値として渡
されたり、 グローバル・メモリに格納されたりすることはなく、 ハンドルを変
更する可能性のあるワードは、 これらの一時的な参照が存在する間は呼び出さ
れません。

   このライブラリを補完するものとしてセルペア表現(cell-pair
representation)があります。 文字列変数に対して $tring ワードを使用します
が、 これは c-addr u 表現では面倒です。 セルペア表現は、 文字列を変更し
ないで処理(検査など)するために使用します。

‘$!’ ( addr1 u $addr –  ) gforth-0.7 “string-store”
   新しく割り当てられた文字列バッファをアドレス($addr)が指す先に格納し、
必要に応じて以前のバッファを解放します。

‘$@’ ( $addr – addr2 u  ) gforth-0.7 “string-fetch”
   格納された文字列のアドレスと長さを返します。

‘$@len’ ( $addr – u  ) gforth-0.7 “string-fetch-len”
   格納されている文字列の長さを返します。

‘$!len’ ( u $addr –  ) gforth-0.7 “string-store-len”
   格納されている文字列(string)領域の長さを変更します(足し算ではない。 長
さを直にいじる) それゆえ、メモリ領域を変更し、 アドレスとカウンタ・セル
も調整(adjust)する必要があります(訳注: 元の長さより長くした場合、 領域を
拡張するだけで初期化はしない。 そこにはゴミが入っているので自分で初期化
する必要がある)

‘$+!len’ ( u $addr – addr  ) gforth-1.0 “string-plus-store-len”
   $addr によって参照されるメモリ領域の最後に u バイト用の空間を確保しま
す(追加。確保するだけで初期化はしない。 $addr の「長さ」に追加もする)。
addr は、 確保した空間の最初のアドレスです。

‘$del’ ( addr off u –  ) gforth-0.7 “string-del”
   文字列のオフセット位置 OFF から U バイト削除します。

‘$ins’ ( addr1 u $addr off –  ) gforth-0.7 “string-ins”
   オフセット位置 OFF に文字列を挿入します。

‘$+!’ ( addr1 u $addr –  ) gforth-0.7 “string-plus-store”
   文字列(addr1 u)を別の文字列($addr)に追加します。

‘c$+!’ ( char $addr –  ) gforth-1.0 “c-string-plus-store”
   文字列に文字を追加します。

‘$free’ ( $addr –  ) gforth-1.0 “string-free”
   $addr が指す文字列を解放し、 $addr のポインタを 0 にします( $ すると
0 0 を返す)

‘$init’ ( $addr –  ) gforth-1.0 “string-init”
   以前に何があったかに関係なく、そこに空の文字列を保存します(訳注: ポイ
ンタを 0 にする訳ではなくて、 ポインタの指す先に長さゼロの文字列がある)

‘$split’ ( addr u char – addr1 u1 addr2 u2  ) gforth-0.7 “string-split”
   文字列中で最初に現れる char を区切り文字として文字列を 2 つに分割しま
す(例: HTML クエリの引数の ’?’)(訳注: 区切り文字 char 自体は分割後の文字
列に含まれない)

‘$iter’ ( .. $addr char xt – ..  ) gforth-0.7 “string-iter”
   区切り文字 char で切り出した部分文字列(addr u)ごとに xt を呼び出しま
す。 xt は (addr u – ) でなければなりません。 これにより、 例えば ’&’ で
区切られた引数を簡単に分解できます(訳注: : my-type ( addr u – ) ."  ["
type ."  ]"  ; variable title s" GNU gforth manual" title $!  title
$ my-type [GNU gforth manual] title bl ’ my-type $iter
[GNU][gforth][manual] ok)。

‘$over’ ( addr u $addr off –  ) gforth-1.0 “string-over”
   $addr の文字列のオフセット位置 off から文字列(addr u)で上書きします。

‘$exec’ ( xt addr –  ) gforth-1.0 “string-exec”
   実行トークン xt を実行し、 その標準出力(TYPE や EMIT やそれらを使用す
るすべてのもの)を addr が指す文字列の末尾に「追加」します。

‘$tmp’ ( xt – addr u  ) gforth-1.0 “string-t-m-p”
   ワードの出力から一時的な文字列を生成します

‘$.’ ( addr –  ) gforth-1.0 “string-dot”
   文字列を出力する、 ショートカット( $ TYPE → $.  )

‘$slurp’ ( fid addr –  ) gforth-1.0 “string-slurp”
   (slurp;音を立ててすする)ファイル fid を最後まで読み取り(ファイルのク
ローズは行いません)、 読み取ったデータを addr の指す文字列に入れます。

‘$slurp-file’ ( c-addr u addr –  ) gforth-1.0 “string-slurp-file”
   c-addr u という名前のファイル内のすべてのデータを addr の文字列に入力
します。

‘$+slurp’ ( fid addr –  ) gforth-1.0 “string-plus-slurp”
   ファイル fid を最後まで読み取り(但しクローズはしません)、 読み取った
データを addr の文字列に「追加」します。

‘$+slurp-file’ ( c-addr u addr –  ) gforth-1.0 “string-plus+slurp-file”
   c-addr u という名前のファイル内のすべてのデータを addr の文字列に「追
加」します。

‘$[]’ ( u $[]addr – addr’  ) gforth-1.0 “string-array”
   addr’ は、 文字列配列 $[]addr の u 番目の要素のアドレスです。 配列の
サイズは必要に応じて変更されます。

‘$[]!’ ( c-addr u n $[]addr –  ) gforth-1.0 “string-array-store”
   文字列 c-addr u を文字列配列 $[]addr のインデックス n に格納します。
必要に応じて配列のサイズが変更されます。

‘$[]+!’ ( c-addr u n $[]addr –  ) gforth-1.0 “string-array-plus-store”
   文字列 c-addr u をインデックス n の文字列に「追加」します。 必要に応
じて配列のサイズが変更されます。 これを ‘$+[]!’ と混同しないでください。

‘$+[]!’ ( c-addr u $[]addr –  ) gforth-1.0 “string-append-array”
   文字列 c-addr u を文字列配列 $[]addr の新しい最後の要素として保存しま
す(つまり要素が1つ増える)。 必要に応じて配列のサイズが変更されます。

‘$[]@’ ( n $[]addr – addr u  ) gforth-1.0 “string-array-fetch”
   配列インデックス n から文字列を取得します — 空の場合はゼロ文字列( 0 0
)を返し、 誤って配列が成長しないようにします(訳注:要素はあるけど空文字列
(長さ0)の場合と、範囲外の要素を指した場合の区別は付かないので注意)

‘$[]#’ ( addr – len  ) gforth-1.0 “string-array-num”
   配列内の要素の数を返します

‘$[]map’ ( addr xt –  ) gforth-1.0 “string-array-map”
   文字列配列 ADDR のすべての要素に対して 実行トークン XT を実行します。
xt は ( ADDR U – ) で、一度に 1 つの文字列を取得します

‘$[]slurp’ ( fid addr –  ) gforth-1.0 “string-array-slurp”
   ファイル FID の内容を 1 行ずつ文字列配列 ADDR に入れます

‘$[]slurp-file’ ( addr u $addr –  ) gforth-1.0 “string-array-slurp-file”
   名前付きファイル ADDR U を 1 行ずつ文字列配列 $ADDR に入れます。

‘$[].’ ( addr –  ) gforth-1.0 “string-array-dot”
   すべての配列エントリを出力します

‘$[]free’ ( addr –  ) gforth-1.0 “string-array-free”
   addr は沢山のセルカウント文字列(string)へのアドレス達を含む、 セル・
カウント文字列(string)へのアドレスで、 $[]free はこれらの文字列を解放、
つまり、 この配列を開放し、 addr の値を 0 にセットします。

‘$save’ ( $addr –  ) gforth-1.0 “string-save”
   savesys のディクショナリに文字列(string)をプッシュします

‘$[]save’ ( addr –  ) gforth-1.0 “string-array-save”
   文字列配列を savesys のディクショナリにプッシュ

‘$boot’ ( $addr –  ) gforth-1.0 “string-boot”
   ディクショナリから文字列を新しく割り当てたメモリに取り込みます。 その
後、 ディクショナリのその文字列の領域を(0で)クリアします(長さはそのまま
)。

‘$[]boot’ ( addr –  ) gforth-1.0 “string-array-boot”
   ディクショナリから、 文字列配列を割り当てられたメモリに取得します

‘$saved’ ( addr –  ) gforth-1.0 “string-saved”
   アドレスを ブート済み(booted)/保存済み(saved) としてマークする

‘$[]saved’ ( addr –  ) gforth-1.0 “string-array-saved”
   アドレスを ブート済み(booted)/保存済み(saved) としてマークする

‘$Variable’ ( –  ) gforth-1.0 “string-variable”
   savesystem 全体にわたって保存される文字列変数。

‘$[]Variable’ ( –  ) gforth-1.0 “string-array-variable”
   savesystem 全体にわたって保存される文字列変数。


File: gforth.info,  Node: Counted string words,  Prev: $tring words,  Up: Strings and Characters

6.8.6 Counted string words
--------------------------

カウンタ付文字列(counted string)は、 指定のアドレスのバイトとして長さを
格納し、 その後に文字列のバイトが続きます。 可能な長さは厳しく制限されて
おり、 入力文字列を破壊せずにその場で部分文字列を作成することはできませ
ん。 したがって、 カウンタ付文字列を使用しないことをお勧めします。 それ
でも、 カウンタ付文字列を処理する必要がある場合、 以下のようなワード群が
あります:

‘count’ ( c-addr1 – c-addr2 u ) core “count”
   c-addr2 は最初の文字で、 u は c-addr1 のカウンタ付文字列の、 長さです
。

   以下のワードは、 (‘s"’ とは異なり) 有用なインタプリタ機能
(interpretation semantics)がなく、 (‘[char]’ とは異なり) 対応するインタ
プリタ用コードがないため、 コロン定義内でのみ使用する必要があります(コロ
ン定義がある場合):

‘C"’ ( compilation "ccc<quote>" – ; run-time  – c-addr  ) core-ext “c-quote”
   コンパイル状態: ‘"’ (二重引用符) を区切り文字として文字列 ccc をパー
スします。 その実行時コードは、 指定のカウンタ付文字列 ccc のアドレスを
c-addr として返します。 インタプリタ機能は未定義です。

   ( gforth-obsolete ) ‘place’ ( c-addr1 u c-addr2 –) \ C-ADDR2 に長さ U
のカウンタ付き文字列を作成し、 文字列 C-ADDR1 U をその場所にコピーします
。
‘string,’ ( c-addr u –  ) gforth-0.2 “string,”
   文字列をカウンタ付き文字列として(here以降の)データ空間に書き込みます
。


File: gforth.info,  Node: Control Structures,  Next: Defining Words,  Prev: Strings and Characters,  Up: Words

6.9 Control Structures
======================

Forth の制御構造は、 コロン定義内のみで、 インタプリタ状態
(interpretively)で使用することはできません(1)。 私たちもこのような制限を
好まないので、 多くのスキームが提案されてはいますが、 これを回避する満足
のいく方法はまだ見つかっていません。

* Menu:

* Selection::                IF ... ELSE ... ENDIF
* Simple Loops::             BEGIN ...
* Counted Loops::            DO
* BEGIN loops with multiple exits::
* General control structures with CASE::
* Arbitrary control structures::
* Calls and returns::
* Exception Handling::

   ---------- Footnotes ----------

   (1) 正確には、 インタプリタ機能(interpretation semantics)(*note
Interpretation and Compilation Semantics::)を持っていません


File: gforth.info,  Node: Selection,  Next: Simple Loops,  Prev: Control Structures,  Up: Control Structures

6.9.1 Selection
---------------

     flag
     IF
       code
     ENDIF

   flag がゼロ以外の場合(‘IF’ などに関する限り、 任意のビットが設定され
たセルは true 扱いです)、 code が実行されます。

     flag
     IF
       code1
     ELSE
       code2
     ENDIF

   FLAG が true の場合は code1 が実行され、 それ以外の場合は code2 が実
行されます。

   ‘ENDIF’ の代わりに ‘THEN’ を使用できます。 実際 ‘THEN’ は標準です、 が
しかし、 ‘ENDIF’ は非常に人気があるものの、 標準ではありません。 私達は
‘ENDIF’ の使用をお勧めします。 なぜなら、 他の言語を知っている人にとって
も混乱が少ないためです(また、 ‘ENDIF’ に対しては、 これらの人々の Forth
に対する否定的な偏見が強化される傾向が見られません)。 なお、 ‘THEN’ のみ
を提供するシステムに ‘ENDIF’ を追加するのは以下のように簡単です:
     : ENDIF   POSTPONE then ; immediate

   [‘Webster’s New Encyclopedic Dictionary’ によると、“then (副詞)” には
以下の意味があります:
     ...  2b: 順番に次の後に続く ...  3d: 必然的な結果として (if you
     were there, then you saw them)
   Forth の ‘THEN’ は 2b の意味を持ちますが、 Pascal や他の多くのプログ
ラミング言語の ‘THEN’ は 3d の意味を持ちます。]

   Gforth には ‘?DUP-IF’ および ‘?DUP-0=-IF’ というワードも用意されてい
るため、 ‘?dup’ の使用を避けることができます。これらの代替手段を使用する
ことは、 ‘?dup’ を使用するよりも効率的です。 ‘ENDIF’ や ‘?DUP-IF’ や
‘?DUP-0=-IF’ の標準 Forth での定義は、‘compat/control.fs’ で提供されます
。

     x
     CASE
       x1 OF code1 ENDOF
       x2 OF code2 ENDOF
       ...
       ( x ) default-code ( x )
     ENDCASE ( )

   xi が x に等しいなら、 最初の codei を実行します。 x1 〜 xn のいずれ
も一致しない場合は、 オプションの default-code が実行されます。 オプショ
ンのデフォルト・ケースは、 最後の ‘ENDOF’ の後にコードを記述するだけで追
加できます。 スタック頂上にある x を使用することはできますが、 それを消
費してはなりません。 値 x は、 この構造によって(一致する ‘OF’ によって、
または一致する OF がない場合は ‘ENDCASE’ によって) 消費されます。 例:

     : num-name ( n -- c-addr u )
      case
        0 of s" zero " endof
        1 of s" one "  endof
        2 of s" two "  endof
        \ default case:
        s" other number"
        rot \ get n on top so ENDCASE can drop it
      endcase ;

   (非標準の) ‘?of’ を使用して、 ‘case’ を 3 つ以上の選択肢の一般的な選
択構造として使用することもできます。 ‘?Of’ はフラグを受け取ります。 例:

     : sgn ( n1 -- n2 )
         \ sign function
         case
     	dup 0< ?of drop -1 endof
     	dup 0> ?of drop 1 endof
     	dup \ n1=0 -> n2=0; dup an item, to be consumed by ENDCASE
         endcase ;

   プログラミング・スタイル・メモ: コードを理解しやすくするには、 選択構
造を介したすべての経路で同一の方法でスタックを変更(消費およびプッシュさ
れるスタック項目の数と型)するようにする必要があります。


File: gforth.info,  Node: Simple Loops,  Next: Counted Loops,  Prev: Selection,  Up: Control Structures

6.9.2 Simple Loops
------------------

     BEGIN
       code1
       flag
     WHILE
       code2
     REPEAT

   code1 が実行され、 flag が計算されます。 flag が true の場合、 code2
が実行され、 BEGIN からループが再開されます。 flag が false の場合、
‘REPEAT’ の後へ実行が続行されます。

     BEGIN
       code
       flag
     UNTIL

   code が実行されます。 ‘flag’ が false の場合、 BEGIN からループが再開
されます。

   プログラミング・スタイル・メモ: コードを理解しやすくするために、 ルー
プの完全な反復(complete iteration)によってスタック上の項目の数と型が変更
されるべきではありません。

     BEGIN
       code
     AGAIN

   これは無限ループです。


File: gforth.info,  Node: Counted Loops,  Next: BEGIN loops with multiple exits,  Prev: Simple Loops,  Up: Control Structures

6.9.3 Counted Loops
-------------------

基本のカウント・ループ:
     limit start ?DO
       body
     LOOP

   これは、 start から始まり limit まで(limit 自身は除く)、 各整数値に対
して 1 回の反復を実行します。 カウンタ、 つまりインデックスには、 ‘i’ を
使用してアクセスできます。 たとえば、 以下のループをご覧ください:
     10 0 ?DO
       i .
     LOOP
出力: ‘0 1 2 3 4 5 6 7 8 9’

   最も内側のループのインデックスには ‘i’ を使用してアクセスでき、 その
一つ外側のループのインデックスには ‘j’ を使用してアクセスでき、 さらにも
う一つ外側のループのインデックスには ‘k’ を使用してアクセスできます。

   ‘i'’ を使用すると最も内側のループの limit にアクセスでき、 ‘delta-i’
を使用すると ‘i'’ - ‘i’ にアクセスできます。

     : foo 7 5 ?do cr i . i' . delta-i . loop ;

   出力:

     5 7 2
     6 7 1

   ループ制御データはリターン・スタックに保持されるため、 リターン・スタ
ックへのアクセスとカウント・ループ・ワードの混在にはいくつかの制限があり
ます。 特に、ループの外側のリターン・スタックに値を置いた場合、 ループ内
で値を読み取る事はできません(1)。 ループ内のリターン・スタックに値を置く
場合は、 ループの終了前、 およびループのインデックスにアクセスする前に値
を削除する必要があります。

   カウント・ループにはいくつかのバリエーションがあります:

   • ‘LEAVE’ は、 最も内側のカウント・ループを直ちに抜け出します。 それ
     が関係する ‘LOOP’ または ‘NEXT’ の後へ実行は移ります。 例:

          10 0 ?DO  i DUP . 3 = IF LEAVE THEN LOOP
     出力: ‘0 1 2 3’

   • ‘UNLOOP’ は、 例えば ‘EXIT’ などを介しての異常なループ終了の準備を
     行います。 ‘UNLOOP’ は、 ‘EXIT’ がリターン・アドレスに到達できるよ
     うに、 リターン・スタックからループ制御パラメーターを削除します(訳
     注: 1重ループなので unloop 1つ。2重ループなら unloop 2つ)。 例:

          : demo 10 0 ?DO i DUP . 3 = IF UNLOOP EXIT THEN LOOP ." Done" ;
     出力: ‘0 1 2 3’

   • start が limit より大きい場合でも、 ‘?DO’ はループを開始します(ラッ
     プアラウンド演算(処理可能な範囲をの最後に達した後に最初に戻る事)に
     よって両者が等しくなるまで ‘LOOP’ を反復します)。 通常、 この振る舞
     いは望ましくないものです。 したがって、 Gforth は (‘?DO’ の代替とし
     て、) ‘+DO’ と ‘U+DO’ を提供します。 これらは、 start が limit より
     大きい場合にはループを開始しません。 ‘+DO’ は符号付きループ・パラメ
     ータ用で、 ‘U+DO’ は符号なしループ・パラメータ用です。

   • ‘?DO’ は ‘DO’ に置き換えることはできます。 ‘DO’ は、 ループ・パラメ
     ータ に関係なく、 常にループに入ります。 あなたが、 どの場合にもル
     ープに入ることを知っている場合でも ‘DO’ は使用しないでください。 こ
     のような知恵はプログラムを保守していく中で無効になる傾向があり、 そ
     れゆえ ‘DO’ が問題を引き起こすことになります。

   • ‘LOOP’ は ‘n +LOOP’ に置き換えることができます。 これにより、インデ
     ックスが 1 ではなく n によって更新されます。 limit-1 と limit の間
     の境界を越えると、 ループは終了します。 例:

          4 0 +DO  i .  2 +LOOP
     出力: ‘0 2’

          4 1 +DO  i .  2 +LOOP
     出力: ‘1 3’

   • n が負数の場合、 ‘n +LOOP’ の動作は奇妙です:

          -1 0 ?DO  i .  -1 +LOOP
     出力: ‘0 -1’

          0 0 ?DO  i .  -1 +LOOP
     出力: なし。

     私たちは ‘?DO’ と ‘+LOOP’ を組み合わせないことをお勧めします。
     Gfors はいくつかの代替手段を提供します:

     ‘I’=limit の反復を含める ‘-1 +LOOP’ の振る舞いが必要な場合、 ‘-[DO’
     または ‘U-[DO’] でループを開始します(ここで、 ‘[’ は、 包含範囲の数
     学的表記法(例: [1,n] からインスピレーションを得ています):

          -1 0 -[DO  i .  -1 +LOOP

     出力: ‘0 -1’.

          0 0 -[DO  i .  -1 +LOOP

     出力: ‘0’

          0 -1 -[DO  i .  -1 +LOOP

     出力: なし。

     limit を除外したい場合、 代わりに ‘1 -LOOP’ (または一般的には ‘u
     -LOOP’)を使用し、 ‘?DO’ または ‘-DO ’ または ‘U-DO’ でループを開始
     します。 ‘-LOOP’ は、limit+1 と limit の間の境界を越えたときにルー
     プを終了します。 例:

          -2 0 -DO  i .  1 -LOOP
     出力: ‘0 -1’

          -1 0 -DO  i .  1 -LOOP
     出力: ‘0’

          0 0 -DO  i .  1 -LOOP
     出力: なし。

     残念ながら、 ‘+DO’, ‘U+DO’, ‘-DO’, ‘U-DO’, ‘-LOOP’ は 標準 Forth で
     は定義されていません。 ただし、 標準のワードのみを使用するこれらの
     ワードの実装が ‘compat/loops.fs’ にて提供されています。

   • よくある作業は、 配列の要素を前方または後方に反復処理することです。
     要素のアドレスに対して反復処理することには 2 つの利点があります。 配
     列の開始アドレスを保持する必要がなくなり、 データ・スタックの負荷が
     軽減されます。 また、 反復ごとにアドレス計算を実行する必要がなくな
     ります。 欠点は、 通常の配列表現 addr u要素 または addr uバイト か
     ら始めて、 start アドレスと limit アドレスを生成するために何らかの
     処理が必要なことです。 Gforth には、addr ubytes 表現からそこに到達
     するために ‘bounds’ があるため、セル配列 ‘v’ を介した前方ループを以
     下のように記述できます:

          create v 1 , 3 , 7 ,
          : foo v 3 cells bounds U+DO i  . cell +LOOP ;
          foo

     これは ‘1 3 7’ を出力します。 逆方向にたどるための入力の前処理はよ
     り複雑であるため、 Gforth はそれを行う ‘MEM-DO’ … ‘LOOP’ 形式のルー
     プ構造を提供します。 これは addr uバイト 表現の配列と要素サイズを受
     け取り、 要素のアドレスを逆順に反復処理します。

          create v 1 , 3 , 7 ,
          : foo1 v 3 cell array>mem MEM-DO i  . LOOP ;
          foo1

     これは ‘7 3 1’ を出力します。‘ARRAY>MEM’ は addr uelems uelemsize を
     ‘MEM-DO’ が期待する addr ubytes uelemsize に変換します(ubytes は
     uelems * uelmsize です)。 このループは ‘MEM-DO’ 通過後にuelemsize ず
     つ減算される、 ‘LOOP’ と対になるループとなります。

     Gforth は、 完全を期すために ‘MEM+DO’ も追加します。 ‘MEM-DO’ と同
     一のパラメータを受け取りますが、 配列を順(forwards)に処理します:

          create v 1 , 3 , 7 ,
          : foo2 v 3 cell array>mem MEM+DO i  . LOOP ;
          foo2

     出力: ‘1 3 7’

   • 別のカウント・ループ:
          n
          FOR
            body
          NEXT
     これは、 ‘?DO’ ループを適切に最適化するのが面倒な、 ネイティブ・コ
     ード・コンパイラ作成者達が好むループです。 このループ構造は標準
     Forth では定義されていません。 Gforth では、 このループは n+1 回繰
     り返します。 ‘i’ は、 n で始まり 0 で終わる値を生成します。 他の
     Forth システムは、‘FOR’ ループをサポートしている場合でも、 振る舞い
     が異なる場合があります。 この問題を回避するには、 ‘FOR’ ループを使
     用しないようにしてください。

   カウント・ループ・ワード群:

‘?DO’ ( compilation – do-sys ; run-time w1 w2 – | loop-sys  ) core-ext “question-do”
   *Note Counted Loops::.

‘+DO’ ( compilation – do-sys ; run-time n1 n2 – | loop-sys  ) gforth-0.2 “plus-do”
   *Note Counted Loops::.

‘U+DO’ ( compilation – do-sys ; run-time u1 u2 – | loop-sys  ) gforth-0.2 “u-plus-do”
   *Note Counted Loops::.

‘bounds’ ( addr u – addr+u addr ) gforth-0.2 “bounds”
   開始アドレス addr と長さ u で表されるメモリ・ブロックを指定すると、
‘u+do’ または ‘?do’ の終了アドレス addr+u と開始アドレス addr を正しい順
序で生成します。

‘-[do’ ( compilation – do-sys ; run-time n1 n2 – | loop-sys  ) gforth-experimental “minus-bracket-do”
   負の方向へカウントされるループを開始します。 n2<n1 の場合、 ループを
スキップします。 このようなカウント・ループは、 増分が負である ‘+loop’ と
対になります。 ‘I’>=n1 である限り実行されます。

‘u-[do’ ( compilation – do-sys ; run-time u1 u2 – | loop-sys  ) gforth-experimental “u-minus-bracket-do”
   負の方向へカウントするループを開始します。 u2<u1 の場合、ループをスキ
ップします。 このようなカウント・ループは、 増分が負の ‘+loop’ と対にな
ります。 ‘I’>=u1 である限り実行されます。

‘-DO’ ( compilation – do-sys ; run-time n1 n2 – | loop-sys  ) gforth-0.2 “minus-do”
   *Note Counted Loops::.

‘U-DO’ ( compilation – do-sys ; run-time u1 u2 – | loop-sys  ) gforth-0.2 “u-minus-do”
   *Note Counted Loops::.

   ‘array>mem’ ( uelements uelemsize – ubytes uelemsize) \ ubytes は
uelements * uelementsize です
‘mem+do’ ( compilation – w xt do-sys; run-time addr ubytes +nstride –  ) gforth-experimental “mem-plus-do”
   ‘I’ を addr から開始し、 ‘I’<addr+ubytes である限り、 nstride 幅のス
テップでメモリ内をアドレスが増える方向にカウント・アップするカウント・ル
ープを開始します。 loop と対にする必要があります。

‘mem-do’ ( compilation – w xt do-sys; run-time addr ubytes +nstride –  ) gforth-experimental “mem-minus-do”
   ‘I’ を addr+ubytes-ustride として開始し、 ‘I’>=addr である間 -nstride
幅のステップでメモリをアドレス下位方向(backward)にステップするカウント・
ループを開始します。 loop と対にしなければなりません。

‘DO’ ( compilation – do-sys ; run-time w1 w2 – loop-sys  ) core “DO”
   *Note Counted Loops::.

‘FOR’ ( compilation – do-sys ; run-time u – loop-sys  ) gforth-0.2 “FOR”
   *Note Counted Loops::.

‘LOOP’ ( compilation do-sys – ; run-time loop-sys1 – | loop-sys2  ) core “LOOP”
   *Note Counted Loops::.

‘+LOOP’ ( compilation do-sys – ; run-time loop-sys1 n – | loop-sys2  ) core “plus-loop”
   *Note Counted Loops::.

‘-LOOP’ ( compilation do-sys – ; run-time loop-sys1 u – | loop-sys2  ) gforth-0.2 “minus-loop”
   *Note Counted Loops::.

‘NEXT’ ( compilation do-sys – ; run-time loop-sys1 – | loop-sys2  ) gforth-0.2 “NEXT”
   *Note Counted Loops::.

‘i’ ( R:n – R:n n ) core “i”
   n は、最も内側のカウント・ループのインデックスです。

‘j’ ( R:n R:w1 R:w2 – n R:n R:w1 R:w2 ) core “j”
   n は、 最も内側から数えて 2 番目のカウント・ループのインデックスです
。

‘k’ ( R:n R:w1 R:w2 R:w3 R:w4 – n R:n R:w1 R:w2 R:w3 R:w4 ) gforth-0.3 “k”
   n は、 最も内側から数えて3番目のカウント・ループのインデックスです。

‘i'’ ( R:w R:w2 – R:w R:w2 w ) gforth-0.2 “i-tick”
   最も内側のカウント・ループの limit

‘delta-i’ ( r:ulimit r:u – r:ulimit r:u u2 ) gforth-1.0 “delta-i”
   u2=‘I'’-‘I’ (limit とインデックスの差)

‘LEAVE’ ( compilation – ; run-time loop-sys –  ) core “LEAVE”
   *Note Counted Loops::.

‘?LEAVE’ ( compilation – ; run-time f | f loop-sys –  ) gforth-0.2 “question-leave”
   *Note Counted Loops::.

‘unloop’ ( R:w1 R:w2 – ) core “unloop”

‘DONE’ ( compilation do-sys – ; run-time –  ) gforth-0.2 “DONE”
   do-sys までのすべての LEAVE を解決します(訳注: loop, +loop , next 等
の中で内部的に呼び出されます)。

   標準では、 do-sys で ‘CS-PICK’ や ‘CS-ROLL’ を使用することは許可され
ていません。 ‘MEM+DO’ と ‘MEM-DO’ によって生成される do-sys を除いて、
Gforth では ‘CS-PICK’ や ‘CS-ROLL’ の使用を許可しますが、 すべての ‘?DO’
などに対して、 定義を介した任意の経路上に ‘UNLOOP’ が正確に 1 つだけ存在
すること(‘LOOP’ などの失敗経路上で ‘UNLOOP’ コンパイルするなど)を確認す
るのはあなたの仕事です。 また、 すべての ‘LEAVE’ が（ループ終了ワードの
1 つまたは ‘DONE’ を使用して)解決されていることを確認する必要があります
。

   ---------- Footnotes ----------

   (1) ええ、まぁ、 移植可能な方法ではできません、 ぐらいな


File: gforth.info,  Node: BEGIN loops with multiple exits,  Next: General control structures with CASE,  Prev: Counted Loops,  Up: Control Structures

6.9.4 ‘Begin’ loops with multiple exits
---------------------------------------

カウント・ループの場合、 複数箇所で ‘leave’ を使用できます。 ‘begin’ ル
ープの場合は、 以下の選択肢があります:

   ループ内で ‘exit’ を使用(複数記述できます)すると、 ループだけでなくコ
ロン定義全体からも去ります。 例:

     : foo
       begin
         condition1 while
           condition2 if
             exit-code2 exit then
           condition3 if
             exit-code3 exit then
         ...
       repeat
       exit-code1 ;

   このアプローチの欠点は、 ループ後に共通コードが必要な場合、 共通コー
ドを含む別のワードで ‘foo’ を包むか、 または、 それぞれの exit-code から
共通コードを呼び出す必要があることです。

   もう 1 つのアプローチは、 ‘begin’ ループ内で複数の ‘while’ を使用する
ことです。 追加の ‘while’ ごとにループの後ろに ‘then’ を追加する必要があ
ります。 例:

     begin
       condition1 while
         condition2 while
           condition3 while
     again then then then

   ここでは、 ループの最後に ‘again’ を使用して、 各 ‘while’ に ‘then’ を
用意しました。 ‘repeat’ は ‘then’ を 1 つ減らしますが、 それ以外の場合は
同じ動作になります。 これが機能する理由の説明については、 *Note
Arbitrary control structures:: をご覧下さい。

   後で共通のコードを使用することはできますが、 上で示したように、 異な
る出口(exit)に対して異なる exit-code を使用することはできません。 以下の
ようにすると、 これらの異なる exit-code を使用できます:

     begin
       condition1 while
         condition2 while
           condition3 while
     again then exit-code3
     else exit-code2 then
     else exit-code1 then

   exit-code は終了条件から比較的離れているため、 これを理解するのは比較
的困難です(このような制御構造に慣れていないことも理由にはなりません)。


File: gforth.info,  Node: General control structures with CASE,  Next: Arbitrary control structures,  Prev: BEGIN loops with multiple exits,  Up: Control Structures

6.9.5 General control structures with ‘case’
--------------------------------------------

Gforth は、 拡張 ‘case’ を提供することで、 上で説明した複数出口ループの
問題を解決する追加のオプションを提供します。 この拡張 ‘case’ の移植可能
な実装は ‘compat/caseext.fs’ にあります。

   この拡張には 3 つの追加ワードがあります。 1 つ目は ‘?of’ で、 ‘case’
内で(単なる同等性のテストではなく、)一般的なテストが可能です。 例:

     : sgn ( n -- -1|0|1 )
       ( n ) case
         dup 0 < ?of drop -1 endof
         dup 0 > ?of drop 1  endof
         \ otherwise leave the 0 on the stack
       0 endcase ;

   注意: ‘endcase’ は値(a value)を drop することに注意してください。 こ
れは ‘of’ ではほとんどうまいこと機能しますが、 ‘?of’ ではたいていうまい
こといかないので、 今回も ‘endcase’ で drop するための値として 0 をスタ
ック置きます。 ここでは、 ‘sgn’ に渡される n は、 いずれの ‘?of’ もトリ
ガーしない場合返り値の 0 そのものになります。

   2 番目の追加ワードは ‘next-case’ で、 これにより ‘case’ をループに変
えることができます。 出口が3つのループは以下のようになります:

     case
       condition1 ?of exit-code1 endof
       condition2 ?of exit-code2 endof
       condition3 ?of exit-code3 endof
       ...
     next-case
     common code afterwards

   ご覧のとおり、 これにより、 先程議論したバリエーションの両方の問題が
解決されます(*note BEGIN loops with multiple exits::)。 注意: ‘endcase’
とは異なり、 ‘next-case’ は値をドロップしないことに注意してください。
(1)

   最後の追加ワードは ‘contof’ です。 これは ‘endof’ の代わりに使用され
、 ループを終了する代わりに次の反復を開始します。 これは、 ダイクストラ
のガード付きコマンド 繰り返し: do と同様の方法で使用できます。 例:

     : gcd ( n1 n2 -- n )
         case
             2dup > ?of tuck - contof
             2dup < ?of over - contof
         endcase ;

   ここで、 2 つの ‘?of’ はループを継続する異なる方法を持っています。 ど
ちらの ‘?of’ もトリガーされない場合、 2 つの数値は等しく、gcd(最大公約数
) になります。 ‘Endcase’ はそれらの 1 つを削除し、もう 1 つは n として残
します。

   これらのワードを組み合わせることもできます。 以下は、 ‘endcase’ を除
く、 各 ‘case’ ワードをそれぞれ 1 回使用する例です:

     : collatz ( u -- )
         \ print the 3n+1 sequence starting at u until we reach 1
         case
             dup .
             1 of endof
             dup 1 and ?of 3 * 1+ contof
             2/
         next-case ;

   この例では、 シーケンスの現在の値をスタックに保持します。 1 の場合、
‘of’ がトリガーされ、 値が削除され、 ‘case’ 構造から去ります。 奇数の場
合、 ‘?of’ がトリガーされ、 3n+1 が計算され、 ‘contof’ で次の反復が開始
されます。 それ以外の場合、 数値が偶数の場合は 2 で除算され、
‘next-case’ でループが再開されます。

   ---------- Footnotes ----------

   (1) ‘next-case’ は、 他の ‘case’ ワード群とは異なり、 名前にハイフン
(‘-’)が含まれています。 VFX Forth には値をドロップする ‘nextcase’ がある
ので、これと区別するためです。


File: gforth.info,  Node: Arbitrary control structures,  Next: Calls and returns,  Prev: General control structures with CASE,  Up: Control Structures

6.9.6 Arbitrary control structures
----------------------------------

標準 Forth は、 ネストされない方法での制御構造の使用を許可・サポートしま
す。 まだ完成されてない制御構造に関する情報は、 制御フロー・スタック
(control-flow stack)に保存されます。 このスタックは Forth のデータ・スタ
ック上に実装でき、 Gforth はそうしました。

   orig エントリは未解決の前方分岐を表し、 dest エントリは後方分岐ターゲ
ットを表します。 いくつかのワードは、 可能なあらゆる制御構造を構築するた
めの基礎となります(ストレージを必要とする制御構造を除く、 呼び出しやコル
ーチンやバックトラッキングなど)。

‘IF’ ( compilation – orig ; run-time f –  ) core “IF”
   実行時(run-time)、 f=0 の場合、 orig を消費する ‘THEN’ (または
‘ELSE’) の後から実行が続行されます。 それ以外の場合は、 ‘IF’ の直後に続
きます(*note Selection::)。

‘AHEAD’ ( compilation – orig ; run-time –  ) tools-ext “AHEAD”
   実行時、 orig を消費する ‘THEN’ の後から実行が続行されます。

‘THEN’ ( compilation orig – ; run-time –  ) core “THEN”
   orig にプッシュした ‘IF’ または ‘AHEAD’ または ‘ELSE’ または ‘WHILE’
は、 ‘THEN’ の直後にジャンプします(*note Selection::)。

‘BEGIN’ ( compilation – dest ; run-time –  ) core “BEGIN”
   dest を消費する ‘UNTIL’ または ‘AGAIN’ または ‘REPEAT’ は、 ‘BEGIN’ の
直後へジャンプします(*note Simple Loops::)。

‘UNTIL’ ( compilation dest – ; run-time f –  ) core “UNTIL”
   実行時、 f=0 の場合、 dest を生成した ‘BEGIN’ の後で実行が続行されま
す。 それ以外の場合は、 ‘UNTIL’の直後から実行が続行されます(*note Simple
Loops::)。

‘AGAIN’ ( compilation dest – ; run-time –  ) core-ext “AGAIN”
   実行時、 dest を生成した ‘BEGIN’ の後から実行が続行されます(*note
Simple Loops::)。

‘CS-PICK’ ( orig0/dest0 orig1/dest1 ... origu/destu u – ... orig0/dest0  ) tools-ext “c-s-pick”

‘CS-ROLL’ ( destu/origu .. dest0/orig0 u – .. dest0/orig0 destu/origu  ) tools-ext “c-s-roll”

‘CS-DROP’ ( dest –  ) gforth-1.0 “CS-DROP”

   標準ワードの ‘CS-PICK’ や ‘CS-ROLL’ を使用すると、 移植可能な方法で制
御フロー・スタックを操作できます。 これら無しだと制御フロー・エントリが
占めるスタック項目の数を知る必要があります(多くのシステムは 1 つのセルを
使用します。 Gforth では現在 3 つを使用しますが、 これは将来変更される可
能性があります)。

   orig は 1 回だけ解決する必要があるため、 ‘CS-PICK’ は dest を pick す
ることしかできず、 かつ、 ‘CS-DROP’ は dest を drop することしかできませ
ん。

   一部の標準の制御構造ワードは、 以下のワード群から構築されます:

‘ELSE’ ( compilation orig1 – orig2 ; run-time –  ) core “ELSE”
   実行時、 orig を消費する ‘THEN’ の後から実行が続行されます。 orig1 を
プッシュした ‘IF’ または ‘AHEAD’ または ‘ELSE’ または ‘WHILE’ は、
‘ELSE’ の直後にジャンプします(*note Selection::)。

‘WHILE’ ( compilation dest – orig dest ; run-time f –  ) core “WHILE”
   実行時、 f=0 の場合、 orig を消費する ‘REPEAT’ (または ‘THEN’ または
‘ELSE’) の後から実行が継続されます。 それ以外の場合は、 ‘WHILE’ の直後か
ら実行されます(*note Simple Loops::)。

‘REPEAT’ ( compilation orig dest – ; run-time –  ) core “REPEAT”
   実行時、 dest を生成した ‘BEGIN’ の後から実行が続行されます。 orig を
プッシュした ‘WHILE’ または ‘IF’ または ‘AHEAD’ または ‘ELSE’ は、
‘REPEAT’ の直後にジャンプします(*note Simple Loops::)。

Gforth は、さらにいくつかの制御構造ワードを追加します:

‘ENDIF’ ( compilation orig – ; run-time –  ) gforth-0.2 “ENDIF”
   ‘THEN’ と同一です。

‘?dup-IF’ ( compilation – orig ; run-time n – n|  ) gforth-0.2 “question-dupe-if”
   これは、スタック・チェッカー(stack checker)などのツールでより適切に処
理できるため、 イディオム「‘?DUP IF’」の代替として推奨されます。 しかも
、 ‘?DUP IF’ より速いです。

‘?DUP-0=-IF’ ( compilation – orig ; run-time n – n|  ) gforth-0.2 “question-dupe-zero-equals-if”

制御構造ワードのもう一つのグループ:

‘case’ ( compilation  – case-sys ; run-time  –  ) core-ext “case”
   ‘case’ 構造の開始。

‘endcase’ ( compilation case-sys – ; run-time x –  ) core-ext “end-case”
   ‘case’ 構造を終わらせます。 x を drop して、‘endcase’ の後ろへ進みま
す。 x の drop は、 元の(‘of’ のみの)‘case’ 構造では便利ですが、 他の場
合(特に ‘?of’ を使用する場合)では(drop する為の) x を明示的に指定する必
要がある場合があります。

‘next-case’ ( compilation case-sys – ; run-time –  ) gforth-1.0 “next-case”
   マッチする ‘case’ にジャンプして、 ‘case’ ループを再開します。
‘endcase’ とは異なり、 ‘next-case’ はセルを drop しないことに注意してく
ださい。

‘of’ ( compilation  – of-sys ; run-time x1 x2 – |x1  ) core-ext “of”
   x1=x2 の場合は続行します(両方を drop します)。 それ以外の場合は、 x1
をスタック上に残し、 ‘endof’ または ‘contof’ の後ろにジャンプします。

‘?of’ ( compilation  – of-sys ; run-time  f –  ) gforth-1.0 “question-of”
   f が true の場合は続行します。 それ以外の場合は、 ‘endof’ または
‘contof’ の後ろにジャンプします。

‘endof’ ( compilation case-sys1 of-sys – case-sys2 ; run-time  –  ) core-ext “end-of”
   ‘endcase’/‘next-case’ の後ろにジャンプして、 囲んでいる ‘case’ 構造体
を終了(exit)します。

‘contof’ ( compilation case-sys1 of-sys – case-sys2 ; run-time  –  ) gforth-1.0 “cont-of”
   囲んでいる ‘case’ にジャンプして、 ‘case’ ループを再開します。

   内部的には、 of-sys は ‘orig’ で、 case-sys はセルとスタック深さ情報
と、0 個以上の ‘orig’ と、 ‘dest’ です。

6.9.6.1 Programming Style
.........................

読みやすさを確保するために、 任意の制御構造を直接作成せず、 必要な制御構
造に対して新しい制御構造ワードを定義し、 プログラム内でこれらのワードを
使用することをお勧めします。たとえば、 以下のように書く代わりに:

     BEGIN
       ...
     IF [ 1 CS-ROLL ]
       ...
     AGAIN THEN

以下のように制御構造のワードを定義することをお勧めします。 例:

     : WHILE ( DEST -- ORIG DEST )
      POSTPONE IF
      1 CS-ROLL ; immediate

     : REPEAT ( orig dest -- )
      POSTPONE AGAIN
      POSTPONE THEN ; immediate

そして、 次に、 これらを使用して制御構造を作成します:

     BEGIN
       ...
     WHILE
       ...
     REPEAT

   このほうがずっと読みやすいですよね。 もちろん、 ‘REPEAT’ と ‘WHILE’ は
定義済みなので、 この例を見て改めて定義する必要はありません。


File: gforth.info,  Node: Calls and returns,  Next: Exception Handling,  Prev: Arbitrary control structures,  Up: Control Structures

6.9.7 Calls and returns
-----------------------

呼び出す定義の名前を記述するだけで定義を呼び出すことができます。 通常、
定義はそれ自身の定義中は表示されません。 直接再帰的な定義を記述したい場
合は、 ‘recursive’ を使用して現在の定義を見えるようにする(使えるようにす
る)か、 ‘recurse’ を使用して現在の定義を直接呼び出すことができます。

‘recursive’ ( compilation – ; run-time –  ) gforth-0.2 “recursive”
   現在の定義中の定義をその定義内で呼び出せるように(表示できるように)し
、 それ自体を再帰的に呼び出せるようにします。

‘recurse’ ( ... – ...  ) core “recurse”
   現在の定義の別名(alias)。

これらのワードの使用例については *Note Recursion Tutorial:: を参照してく
ださい。

   プログラミング・スタイル・メモ: 私は、‘recurse’ よりも ‘recursive’ を
使用することを好みます。 名前で定義を呼び出す方が、 やや難解な ‘recurse’
よりも説明的であるためです(名前が適切に選択されていれば)。 たとえば、ク
イックソートの実装では、「今、再帰呼び出しを行う」(now do a recursive
call)と読むよりも、「今、パーティションをソートする」(now sort the
partitions)と読む(そして考える)方がはるかに優れています。

   相互再帰(mutual recursion)の場合は、 以下のように延期ワード
(‘Defer’red words)を使用します:

     Defer foo

     : bar ( ... -- ... )
      ... foo ... ;

     :noname ( ... -- ... )
      ... bar ... ;
     IS foo

   延期ワードについては、 *note Deferred Words:: で詳しく説明します。

   定義の終わりに達するか、 ‘EXIT’ に遭遇すると、 現在の定義は呼び出し元
の定義に制御を返します。

‘EXIT’ ( compilation – ; run-time nest-sys –  ) core “EXIT”
   呼び出し元の定義に戻る(return): 通常、 定義から速やかに戻るのを強制す
る方法として使用されます。 ‘EXIT’ する前に、 リターン・スタックをクリー
ンアップし、 未処理の ‘?DO’...‘LOOP’ を ‘UNLOOP’ する必要があります。 ロ
ーカルズ(locals)が無い場合に ‘exit’ のように動作するティック可能なワード
(tickable word)には ‘;s’ を使用します。

‘?EXIT’ ( –  ) gforth-0.2 “?EXIT”
   f が true の場合、 呼び出し元の定義に戻ります(return)。

‘;s’ ( R:w – ) gforth-0.2 “semis”
   ‘EXIT’ によってコンパイルされたプリミティブ。


File: gforth.info,  Node: Exception Handling,  Prev: Calls and returns,  Up: Control Structures

6.9.8 Exception Handling
------------------------

ワードが処理できないエラー状態を検出した場合、 例外を投げる(‘throw’)こと
ができます。 最も単純なケースでは、 これによりプログラムが終了し、適切な
エラーが報告されます。

‘throw’ ( y1 .. ym nerror – y1 .. ym / z1 .. zn error  ) exception “throw”
   nerror が 0 の場合は、 それを drop して続行します。 それ以外の場合は
、 動的に囲んでいる次の例外ハンドラー(next dynamically enclosing
exception handler)に制御を移し、 それに応じてスタックをリセットし、
nerror をプッシュします。

‘fast-throw’ ( ... wball – ... wball ) gforth-experimental “fast-throw”
   軽量の ‘throw’ バリエーション: ゼロ以外のみに使用され、 バックトレー
スを保存したり、 欠落している ‘catch’ を扱ったりしません。

   ‘throw’ は、スタック上のセル・サイズのエラー番号数値を消費します。 標
準 Forth には事前定義されたエラー番号がいくつかあります(‘errors.fs’ 参照
)。 Gforth (および他のほとんどのシステム)では、 さまざまなワードによって
生成された ior をエラー番号として使用できます(たとえば、 ‘allocate’ の一
般的な使用法は ‘allocate throw’ です)。 Gforth は、 (適切なエラー報告付
きで)独自のエラー番号を定義するための ‘Exception’ というワードも提供しま
す。 このワードの標準 Forth バージョン(ただしエラー・メッセージなし) は
‘compat/excel.fs’ で入手できます。 最後に、 あなた独自のエラー番号(-4095
〜 0 の範囲以外の任意の番号)を使用できますが、 表示されるのは適切なエラ
ー・メッセージではなく、数字のみです。 たとえば、 以下のことを試してみて
ください:

     -10 throw                    \ 標準で定義済
     -267 throw                   \ システムで定義済
     s" my error" exception throw \ ユーザー定義
     7 throw                      \ 思いつくままの任意の番号

‘exception’ ( addr u – n  ) gforth-0.2 “exception”
   N は、 -4095 〜 -256 の範囲内で以前に使用されていなかった ‘throw’ 値
です。 ‘Exception’ を連続して呼び出すと、 連続して減少する数値が返されま
す。 Gforth は文字列 ADDR U をエラー・メッセージとして使用します(訳注: 同
じエラーメッセージを使いまわすには、 s" hoge err msg" exception constant
hoge-error hoge-error !  などとして得られた hoge-error を使いまわす。
hoge-error throw 等する)

   エラー番号を文字列に変換するためのワード(通常は POSIX の ‘strerror’ を
モデルにしたもの)がある場合もあります。 以下のワードを使用すると、 これ
らの文字列を Gforth のエラー処理に取り込むことができます:

‘exceptions’ ( xt n1 – n2  ) gforth-1.0 “exceptions”
   throw時: xt ‘( +n -- c-addr u )’ は、 0<=n<n1 の範囲のローカルのエラ
ー・コードをエラー・メッセージに変換します。 ‘Exceptions’ は、
n2-n1<n3<=n2 の範囲で n1 個(0 〜 n1)のエラー・コードを予約します。 n2 に
、 対応する Gforth エラー・コード(ローカルのエラー番号 0 に対応。 つまり
、 0<=n<n1 の範囲のローカルのエラー・コードに 対応する Gforth エラー・コ
ードは n2 <= n3 < n2+n1)を返します。 (後の時点で)その範囲に対応した
Gforth エラー・コード n3 が throw されると、 n2-n3 がプッシュされ(つまり
ローカルのエラー番号に変換した値をプッシュし)、 xt が実行されて、 xt が
エラー・メッセージを生成します(訳注: minos2/pulse-audio.fs 等で確認。 xt
にC-interface ワードをセットし、 外部Cライブラリのエラー・メッセージを
gforth 内から表示するのに使っているようだ)

   たとえば、 C言語ライブラリの ‘errno’ エラー (および ‘strerror’ を使用
した変換) がまだ Gforth で直接サポートされていないとした場合、 以下のよ
うにして ‘strerror’ を gforth と結び付けることができます:

     ' strerror 1536 exceptions constant errno-base
     : errno-ior ( -- n )
     \ n は errno の値に対応する Gforth ior を求めなければならないので、
     \ ここでerrno 範囲と Gforth ior の範囲の間で変換する必要があります。
     \ ERRNO は Gforth ワードではないため、
     \ それにアクセスするには C インターフェイスを使用する必要があります。
       errno errno-base over - swap 0<> and ;

   C言語の関数(C言語インターフェイス(C interface)を使用)を呼び出し、 そ
の戻り値がエラーが発生したことを示している場合、 ‘errno-ior throw’ を実
行して、適切なエラー・メッセージ (“Permission denied” など)を含む例外を
生成できます。

   フラグが true の場合、 特定の err# でエラーを投げる(‘THROW’)一般的な
慣用句は以下のとおりです:

     ( flag ) 0<> err# and throw

   あなたのプログラムで、 例外をキャッチする例外ハンドラーを提供できます
。 例外ハンドラーを使用すると、 問題を修正したり、 一部のデータ構造をク
リーンアップして例外を次の例外ハンドラーに投げたり(throw)することができ
ます。 ‘throw’ は動的に最も内側の例外ハンドラー(the dynamically
innermost exception handler)にジャンプすることに注意してください。 シス
テムの例外ハンドラーは最も外側にあり、 エラーを出力してコマンド・ライン
の解釈(interpretation)を再開するだけです(または、 バッチ・モード(つまり
、 シェル・コマンド・ラインの処理中)では Gforth を終了します)。

   例外をキャッチする標準 Forth での方法は ‘catch’ です:

‘catch’ ( x1 .. xn xt – y1 .. ym 0 / z1 .. zn error  ) exception “catch”
   xt を実行します。 実行から正常に戻った場合、 ‘catch’ はスタックに 0 を
プッシュします。 ‘throw’ を介して実行が戻った場合、 すべてのスタックは
‘catch’ へ入る時点の深さにリセットされ、 TOS (xt の位置) は throw コード
に置き換えられます。

‘nothrow’ ( –  ) gforth-0.7 “nothrow”
   再 throw しない ‘catch’ または ‘endtry’ の後ろでこれ (または標準のシ
ーケンス ‘['] false catch 2drop’) を使用します。 これにより、 次の
‘throw’ でバックトレースが確実に記録されます。

   例外ハンドラーの最も一般的な使用法は、 エラーが発生したときに状態をク
リーンアップすることです。 例：

     base @ >r hex \ actually the HEX should be inside foo to protect
                   \ against exceptions between HEX and CATCH
     ['] foo catch ( nerror|0 )
     r> base !
     ( nerror|0 ) throw \ pass it on

   ‘myerror’ というエラー番号を処理するための ‘catch’ の使用は以下のよう
になります:

     ['] foo catch
     CASE
       myerror OF ... ( do something about it ) nothrow ENDOF
       dup throw \ default: pass other errors on, do nothing on non-errors
     ENDCASE

   コードを別のワードでくるむ要があるのは面倒な場合が多いため、 Gforth で
は代替構文を提供しています:

     TRY
       code1
       IFERROR
         code2
       THEN
       code3
     ENDTRY

   これは、 code1 を実行しします。 code1 が正常に完了すると、 code3 の実
行へ続きます。 code1 または、 ‘endtry’ より前で例外があった場合、 スタッ
クは ‘try’ 時の深さにリセットされ、 throw された値をデータ・スタックにプ
ッシュし、 code2 の実行に続き、 そして、 最終的に code3 に到達します。

‘try’ ( compilation  – orig ; run-time  – R:sys1  ) gforth-0.5 “try”
   例外キャッチ領域の開始

‘endtry’ ( compilation  – ; run-time  R:sys1 –  ) gforth-0.5 “endtry”
   例外キャッチ領域の終わり

‘iferror’ ( compilation  orig1 – orig2 ; run-time  –  ) gforth-0.7 “iferror”
   例外処理コードを開始します(‘try’ と ‘endtry’ の間に例外がある場合に実
行されます)。 この部分は ‘then’ で終了する必要があります。

   code2 が必要ない場合は、 ‘iferror then’ の代わりに ‘restore’ を記述で
きます:

     TRY
       code1
     RESTORE
       code3
     ENDTRY

   先程の例をこの構文で身綺麗にしてみます:

     base @ { oldbase }
     TRY
       hex foo \ now the hex is placed correctly
       0       \ value for throw
     RESTORE
       oldbase base !
     ENDTRY
     throw

   このバリエーションの追加の利点は、 ‘restore’ と ‘endtry’ の間の例外
(たとえば、 ユーザーが ‘Ctrl-C’ を押すことによる例外)でも、 ‘restore’ の
直後へコードの実行が移ることです。 ゆえに、 いかなる状況であっても base
は復元されます。

   ただし、 このコード自体が例外を引き起こさないようにする必要があります
。 そうしないと、 ‘iferror’/‘restore’ コードがループします。 さらに、
‘iferror’/‘restore’ コードで必要なスタックの内容が ‘try’ と ‘endtry’ の
間のあらゆる場所に存在することも確認する必要があります。 この例では、 こ
れは ‘try’ の前にデータを「ローカルズ」(locals)に置くことによって実現さ
れます(リターン・スタック上の例外フレーム(sys1)が邪魔なのでリターン・ス
タックは使用できません)。

   この種の使用法は、 Lisp の ‘unwind-protect’ と同様のものです。

   もし、あなたが、 この例外再開始(exception-restarting)の振る舞いを望ま
ない場合は、 以下のようにしてください:

     TRY
       code1
     ENDTRY-IFERROR
       code2
     THEN

   code1 に例外がある場合は code2 が実行され、 それ以外の場合は ‘then’ の
後ろ (または ‘else’ 分岐の可能性あり) から実行が続行されます。 これはバ
ージョン 0.7 より前の Gforth では以下の構成要素に該当します

     TRY
       code1
     RECOVER
       code2
     ENDTRY

   つまり、 この ‘recover’ を使用しているコードを直に ‘try ...
entry-iferror ... then’ へと置き換えることができます。 ただし、 その置き
換え作業中に他の ‘try’ バリエーションのいずれかを使用した方が良いかどう
かも検討することをお勧めします。

   移行を容易にするために、 Gforth は 2 つの互換性ファイルを提供します:
1つ目は ‘endtry-iferror.fs’ で、 古いシステム用に ‘try ...
endtry-iferror ... then’ 構文を提供します(ただし、 ‘iferror’ または
‘restore’ は提供しません)。 2つ目の ‘recover-endtry.fs’ は、 新しいシス
テム上で古い構文の ‘try ... recover ... endtry’ 構文を提供するので、 古
いプログラムを実行するための一時しのぎとして使用できます。 どちらのファ
イルもどのシステムでも動作します(システムが、 実装する構文を既に定義済み
の場合は何も行わないだけです)。 そのため、 古いシステムと新しいシステム
を混在させて使用している場合でも、 これらのファイルのいずれかを無条件に
‘require’ することができます。

‘restore’ ( compilation  orig1 – ; run-time  –  ) gforth-0.7 “restore”
   コードの復元(restore)を開始します。 これは、 例外がある場合と無い場合
に行われます。

‘endtry-iferror’ ( compilation  orig1 – orig2 ; run-time  R:sys1 –  ) gforth-0.7 “endtry-iferror”
   例外キャッチ領域を終了し、 その領域外で例外処理コードを開始します
(‘try’ と ‘endtry-iferror’ の間に例外がある場合に実行されます)。 この部
分は ‘then’ (または ‘else’...‘then’) で終了する必要があります。

   ここで、 エラー処理の例を以下に示します:

     TRY
       foo
     ENDTRY-IFERROR
       CASE
         myerror OF ... ( do something about it ) nothrow ENDOF
         throw \ pass other errors on
       ENDCASE
     THEN

   プログラミング・スタイル・メモ: いつものように、 エラーを渡すための
‘throw’ の後、 または ‘ENDTRY’ の後のいずれか(または、‘catch’ を使用する
場合は、エラーを処理するための選択構造の終了後)で、 スタックの深さが静的
に明白であることを保証する必要があります。

   ‘throw’ の代替は 2 つあります: ‘Abort"’ は条件付きでエラー・メッセー
ジを提供できます。 ‘Abort’ は「中止」(Abort)エラーを生成するだけです。

   これらのワードの問題は、 例外ハンドラーが、 異なる ‘abort"’ を区別で
きないことです。 例外ハンドラーにとってはそれらは ‘-2 throw’ のように見
えるだけです(標準のプログラムではエラー・メッセージにアクセスできません
)。 同様に、 ‘abort’ は例外ハンドラーに対して ‘-1 throw’ のように見えま
す。

‘ABORT"’ ( compilation ’ccc"’ – ; run-time f –  ) core,exception-ext “abort-quote”
   f のいずれかのビットがゼロ以外の場合、 ‘-2 throw’ の機能を実行し、 例
外スタック上例外フレームがない場合は文字列 ccc を表示します。

‘abort’ ( ?? – ??  ) core,exception-ext “abort”
   ‘-1 throw’.

   実行を中止する必要があるほど深刻でない問題の場合は、 警告を表示するだ
けで済みます。 変数 ‘warnings’ を使用すると、 表示される警告の数を調整で
きます。

‘WARNING"’ ( compilation ’ccc"’ – ; run-time f –  ) gforth-1.0 “WARNING"”
   f がゼロ以外の場合、 警告メッセージとして文字列 ccc を表示します。

‘warnings’ ( – addr  ) gforth-0.2 “warnings”
   以下の警告レベルをセットしてください
‘0’
     警告オフ
‘-1’
     通常警告オン
‘-2’
     初心者警告オン
‘-3’
     偏執狂的警告オン
‘-4’
     全ての警告をエラーとして扱います(初心者警告を含む)


File: gforth.info,  Node: Defining Words,  Next: Interpretation and Compilation Semantics,  Prev: Control Structures,  Up: Words

6.10 Defining Words
===================

定義ワード(defining word)は、 ディクショナリに新しいエントリを作成するこ
とによって Forth を拡張するために使用されます。

* Menu:

* CREATE::
* Variables::                Variables and user variables
* Constants::
* Values::                   Initialised variables
* Varues::
* Colon Definitions::
* Anonymous Definitions::    名前無しのワード定義
* Quotations::
* Supplying names::          定義ワードの名前を文字列として渡す
* User-defined Defining Words::
* Deferred Words::           前方参照の許容
* Forward::                  自動解決される前方参照
* Aliases::


File: gforth.info,  Node: CREATE,  Next: Variables,  Prev: Defining Words,  Up: Defining Words

6.10.1 ‘CREATE’
---------------

定義ワードは、 ディクショナリに新しいエントリを作成するために使用されま
す。 最も単純な定義ワードは ‘CREATE’ です。 ‘CREATE’ は以下のように使用
します:

     CREATE new-word1

   ‘CREATE’ はパース・ワード(parsing word)です。 つまり、入力ストリーム
から引数(argument)を受け取ります(この例では ‘new-word1’ です)。 ‘CREATE’
は ‘new-word1’ のディクショナリ・エントリを作成します。 ‘new-word1’ が実
行される時は、 アドレスがスタックに残されるだけです。 そのアドレスは、
‘new-word1’ が定義された時点のデータ空間ポインタ(‘HERE’)の値を表します。
したがって、 ‘CREATE’ は名前をメモリ領域のアドレスに関連付ける方法です。

‘Create’ ( "name" –  ) core “Create”

   注意: 標準 Forth は、 ‘create’ に対してのみ、 そのボディ部分がディク
ショナリのデータ空間(つまり、 ‘here’ や ‘allot’ などが機能する空間。
*note Dictionary allocation::)にあることを保証することに注意してください
。 また、 標準 Forth では、 ‘does>’ で変更できるのは ‘create’ で作成され
たワードのみで(*note User-defined Defining Words::)、 標準 Forth の
‘>body’ は ‘create’ されたワードにのみ適用できます。

   この new-word1 の例を拡張して、 データ空間にメモリを少々確保すると、
最終的には variable のような代物になります。 これを行う 2 つの異なる方法
を以下に示します:

     CREATE new-word2 1 cells allot  \ 1 セル予約 - 初期値未定義
     CREATE new-word3 4 ,            \ 1 セル予約 かつ (4で)初期化

   これらの変数は、 以下のように ‘@’ (「フェッチ」(fetch;取り出す)) と
‘!’ (「ストア」(store;格納する)) を使用して検査(examine)および変更
(modify)できます:

     new-word2 @ .      \ get address, fetch from it and display
     1234 new-word2 !   \ new value, get address, store to it

   同様のメカニズムを使用して配列を作成できます。 たとえば、 80 文字のテ
キスト入力バッファです:

     CREATE text-buf 80 chars allot

     text-buf 0 chars + c@ \ the 1st character (offset 0)
     text-buf 3 chars + c@ \ the 4th character (offset 3)

   メモリに適切な領域を割り当てることで、 思いつく限りの複雑なデータ構造
を構築できます。 これについてさらに詳しく説明し、 それを容易にする
Gforth ツールについて知りたい場合は、 *Note Structures:: を参照ください
。


File: gforth.info,  Node: Variables,  Next: Constants,  Prev: CREATE,  Up: Defining Words

6.10.2 Variables
----------------

前のセクションでは、 一連のコマンドを使用して変数を生成する方法を説明し
ました。 最終的な改良として、 (次のセクションの主題を先取りして)そのコー
ド・シーケンス全体を定義ワードでまとめることができ、 新しい変数の作成が
容易になります:

     : myvariableX ( "name" -- a-addr ) CREATE 1 cells allot ;
     : myvariable0 ( "name" -- a-addr ) CREATE 0 , ;

     myvariableX foo \ variable foo starts off with an unknown value
     myvariable0 joe \ whilst joe is initialised to 0

     45 3 * foo !   \ set foo to 135
     1234 joe !     \ set joe to 1234
     3 joe +!       \ increment joe by 3.. to 1237

   当然のことながら、 Forth にはすでに ‘Variable’ の定義があるため、
‘myvariable’ を定義する必要はありません。 標準 Forth は、 ‘Variable’ が
作成時に初期化されることを保証しません(つまり、 ‘myvariableX’ のように振
る舞う可能性があります)。 対照的に、Gforth の ‘Variable’ は変数を 0 に初
期化します(つまり、 ‘myvariable0’ とまったく同じように振る舞います)。
Forth は、 倍精度変数と浮動小数点変数に対して、 それぞれ ‘2Variable’ と
‘fvariable’ も提供します。 これらは、Gforth ではそれぞれ 0.  と 0e に初
期化されます。 ‘Variable’ を使用してブール値を保存する場合、 ‘on’ と
‘off’ を使用してその状態を切り替えることができます。

‘Variable’ ( "name" –  ) core “Variable”
   name を定義し、 addr で始まるセルを予約します。 name 実行時: ‘( --
addr )’

‘AVariable’ ( "name" –  ) gforth-0.2 “AVariable”
   ‘variable’ と同様に機能しますが、 (クロス・コンパイルされたコードで使
用される場合)その変数に格納されているセルがアドレスであることをクロス・
コンパイラーに伝えます。

‘2Variable’ ( "name" –  ) double “two-variable”

‘fvariable’ ( "name" –  ) floating “f-variable”

   最後に、 任意の長さのバッファは以下のようになります

‘buffer:’ ( u "name" –  ) core-ext “buffer-colon”
   name を定義し、addr から始まる u バイトを予約します。 name 実行時: ‘(
-- addr )’ なお、 Gforth は予約したバイトを 0 に初期化しますが、 標準で
は保証されません。


File: gforth.info,  Node: Constants,  Next: Values,  Prev: Variables,  Up: Defining Words

6.10.3 Constants
----------------

‘constant’ を使用すると、 固定値を宣言し、 名前でそれを参照できます。 例
:

     12 Constant INCHES-PER-FOOT
     3E+08 fconstant SPEED-O-LIGHT

   ‘Variable’ は読み取りと書き込みの両方ができるため、 その実行時の振る
舞いは、 現在の値を操作できるアドレスを提供することです。 それとは対照的
に、 ‘Constant’ の値は一度宣言すると変更できないため、 アドレスを指定す
る必要はありません(1) – 定数の値を直接返す方が効率的です。 そして正にそ
のとおりになります。 つまり、 定数の実行時の効果は、その値をスタックの頂
上に置くことです((‘Constant’ を実装する方法の1つは *note User-defined
Defining Words:: で見つけることができます)。

   Forth は、それぞれ2倍長定数と浮動小数点定数を定義するための
‘2Constant’ と ‘fconstant’ も提供します。

‘Constant’ ( w "name" –  ) core “Constant”
   定数 name を値 w で定義します。

   name 実行時: – w

‘AConstant’ ( addr "name" –  ) gforth-0.2 “AConstant”
   ‘constant’ と似ていますが、 アドレスのための定数を定義します(これはク
ロス・コンパイラーでのみ違いが生じます)。

‘2Constant’ ( w1 w2 "name" –  ) double “two-constant”

‘fconstant’ ( r "name" –  ) floating “f-constant”

   Forth の定数は、他のプログラミング言語の定数とは異なる振る舞いをしま
す。 他の言語では、 定数(アセンブラの EQU や C の #define など)はコンパ
イル時にのみ存在します。 実行プログラム(executable program)では、 定数は
即値(absolute number)に変換されているため、 シンボリック・デバッガを使用
しない限り、 その数値がどのような抽象的なものを表しているかを知ることは
不可能です。 Forth では、 定数はヘッダー空間にエントリを持ち、 それを使
用するコードが定義された後もそこに残ります。 実際、 実行時に機能する義務
があるため、 それをディクショナリに残しておく必要があります。 例:

     12 Constant INCHES-PER-FOOT
     : FEET-TO-INCHES ( n1 -- n2 ) INCHES-PER-FOOT * ;

   ここで、 ‘FEET-TO-INCHES’ が実行されると、 定数 ‘INCHES-PER-FOOT’ に
関連付けられた xt が実行されます。 ‘see’ を使用して ‘FEET-TO-INCHES’ の
定義を逆コンパイルすると、 ‘INCHES-PER-FOOT’ を呼び出していることがわか
ります。 一部の Forth コンパイラは、定数を使用する場所にインライン展開
(in-lining)することによって定数を最適化しようとします。 以下のようにして
Gforth に定数をインライン化するように強制できます:

     : FEET-TO-INCHES ( n1 -- n2 ) [ INCHES-PER-FOOT ] LITERAL * ;

   ここで、 ‘see’ を使用して ‘FEET-TO-INCHES’ の このバージョンを逆コン
パイルすると、 ‘INCHES-PER-FOOT’ が存在しないことがわかります。 これがど
のように機能するかを理解するには、 *note Interpret/Compile states:: と
*note Literals:: を読んでください。

   この方法で定数をインライン化すると、 実行時間がわずかに改善される可能
性があり、 定数がコンパイル時にのみ参照されるようにすることができます。
ただし、 定数の定義はまだディクショナリに残っています。 一部の Forth コ
ンパイラは、 一時的なワード(transient words)を保持する 2 番目のディクシ
ョナリを制御するメカニズムを提供し、 メモリ領域を回復するために後でこの
2 番目のディクショナリを削除できるようしています。 ただし、 これを行う標
準の方法はありません。

   ---------- Footnotes ----------

   (1) まあ、 多くの場合、 それは可能ではありますが、 標準的な移植可能な
方法では変更できません。 ‘Value’ を使用する方が安全です (続きを読んでく
ださい)まあ、多くの場合変更できますが、標準的な移植可能な方法では変更で
きません。 ‘Value’ (続きを読んでください)


File: gforth.info,  Node: Values,  Next: Varues,  Prev: Constants,  Up: Defining Words

6.10.4 Values
-------------

‘Value’ は ‘Constant’ のように動作しますが、 変更することができます。
‘TO’ は、‘Values’ を変更するパース・ワード(parsing word)です。 (標準
Forth ではなく) Gforth では、 ‘>body’ を使用しても ‘value’ にアクセス(お
よび変更)できます。

   ここで幾つか例を示します:

     12 Value APPLES     \ APPLES を初期値 12 で定義
     34 TO APPLES        \ APPLES の値を変更。 TO はパース・ワード
     1 ' APPLES >body +! \ APPLES をインクリメント。 非標準の使い方
     APPLES              \ スタック頂上に 35 を置く(はず)

‘Value’ ( w "name" –  ) core-ext “Value”
   name を初期値 w で定義します。 この値は ‘to name’ または ‘->name’ で
変更できます(訳注: -> と name の間に空白を開けない。 ->name とする。 ワ
ードではなく、 テキスト・インタプリタの認識器(recognizer)機能によるもの
)。

   name 実行時: – w2

‘AValue’ ( w "name" –  ) gforth-0.6 “AValue”
   Like ‘value’, but defines a value for an address (this only makes a
difference in the cross-compiler).

‘2Value’ ( d "name" –  ) double-ext “two-value”

‘fvalue’ ( r "name" –  ) floating-ext “f-value”
   Define name ‘( -- r1 )’ where r1 initially is r; this value can be
changed with ‘to name’ or ‘->name’.

‘TO’ ( value "name" –  ) core-ext “TO”
   changes the value of NAME to VALUE

‘+TO’ ( value "name" –  ) gforth-1.0 “+TO”
   increments the value of NAME by VALUE


File: gforth.info,  Node: Varues,  Next: Colon Definitions,  Prev: Values,  Up: Defining Words

6.10.5 Varues
-------------

Sometimes you want to take the address of a value-like word.  Because
this has some disadvantages, Gforth asks you to be explicit about it,
and use ‘varue’ (named that way because it combines characteristics of a
variable and a value) to declare the name.

‘Varue’ ( w "name" –  ) gforth-1.0 “Varue”
   Like ‘value’, but you can also use ‘addr name’; in the future, varues
may be less efficient than values.

‘2varue’ ( x1 x2 "name" –  ) gforth-1.0 “2varue”
   Like ‘2value’, but you can also use ‘addr name’; in the future,
2varues may be less efficient than 2values.

‘fvarue’ ( r "name" –  ) gforth-1.0 “fvarue”
   Like ‘fvalue’, but you can also use ‘addr name’; in the future,
fvarues may be less efficient than fvalues.

‘addr’ ( "name" – addr  ) gforth-1.0 “addr”
   provides the address ADDR of the varue, 2varue, or fvarue NAME or a
local name defined with one of ‘wa: ca: da: fa: xta:’.


File: gforth.info,  Node: Colon Definitions,  Next: Anonymous Definitions,  Prev: Varues,  Up: Defining Words

6.10.6 Colon Definitions
------------------------

     : name ( ... -- ... )
         word1 word2 word3 ;

Creates a word called ‘name’ that, upon execution, executes ‘word1 word2
word3’.  ‘name’ is a “(colon) definition”.

   The explanation above is somewhat superficial.  For simple examples
of colon definitions see *note Your first definition::.  For an in-depth
discussion of some of the issues involved, *Note Interpretation and
Compilation Semantics::.

‘:’ ( "name" – colon-sys  ) core “colon”

‘;’ ( compilation colon-sys – ; run-time nest-sys –  ) core “semicolon”

   We plan to to perform automatic inlining eventually, but for now you
can perform inlining with

‘inline:’ ( "name" – inline:-sys  ) gforth-experimental “inline-colon”
   Start inline colon definition.  The code between ‘inline:’ and
‘;inline’ has to compile (not perform) the code to be inlined, but the
resulting definition name is a colon definition that performs the
inlined code.  Note that the compiling code must have the stack effect
‘( -- )’, otherwise you will get an error when Gforth tries to create
the colon definition for name.

‘;inline’ ( inline:-sys –  ) gforth-experimental “semi-inline”
   end inline definition started with ‘inline:’

   As an example, you can define an inlined word and use it with

     inline: my2dup ( a b -- a b a b )
         ]] over over [[ ;inline

     #1. my2dup d. d.
     : foo my2dup ;
     #1. foo d. d.
     see foo

   Inline words are related to macros (*note Macros::); the difference
is that a macro has immediate compilation semantics while an
‘inline:’-defined word has default compilation semantics; this means
that you normally use a macro only inside a colon definition, while you
can use an ‘inline:’ word also interpretively.  But that also means that
you can do some things with macros that you cannot do as an ‘inline:’
word.  E.g.,

     \ Doesn't work:
     \   inline: endif ]] then [[ ;inline
     \ Instead, write a macro:
     : endif ]] then [[ ; immediate

   Conversely, for words that would be fine as non-immediate colon
definitions, define them as non-immediate colon definitions or (if
utmost performance is required) as ‘inline:’ words; don’t define them as
macros, because then you cannot properly use them interpretively:

     : another2dup ]] over over [[ ; immediate
     \ Doesn't work:
     \   #1. another2dup d. d.

   You may wonder why you have to write compiling code between ‘inline:’
and ‘;inline’.  That’s because the implementation of an inline word like
‘my2dup’ above works similar to:

     : compile-my2dup ( xt -- )
         drop ]] over over [[ ;

     : my2dup [ 0 compile-my2dup ] ;
     ' compile-my2dup set-optimizer

   The ‘DROP’ and ‘0’ are there because ‘compile-my2dup’ is the
implementation of ‘compile,’ for ‘my2dup’, and ‘compile,’ expects an xt
(*note User-defined compile-comma::).


File: gforth.info,  Node: Anonymous Definitions,  Next: Quotations,  Prev: Colon Definitions,  Up: Defining Words

6.10.7 Anonymous Definitions
----------------------------

Sometimes you want to define an “anonymous word”; a word without a name.
You can do this with:

‘:noname’ ( – xt colon-sys  ) core-ext “colon-no-name”

   This leaves the execution token for the word on the stack after the
closing ‘;’.  Here’s an example in which a deferred word is initialised
with an ‘xt’ from an anonymous colon definition:

     Defer deferred
     :noname ( ... -- ... )
       ... ;
     IS deferred

Gforth provides an alternative way of doing this, using two separate
words:

‘noname’ ( –  ) gforth-0.2 “noname”
   The next defined word will be anonymous.  The defining word will
leave the input stream alone.  The xt of the defined word will be given
by ‘latestxt’.

‘latestxt’ ( – xt  ) gforth-0.6 “latestxt”
   xt is the execution token of the last word defined.

The previous example can be rewritten using ‘noname’ and ‘latestxt’:

     Defer deferred
     noname : ( ... -- ... )
       ... ;
     latestxt IS deferred

‘noname’ works with any defining word, not just ‘:’.

   ‘latestxt’ also works when the last word was not defined as ‘noname’.
It does not work for combined words, though.  It also has the useful
property that is is valid as soon as the header for a definition has
been built.  Thus:

     latestxt . : foo [ latestxt . ] ; ' foo .

prints 3 numbers; the last two are the same.


File: gforth.info,  Node: Quotations,  Next: Supplying names,  Prev: Anonymous Definitions,  Up: Defining Words

6.10.8 Quotations
-----------------

A quotation is an anonymous colon definition inside another colon
definition.  Quotations are useful when dealing with words that consume
an execution token, like ‘catch’ or ‘outfile-execute’.  E.g.  consider
the following example of using ‘outfile-execute’ (*note Redirection::):

     : some-warning ( n -- )
         cr ." warning# " . ;

     : print-some-warning ( n -- )
         ['] some-warning stderr outfile-execute ;

   Here we defined ‘some-warning’ as a helper word whose xt we could
pass to outfile-execute.  Instead, we can use a quotation to define such
a word anonymously inside ‘print-some-warning’:

     : print-some-warning ( n -- )
       [: cr ." warning# " . ;] stderr outfile-execute ;

   The quotation is bouded by ‘[:’ and ‘;]’.  It produces an execution
token at run-time.

‘[:’ ( compile-time: – quotation-sys flag colon-sys  ) gforth-1.0 “bracket-colon”
   Starts a quotation

‘;]’ ( compile-time: quotation-sys – ; run-time: – xt  ) gforth-1.0 “semi-bracket”
   ends a quotation


File: gforth.info,  Node: Supplying names,  Next: User-defined Defining Words,  Prev: Quotations,  Up: Defining Words

6.10.9 Supplying the name of a defined word
-------------------------------------------

By default, a defining word takes the name for the defined word from the
input stream.  Sometimes you want to supply the name from a string.  You
can do this with:

‘nextname’ ( c-addr u –  ) gforth-0.2 “nextname”
   The next defined word will have the name C-ADDR U; the defining word
will leave the input stream alone.

   For example:

     s" foo" nextname create

is equivalent to:

     create foo

‘nextname’ works with any defining word.


File: gforth.info,  Node: User-defined Defining Words,  Next: Deferred Words,  Prev: Supplying names,  Up: Defining Words

6.10.10 User-defined Defining Words
-----------------------------------

You can define new defining words in terms of any existing defining
word, but ‘:’ and ‘create’...‘does>’/‘set-does>’ are particularly
flexible, whereas the children of, e.g., ‘constant’ are all just
constants.

* Menu:

* User-defined defining words with colon definitions::
* User-defined defining words using CREATE::
* CREATE..DOES> applications::
* CREATE..DOES> details::
* Advanced does> usage example::
* User-defined TO and DEFER@::
* User-defined compile-comma::
* Creating from a prototype::
* Making a word current::
* Const-does>::


File: gforth.info,  Node: User-defined defining words with colon definitions,  Next: User-defined defining words using CREATE,  Prev: User-defined Defining Words,  Up: User-defined Defining Words

6.10.10.1 User-defined defining words with colon definitions
............................................................

You can create a new defining word by wrapping defining-time code around
an existing defining word and putting the sequence in a colon
definition.

   For example, suppose that you have a word ‘stats’ that gathers
statistics about colon definitions given the xt of the definition, and
you want every colon definition in your application to make a call to
‘stats’.  You can define and use a new version of ‘:’ like this:

     : stats
       ( xt -- ) DUP ." (Gathering statistics for " . ." )"
       ... ;  \ other code

     : my: : latestxt postpone literal ['] stats compile, ;

     my: foo + - ;

   When ‘foo’ is defined using ‘my:’ these steps occur:

   • ‘my:’ is executed.
   • The ‘:’ within the definition (the one between ‘my:’ and
     ‘latestxt’) is executed, and does just what it always does; it
     parses the input stream for a name, builds a dictionary header for
     the name ‘foo’ and switches ‘state’ from interpret to compile.
   • The word ‘latestxt’ is executed.  It puts the xt for the word that
     is being defined – ‘foo’ – onto the stack.
   • The code that was produced by ‘postpone literal’ is executed; this
     causes the value on the stack to be compiled as a literal in the
     code area of ‘foo’.
   • The code ‘['] stats’ compiles a literal into the definition of
     ‘my:’.  When ‘compile,’ is executed, that literal – the execution
     token for ‘stats’ – is layed down in the code area of ‘foo’ ,
     following the literal(1).
   • At this point, the execution of ‘my:’ is complete, and control
     returns to the text interpreter.  The text interpreter is in
     compile state, so subsequent text ‘+ -’ is compiled into the
     definition of ‘foo’ and the ‘;’ terminates the definition as
     always.

   You can use ‘see’ to decompile a word that was defined using ‘my:’
and see how it is different from a normal ‘:’ definition.  For example:

     : bar + - ;  \ like foo but using : rather than my:
     see bar
     : bar
       + - ;
     see foo
     : foo
       `foo stats + - ;

   ‘`foo’ is another way of writing ‘['] foo’.

   ---------- Footnotes ----------

   (1) Strictly speaking, the mechanism that ‘compile,’ uses to convert
an xt into something in the code area is implementation-dependent.  A
threaded implementation might spit out the execution token directly
whilst another implementation might spit out a native code sequence.


File: gforth.info,  Node: User-defined defining words using CREATE,  Next: CREATE..DOES> applications,  Prev: User-defined defining words with colon definitions,  Up: User-defined Defining Words

6.10.10.2 User-defined defining words using create
..................................................

If you want the words defined with your defining words to behave
differently from words defined with standard defining words, you can
write your defining word like this:

     : def-word ( "name" -- )
         CREATE code1
     DOES> ( ... -- ... )
         code2 ;

     def-word name

   This fragment defines a “defining word” ‘def-word’ and then executes
it.  When ‘def-word’ executes, it ‘CREATE’s a new word ‘name’, and
executes the code code1.  The code code2 is not executed at this time.
The word ‘name’ is sometimes called a “child” of ‘def-word’.

   When you execute ‘name’, the address of the body of ‘name’ is put on
the data stack and code2 is executed (the address of the body of ‘name’
is the address ‘HERE’ returns immediately after the ‘CREATE’, i.e., the
address a ‘create’d word returns by default).

   You can use ‘def-word’ to define a set of child words that behave
similarly; they all have a common run-time behaviour determined by
code2.  Typically, the code1 sequence builds a data area in the body of
the child word.  The structure of the data is common to all children of
‘def-word’, but the data values are specific – and private – to each
child word.  When a child word is executed, the address of its private
data area is passed as a parameter on TOS to be used and manipulated(1)
by code2.

   The two fragments of code that make up the defining words act (are
executed) at two completely separate times:

   • At define time, the defining word executes code1 to generate a
     child word
   • At child execution time, when a child word is invoked, code2 is
     executed, using parameters (data) that are private and specific to
     the child word.

   Another way of understanding the behaviour of ‘def-word’ and ‘name’
is to say that, if you make the following definitions:
     : def-word1 ( "name" -- )
         CREATE code1 ;

     : action1 ( ... -- ... )
         code2 ;

     def-word1 name1

Then using ‘name1 action1’ is equivalent to using ‘name’.

   Another way of writing ‘def-word’ is (*note Quotations::):

     : def-word ( "name" -- ; name execution: ... -- ... )
         create code1
         [: code2 ;] set-does> ;

   Gforth actually compiles the code using ‘does>’ into code equivalent
to the latter code.  An advantage of the ‘set-does>’ approach is that
you can put other code behind it and you can use it inside control
structures without needing workarounds.  A disadvantage is that it is
Gforth-specific.

   A classic example is that you can define ‘CONSTANT’ in this way:

     : CONSTANT ( w "name" -- )
         CREATE ,
     DOES> ( -- w )
         @ ;

or equivalently

     : CONSTANT ( w "name" -- ; name execution: -- w )
         create ,
         ['] @ set-does> ;

   When you create a constant with ‘5 CONSTANT five’, a set of
define-time actions take place; first a new word ‘five’ is created, then
the value 5 is laid down in the body of ‘five’ with ‘,’.  When ‘five’ is
executed, the address of the body is put on the stack, and ‘@’ retrieves
the value 5.  The word ‘five’ has no code of its own; it simply contains
a data field and the xt of the quotation or of ‘@’.

   The final example in this section is intended to remind you that
space reserved in ‘CREATE’d words is data space and therefore can be
both read and written by a Standard program(2):

     : foo ( "name" -- )
         CREATE -1 ,
     DOES> ( -- )
         @ . ;

     foo first-word
     foo second-word

     123 ' first-word >BODY !

   If ‘first-word’ had been a ‘CREATE’d word, we could simply have
executed it to get the address of its data field.  However, since it was
defined to have ‘DOES>’ actions, its execution semantics are to perform
those ‘DOES>’ actions.  To get the address of its data field it’s
necessary to use ‘'’ to get its xt, then ‘>BODY’ to translate the xt
into the address of the data field.  When you execute ‘first-word’, it
will display ‘123’.  When you execute ‘second-word’ it will display
‘-1’.

   In the examples above the stack comment after the ‘DOES>’ specifies
the stack effect of the defined words, not the stack effect of the
following code (the following code expects the address of the body on
the top of stack, which is not reflected in the stack comment).  This is
the convention that I use and recommend (it clashes a bit with using
locals declarations for stack effect specification, though).

   ---------- Footnotes ----------

   (1) It is legitimate both to read and write to this data area.

   (2) Exercise: use this example as a starting point for your own
implementation of ‘Value’ and ‘TO’ – if you get stuck, investigate the
behaviour of ‘'’ and ‘[']’.


File: gforth.info,  Node: CREATE..DOES> applications,  Next: CREATE..DOES> details,  Prev: User-defined defining words using CREATE,  Up: User-defined Defining Words

6.10.10.3 Applications of ‘CREATE..DOES>’
.........................................

You may wonder how to use this feature.  Here are some usage patterns:

   When you see a sequence of code occurring several times, and you can
identify a meaning, you will factor it out as a colon definition.  When
you see similar colon definitions, you can factor them using
‘CREATE..DOES>’.  E.g., an assembler usually defines several words that
look very similar:
     : ori, ( reg-target reg-source n -- )
         0 asm-reg-reg-imm ;
     : andi, ( reg-target reg-source n -- )
         1 asm-reg-reg-imm ;

This could be factored with:
     : reg-reg-imm ( op-code -- )
         CREATE ,
     DOES> ( reg-target reg-source n -- )
         @ asm-reg-reg-imm ;

     0 reg-reg-imm ori,
     1 reg-reg-imm andi,

   Another view of ‘CREATE..DOES>’ is to consider it as a crude way to
supply a part of the parameters for a word (known as “currying” in the
functional language community).  E.g., ‘+’ needs two parameters.
Creating versions of ‘+’ with one parameter fixed can be done like this:

     : curry+ ( n1 "name" -- )
         CREATE ,
     DOES> ( n2 -- n1+n2 )
         @ + ;

      3 curry+ 3+
     -2 curry+ 2-


File: gforth.info,  Node: CREATE..DOES> details,  Next: Advanced does> usage example,  Prev: CREATE..DOES> applications,  Up: User-defined Defining Words

6.10.10.4 The gory details of ‘CREATE..DOES>’
.............................................

‘DOES>’ ( compilation colon-sys1 – colon-sys2  ) core “does”

   This means that you need not use ‘CREATE’ and ‘DOES>’ in the same
definition; you can put the ‘DOES>’-part in a separate definition.  This
allows us to, e.g., select among different ‘DOES>’-parts:
     : does1
     DOES> ( ... -- ... )
         code1 ;

     : does2
     DOES> ( ... -- ... )
         code2 ;

     : def-word ( ... -- ... )
         create ...
         IF
            does1
         ELSE
            does2
         ENDIF ;

   In this example, the selection of whether to use ‘does1’ or ‘does2’
is made at definition-time; at the time that the child word is
‘CREATE’d.

   Note that the property of ‘does>’ to end the definition makes it
necessary to introduce extra definitions ‘does1’ and ‘does2’.  You can
avoid that with ‘set-does>’:

     : def-word ( ... -- ... )
         create ...
         IF
            [: code1 ;] set-does>
         ELSE
            [: code2 ;] set-does>
         ENDIF ;

   In a standard program you can apply a ‘DOES>’-part only if the last
word was defined with ‘CREATE’.  In Gforth, the ‘DOES>’-part will
override the behaviour of the last word defined in any case.  In a
standard program, you can use ‘DOES>’ only in a colon definition.  In
Gforth, you can also use it in interpretation state, in a kind of
one-shot mode; for example:
     CREATE name ( ... -- ... )
       initialization
     DOES>
       code ;

is equivalent to the standard:
     :noname
     DOES>
         code ;
     CREATE name EXECUTE ( ... -- ... )
         initialization

   Gforth also supports quotations in interpreted code, and quotations
save and restore the current definition, so you can also write the
example above also as:

     CREATE name ( ... -- ... )
       initialization
     [: code ;] set-does>

‘set-does>’ ( xt –  ) gforth-1.0 “set-does>”
   Changes the current word such that it pushes its body address and
then executes xt.  Also changes the ‘compile,’ implementation
accordingly.  Call ‘set-optimizer’ afterwards if you want a more
efficient implementation.

‘>body’ ( xt – a_addr  ) core “to-body”
   Get the address of the body of the word represented by xt (the
address of the word’s data field).


File: gforth.info,  Node: Advanced does> usage example,  Next: User-defined TO and DEFER@,  Prev: CREATE..DOES> details,  Up: User-defined Defining Words

6.10.10.5 Advanced does> usage example
......................................

The MIPS disassembler (‘arch/mips/disasm.fs’) contains many words for
disassembling instructions, that follow a very repetetive scheme:

     :noname DISASM-OPERANDS s" INST-NAME" type ;
     ENTRY-NUM cells TABLE + !

   Of course, this inspires the idea to factor out the commonalities to
allow a definition like

     DISASM-OPERANDS ENTRY-NUM TABLE define-inst INST-NAME

   The parameters DISASM-OPERANDS and TABLE are usually correlated.
Moreover, before I wrote the disassembler, there already existed code
that defines instructions like this:

     ENTRY-NUM INST-FORMAT INST-NAME

   This code comes from the assembler and resides in
‘arch/mips/insts.fs’.

   So I had to define the INST-FORMAT words that performed the scheme
above when executed.  At first I chose to use run-time code-generation:

     : INST-FORMAT ( entry-num "name" -- ; compiled code: addr w -- )
       :noname Postpone DISASM-OPERANDS
       name Postpone sliteral Postpone type Postpone ;
       swap cells TABLE + ! ;

   Note that this supplies the other two parameters of the scheme above.

   An alternative would have been to write this using ‘create’/‘does>’:

     : INST-FORMAT ( entry-num "name" -- )
       here name string, ( entry-num c-addr ) \ parse and save "name"
       noname create , ( entry-num )
       latestxt swap cells TABLE + !
     does> ( addr w -- )
       \ disassemble instruction w at addr
       @ >r
       DISASM-OPERANDS
       r> count type ;

   Somehow the first solution is simpler, mainly because it’s simpler to
shift a string from definition-time to use-time with ‘sliteral’ than
with ‘string,’ and friends.

   I wrote a lot of words following this scheme and soon thought about
factoring out the commonalities among them.  Note that this uses a
two-level defining word, i.e., a word that defines ordinary defining
words.

   This time a solution involving ‘postpone’ and friends seemed more
difficult (try it as an exercise), so I decided to use a
‘create’/‘does>’ word; since I was already at it, I also used
‘create’/‘does>’ for the lower level (try using ‘postpone’ etc.  as an
exercise), resulting in the following definition:

     : define-format ( disasm-xt table-xt -- )
         \ define an instruction format that uses disasm-xt for
         \ disassembling and enters the defined instructions into table
         \ table-xt
         create 2,
     does> ( u "inst" -- )
         \ defines an anonymous word for disassembling instruction inst,
         \ and enters it as u-th entry into table-xt
         2@ swap here name string, ( u table-xt disasm-xt c-addr ) \ remember string
         noname create 2,      \ define anonymous word
         execute latestxt swap ! \ enter xt of defined word into table-xt
     does> ( addr w -- )
         \ disassemble instruction w at addr
         2@ >r ( addr w disasm-xt R: c-addr )
         execute ( R: c-addr ) \ disassemble operands
         r> count type ; \ print name

   Note that the tables here (in contrast to above) do the ‘cells +’ by
themselves (that’s why you have to pass an xt).  This word is used in
the following way:

     ' DISASM-OPERANDS ' TABLE define-format INST-FORMAT

   As shown above, the defined instruction format is then used like
this:

     ENTRY-NUM INST-FORMAT INST-NAME

   In terms of currying, this kind of two-level defining word provides
the parameters in three stages: first DISASM-OPERANDS and TABLE, then
ENTRY-NUM and INST-NAME, finally ‘addr w’, i.e., the instruction to be
disassembled.

   Of course this did not quite fit all the instruction format names
used in ‘insts.fs’, so I had to define a few wrappers that conditioned
the parameters into the right form.

   If you have trouble following this section, don’t worry.  First, this
is involved and takes time (and probably some playing around) to
understand; second, this is the first two-level ‘create’/‘does>’ word I
have written in seventeen years of Forth; and if I did not have
‘insts.fs’ to start with, I may well have elected to use just a
one-level defining word (with some repeating of parameters when using
the defining word).  So it is not necessary to understand this, but it
may improve your understanding of Forth.


File: gforth.info,  Node: User-defined TO and DEFER@,  Next: User-defined compile-comma,  Prev: Advanced does> usage example,  Up: User-defined Defining Words

6.10.10.6 User-defined ‘to’ and ‘defer@’
........................................

Gforth’s values have several operators: ‘to’ (to which ‘is’ is an alias,
and ‘defer!’ takes an xt instead of a name in the input stream), ‘+to’,
‘addr’, and ‘action-of’ (where ‘defer@’ takes an xt instead of a name in
the input stream).

   Gforth allows you to change the ‘(to)’ action of a word.

‘(to)’ ( val operation xt –  ) gforth-1.0 “paren-to”
   xt is of a value like word name.  Stores val ‘to’ name.  operation
selects between ‘to’, ‘+to’, ‘addr’, and ‘action-of’.

‘to-table:’ ( "name" "xt1" .. "xtn" –  ) gforth-experimental “to-table-colon”
   create a table with entries for ‘TO’, ‘+TO’, ‘ADDR’, and ‘ACTION-OF’.
Use ‘n/a’ to mark unsupported operations.

‘to-method:’ ( xt table "name" –  ) gforth-experimental “to-method-colon”
   create a to-method, where XT computes the address to access the
field, and TABLE contains the operators to store to it.

‘set-to’ ( to-xt –  ) gforth-1.0 “set-to”
   Sets the implementation of the ‘(to) ( val xt -- )’ method of the
current word to to-xt.

‘n/a’ ( –  ) gforth-experimental “not-available”
   this word can be ticked, but throws an “Operation not supported”
exception on interpretation and compilation.  Use this for methods and
alike that aren’t supported.

   ‘(to)’ is a word used inside ‘to’: it stores the value at run-time.
The general stack effect of ‘(to)’ method is ‘( val operation xt -- )’,
where xt identifies the word stored into, operation the actual variant
of ‘to’-like operations, and val is the value (of appropriate type)
stored there.

   You shall implement the ‘to’-method using ‘to-table:’ to create a
type-specific table of operations (not specified slots at the end of the
table are filled up with ‘n/a’), and using ‘to-method:’ together with
the operation to get from the xt of the value to its data field (usually
‘>body’ for values in the dictionary, but value-style data can also
reside in structures or user areas).

   E.g., one can implement ‘fvalue’ as follows:

     to-table: f!-table f! f+!
     ' >body f!-table to-method: fvalue-to

     : fvalue ( r "name" -- ; name: -- r )
       create f,
       ['] f@ set-does>
       ['] fvalue-to set-to ;

     5e fvalue foo
     : bar foo 1e f+ to foo ;
     see bar


File: gforth.info,  Node: User-defined compile-comma,  Next: Creating from a prototype,  Prev: User-defined TO and DEFER@,  Up: User-defined Defining Words

6.10.10.7 User-defined ‘compile,’
.................................

You can also change the implementation of ‘compile,’ for a word, with

‘set-optimizer’ ( xt –  ) gforth-1.0 “set-optimizer”
   Changes the current word such that ‘compile,’ing it executes xt (with
the same stack contents as passed to ‘compile,’).  Note that ‘compile,’
must be consistent with ‘execute’, so you must use ‘set-optimizer’ only
to install a more efficient implementation of the same behaviour.

‘opt:’ ( compilation – colon-sys2 ; run-time – nest-sys  ) gforth-1.0 “opt:”
   Starts a nameless colon definition; when it is complete, this colon
definition will become the ‘compile,’ implementation of the latest word
(before the ‘opt:’).

   Note that the resulting ‘compile,’ must still be equivalent to
‘postpone literal postpone execute’, so ‘set-optimizer’ is useful for
efficiency, not for changing the behaviour.  There is nothing that
prevents you from shooting yourself in the foot, however.  You can check
whether your uses of ‘set-optimizer’ are correct by comparing the
results when you use it with the results you get when you disable your
uses by first defining

     : set-optimizer drop ;

   As an example of the use of ‘set-optimizer’, we can enhance one of
the definitions of ‘CONSTANT’ above as follows.

     : CONSTANT ( n "name" -- ; name: -- n )
       create ,
       ['] @ set-does>
       [: >body @ postpone literal ;] set-optimizer
     ;

   The only change is the addition of the ‘set-optimizer’ line.  When
you define a constant and compile it:

     5 constant five
     : foo five ;

   the compiled ‘five’ in ‘foo’ is now compiled to the literal 5 instead
of a generic invocation of ‘five’.  The quotation has the same stack
effect as ‘compile,’: ‘( xt -- )’.  The passed xt belongs to the
‘compile,’d word, i.e., ‘five’ in the example.  In the example the xt is
first converted to the body address, then the value 5 at that place is
fetched, and that value is compiled with the ‘postpone literal’ (*note
Literals::).

   This use of ‘set-optimizer’ assumes that the user does not change the
value of a constant with, e.g., ‘6 ' five >body !’.  While ‘five’ has
been defined with ‘create’, that is an implementation detail of
‘CONSTANT’, and if you don’t document it, the user must not rely on it.
And if you use ‘set-optimizer’ in a way that assumes that the body does
not change (like is done here), you must not document that ‘create’ is
used; and conversely, if you document it, you have to write the
‘compile,’ implementation such that it can deal with changing bodies.

   Another example is a better-optimized variant of the ‘fvalue’ example
above:

     : compile-fvalue-to ( xt-value-to -- )
       drop ]] >body f! [[ ;

     : fvalue-to ( r xt -- )
       >body f! ;
     ' compile-fvalue-to set-optimizer

     : fvalue ( r "name" -- ; name: -- r )
       create f,
       ['] f@ set-does>
       [: >body ]] literal f@ [[ ;] set-optimizer
       ['] fvalue-to set-to ;

     5e fvalue foo
     : bar foo 1e f+ to foo ;
     see bar

   Compare the code for ‘bar’ with the one for the earlier definition.
Here we see the optimization of both the code for reading the fvalue
(coming from the ‘set-optimizer’ in ‘fvalue’) and for writing the fvalue
(coming from the ‘set-optimizer’ applied to ‘fvalue-to’.  Because an
fvalue can change (unlike a constant), the reading part (inside
‘fvalue’) compiles the address and a ‘f@’ that is performed at run-time.

   For ‘fvalue-to’, the ‘compile,’ implementation basically just
compiles the code executed by ‘fvalue’ inline.  The compilation
semantics of ‘to’ compiles the address as literal and then the ‘(to)’
implementation (i.e., ‘fvalue-to’).  In this process the ‘>body’ is
optimized away.

   In practice Gforth’s ‘fvalue’ includes a few additional twists, e.g.,
to support ‘+TO’.

   Note that the call to ‘set-optimizer’ has to be performed after the
call to ‘set-does>’ (or ‘does>’, because ‘set-does>’ overwrites the
‘compile,’ implementation itself.

   As we can see in the ‘fvalue-to’ example, we can also apply
‘set-optimizer’ to individual words rather than inside a defining word
like ‘constant’ or ‘fvalue’.  In this case, the xt of the word passed to
optimizer is usually unnecessary and is ‘drop’ped, as in
‘compile-fvalue-to’.

   The engine ‘gforth-itc’ uses ‘,’ for ‘compile,’ and ‘set-optimizer’
has no effect there.


File: gforth.info,  Node: Creating from a prototype,  Next: Making a word current,  Prev: User-defined compile-comma,  Up: User-defined Defining Words

6.10.10.8 Creating from a prototype
...................................

In the above we show how to define a word by first using ‘create’, and
then modifying it with ‘set-does>’, ‘set-to’, ‘set-optimizer’ etc.

   An alternative way is to create a prototype using these words, and
then create a new word from that prototype.  This kind of copying does
not cover the body, so that has to be allocated and initialized
explicitly.  Taking ‘fvalue’ above, we could instead define it as:

     create fvalue-prototype ( -- r )
     ['] f@ set-does>
     [: >body ]] literal f@ [[ ;] set-optimizer
     ['] fvalue-to set-to

     : fvalue ( r "name" -- ; name: -- r )
       ``fvalue-prototype create-from f, reveal ;

   An advantage of this approach is that creating ‘fvalue’ words is now
faster, because it does not need to first duplicate the header methods
of ‘create’, modify them, and eventually deduplicate them.  But this
advantage is only relevant if the number of words created with this
defining word is huge.

‘create-from’ ( nt "name" –  ) gforth-1.0 “create-from”
   Create a word name that behaves like nt, but with an empty body.  nt
must be the nt of a named word.  The resulting header is not yet
revealed.  Creating a word with ‘create-from’ without using any ‘set-’
words is faster than if you create a word using ‘set-’ words,
‘immediate’, or ‘does>’.  You can use ‘noname’ with ‘create-from’.

‘reveal’ ( –  ) gforth-0.2 “reveal”
   Put the current word in the wordlist current at the time of the
header definition.

   The performance advantage does not extend to using ‘noname’ with the
defining word.  Therefore we also have

‘noname-from’ ( xt –  ) gforth-1.0 “noname-from”
   Create a nameless word that behaves like xt, but with an empty body.
xt must be the nt of a nameless word.

   Here’s a usage example:

     ``fvalue-prototype noname create-from
     latestnt constant noname-fvalue-prototype

     : noname-fvalue ( r -- xt ; xt execution: -- r )
       noname-fvalue-prototype noname-from f,
       latestxt ;


File: gforth.info,  Node: Making a word current,  Next: Const-does>,  Prev: Creating from a prototype,  Up: User-defined Defining Words

6.10.10.9 Making a word current
...............................

Many words mentioned above, such as ‘immediate’ or ‘set-optimizer’
change the “current” or “most recently defined” word.  Sometimes you
want to change an earlier word.  You can do this with

‘make-latest’ ( nt –  ) gforth-1.0 “make-latest”
   Make nt the latest definition, which can be manipulated by
‘immediate’ and ‘set-*’ operations.  If you have used (especially
compiled) the word referred to by nt already, do not change the
behaviour of the word (only its implementation), otherwise you may get a
surprising mix of behaviours that is not consistent between Gforth
engines and versions.


File: gforth.info,  Node: Const-does>,  Prev: Making a word current,  Up: User-defined Defining Words

6.10.10.10 ‘Const-does>’
........................

A frequent use of ‘create’...‘does>’ is for transferring some values
from definition-time to run-time.  Gforth supports this use with

‘const-does>’ ( run-time: w*uw r*ur uw ur "name" –  ) gforth-obsolete “const-does”
   Defines NAME and returns.

   NAME execution: pushes W*UW R*UR, then performs the code following
the ‘const-does>’.

   A typical use of this word is:

     : curry+ ( n1 "name" -- )
     1 0 CONST-DOES> ( n2 -- n1+n2 )
         + ;

     3 curry+ 3+

   Here the ‘1 0’ means that 1 cell and 0 floats are transferred from
definition to run-time.

   The advantages of using ‘const-does>’ are:

   • You don’t have to deal with storing and retrieving the values,
     i.e., your program becomes more writable and readable.

   • When using ‘does>’, you have to introduce a ‘@’ that cannot be
     optimized away (because you could change the data using
     ‘>body’...‘!’); ‘const-does>’ avoids this problem.

   A Standard Forth implementation of ‘const-does>’ is available in
‘compat/const-does.fs’.


File: gforth.info,  Node: Deferred Words,  Next: Forward,  Prev: User-defined Defining Words,  Up: Defining Words

6.10.11 Deferred Words
----------------------

The defining word ‘Defer’ allows you to define a word by name without
defining its behaviour; the definition of its behaviour is deferred.
Here are two situation where this can be useful:

   • Where you want to allow the behaviour of a word to be altered
     later, and for all precompiled references to the word to change
     when its behaviour is changed.
   • For mutual recursion; *Note Calls and returns::.

   In the following example, ‘foo’ always invokes the version of ‘greet’
that prints “‘Good morning’” whilst ‘bar’ always invokes the version
that prints “‘Hello’”.  There is no way of getting ‘foo’ to use the
later version without re-ordering the source code and recompiling it.

     : greet ." Good morning" ;
     : foo ... greet ... ;
     : greet ." Hello" ;
     : bar ... greet ... ;

   This problem can be solved by defining ‘greet’ as a ‘Defer’red word.
The behaviour of a ‘Defer’red word can be defined and redefined at any
time by using ‘IS’ to associate the xt of a previously-defined word with
it.  The previous example becomes:

     Defer greet ( -- )
     : foo ... greet ... ;
     : bar ... greet ... ;
     : greet1 ( -- ) ." Good morning" ;
     : greet2 ( -- ) ." Hello" ;
     ' greet2 IS greet  \ make greet behave like greet2

   プログラミング・スタイル・メモ: You should write a stack comment for
every deferred word, and put only XTs into deferred words that conform
to this stack effect.  Otherwise it’s too difficult to use the deferred
word.

   A deferred word can be used to improve the statistics-gathering
example from *note User-defined Defining Words::; rather than edit the
application’s source code to change every ‘:’ to a ‘my:’, do this:

     : real: : ;     \ retain access to the original
     defer :         \ redefine as a deferred word
     ' my: IS :      \ use special version of :
     \
     \ load application here
     \
     ' real: IS :    \ go back to the original

   One thing to note is that ‘IS’ has special compilation semantics,
such that it parses the name at compile time (like ‘TO’):

     : set-greet ( xt -- )
       IS greet ;

     ' greet1 set-greet

   In situations where ‘IS’ does not fit, use ‘defer!’ instead.

   A deferred word can only inherit execution semantics from the xt
(because that is all that an xt can represent – for more discussion of
this *note Tokens for Words::); by default it will have default
interpretation and compilation semantics deriving from this execution
semantics.  However, you can change the interpretation and compilation
semantics of the deferred word in the usual ways:

     : bar .... ; immediate
     Defer fred immediate
     Defer jim

     ' bar IS jim  \ jim has default semantics
     ' bar IS fred \ fred is immediate

‘Defer’ ( "name" –  ) core-ext “Defer”
   Define a deferred word name; its execution semantics can be set with
‘defer!’ or ‘is’ (and they have to, before first executing name.

‘defer!’ ( xt xt-deferred –  ) core-ext “defer-store”
   Changes the ‘defer’red word XT-DEFERRED to execute XT.

‘IS’ ( value "name" –  ) core-ext “IS”
   changes the ‘defer’red word NAME to execute VALUE

‘defer@’ ( xt-deferred – xt  ) core-ext “new-defer-fetch”
   xt represents the word currently associated with the deferred word
xt-deferred.

‘action-of’ ( interpretation "name" – xt; compilation "name" – ; run-time – xt  ) core-ext “action-of”
   Xt is the XT that is currently assigned to name.

   Definitions of these Forth-2012 words in Forth-94 are provided in
‘compat/defer.fs’.  In addition, Gforth provides:

‘defers’ ( compilation "name" – ; run-time ... – ...  ) gforth-0.2 “defers”
   Compiles the present contents of the deferred word name into the
current definition.  I.e., this produces static binding as if name was
not deferred.

‘wrap-xt’ ( xt1 xt2 xt: xt3 – ...  ) gforth-1.0 “wrap-xt”
   Set deferred word xt2 to xt1 and execute xt3.  Restore afterwards.

‘preserve’ ( "name" –  ) gforth-1.0 “preserve”
   emit code that reverts a deferred word to the state at compilation


File: gforth.info,  Node: Forward,  Next: Aliases,  Prev: Deferred Words,  Up: Defining Words

6.10.12 Forward
---------------

The defining word ‘Forward’ in ‘forward.fs’ allows you to create forward
references, which are resolved automatically, and do not incur
additional costs like the indirection of ‘Defer’.  However, these
forward definitions only work for colon definitions.

‘forward’ ( "name" –  ) gforth-1.0 “forward”
   Defines a forward reference to a colon definition.  Defining a colon
definition with the same name in the same wordlist resolves the forward
references.  Use ‘.unresolved’ to check whether any forwards are
unresolved.

‘.unresolved’ ( –  ) gforth-1.0 “.unresolved”
   print all unresolved forward references


File: gforth.info,  Node: Aliases,  Prev: Forward,  Up: Defining Words

6.10.13 Aliases
---------------

The defining word ‘synonym’ allows you to define a word by name that has
the same behaviour as some other word.  Here are two situation where
this can be useful:

   • When you want access to a word’s definition from a different word
     list (for an example of this, see the definition of the ‘Root’ word
     list in the Gforth source).
   • When you want to create a synonym; a definition that can be known
     by either of two names (for example, ‘THEN’ and ‘ENDIF’ are
     synonyms).

‘Synonym’ ( "name" "oldname" –  ) tools-ext “Synonym”
   Define name to behave the same way as oldname: Same interpretation
semantics, same compilation semantics, same ‘to’/‘defer!’ and ‘defer@’
semantics.

   Gforth also offers the non-standard ‘alias’, that does not inherit
the compilation semantics, ‘to’/‘defer!’ or ‘defer@’ semantics from its
parent.  You can then change, e.g., the compilation semantics with,
e.g., ‘immediate’.

‘Alias’ ( xt "name" –  ) gforth-0.2 “Alias”
   Define name as a word that performs xt.  Unlike for deferred words,
aliases don’t have an indirection overhead when compiled.

   Example:

     : foo ... ; immediate

     ' foo Alias bar1           \ bar1 is not an immediate word
     ' foo Alias bar2 immediate \ bar2 is an immediate word
     synonym bar3 foo           \ bar3 is an immediate word

   Both synonyms and aliases have a different nt than the original, but
ticking it (or using ‘name>interpret’) produces the same xt as the
original (*note Tokens for Words::).


File: gforth.info,  Node: Interpretation and Compilation Semantics,  Next: Tokens for Words,  Prev: Defining Words,  Up: Words

6.11 Interpretation and Compilation Semantics
=============================================

The “interpretation semantics” of a (named) word are what the text
interpreter does when it encounters the word in interpret state.  It
also appears in some other contexts, e.g., the execution token returned
by ‘' word’ identifies the interpretation semantics of word (in other
words, ‘' word execute’ is equivalent to interpret-state text
interpretation of ‘word’).

   The “compilation semantics” of a (named) word are what the text
interpreter does when it encounters the word in compile state.  It also
appears in other contexts, e.g, ‘POSTPONE word’ compiles(1) the
compilation semantics of word.

   Most words have default compilation semantics: compile the execution
semantics (stack effect ‘( -- )’).  But a number of words have other
compilation semantics, documented for the individual word (including its
stack effect).

   The standard also talks about “execution semantics”.  In the standard
it never differs from the interpretation semantics if both are defined,
but one or both of them may not be defined.  Gforth makes no difference
between interpretation and execution semantics, so these terms are used
interchangeably.

   In Gforth (since 1.0) all words have defined interpretation/execution
semantics.  For many words that have no defined interpretation nor
execution semantics in the standard (e.g., ‘if’), the
interpretation/execution semantics in Gforth are to perform the
compilation semantics.

   In the standard, execution semantics are used to define
interpretation and compilation semantics by default: By default, the
interpretation semantics of a word are to ‘execute’ its execution
semantics, and the compilation semantics of a word are to ‘compile,’ its
execution semantics.(2)

   Unnamed words (*note Anonymous Definitions::) cannot be encountered
by the text interpreter, ticked, or ‘postpone’d.  Such a word is
represented by its xt (*note Tokens for Words::), and the behaviour when
this xt is ‘execute’d is called its execution semantics.

   You can change the semantics of the most-recently defined word:

‘immediate’ ( –  ) core “immediate”
   Make the compilation semantics of a word be to ‘execute’ the
execution semantics.

‘compile-only’ ( –  ) gforth-0.2 “compile-only”
   Mark the last definition as compile-only; as a result, the text
interpreter and ‘'’ will warn when they encounter such a word.

‘restrict’ ( –  ) gforth-0.2 “restrict”
   A synonym for ‘compile-only’

   By convention, words with non-default compilation semantics (e.g.,
immediate words) often have names surrounded with brackets (e.g., ‘[']’,
*note Execution token::).

   Note that ticking (‘'’) a compile-only word gives a warning (“<word>
is compile-only”).

* Menu:

* Combined words::

   ---------- Footnotes ----------

   (1) In standard terminology, “appends to the current definition”.

   (2) In standard terminology: The default interpretation semantics are
its execution semantics; the default compilation semantics are to append
its execution semantics to the execution semantics of the current
definition.


File: gforth.info,  Node: Combined words,  Prev: Interpretation and Compilation Semantics,  Up: Interpretation and Compilation Semantics

6.11.1 Combined Words
---------------------

Gforth allows you to define “combined words” – words that have an
arbitrary combination of interpretation and compilation semantics.

‘interpret/compile:’ ( interp-xt comp-xt "name" –  ) gforth-0.2 “interpret/compile:”

   This feature was introduced for implementing ‘TO’ and ‘S"’.  I
recommend that you do not define such words, as cute as they may be:
they make it hard to get at both parts of the word in some contexts.
E.g., assume you want to get an execution token for the compilation
part.  Instead, define two words, one that embodies the interpretation
part, and one that embodies the compilation part.  Once you have done
that, you can define a combined word with ‘interpret/compile:’ for the
convenience of your users.

   You might try to use this feature to provide an optimizing
implementation of the default compilation semantics of a word.  For
example, by defining:
     :noname
        foo bar ;
     :noname
        POSTPONE foo POSTPONE bar ;
     interpret/compile: opti-foobar

as an optimizing version of:

     : foobar
         foo bar ;

   Unfortunately, this does not work correctly with ‘[compile]’, because
‘[compile]’ assumes that the compilation semantics of all
‘interpret/compile:’ words are non-default.  I.e., ‘[compile]
opti-foobar’ would compile compilation semantics, whereas ‘[compile]
foobar’ would compile interpretation semantics.

   Some people try to use “state-smart” words to emulate the feature
provided by ‘interpret/compile:’ (words are state-smart if they check
‘STATE’ during execution).  E.g., they would try to code ‘foobar’ like
this:

     : foobar
       STATE @
       IF ( compilation state )
         POSTPONE foo POSTPONE bar
       ELSE
         foo bar
       ENDIF ; immediate

   Although this works if ‘foobar’ is only processed by the text
interpreter, it does not work in other contexts (like ‘'’ or
‘POSTPONE’).  E.g., ‘' foobar’ will produce an execution token for a
state-smart word, not for the interpretation semantics of the original
‘foobar’; when you execute this execution token (directly with ‘EXECUTE’
or indirectly through ‘COMPILE,’) in compile state, the result will not
be what you expected (i.e., it will not perform ‘foo bar’).  State-smart
words are a bad idea.  Simply don’t write them(1)!

   ---------- Footnotes ----------

   (1) For a more detailed discussion of this topic, see M. Anton Ertl,
‘‘State’-smartness—Why it is Evil and How to Exorcise it
(https://www.complang.tuwien.ac.at/papers/ertl98.ps.gz)’, EuroForth ’98.


File: gforth.info,  Node: Tokens for Words,  Next: Compiling words,  Prev: Interpretation and Compilation Semantics,  Up: Words

6.12 Tokens for Words
=====================

This section describes the creation and use of tokens that represent
words.

* Menu:

* Execution token::          実行/インタプリタ
                               機能(execution/interpretation semantics)
* Name token::               名前付きワード
* Compilation token::        コンパイル機能(compilation semantics)


File: gforth.info,  Node: Execution token,  Next: Name token,  Prev: Tokens for Words,  Up: Tokens for Words

6.12.1 Execution token
----------------------

An “execution token” (_xt_) represents some behaviour of a word.  You
can use ‘execute’ to invoke the behaviour represented by the xt and
‘compile,’ (*note Macros::) to compile it into the current definition.
Other uses include deferred words (*note Deferred Words::).

   In particular, there is _the_ execution token of a word that
represents its interpretation semantics aka execution semantics.(1)

   For a named word x, you can use ‘`x’ to get its execution token:

     5 `. ( n xt )
     execute ( )      \ execute the xt (i.e., ".")
     : foo `. execute ;
     5 foo

   However, the ‘`’ prefix is a Gforth extension, so you may prefer to
use the standard Forth words:

‘'’ ( "name" – xt  ) core “tick”
   xt represents name’s interpretation semantics.  Perform ‘-14 throw’
if the word has no interpretation semantics.

‘[']’ ( compilation. "name" – ; run-time. – xt  ) core “bracket-tick”
   xt represents name’s interpretation semantics.  Perform ‘-14 throw’
if the word has no interpretation semantics.

   These are parsing words (whereas ‘`x’ is treated as a literal by a
recognizer), and you may find the behaviour in interpreted and compiled
code unintuitive:

     5 ' .   ( n xt )
     execute ( )      \ execute the xt of .
     \ does not work as intended:
     \ : foo ' . ;
     \ 5 foo execute
     \ instead:
     : foo ['] . ;
     5 foo execute    \ execute the xt of .
     \ Usage of ' in colon definition:
     : bar ' execute ;
     5 bar .          \ execute the xt of .

   ‘'’ parses at run-time, so if you put it in a colon definition, as in
‘bar’, it does not consume the next word in the colon definition, but
the next word at run-time (i.e., the ‘.’ in the invocation of ‘bar’).
If you want to put a literal xt in a colon definition without writing
‘`x’, write ‘['] x’.

   Gforth’s ‘`x’, ‘'’ and ‘[']’ warn when you use them on compile-only
words, because such usage may be non-portable between different Forth
systems.

   You can avoid that warning as well as the portability problems by
defining an immediate variant of the word, e.g.:

     : if postpone if ; immediate
     : test [ ' if execute ] ." test" then ;

   The resulting execution token performs the compilation semantics of
‘if’ when ‘execute’d.

   Another way to get an xt is ‘:noname’ or ‘latestxt’ (*note Anonymous
Definitions::).  For anonymous words this gives an xt for the only
behaviour the word has (the execution semantics), but you can also use
it after defining a named word to get its xt.

     :noname ." hello" ;
     execute

   An xt occupies one cell and can be manipulated like any other cell.

   In Standard Forth the xt is just an abstract data type (i.e., defined
by the operations that produce or consume it).  The concrete
implementation (since Gforth 1.0) is the body address (for old hands:
PFA) of the word; in Gforth 0.7 and earlier, the xt was implemented as
code field addres (CFA, 2 cells before the PFA).

‘execute’ ( xt – ) core “execute”
   Perform the semantics represented by the execution token, xt.

‘execute-exit’ ( compilation – ; run-time xt nest-sys –  ) gforth-1.0 “execute-exit”
   Execute ‘xt’ and return from the current definition, in a
tail-call-optimized way: The return address ‘nest-sys’ and the locals
are deallocated before executing ‘xt’.

‘perform’ ( a-addr – ) gforth-0.2 “perform”
   ‘@ execute’.

   ‘Noop’ is sometimes used to have a placeholder execution token:

‘noop’ ( – ) gforth-0.2 “noop”

   ---------- Footnotes ----------

   (1) The Forth standard has words with undefined interpretation
semantics (e.g., ‘r@’) and words without defined execution semantics
(e.g., ‘s"’) and words with neither (e.g., ‘if’), but in cases where
both interpretation and execution semantics are defined, they are the
same; so we treat them as being the same.


File: gforth.info,  Node: Name token,  Next: Compilation token,  Prev: Execution token,  Up: Tokens for Words

6.12.2 Name token
-----------------

Gforth represents named words by the “name token”, (nt).  The name token
is a cell-sized abstract data type that occurs as argument or result of
the words below.

   Since Gforth 1.0, for most words the concrete implementation of their
nt is the same address as its xt (this is the primary nt for the xt).
However, synonyms, aliases, and words defined with ‘interpret/compile:’
get their xt from another word, but still have an nt of their own (that
is different from the xt).  Therefore, you cannot use xts and nts
interchangeably, even if you are prepared to write code specific to
Gforth 1.0.  You do not get these alternate nts for the xt with ‘>name’.

   You get the nt of a word x with ‘``x’ (since Gforth 1.0) or with

‘find-name’ ( c-addr u – nt | 0  ) gforth-0.2 “find-name”
   Find the name c-addr u in the current search order.  Return its nt,
if found, otherwise 0.

‘find-name-in’ ( c-addr u wid – nt | 0  ) gforth-1.0 “find-name-in”
   search the word list identified by wid for the definition named by
the string at c-addr u.  Return its nt, if found, otherwise 0.

‘latest’ ( – nt  ) gforth-0.6 “latest”
   NT is the name token of the last word defined; it is 0 if the last
word has no name.

‘latestnt’ ( – nt  ) gforth-1.0 “latestnt”
   nt is the name token of the last word defined.

‘>name’ ( xt – nt|0  ) gforth-0.2 “to-name”
   The primary name token nt of the word represented by xt.  Returns 0
if xt is not an xt (using a heuristic check that has a small chance of
misidentifying a non-xt as xt), or if the primary nt is of an unnamed
word.  As of Gforth 1.0, every xt has a primary nt, but other named
words may have the same interpretation sematics xt.

‘xt>name’ ( xt – nt  ) gforth-1.0 “xt-to-name”
   Produces the primary nt for an xt.  If xt is not an xt, nt is not
guaranteed to be an nt.

   You can get all the nts in a wordlist with

‘traverse-wordlist’ ( ... xt wid – ...  ) tools-ext “traverse-wordlist”
   perform xt ( ...  nt – f ...  )  once for every word nt in the
wordlist wid, until f is false or the wordlist is exhausted.  xt is free
to use the stack underneath.

   You can use the nt to access the interpretation and compilation
semantics of a word, its name, and the next word in the wordlist:

‘name>interpret’ ( nt – xt  ) tools-ext “name-to-interpret”
   xt represents the interpretation semantics of the word nt.

‘name>compile’ ( nt – w xt  ) tools-ext “name-to-compile”
   w xt is the compilation token for the word nt.

‘name>string’ ( nt – addr u  ) tools-ext “name-to-string”
   addr count is the name of the word represented by nt.

‘id.’ ( nt –  ) gforth-0.6 “i-d-dot”
   Print the name of the word represented by NT.

‘.id’ ( nt –  ) gforth-0.6 “dot-i-d”
   F83 name for ‘id.’.

‘name>link’ ( nt1 – nt2 / 0  ) gforth-1.0 “name-to-link”
   For a word nt1, returns the previous word nt2 in the same wordlist,
or 0 if there is no previous word.

   A nameless word usually has no interpretation nor compilation
semantics, no name, and it’s not in a wordlist.  But in Gforth (since
1.0) all words are equal, so even nameless words have an nt (but they
are in no wordlist).  You can get that nt with ‘latestnt’, and the words
above that consume nts do something reasonable for these nts.

   As a usage example, the following code lists all the words in
‘forth-wordlist’ with non-default compilation semantics:

     : ndcs-words ( wid -- )
       [: dup name>compile ['] compile, <> if over id. then 2drop true ;]
       swap traverse-wordlist ;

     forth-wordlist ndcs-words

   This code assumes that a word has default compilation semantics if
the xt part of its compilation token is the xt of ‘compile,’.

   The closest thing to the nt in older Forth systems is the name field
address (NFA), but there are significant differences: in older Forth
systems each word had a unique NFA, LFA, CFA and PFA (in this order, or
LFA, NFA, CFA, PFA) and there were words for getting from one to the
next.  In contrast, in Gforth several nts can get the same xt from
‘name>interpret’ xt; there is a link field in the structure identified
by the name token, but searching usually uses a hash table external to
these structures; the name in Gforth has a cell-wide count-and-flags
field, and the nt is not implemented as the address of that count field.


File: gforth.info,  Node: Compilation token,  Prev: Name token,  Up: Tokens for Words

6.12.3 Compilation token
------------------------

The compilation semantics of a named word is represented by a
“compilation token” consisting of two cells: w xt.  The top cell xt is
an execution token.  The compilation semantics represented by the
compilation token can be performed with ‘execute’, which consumes the
whole compilation token, with an additional stack effect determined by
the represented compilation semantics.

   At present, the w part of a compilation token is an execution token,
and the xt part represents either ‘execute’ or ‘compile,’(1).  However,
don’t rely on that knowledge, unless necessary; future versions of
Gforth may introduce unusual compilation tokens (e.g., a compilation
token that represents the compilation semantics of a literal).

   You get the compilation token of, e.g., ‘if’ in a standard way with
‘name>compile’, e.g., ‘`if name>compile’, but there are also parsing
words to get the compilation token of a word:

‘[COMP']’ ( compilation "name" – ; run-time – w xt  ) gforth-0.2 “bracket-comp-tick”
   Compilation token w xt represents name’s compilation semantics.

‘COMP'’ ( "name" – w xt  ) gforth-0.2 “comp-tick”
   Compilation token w xt represents name’s compilation semantics.

   You can perform the compilation semantics represented by the
compilation token with ‘execute’.  You can compile the compilation
semantics with ‘postpone,’.  I.e., ‘``x name>compile postpone,’ is
equivalent to ‘postpone x’.

‘postpone,’ ( w xt –  ) gforth-0.2 “postpone-comma”
   Compile the compilation semantics represented by the compilation
token w xt.

   ---------- Footnotes ----------

   (1) Depending upon the compilation semantics of the word.  If the
word has default compilation semantics, the xt will represent
‘compile,’.  Otherwise (e.g., for immediate words), the xt will
represent ‘execute’.


File: gforth.info,  Node: Compiling words,  Next: The Text Interpreter,  Prev: Tokens for Words,  Up: Words

6.13 Compiling words
====================

In contrast to most other languages, Forth has no strict boundary
between compilation and run-time.  E.g., you can run arbitrary code
between defining words (or for computing data used by defining words
like ‘constant’).  Moreover, ‘Immediate’ (*note Interpretation and
Compilation Semantics:: and ‘[’...‘]’  (see below) allow running
arbitrary code while compiling a colon definition (exception: you must
not allot dictionary space).

* Menu:

* Literals::                 データ値をコンパイルします
* Macros::                   Compiling words


File: gforth.info,  Node: Literals,  Next: Macros,  Prev: Compiling words,  Up: Compiling words

6.13.1 Literals
---------------

The simplest and most frequent example is to compute a literal during
compilation.  E.g., the following definition prints an array of strings,
one string per line:

     : .strings ( addr u -- ) \ gforth
         2* cells bounds U+DO
     	cr i 2@ type
         2 cells +LOOP ;

   With a simple-minded compiler like Gforth’s, this computes ‘2 cells’
on every loop iteration.  You can compute this value once and for all at
compile time and compile it into the definition like this:

     : .strings ( addr u -- ) \ gforth
         2* cells bounds U+DO
     	cr i 2@ type
         [ 2 cells ] literal +LOOP ;

   ‘[’ switches the text interpreter to interpret state (you will get an
‘ok’ prompt if you type this example interactively and insert a newline
between ‘[’ and ‘]’), so it performs the interpretation semantics of ‘2
cells’; this computes a number.  ‘]’ switches the text interpreter back
into compile state.  It then performs ‘Literal’’s compilation semantics,
which are to compile this number into the current word.  You can
decompile the word with ‘see .strings’ to see the effect on the compiled
code.

   You can also optimize the ‘2* cells’ into ‘[ 2 cells ] literal *’ in
this way.

‘[’ ( –  ) core “left-bracket”
   Enter interpretation state.  Immediate word.

‘]’ ( –  ) core “right-bracket”
   Enter compilation state.

‘Literal’ ( compilation n – ; run-time – n  ) core “Literal”
   Compilation semantics: compile the run-time semantics.
Run-time Semantics: push n.
Interpretation semantics: undefined.

‘ALiteral’ ( compilation addr – ; run-time – addr  ) gforth-0.2 “ALiteral”
   Works like ‘literal’, but (when used in cross-compiled code) tells
the cross-compiler that the literal is an address.

‘]L’ ( compilation: n – ; run-time: – n  ) gforth-0.5 “]L”
   equivalent to ‘] literal’

   There are also words for compiling other data types than single cells
as literals:

‘2Literal’ ( compilation w1 w2 – ; run-time  – w1 w2  ) double “two-literal”
   Compile appropriate code such that, at run-time, w1 w2 are placed on
the stack.  Interpretation semantics are undefined.

‘FLiteral’ ( compilation r – ; run-time – r  ) floating “f-literal”
   Compile appropriate code such that, at run-time, r is placed on the
(floating-point) stack.  Interpretation semantics are undefined.

‘SLiteral’ ( Compilation c-addr1 u ; run-time – c-addr2 u  ) string “SLiteral”
   Compilation: compile the string specified by c-addr1, u into the
current definition.  Run-time: return c-addr2 u describing the address
and length of the string.

   You might be tempted to pass data from outside a colon definition to
the inside on the data stack.  This does not work, because ‘:’ puhes a
colon-sys, making stuff below unaccessible.  E.g., this does not work:

     5 : foo literal ; \ error: "unstructured"

   Instead, you have to pass the value in some other way, e.g., through
a variable:

     variable temp
     5 temp !
     : foo [ temp @ ] literal ;


File: gforth.info,  Node: Macros,  Prev: Literals,  Up: Compiling words

6.13.2 Macros
-------------

‘Literal’ and friends compile data values into the current definition.
You can also write words that compile other words into the current
definition.  E.g.,

     : compile-+ ( -- ) \ compiled code: ( n1 n2 -- n )
       POSTPONE + ;

     : foo ( n1 n2 -- n )
       [ compile-+ ] ;
     1 2 foo .

   This is equivalent to ‘: foo + ;’ (‘see foo’ to check this).  What
happens in this example?  ‘Postpone’ compiles the compilation semantics
of ‘+’ into ‘compile-+’; later the text interpreter executes ‘compile-+’
and thus the compilation semantics of +, which compile (the execution
semantics of) ‘+’ into ‘foo’.(1)

‘postpone’ ( "name" –  ) core “postpone”
   Compiles the compilation semantics of name.

   Compiling words like ‘compile-+’ are usually immediate (or similar)
so you do not have to switch to interpret state to execute them;
modifying the last example accordingly produces:

     : [compile-+] ( compilation: --; interpretation: -- )
       \ compiled code: ( n1 n2 -- n )
       POSTPONE + ; immediate

     : foo ( n1 n2 -- n )
       [compile-+] ;
     1 2 foo .

   You will occassionally find the need to POSTPONE several words;
putting POSTPONE before each such word is cumbersome, so Gforth provides
a more convenient syntax: ‘]] ... [[’.  This allows us to write
‘[compile-+]’ as:

     : [compile-+] ( compilation: --; interpretation: -- )
       ]] + [[ ; immediate

‘]]’ ( –  ) gforth-0.6 “right-bracket-bracket”
   Switch into postpone state: All words and recognizers are processed
as if they were preceded by ‘postpone’.  Postpone state ends when ‘[[’
is recognized.

   The unusual direction of the brackets indicates their function: ‘]]’
switches from compilation to postponing (i.e., compilation of
compilation), just like ‘]’ switches from immediate execution
(interpretation) to compilation.  Conversely, ‘[[’ switches from
postponing to compilation, ananlogous to ‘[’ which switches from
compilation to immediate execution.

   The real advantage of ‘]] ’...‘ [[’ becomes apparent when there are
many words to POSTPONE. E.g., the word ‘compile-map-array’ (*note
Advanced macros Tutorial::) can be written much shorter as follows:

     : compile-map-array ( compilation: xt -- ; run-time: ... addr u -- ... )
     \ at run-time, execute xt ( ... x -- ... ) for each element of the
     \ array beginning at addr and containing u elements
       {: xt: xt :}
       ]] cells over + swap ?do
         i @ xt 1 cells +loop [[ ;

     : sum-array ( addr u -- n )
       0 [ ' + compile-map-array ] ;

   If you then say ‘see sum-array’, it shows the following code:

     : sum-array
       #0 over + swap ?do
         i  + #8 +LOOP
     ;

   In addition to ‘]]’...‘[[’, this example shows off some other
features:

   • It uses a defer-flavoured (defined with ‘xt:’ local ‘xt’;
     mentioning the local inside ‘]]’...‘[[’ results in ‘compile,’ing
     the xt in the local.

   • It uses the literal ‘1’ inside ‘]]’...‘[[’.  This results in
     ‘postpone’ing the ‘1’, i.e.  compiling it when ‘compile-map-array’
     is run.

   • When ‘compile-map-array’ is run, ‘1 cells’ is compiled and
     optimized into ‘#8’ by Gforth’s constant folding.

   Note that parsing words such as ‘s\"’ don’t parse at postpone time
and therefore not inside ‘]]’...‘[[’.  Instead of ‘s\" mystring\n"’ you
can use the string recognizer and write ‘"mystring\n"’, which works
inside ‘]]’...‘[[’.  Likewise for the parsing word ‘[']’ and the
recognizer notation starting with ‘`’.

   But if you prefer to use ‘s\"’ (or have a parsing word that has no
recognizer replacement), you can do it by switching back to compilation:

     ]] ... [[ s\" mystring\n" ]] 2literal ... [[

   Definitions of ‘]]’ and friends in Standard Forth are provided in
‘compat/macros.fs’.

   Immediate compiling words are similar to macros in other languages
(in particular, Lisp).  The important differences to macros in, e.g., C
are:

   • You use the same language for defining and processing macros, not a
     separate preprocessing language and processor.

   • Consequently, the full power of Forth is available in macro
     definitions.  E.g., you can perform arbitrarily complex
     computations, or generate different code conditionally or in a loop
     (e.g., *note Advanced macros Tutorial::).  This power is very
     useful when writing a parser generators or other code-generating
     software.

   • Macros defined using ‘postpone’ etc.  deal with the language at a
     higher level than strings; name binding happens at macro definition
     time, so you can avoid the pitfalls of name collisions that can
     happen in C macros.  Of course, Forth is a liberal language and
     also allows to shoot yourself in the foot with text-interpreted
     macros like

          : [compile-+] s" +" evaluate ; immediate

     Apart from binding the name at macro use time, using ‘evaluate’
     also makes your definition ‘state’-smart (*note state-smartness::).

   You may want the macro to compile a number into a word.  The word to
do it is ‘literal’, but you have to ‘postpone’ it, so its compilation
semantics take effect when the macro is executed, not when it is
compiled:

     : [compile-5] ( -- ) \ compiled code: ( -- n )
       5 POSTPONE literal ; immediate

     : foo [compile-5] ;
     foo .

   You may want to pass parameters to a macro, that the macro should
compile into the current definition.  If the parameter is a number, then
you can use ‘postpone literal’ (similar for other values).

   If you want to pass a word that is to be compiled, the usual way is
to pass an execution token and ‘compile,’ it:

     : twice1 ( xt -- ) \ compiled code: ... -- ...
       dup compile, compile, ;

     : 2+ ( n1 -- n2 )
       [ ' 1+ twice1 ] ;

‘compile,’ ( xt –  ) core-ext “compile-comma”
   Append the semantics represented by xt to the current definition.
When the resulting code fragment is run, it behaves the same as if xt is
‘execute’d.

   An alternative available in Gforth, that allows you to pass the
compilation semantics as parameters is to use the compilation token
(*note Compilation token::).  The same example in this technique:

     : twice ( ... ct -- ... ) \ compiled code: ... -- ...
       2dup 2>r execute 2r> execute ;

     : 2+ ( n1 -- n2 )
       [ comp' 1+ twice ] ;

   In the example above ‘2>r’ and ‘2r>’ ensure that ‘twice’ works even
if the executed compilation semantics has an effect on the data stack.

   You can also define complete definitions with these words; this
provides an alternative to using ‘does>’ (*note User-defined Defining
Words::).  E.g., instead of

     : curry+ ( n1 "name" -- )
         CREATE ,
     DOES> ( n2 -- n1+n2 )
         @ + ;

   you could define

     : curry+ ( n1 "name" -- )
       \ name execution: ( n2 -- n1+n2 )
       >r : r> POSTPONE literal POSTPONE + POSTPONE ; ;

     -3 curry+ 3-
     see 3-

   The sequence ‘>r : r>’ is necessary, because ‘:’ puts a colon-sys on
the data stack that makes everything below it unaccessible.

   This way of writing defining words is sometimes more, sometimes less
convenient than using ‘does>’ (*note Advanced does> usage example::).
One advantage of this method is that it can be optimized better, because
the compiler knows that the value compiled with ‘literal’ is fixed,
whereas the data associated with a ‘create’d word can be changed.

‘[compile]’ ( compilation "name" – ; run-time ? – ?  ) core-ext “bracket-compile”
   Legacy word.  Use ‘postpone’ instead.  Works like ‘postpone’ if name
has non-default compilation semantics.  If name has default compilation
semantics (i.e., is a normal word), compiling ‘[compile] name’ is
equivalent to compiling name (i.e.  ‘[compile]’ is redundant in this
case.

   ---------- Footnotes ----------

   (1) A recent RFI answer requires that compiling words should only be
executed in compile state, so this example is not guaranteed to work on
all standard systems, but on any decent system it will work.


File: gforth.info,  Node: The Text Interpreter,  Next: The Input Stream,  Prev: Compiling words,  Up: Words

6.14 The Text Interpreter
=========================

The text interpreter(1) is an endless loop that processes input from the
current input device.  It is also called the outer interpreter, in
contrast to the inner interpreter (*note Engine::) which executes the
compiled Forth code on interpretive implementations.

   The text interpreter operates in one of two states: “interpret state”
and “compile state”.  The current state is defined by the aptly-named
variable ‘state’.

   This section starts by describing how the text interpreter behaves
when it is in interpret state, processing input from the user input
device – the keyboard.  This is the mode that a Forth system is in after
it starts up.

   The text interpreter works from an area of memory called the “input
buffer”(2), which stores your keyboard input when you press the <RET>
key.  Starting at the beginning of the input buffer, it skips leading
spaces (called “delimiters”) then parses a string (a sequence of
non-space characters) until it reaches either a space character or the
end of the buffer.  Having parsed a string, it makes two attempts to
process it:

   • It looks for the string in a “dictionary” of definitions.  If the
     string is found, the string names a “definition” (also known as a
     “word”) and the dictionary search returns information that allows
     the text interpreter to perform the word’s “interpretation
     semantics”.  In most cases, this simply means that the word will be
     executed.
   • If the string is not found in the dictionary, the text interpreter
     attempts to treat it as a number, using the rules described in
     *note Number Conversion::.  If the string represents a legal number
     in the current radix, the number is pushed onto a parameter stack
     (the data stack for integers, the floating-point stack for
     floating-point numbers).

   If both attempts fail, the text interpreter discards the remainder of
the input buffer, issues an error message and waits for more input.  If
one of the attempts succeeds, the text interpreter repeats the parsing
process until the whole of the input buffer has been processed, at which
point it prints the status message “‘ ok’” and waits for more input.

   The text interpreter keeps track of its position in the input buffer
by updating a variable called ‘>IN’ (pronounced “to-in”).  The value of
‘>IN’ starts out as 0, indicating an offset of 0 from the start of the
input buffer.  The region from offset ‘>IN @’ to the end of the input
buffer is called the “parse area”(3).  This example shows how ‘>IN’
changes as the text interpreter parses the input buffer:

     : remaining source >in @ /string
       cr ." ->" type ." <-" ; immediate

     1 2 3 remaining + remaining .

     : foo 1 2 3 remaining swap remaining ;

The result is:

     ->+ remaining .<-
     ->.<-5  ok

     ->SWAP remaining ;-<
     ->;<-  ok

   The value of ‘>IN’ can also be modified by a word in the input buffer
that is executed by the text interpreter.  This means that a word can
“trick” the text interpreter into either skipping a section of the input
buffer(4) or into parsing a section twice.  For example:

     : lat ." <<foo>>" ;
     : flat ." <<bar>>" >IN DUP @ 3 - SWAP ! ;

When ‘flat’ is executed, this output is produced(5):

     <<bar>><<foo>>

   This technique can be used to work around some of the
interoperability problems of parsing words.  Of course, it’s better to
avoid parsing words where possible.

Two important notes about the behaviour of the text interpreter:

   • It processes each input string to completion before parsing
     additional characters from the input buffer.
   • It treats the input buffer as a read-only region (and so must your
     code).

When the text interpreter is in compile state, its behaviour changes in
these ways:

   • If a parsed string is found in the dictionary, the text interpreter
     will perform the word’s “compilation semantics”.  In most cases,
     this simply means that the execution semantics of the word will be
     appended to the current definition.
   • When a number is encountered, it is compiled into the current
     definition (as a literal) rather than being pushed onto a parameter
     stack.
   • If an error occurs, ‘state’ is modified to put the text interpreter
     back into interpret state.
   • Each time a line is entered from the keyboard, Gforth prints “‘
     compiled’” rather than “ ‘ok’”.

   When the text interpreter is using an input device other than the
keyboard, its behaviour changes in these ways:

   • When the parse area is empty, the text interpreter attempts to
     refill the input buffer from the input source.  When the input
     source is exhausted, the input source is set back to the previous
     input source.
   • It doesn’t print out “‘ ok’” or “‘ compiled’” messages each time
     the parse area is emptied.
   • If an error occurs, the input source is set back to the user input
     device.

   You can read about this in more detail in *note Input Sources::.

‘>in’ ( – addr  ) core “to-in”
   ‘uvar’ variable – a-addr is the address of a cell containing the char
offset from the start of the input buffer to the start of the parse
area.

‘source’ ( – addr u  ) core “source”
   Return address addr and length u of the current input buffer

‘tib’ ( – addr  ) core-ext-obsolescent “t-i-b”

‘#tib’ ( – addr  ) core-ext-obsolescent “number-t-i-b”
   ‘uvar’ variable – a-addr is the address of a cell containing the
number of characters in the terminal input buffer.  OBSOLESCENT:
‘source’ superceeds the function of this word.

‘interpret’ ( ... – ...  ) gforth-0.2 “interpret”

* Menu:

* Input Sources::
* Number Conversion::
* Interpret/Compile states::
* Interpreter Directives::
* Recognizers::
* Text Interpreter Hooks::

   ---------- Footnotes ----------

   (1) This is an expanded version of the material in *note Introducing
the Text Interpreter::.

   (2) When the text interpreter is processing input from the keyboard,
this area of memory is called the “terminal input buffer” (TIB) and is
addressed by the (obsolescent) words ‘TIB’ and ‘#TIB’.

   (3) In other words, the text interpreter processes the contents of
the input buffer by parsing strings from the parse area until the parse
area is empty.

   (4) This is how parsing words work.

   (5) Exercise for the reader: what would happen if the ‘3’ were
replaced with ‘4’?


File: gforth.info,  Node: Input Sources,  Next: Number Conversion,  Prev: The Text Interpreter,  Up: The Text Interpreter

6.14.1 Input Sources
--------------------

By default, the text interpreter processes input from the user input
device (the keyboard) when Forth starts up.  The text interpreter can
process input from any of these sources:

   • The user input device – the keyboard.
   • A file, using the words described in *note Forth source files::.
   • A block, using the words described in *note Blocks::.
   • A text string, using ‘evaluate’.

   A program can identify the current input device from the values of
‘source-id’ and ‘blk’.

‘source-id’ ( – 0 | -1 | fileid  ) core-ext,file “source-i-d”
   Return 0 (the input source is the user input device), -1 (the input
source is a string being processed by ‘evaluate’) or a fileid (the input
source is the file specified by fileid).

‘blk’ ( – addr  ) block “b-l-k”
   ‘uvar’ variable – This cell contains the current block number (or 0
if the current input source is not a block).

‘save-input’ ( – x1 .. xn n  ) core-ext “save-input”
   The n entries xn - x1 describe the current state of the input source
specification, in some platform-dependent way that can be used by
‘restore-input’.

‘restore-input’ ( x1 .. xn n – flag  ) core-ext “restore-input”
   Attempt to restore the input source specification to the state
described by the n entries xn - x1.  flag is true if the restore fails.
In Gforth with the new input code, it fails only with a flag that can be
used to throw again; it is also possible to save and restore between
different active input streams.  Note that closing the input streams
must happen in the reverse order as they have been opened, but in
between everything is allowed.

‘evaluate’ ( ... addr u – ...  ) core,block “evaluate”
   Save the current input source specification.  Store ‘-1’ in
‘source-id’ and ‘0’ in ‘blk’.  Set ‘>IN’ to ‘0’ and make the string
c-addr u the input source and input buffer.  Interpret.  When the parse
area is empty, restore the input source specification.

‘query’ ( –  ) core-ext-obsolescent “query”
   Make the user input device the input source.  Receive input into the
Terminal Input Buffer.  Set ‘>IN’ to zero.  OBSOLESCENT: superceeded by
‘accept’.


File: gforth.info,  Node: Number Conversion,  Next: Interpret/Compile states,  Prev: Input Sources,  Up: The Text Interpreter

6.14.2 Number Conversion
------------------------

You get an overview of how the text interpreter converts its numeric
input in *note Literals in source code::.  This section describes some
related words.

   By default, the number base used for integer number conversion is
given by the contents of the variable ‘base’.  Note that a lot of
confusion can result from unexpected values of ‘base’.  If you change
‘base’ anywhere, make sure to save the old value and restore it
afterwards; better yet, use ‘base-execute’, which does this for you.  In
general I recommend keeping ‘base’ decimal, and using the prefixes
described in *note Literals in source code:: for the popular non-decimal
bases.

‘base-execute’ ( i*x xt u – j*x  ) gforth-0.7 “base-execute”
   execute xt with the content of ‘BASE’ being u, and restoring the
original ‘BASE’ afterwards.

‘base’ ( – a-addr  ) core “base”
   ‘User’ variable – a-addr is the address of a cell that stores the
number base used by default for number conversion during input and
output.  Don’t store to ‘base’, use ‘base-execute’ instead.

‘hex’ ( –  ) core-ext “hex”
   Set ‘base’ to &16 (hexadecimal).  Don’t use ‘hex’, use ‘base-execute’
instead.

‘decimal’ ( –  ) core “decimal”
   Set ‘base’ to &10 (decimal).  Don’t use ‘decimal’, use ‘base-execute’
instead.

‘dpl’ ( – a-addr  ) gforth-0.2 “Decimal-PLace”
   ‘User’ variable – a-addr is the address of a cell that stores the
position of the decimal point in the most recent numeric conversion.
Initialised to -1.  After the conversion of a number containing no
decimal point, ‘dpl’ is -1.  After the conversion of ‘2.’ it holds 0.
After the conversion of 234123.9 it contains 1, and so forth.

Number conversion has a number of traps for the unwary:

   • You cannot determine the current number base using the code
     sequence ‘base @ .’ – the number base is always 10 in the current
     number base.  Instead, use something like ‘base @ dec.’
   • There is a word ‘bin’ but it does not set the number base!  (*note
     General files::).
   • Standard Forth requires the ‘.’ of a double-precision number to be
     the final character in the string.  Gforth allows the ‘.’ to be
     anywhere.
   • The number conversion process does not check for overflow.

   You can read numbers into your programs with the words described in
*note Line input and conversion::.


File: gforth.info,  Node: Interpret/Compile states,  Next: Interpreter Directives,  Prev: Number Conversion,  Up: The Text Interpreter

6.14.3 Interpret/Compile states
-------------------------------

A standard program is not permitted to change ‘state’ explicitly.
However, it can change ‘state’ implicitly, using the words ‘[’ and ‘]’.
When ‘[’ is executed it switches ‘state’ to interpret state, and
therefore the text interpreter starts interpreting.  When ‘]’ is
executed it switches ‘state’ to compile state and therefore the text
interpreter starts compiling.  The most common usage for these words is
for switching into interpret state and back from within a colon
definition; this technique can be used to compile a literal (for an
example, *note Literals::) or for conditional compilation (for an
example, *note Interpreter Directives::).


File: gforth.info,  Node: Interpreter Directives,  Next: Recognizers,  Prev: Interpret/Compile states,  Up: The Text Interpreter

6.14.4 Interpreter Directives
-----------------------------

These words are usually used in interpret state; typically to control
which parts of a source file are processed by the text interpreter.
There are only a few Standard Forth Standard words, but Gforth
supplements these with a rich set of immediate control structure words
to compensate for the fact that the non-immediate versions can only be
used in compile state (*note Control Structures::).  Typical usage:

     [undefined] \G [if]
       : \G ... ; immediate
     [endif]

   So if the system does not define ‘\G’, compile some replacement code
(with possibly reduced functionality).

‘[IF]’ ( flag –  ) tools-ext “bracket-if”
   If flag is ‘TRUE’ do nothing (and therefore execute subsequent words
as normal).  If flag is ‘FALSE’, parse and discard words from the parse
area (refilling it if necessary using ‘REFILL’) including nested
instances of ‘[IF]’..  ‘[ELSE]’..  ‘[THEN]’ and ‘[IF]’..  ‘[THEN]’ until
the balancing ‘[ELSE]’ or ‘[THEN]’ has been parsed and discarded.
Immediate word.

‘[ELSE]’ ( –  ) tools-ext “bracket-else”
   Parse and discard words from the parse area (refilling it if
necessary using ‘REFILL’) including nested instances of ‘[IF]’..
‘[ELSE]’..  ‘[THEN]’ and ‘[IF]’..  ‘[THEN]’ until the balancing ‘[THEN]’
has been parsed and discarded.  ‘[ELSE]’ only gets executed if the
balancing ‘[IF]’ was ‘TRUE’; if it was ‘FALSE’, ‘[IF]’ would have parsed
and discarded the ‘[ELSE]’, leaving the subsequent words to be executed
as normal.  Immediate word.

‘[THEN]’ ( –  ) tools-ext “bracket-then”
   Do nothing; used as a marker for other words to parse and discard up
to.  Immediate word.

‘[ENDIF]’ ( –  ) gforth-0.2 “bracket-end-if”
   Do nothing; synonym for ‘[THEN]’

‘[defined]’ ( "<spaces>name" – flag  ) tools-ext “bracket-defined”
   returns true if name is found in current search order

‘[undefined]’ ( "<spaces>name" – flag  ) tools-ext “bracket-undefined”
   returns false if name is found in current search order

‘[IFDEF]’ ( "<spaces>name" –  ) gforth-0.2 “bracket-if-def”
   If name is found in the current search-order, behave like ‘[IF]’ with
a ‘TRUE’ flag, otherwise behave like ‘[IF]’ with a ‘FALSE’ flag.
Immediate word.

‘[IFUNDEF]’ ( "<spaces>name" –  ) gforth-0.2 “bracket-if-un-def”
   If name is not found in the current search-order, behave like ‘[IF]’
with a ‘TRUE’ flag, otherwise behave like ‘[IF]’ with a ‘FALSE’ flag.
Immediate word.

‘[?DO]’ ( n-limit n-index –  ) gforth-0.2 “bracket-question-do”

‘[DO]’ ( n-limit n-index –  ) gforth-0.2 “bracket-do”

‘[LOOP]’ ( –  ) gforth-0.2 “bracket-loop”

‘[+LOOP]’ ( n –  ) gforth-0.2 “bracket-question-plus-loop”

‘[FOR]’ ( n –  ) gforth-0.2 “bracket-for”

‘[NEXT]’ ( n –  ) gforth-0.2 “bracket-next”

‘[I]’ ( run-time – n  ) gforth-0.2 “bracket-i”
   At run-time, ‘[I]’ pushes the loop index of the
text-interpretation-time ‘[do]’ iteration.  If you want to process the
index at interpretation time, interpret ‘[I]’ interpretevely, or use
‘INT-[I]’.

‘INT-[I]’ ( – n  ) gforth-1.0 “int-bracket-i”
   Push the loop index of the ‘[do]’ iteration at text interpretation
time.

‘[BEGIN]’ ( –  ) gforth-0.2 “bracket-begin”

‘[UNTIL]’ ( flag –  ) gforth-0.2 “bracket-until”

‘[AGAIN]’ ( –  ) gforth-0.2 “bracket-again”

‘[WHILE]’ ( flag –  ) gforth-0.2 “bracket-while”

‘[REPEAT]’ ( –  ) gforth-0.2 “bracket-repeat”

   You can use ‘#line’ to change Gforth’s idea about the current source
line number and source file.  This is useful in cases where the Forth
file is generated from some other source code file, and you want to get,
e.g.  error messages etc.  that refer to the original source code; then
the Forth-code generator needs to insert ‘#line’ lines in the Forth code
wherever appropriate.

‘#line’ ( "u" "["file"]" –  ) gforth-1.0 “#line”
   Set the line number to u and (if present) the file name to file.
Consumes the rest of the line.


File: gforth.info,  Node: Recognizers,  Next: Text Interpreter Hooks,  Prev: Interpreter Directives,  Up: The Text Interpreter

6.14.5 Recognizers
------------------

テキスト・インタプリタはソース・コードを処理するときに、 コードを空白で
区切られた文字列に分割し、 認識器群(recognizers)の中からどれか1つの認識
器が文字列を識別(identify)(認識(recognize))するまで認識器群を呼び出して
、 それらをワードや数値などとして識別します。 その文字列が認識されない場
合、 テキスト・インタプリタはエラー(‘undefined word’)を報告します。

   認識器を取り扱う通常の方法は、 認識器の 1 つを識別(identify)するコー
ドを記述するだけです(*note Default Recognizers::)。 ただし、 それらを操
作したり(*note Dealing with existing Recognizers::)、 新しい認識器を定義
したりすることもできます(*note Defining Recognizers::)。

* Menu:

* Default Recognizers::
* Dealing with existing Recognizers::
* Defining Recognizers::


File: gforth.info,  Node: Default Recognizers,  Next: Dealing with existing Recognizers,  Prev: Recognizers,  Up: Recognizers

6.14.5.1 Default Recognizers
............................

標準の Forth テキスト・インタプリタは、 検索順序(search order)内のワード
(‘rec-nt’) と、 整数(‘rec-num’)と、 浮動小数点数(‘rec-float’)を認識しま
す。 デフォルトでは、 Gforth は 以下の構文も認識します

   • 文字列 例: ‘"mystring"’ (‘rec-string’)

   • 混合数値(complex numbers) 例: ‘0e+1ei’ (‘rec-complex’)

   • value への格納または defered word の変更 例: ‘->myvalue’ (‘rec-to’)

   • ワードのインタプリタ機能(interpretation semantics)表す xt です。 例
     : ‘`dup’ (‘rec-tick’)

   • ワードの nt です。 例: ‘``mysynonym’ (‘rec-dtick’)

   • ワードのボディのアドレス 例: ‘<myarray+8>’ (‘rec-body’)

   • オペレーティング・システムの環境変数へのアクセス 例: ‘${HOME}’
     (‘rec-env’)

   • ボキャブラリ内のワード 例: ‘myvoc1:myvoc2:myword’ (‘rec-scope’)

   • 指定の認識器(recognizer)使用して何かを認識する 例: ‘float?1.’
     (‘rec-meta’)

   ‘locate’ (*note Locating source code definitions::) を使用して、 ソー
ス・コードの一片を、 どの認識器(recognizer)が認識するか調べられます。 例
:

     defer mydefer
     locate ->mydefer

   これは ‘rec-to’ が ‘->mydefer’ を認識したことを示すハズです。 ただし
、 認識器がディクショナリのワードを認識する場合(スコープ認識機能など)、
locate はそのワードを表示します。

   以下を使用すると、 使用されている認識器と認識器の順序を確認できます

‘.recognizers’ ( –  ) gforth-experimental “dot-recognizers”
   (.order とは異なり、)最初に検索された認識器を左端にして、 現在の認識
器の順序を出力します。 すべての認識器に共通のプレフィックスである ‘rec-’
の代わりに、 反転表示の ‘~’ が表示されます。

   通常、 認識器は、 他の認識器と同一の文字列との一致を避けるように設計
されています。 たとえば、‘rec-env’ (環境変数認識器)には、 ‘$ADD’ のよう
な入力文字列の数値認識器との競合を避けるために中かっこ(braces)が必要です
。 ただし、 このポリシーにはいくつかの例外があります:

   • ワード名には任意の名前を付けることができるため、 他の認識器と競合す
     る可能性があります(また、 検索順序(search order)は他の認識器よりも
     前に検索されます)。

     ただし、 名前は ‘0’ (ゼロ)で始まらない傾向がある(そして ‘0’ (ゼロ)
     で始まる場合は特殊文字が含まれる傾向がある)ため、 base が ‘hex’ の
     場合は、 数値を ‘0’ (ゼロ)で始めることをお勧めします。

     これまで私たちが見てきた幾多のコードでは、 ワードを ‘'’ (クォート。
     別名ティック)で始める方が、 ‘`’ (バック・クォート。別名バック・ティ
     ック) で始めるよりもはるかに一般的であるため、 xt と nt の認識器は
     ‘`’ (バック・クォート)を使用して競合を減らしてください。

   • 整数認識器 ‘rec-num’ と、 浮動小数点認識器 ‘rec-float’ は、 どちら
     も、 たとえば ‘1.’ を認識します。 しかし、 ‘rec-num’ が(デフォルト
     では)先にあるため、 ‘1.’ は2倍長セルの整数として認識されます。
     ‘rec-float’ を最初に使用するように認識順序を変更すると、 ‘1.’ は浮
     動小数点数として認識されますが、 標準 Forth で書かれたコードを読み
     込むと、 非標準的な振る舞いになる可能性があります。

     いずれの場合も、 以下のようにして、 あなた独自のコード内では、 この
     競合を回避することをお勧めします。 つまり、 常に数値プレフィックス
     を付けて2倍長セル整数を記述します(例: ‘#1.’)。 また、 浮動小数点数
     は常に ‘e’ を使用して記述します(例: ‘1e’)。

   • ‘->’ で始まるワードをいくつか見てきました。 ‘to myvalue’ または
     ‘to?->myvalue’ を使用すると競合を回避できます(後者は ‘postpone’ で
     機能します)。


File: gforth.info,  Node: Dealing with existing Recognizers,  Next: Defining Recognizers,  Prev: Default Recognizers,  Up: Recognizers

6.14.5.2 Dealing with existing Recognizers
..........................................

A recognizer is a word to which you pass a string.  If the recognizer
recognizes the string, it typically returns some data and the xt of a
word for processing the data; this word is called the translator.  If
the recognizer does not recognize the string, it returns the xt of
‘notfound’.

   All recognizers have the stack effect ( c-addr u – ...  xt ).

   Recognizers take a string and return some data and a translator for
interpreting that data.  Gforth implements that translator as xt
(executing it will perform the appropriate action to handle the token in
the current state), but other Forth systems may implement it as actual
table, with three xts inside.  The first xt is the
interpretation/run-time xt, it performs the interpretation semantics on
the data (usually, this means it just leaves the data on the stack).
The second xt performs the compilation semantics, it gets the data and
the run-time semantics xt.  The third xt perfoms the postpone semantics,
it also gets the data and the run-time semantics xt.  You can use
‘>postpone’ to postpone the run-time xt.

   Recognizers are organized as stack, so you can arrange the sequence
of recognizers in the same way as the vocabulary stack.  Recognizer
stacks are themselves recognizers, i.e.  they are executable, take a
string and return a translator.

‘notfound’ ( state –  ) gforth-experimental “notfound”
   If a recognizer fails, it returns ‘notfound’

‘rec-nt’ ( addr u – nt translate-nt | notfound  ) gforth-experimental “rec-nt”
   recognize a name token

‘rec-num’ ( addr u – n/d table | notfound  ) gforth-experimental “rec-num”
   converts a number to a single/double integer

‘rec-float’ ( addr u – r translate-float | notfound  ) gforth-experimental “rec-float”
   recognize floating point numbers

‘rec-string’ ( addr u – addr u’ r:string | rectype-null  ) gforth-experimental “rec-string”
   Convert strings enclosed in double quotes into string literals,
escapes are treated as in ‘S\"’.

‘rec-to’ ( addr u – xt n r:to | rectype-null  ) gforth-experimental “rec-to”
   words prefixed with ‘->’ are treated as if preceeded by ‘TO’, with
‘+>’ as ‘+TO’, with ‘'>’ as ‘ADDR’, with ‘@>’ as ‘ACTION-OF’, and with
‘=>’ as ‘IS’.

‘rec-tick’ ( addr u – xt rectype-num | rectype-null  ) gforth-experimental “rec-tick”
   words prefixed with ‘`’ return their xt.  Example: ‘`dup’ gives the
xt of dup

‘rec-dtick’ ( addr u – nt rectype-num | rectype-null  ) gforth-experimental “rec-dtick”
   words prefixed with ‘``’ return their nt.  Example: ‘``S"’ gives the
nt of ‘S"’

‘rec-body’ ( addr u – xt translate-tick | translate-null  ) gforth-experimental “rec-body”
   words bracketed with ‘'<'’ ‘'>'’ return their body.  Example: ‘<dup>’
gives the body of dup

‘get-recognizers’ ( – xt1 .. xtn n  ) gforth-experimental “get-recognizers”
   push the content on the recognizer stack

‘set-recognizers’ ( xt1 .. xtn n –  ) gforth-experimental “set-recognizers”
   set the recognizer stack from content on the stack

‘recognize’ ( addr u rec-addr – ... rectype  ) gforth-experimental “recognize”
   apply a recognizer stack to a string, delivering a token

‘recognizer-sequence:’ ( xt1 .. xtn n "name" –  ) gforth-experimental “recognizer-sequence:”
   concatenate a stack of recognizers to one recognizer with the name
"name".  xtn is tried first, xt1 last, just like on the recognizer stack

‘forth-recognize’ ( c-addr u – ... translate-xt  ) recognizer “forth-recognize”
   The system recognizer

‘forth-recognizer’ ( – xt  ) gforth-experimental “forth-recognizer”
   backward compatible to Matthias Trute recognizer API. This construct
turns a deferred word into a value-like word.

‘set-forth-recognize’ ( xt –  ) recognizer “set-forth-recognize”
   Change the system recognizer

‘translate:’ ( int-xt comp-xt post-xt "name" –  ) gforth-experimental “translate:”
   create a new recognizer table.  Items are in order of STATE value,
which are 0 or negative.  Up to 7 slots are available for extensions.

‘translate-nt’ ( i*x nt – j*x  ) gforth-experimental “translate-nt”
   translate a name token

‘translate-num’ ( x – | x  ) gforth-experimental “translate-num”
   translate a number

‘translate-dnum’ ( dx – | dx  ) gforth-experimental “translate-dnum”
   translate a double number

   doc-translate-float
‘try-recognize’ ( addr u xt – results | false  ) gforth-experimental “try-recognize”
   For nested recognizers: try to recognize ADDR U, and execute XT to
check if the result is desired.  If XT returns false, clean up all side
effects of the recognizer, and return false.  Otherwise return the
results of the call to XT, of which the topmost is non-zero.

‘>interpret’ ( translator –  ) gforth-experimental “>interpret”
   perform interpreter action of translator

‘>compile’ ( translator –  ) gforth-experimental “>compile”
   perform compile action of translator

‘>postpone’ ( translator –  ) gforth-experimental “>postpone”
   perform postpone action of translator

‘translate-method:’ ( "name" –  ) gforth-experimental “translate-method:”
   create a new translate method, extending the translator table.  You
can assign an xt to an existing rectype by using XT RECTYPE ‘to’
TRANSLATOR.

‘translate-state’ ( xt –  ) gforth-experimental “translate-state”
   change the current state of the system so that executing a translator
matches the translate-method passsed as XT


File: gforth.info,  Node: Defining Recognizers,  Prev: Dealing with existing Recognizers,  Up: Recognizers

6.14.5.3 Defining Recognizers
.............................


File: gforth.info,  Node: Text Interpreter Hooks,  Prev: Recognizers,  Up: The Text Interpreter

6.14.6 Text Interpreter Hooks
-----------------------------

‘before-line’ ( –  ) gforth-1.0 “before-line”
   Deferred word called before the text interpreter parses the next line

‘before-word’ ( –  ) gforth-0.7 “before-word”
   Deferred word called before the text interpreter parses the next word

‘line-end-hook’ ( –  ) gforth-0.7 “line-end-hook”
   called at every end-of-line when text-interpreting from a file


File: gforth.info,  Node: The Input Stream,  Next: Word Lists,  Prev: The Text Interpreter,  Up: Words

6.15 The Input Stream
=====================

The text interpreter reads from the input stream, which can come from
several sources (*note Input Sources::).  Some words, in particular
defining words, but also words like ‘'’, read parameters from the input
stream instead of from the stack.

   Such words are called parsing words, because they parse the input
stream.  Parsing words are hard to use in other words, because it is
hard to pass program-generated parameters through the input stream.
They also usually have an unintuitive combination of interpretation and
compilation semantics when implemented naively, leading to various
approaches that try to produce a more intuitive behaviour (*note
Combined words::).

   It should be obvious by now that parsing words are a bad idea.  If
you want to implement a parsing word for convenience, also provide a
factor of the word that does not parse, but takes the parameters on the
stack.  To implement the parsing word on top if it, you can use the
following words:

‘parse’ ( xchar "ccc<xchar>" – c-addr u  ) core-ext,xchar-ext “parse”
   Parse ccc, delimited by xchar, in the parse area.  c-addr u specifies
the parsed string within the parse area.  If the parse area was empty, u
is 0.

‘string-parse’ ( c-addr1 u1 "ccc<string>" – c-addr2 u2  ) gforth-1.0 “string-parse”
   Parse ccc, delimited by the string c-addr1 u1, in the parse area.
c-addr2 u2 specifies the parsed string within the parse area.  If the
parse area was empty, u2 is 0.

‘parse-name’ ( "name" – c-addr u  ) core-ext “parse-name”
   Get the next word from the input buffer

‘parse-word’ ( – c-addr u  ) gforth-obsolete “parse-word”
   old name for ‘parse-name’; this word has a conflicting behaviour in
some other systems.

‘name’ ( – c-addr u  ) gforth-obsolete “name”
   old name for ‘parse-name’

‘word’ ( char "<chars>ccc<char>– c-addr  ) core “word”
   Skip leading delimiters.  Parse ccc, delimited by char, in the parse
area.  c-addr is the address of a transient region containing the parsed
string in counted-string format.  If the parse area was empty or
contained no characters other than delimiters, the resulting string has
zero length.  A program may replace characters within the counted
string.  OBSOLESCENT: the counted string has a trailing space that is
not included in its length.

‘refill’ ( – flag  ) core-ext,block-ext,file-ext “refill”
   Attempt to fill the input buffer from the input source.  When the
input source is the user input device, attempt to receive input into the
terminal input device.  If successful, make the result the input buffer,
set ‘>IN’ to 0 and return true; otherwise return false.  When the input
source is a block, add 1 to the value of ‘BLK’ to make the next block
the input source and current input buffer, and set ‘>IN’ to 0; return
true if the new value of ‘BLK’ is a valid block number, false otherwise.
When the input source is a text file, attempt to read the next line from
the file.  If successful, make the result the current input buffer, set
‘>IN’ to 0 and return true; otherwise, return false.  A successful
result includes receipt of a line containing 0 characters.

   If you have to deal with a parsing word that does not have a
non-parsing factor, you can use ‘execute-parsing’ to pass a string to
it:

‘execute-parsing’ ( ... addr u xt – ...  ) gforth-0.6 “execute-parsing”
   Make addr u the current input source, execute xt ‘( ... -- ... )’,
then restore the previous input source.

   Example:

     5 s" foo" ' constant execute-parsing
     \ equivalent to
     5 constant foo

   A definition of this word in Standard Forth is provided in
‘compat/execute-parsing.fs’.

   If you want to run a parsing word on a file, the following word
should help:

‘execute-parsing-file’ ( i*x fileid xt – j*x  ) gforth-0.6 “execute-parsing-file”
   Make fileid the current input source, execute xt ‘( i*x -- j*x )’,
then restore the previous input source.


File: gforth.info,  Node: Word Lists,  Next: Environmental Queries,  Prev: The Input Stream,  Up: Words

6.16 Word Lists
===============

A wordlist is a list of named words; you can add new words and look up
words by name (and you can remove words in a restricted way with
markers).  Every named (and ‘reveal’ed) word is in one wordlist.

   The text interpreter searches the wordlists present in the search
order (a stack of wordlists), from the top to the bottom.  Within each
wordlist, the search starts conceptually at the newest word; i.e., if
two words in a wordlist have the same name, the newer word is found.

   New words are added to the “compilation wordlist” (aka current
wordlist).

   A word list is identified by a cell-sized word list identifier (wid)
in much the same way as a file is identified by a file handle.  The
numerical value of the wid has no (portable) meaning, and might change
from session to session.

   The Standard Forth “Search order” word set is intended to provide a
set of low-level tools that allow various different schemes to be
implemented.  Gforth also provides ‘vocabulary’, a traditional Forth
word.  ‘compat/vocabulary.fs’ provides an implementation in Standard
Forth.

‘forth-wordlist’ ( – wid  ) search “forth-wordlist”
   ‘Constant’ – wid identifies the word list that includes all of the
standard words provided by Gforth.  When Gforth is invoked, this word
list is the compilation word list and is at the top of the search order.

‘definitions’ ( –  ) search “definitions”
   Set the compilation word list to be the same as the word list that is
currently at the top of the search order.

‘get-current’ ( – wid  ) search “get-current”
   wid is the identifier of the current compilation word list.

‘set-current’ ( wid –  ) search “set-current”
   Set the compilation word list to the word list identified by wid.

‘get-order’ ( – widn .. wid1 n  ) search “get-order”
   Copy the search order to the data stack.  The current search order
has n entries, of which wid1 represents the wordlist that is searched
first (the word list at the top of the search order) and widn represents
the wordlist that is searched last.

‘set-order’ ( widn .. wid1 n –  ) search “set-order”
   If N=0, empty the search order.  If N=-1, set the search order to the
implementation-defined minimum search order (for Gforth, this is the
word list ‘Root’).  Otherwise, replace the existing search order with
the N wid entries such that WID1 represents the word list that will be
searched first and WIDN represents the word list that will be searched
last.

‘wordlist’ ( – wid  ) search “wordlist”
   Create a new, empty word list represented by wid.

‘table’ ( – wid  ) gforth-0.2 “table”
   Create a lookup table (case-sensitive, no warnings).

‘cs-wordlist’ ( – wid  ) gforth-1.0 “cs-wordlist”
   Create a case-sensitive wordlist.

‘cs-vocabulary’ ( "name" –  ) gforth-1.0 “cs-vocabulary”
   Create a case-sensitive vocabulary

‘>order’ ( wid –  ) gforth-0.5 “to-order”
   Push WID on the search order.

‘previous’ ( –  ) search-ext “previous”
   Drop the wordlist at the top of the search order.

‘also’ ( –  ) search-ext “also”
   Like ‘DUP’ for the search order.  Usually used before a vocabulary
(e.g., ‘also Forth’); the combined effect is to push the wordlist
represented by the vocabulary on the search order.

‘Forth’ ( –  ) search-ext “Forth”
   Replace the wid at the top of the search order with the wid
associated with the word list ‘forth-wordlist’.

‘Only’ ( –  ) search-ext “Only”
   Set the search order to the implementation-defined minimum search
order (for Gforth, this is the word list ‘Root’).

‘order’ ( –  ) search-ext “order”
   Print the search order and the compilation word list.  The word lists
are printed in the order in which they are searched (which is reversed
with respect to the conventional way of displaying stacks).  The
compilation word list is displayed last.

‘.voc’ ( wid –  ) gforth-0.2 “dot-voc”
   print the name of the wordlist represented by WID.  Can only print
names defined with ‘vocabulary’ or ‘wordlist constant’, otherwise prints
‘address’.

‘find’ ( c-addr – xt +-1 | c-addr 0  ) core,search “find”
   Search all word lists in the current search order for the definition
named by the counted string at c-addr.  If the definition is not found,
return 0.  If the definition is found return 1 (if the definition has
non-default compilation semantics) or -1 (if the definition has default
compilation semantics).  The xt returned in interpret state represents
the interpretation semantics.  The xt returned in compile state
represented either the compilation semantics (for non-default
compilation semantics) or the run-time semantics that the compilation
semantics would ‘compile,’ (for default compilation semantics).  The ANS
Forth standard does not specify clearly what the returned xt represents
(and also talks about immediacy instead of non-default compilation
semantics), so this word is questionable in portable programs.  If
non-portability is ok, ‘find-name’ and friends are better (*note Name
token::).

‘search-wordlist’ ( c-addr count wid – 0 | xt +-1  ) search “search-wordlist”
   Search the word list identified by wid for the definition named by
the string at c-addr count.  If the definition is not found, return 0.
If the definition is found return 1 (if the definition is immediate) or
-1 (if the definition is not immediate) together with the xt.  In
Gforth, the xt returned represents the interpretation semantics.  ANS
Forth does not specify clearly what xt represents.

‘words’ ( –  ) tools “words”
   Display a list of all of the definitions in the word list at the top
of the search order.

‘vlist’ ( –  ) gforth-0.2 “vlist”
   Old (pre-Forth-83) name for ‘WORDS’.

‘wordlist-words’ ( wid –  ) gforth-0.6 “wordlist-words”
   Display the contents of the wordlist wid.

‘mwords’ ( ["pattern"] –  ) gforth-1.0 “mwords”
   list all words matching the optional parameter PATTERN; if none, all
words match.  Words are listed old to new.  Pattern match like ‘search’
(default), you can switch to globbing with ‘' mword-filename-match is
mword-match’.

‘Root’ ( –  ) gforth-0.2 “Root”
   Add the root wordlist to the search order stack.  This vocabulary
makes up the minimum search order and contains only a search-order
words.

‘Vocabulary’ ( "name" –  ) gforth-0.2 “Vocabulary”
   Create a definition "name" and associate a new word list with it.
The run-time effect of "name" is to replace the wid at the top of the
search order with the wid associated with the new word list.

‘seal’ ( –  ) gforth-0.2 “seal”
   Remove all word lists from the search order stack other than the word
list that is currently on the top of the search order stack.

‘vocs’ ( –  ) gforth-0.2 “vocs”
   List vocabularies and wordlists defined in the system.

‘current’ ( – addr  ) gforth-0.2 “current”
   ‘Variable’ – holds the wid of the compilation word list.

‘context’ ( – addr  ) gforth-0.2 “context”
   ‘context’ ‘@’ is the wid of the word list at the top of the search
order.

‘map-vocs’ ( ... xt – ...  ) gforth-1.0 “map-vocs”
   Perform xt ( ...  wid – ...  )  for all wordlists (including tables
and cs-wordlists) in the system.

* Menu:

* Vocabularies::
* Why use word lists?::
* Word list example::


File: gforth.info,  Node: Vocabularies,  Next: Why use word lists?,  Prev: Word Lists,  Up: Word Lists

6.16.1 Vocabularies
-------------------

Here is an example of creating and using a new wordlist using Standard
Forth words:

     wordlist constant my-new-words-wordlist
     : my-new-words get-order nip my-new-words-wordlist swap set-order ;

     \ add it to the search order
     also my-new-words

     \ alternatively, add it to the search order and make it
     \ the compilation word list
     also my-new-words definitions
     \ type "order" to see the problem

   The problem with this example is that ‘order’ has no way to associate
the name ‘my-new-words’ with the wid of the word list (in Gforth,
‘order’ and ‘vocs’ will display ‘???’ for a wid that has no associated
name).  There is no Standard way of associating a name with a wid.

   In Gforth, this example can be re-coded using ‘vocabulary’, which
associates a name with a wid:

     vocabulary my-new-words

     \ add it to the search order
     also my-new-words

     \ alternatively, add it to the search order and make it
     \ the compilation word list
     my-new-words definitions
     \ type "order" to see that the problem is solved


File: gforth.info,  Node: Why use word lists?,  Next: Word list example,  Prev: Vocabularies,  Up: Word Lists

6.16.2 Why use word lists?
--------------------------

Here are some reasons why people use wordlists:

   • To prevent a set of words from being used outside the context in
     which they are valid.  Two classic examples of this are an
     integrated editor (all of the edit commands are defined in a
     separate word list; the search order is set to the editor word list
     when the editor is invoked; the old search order is restored when
     the editor is terminated) and an integrated assembler (the op-codes
     for the machine are defined in a separate word list which is used
     when a ‘CODE’ word is defined).

   • To organize the words of an application or library into a
     user-visible set (in ‘forth-wordlist’ or some other common
     wordlist) and a set of helper words used just for the
     implementation (hidden in a separate wordlist).  This keeps
     ‘words’’ output smaller, separates implementation and interface,
     and reduces the chance of name conflicts within the common
     wordlist.

   • To prevent a name-space clash between multiple definitions with the
     same name.  For example, when building a cross-compiler you might
     have a word ‘IF’ that generates conditional code for your target
     system.  By placing this definition in a different word list you
     can control whether the host system’s ‘IF’ or the target system’s
     ‘IF’ get used in any particular context by controlling the order of
     the word lists on the search order stack.

   The downsides of using wordlists are:

   • Debugging becomes more cumbersome.

   • Name conflicts worked around with wordlists are still there, and
     you have to arrange the search order carefully to get the desired
     results; if you forget to do that, you get hard-to-find errors (as
     in any case where you read the code differently from the compiler;
     ‘see’ can help seeing which of several possible words the name
     resolves to in such cases).  ‘See’ displays just the name of the
     words, not what wordlist they belong to, so it might be misleading.
     Using unique names is a better approach to avoid name conflicts.

   • You have to explicitly undo any changes to the search order.  In
     many cases it would be more convenient if this happened implicitly.
     Gforth currently does not provide such a feature, but it may do so
     in the future.


File: gforth.info,  Node: Word list example,  Prev: Why use word lists?,  Up: Word Lists

6.16.3 Word list example
------------------------

The following example is from the garbage collector
(https://www.complang.tuwien.ac.at/forth/garbage-collection.zip) and
uses wordlists to separate public words from helper words:

     get-current ( wid )
     vocabulary garbage-collector also garbage-collector definitions
     ... \ define helper words
     ( wid ) set-current \ restore original (i.e., public) compilation wordlist
     ... \ define the public (i.e., API) words
         \ they can refer to the helper words
     previous \ restore original search order (helper words become invisible)


File: gforth.info,  Node: Environmental Queries,  Next: Files,  Prev: Word Lists,  Up: Words

6.17 Environmental Queries
==========================

Forth-94 introduced the idea of “environmental queries” as a way for a
program running on a system to determine certain characteristics of the
system.  The Standard specifies a number of strings that might be
recognised by a system, and a way of querying them:

‘environment?’ ( c-addr u – false / ... true  ) core “environment-query”
   c-addr, u specify a counted string.  If the string is not recognised,
return a ‘false’ flag.  Otherwise return a ‘true’ flag and some
(string-specific) information about the queried string.

   Note that, whilst the documentation for (e.g.)  ‘ADDRESS-UNIT-BITS’
shows it returning one cell on the stack, querying it using
‘environment?’ will return an additional item; the ‘true’ flag that
shows that the string was recognised; so for querying
‘ADDRESS-UNIT-BITS’ the stack effect of ‘environment?’ is ‘( c-addr u --
n true )’.

   Several environmental queries deal with the system’s limits:

‘ADDRESS-UNIT-BITS’ ( – n  ) environment “ADDRESS-UNIT-BITS”
   Size of one address unit, in bits.

‘MAX-CHAR’ ( – u  ) environment “MAX-CHAR”
   Maximum value of any character in the character set

‘/COUNTED-STRING’ ( – n  ) environment “slash-counted-string”
   Maximum size of a counted string, in characters.

‘/HOLD’ ( – n  ) environment “slash-hold”
   Size of the pictured numeric string output buffer, in characters.

‘/PAD’ ( – n  ) environment “slash-pad”
   Size of the scratch area pointed to by ‘PAD’, in characters.

‘CORE’ ( – f  ) environment “CORE”
   True if the complete core word set is present.  Always true for
Gforth.

‘CORE-EXT’ ( – f  ) environment “CORE-EXT”
   True if the complete core extension word set is present.  Always true
for Gforth.

‘FLOORED’ ( – f  ) environment “FLOORED”
   True if ‘/’ etc.  perform floored division

‘MAX-N’ ( – n  ) environment “MAX-N”
   Largest usable signed integer.

‘MAX-U’ ( – u  ) environment “MAX-U”
   Largest usable unsigned integer.

‘MAX-D’ ( – d  ) environment “MAX-D”
   Largest usable signed double.

‘MAX-UD’ ( – ud  ) environment “MAX-UD”
   Largest usable unsigned double.

‘return-stack-cells’ ( – n  ) environment “return-stack-cells”
   Maximum size of the return stack, in cells.

‘stack-cells’ ( – n  ) environment “stack-cells”
   Maximum size of the data stack, in cells.

‘floating-stack’ ( – n  ) environment “floating-stack”
   N is non-zero, showing that Gforth maintains a separate
floating-point stack of depth N.

‘#locals’ ( – n  ) environment “number-locals”
   The maximum number of locals in a definition

‘wordlists’ ( – n  ) environment “wordlists”
   the maximum number of wordlists usable in the search order

‘max-float’ ( – r  ) environment “max-float”
   The largest usable floating-point number (implemented as largest
finite number in Gforth)

‘XCHAR-ENCODING’ ( – addr u  ) environment “XCHAR-ENCODING”
   Returns a printable ASCII string that reperesents the encoding, and
use the preferred MIME name (if any) or the name in
<http://www.iana.org/assignments/character-sets> like “ISO-LATIN-1” or
“UTF-8”, with the exception of “ASCII”, where we prefer the alias
“ASCII”.

‘MAX-XCHAR’ ( – xchar  ) environment “MAX-XCHAR”
   Maximal value for xchar.  This depends on the encoding.

‘XCHAR-MAXMEM’ ( – u  ) environment “XCHAR-MAXMEM”
   Maximal memory consumed by an xchar in address units

   Several environemtal queries are there for determining the presence
of the Forth-94 version of a wordset; they all have the stack effect ‘(
-- f )’ if the string is present (so the ‘environment?’ stack effect for
these queries is ‘( c-addr u -- false / f true )’.

   ‘block block-ext double double-ext exception exception-ext facility
facility-ext file file-ext floating floating-ext locals locals-ext
memory-alloc memory-alloc-ext tools tools-ext search-order
search-order-ext string string-ext’

   These wordset queries were rarely used and implemented, so Forth-2012
did not introduce a way to query for the Forth-2012 variants of the
wordsets.  Instead, the idea is that you use ‘[defined]’ (*note
Interpreter Directives::) instead.

   Forth-200x (a group that works on the next standard; the documents
that they produce are also called Forth-200x) defines extension queries
for the extension proposals once they finish changing (CfV stage), so
programs using these proposals can check whether a system has them, and
maybe load the reference implementation (if one exists).  If
‘environment?’ finds such a query, then the corresponding proposal on
<www.forth200x.org> is implemented on the system (but the absence tells
you nothing, as usual with ‘environment?’).  These queries have the
stack effect ‘( -- )’, which means that for them ‘environment?’ has the
stack effect ‘( c-addr u -- false / true )’, which is more convenient
than that of wordset queries.  A number of these proposals have been
incorporated into Forth-2012.  The extension queries are also not
particularly popular among Forth system implementors, so going for
‘[defined]’ may be the better approach.  Anyway, Gforth implements the
following extension queries:

   ‘X:2value X:buffer X:deferred X:defined X:ekeys X:escaped-strings
X:extension-query X:fp-stack X:ftrunc X:fvalue X:locals X:n-to-r
X:number-prefixes X:parse-name X:required X:s-escape-quote X:s-to-f
X:structures X:synonym X:text-substitution X:throw-iors
X:traverse-wordlist X:xchar’

   In addition, Gforth implements the following Gforth-specific queries:

‘gforth’ ( – c-addr u  ) gforth-environment “gforth”
   Counted string representing a version string for this version of
Gforth (for versions>0.3.0).  The version strings of the various
versions are guaranteed to be ordered lexicographically.

‘os-class’ ( – c-addr u  ) gforth-environment “os-class”
   Counted string representing a description of the host operating
system.

‘os-type’ ( – c-addr u  ) gforth-environment “os-type”
   Counted string equal to "$host_os"

   The Standard requires that the header space used for environmental
queries be distinct from the header space used for definitions.

   Typically, a Forth system supports environmental queries by creating
a set of definitions in a wordlist that is only used for environmental
queries; that is what Gforth does.  There is no Standard way of adding
definitions to the set of recognised environmental queries, but in
Gforth and other systems that use the wordlist mechanism, the wordlist
used to honour environmental queries can be manipulated just like any
other word list.

‘environment-wordlist’ ( – wid  ) gforth-0.2 “environment-wordlist”
   wid identifies the word list that is searched by environmental
queries (present in SwiftForth and VFX).

‘environment’ ( –  ) gforth-0.6 “environment”
   A vocabulary for ‘environment-wordlist’ (present in Win32Forth and
VFX).

   Here are some examples of using environmental queries:

     s" address-unit-bits" environment? 0=
     [IF]
          cr .( environmental attribute address-units-bits unknown... ) cr
     [ELSE]
          drop \ ensure balanced stack effect
     [THEN]

     \ this might occur in the prelude of a standard program that uses THROW
     s" exception" environment? [IF]
        0= [IF]
           : throw abort" exception thrown" ;
        [THEN]
     [ELSE] \ we don't know, so make sure
        : throw abort" exception thrown" ;
     [THEN]

     s" gforth" environment? [IF] .( Gforth version ) TYPE
                             [ELSE] .( Not Gforth..) [THEN]

     \ a program using v*
     s" gforth" environment? [IF]
       s" 0.5.0" compare 0< [IF] \ v* is a primitive since 0.5.0
        : v* ( f_addr1 nstride1 f_addr2 nstride2 ucount -- r )
          >r swap 2swap swap 0e r> 0 ?DO
            dup f@ over + 2swap dup f@ f* f+ over + 2swap
          LOOP
          2drop 2drop ;
       [THEN]
     [ELSE] \
       : v* ( f_addr1 nstride1 f_addr2 nstride2 ucount -- r )
       ...
     [THEN]

   Here is an example of adding a definition to the environment word
list:

     get-current environment-wordlist set-current
     true constant block
     true constant block-ext
     set-current

   You can see what definitions are in the environment word list like
this:

     environment-wordlist wordlist-words


File: gforth.info,  Node: Files,  Next: Blocks,  Prev: Environmental Queries,  Up: Words

6.18 Files
==========

Gforth provides facilities for accessing files that are stored in the
host operating system’s file-system.  Files that are processed by Gforth
can be divided into two categories:

   • Files that are processed by the Text Interpreter (“Forth source
     files”).
   • Files that are processed by some other program (“general files”).

* Menu:

* Forth source files::
* General files::
* Redirection::
* Directories::
* Search Paths::


File: gforth.info,  Node: Forth source files,  Next: General files,  Prev: Files,  Up: Files

6.18.1 Forth source files
-------------------------

The simplest way to interpret the contents of a file is to use one of
these two formats:

     include mysource.fs
     s" mysource.fs" included

   You usually want to include a file only if it is not included already
(by, say, another source file).  In that case, you can use one of these
three formats:

     require mysource.fs
     needs mysource.fs
     s" mysource.fs" required

   It is good practice to write your source files such that interpreting
them does not change the stack.  Source files designed in this way can
be used with ‘required’ and friends without complications.  For example:

     1024 require foo.fs drop

   Here you want to pass the argument 1024 (e.g., a buffer size) to
‘foo.fs’.  Interpreting ‘foo.fs’ has the stack effect ( n – n ), which
allows its use with ‘require’.  Of course with such parameters to
required files, you have to ensure that the first ‘require’ fits for all
uses (i.e., ‘require’ it early in the master load file).

‘include-file’ ( i*x wfileid – j*x  ) file “include-file”
   Interpret (process using the text interpreter) the contents of the
file WFILEID.

‘included’ ( i*x c-addr u – j*x  ) file “included”
   ‘include-file’ the file whose name is given by the string C-ADDR U.

‘included?’ ( c-addr u – f  ) gforth-0.2 “included?”
   True only if the file C-ADDR U is in the list of earlier included
files.  If the file has been loaded, it may have been specified as, say,
‘foo.fs’ and found somewhere on the Forth search path.  To return ‘true’
from ‘included?’, you must specify the exact path to the file, even if
that is ‘./foo.fs’

‘include’ ( ... "file" – ...  ) file-ext “include”
   ‘include-file’ the file FILE.

‘required’ ( i*x addr u – i*x  ) file-ext “required”
   ‘include-file’ the file with the name given by ADDR U, if it is not
‘included’ (or ‘required’) already.  Currently this works by comparing
the name of the file (with path) against the names of earlier included
files.

‘require’ ( ... "file" – ...  ) file-ext “require”
   ‘include-file’ FILE only if it is not included already.

‘needs’ ( ... "name" – ...  ) gforth-0.2 “needs”
   An alias for ‘require’; exists on other systems (e.g., Win32Forth).

‘\\\’ ( –  ) gforth-1.0 “\\\”
   skip remaining source file

‘.included’ ( –  ) gforth-0.5 “.included”
   List the names of the files that have been ‘included’.

‘sourcefilename’ ( – c-addr u  ) gforth-0.2 “sourcefilename”
   The name of the source file which is currently the input source.  The
result is valid only while the file is being loaded.  If the current
input source is no (stream) file, the result is undefined.  In Gforth,
the result is valid during the whole session (but not across
‘savesystem’ etc.).

‘sourceline#’ ( – u  ) gforth-0.2 “sourceline-number”
   The line number of the line that is currently being interpreted from
a (stream) file.  The first line has the number 1.  If the current input
source is not a (stream) file, the result is undefined.

   A definition in Standard Forth for ‘required’ is provided in
‘compat/required.fs’.


File: gforth.info,  Node: General files,  Next: Redirection,  Prev: Forth source files,  Up: Files

6.18.2 General files
--------------------

Files are opened/created by name and type.  The following file access
methods (FAMs) are recognised:

‘r/o’ ( – fam  ) file “r-o”

‘r/w’ ( – fam  ) file “r-w”

‘w/o’ ( – fam  ) file “w-o”

‘bin’ ( fam1 – fam2  ) file “bin”

‘+fmode’ ( fam1 rwxrwxrwx – fam2  ) gforth-1.0 “plus-f-mode”
   add file access mode to fam - for create-file only

   When a file is opened/created, it returns a file identifier, wfileid
that is used for all other file commands.  All file commands also return
a status value, wior, that is 0 for a successful operation and an
implementation-defined non-zero value in the case of an error.

‘open-file’ ( c-addr u wfam – wfileid wior ) file “open-file”

‘create-file’ ( c-addr u wfam – wfileid wior ) file “create-file”

‘close-file’ ( wfileid – wior ) file “close-file”

‘delete-file’ ( c-addr u – wior ) file “delete-file”

‘rename-file’ ( c-addr1 u1 c-addr2 u2 – wior ) file-ext “rename-file”
   Rename file c_addr1 u1 to new name c_addr2 u2

‘read-file’ ( c-addr u1 wfileid – u2 wior ) file “read-file”
   Read u1 characters from file wfileid into the buffer at c_addr.  A
non-zero wior indicates an error.  U2 indicates the length of the read
data.  End-of-file is not an error and is indicated by u2$<$u1 and
wior=0.

‘read-line’ ( c_addr u1 wfileid – u2 flag wior  ) file “read-line”
   Reads a line from wfileid into the buffer at c_addr u1.  Gforth
supports all three common line terminators: LF, CR and CRLF. A non-zero
wior indicates an error.  A false flag indicates that ‘read-line’ has
been invoked at the end of the file.  u2 indicates the line length
(without terminator): u2$<$u1 indicates that the line is u2 chars long;
u2=u1 indicates that the line is at least u1 chars long, the u1 chars of
the buffer have been filled with chars from the line, and the next slice
of the line with be read with the next ‘read-line’.  If the line is u1
chars long, the first ‘read-line’ returns u2=u1 and the next read-line
returns u2=0.

‘key-file’ ( fd – key  ) gforth-0.4 “key-file”
   Read one character n from wfileid.  This word disables buffering for
wfileid.  If you want to read characters from a terminal in
non-canonical (raw) mode, you have to put the terminal in non-canonical
mode yourself (using the C interface); the exception is ‘stdin’: Gforth
automatically puts it into non-canonical mode.

‘key?-file’ ( wfileid – f ) gforth-0.4 “key-q-file”
   f is true if at least one character can be read from wfileid without
blocking.  If you also want to use ‘read-file’ or ‘read-line’ on the
file, you have to call ‘key?-file’ or ‘key-file’ first (these two words
disable buffering).

‘file-eof?’ ( wfileid – flag ) gforth-0.6 “file-eof-query”
   FLAG is true if the end-of-file indicator for WFILEID is set.

‘write-file’ ( c-addr u1 wfileid – wior ) file “write-file”

‘write-line’ ( c-addr u wfileid – ior  ) file “write-line”

‘emit-file’ ( c wfileid – wior ) gforth-0.2 “emit-file”

‘flush-file’ ( wfileid – wior ) file-ext “flush-file”

‘file-status’ ( c-addr u – wfam wior ) file-ext “file-status”

‘file-position’ ( wfileid – ud wior ) file “file-position”

‘reposition-file’ ( ud wfileid – wior ) file “reposition-file”

‘file-size’ ( wfileid – ud wior ) file “file-size”

‘resize-file’ ( ud wfileid – wior ) file “resize-file”

‘slurp-file’ ( c-addr1 u1 – c-addr2 u2  ) gforth-0.6 “slurp-file”
   C-ADDR1 U1 is the filename, C-ADDR2 U2 is the file’s contents

‘slurp-fid’ ( fid – addr u  ) gforth-0.6 “slurp-fid”
   ADDR U is the content of the file FID

‘stdin’ ( – wfileid ) gforth-0.4 “stdin”
   The standard input file of the Gforth process.

‘stdout’ ( – wfileid ) gforth-0.2 “stdout”
   The standard output file of the Gforth process.

‘stderr’ ( – wfileid ) gforth-0.2 “stderr”
   The standard error output file of the Gforth process.


File: gforth.info,  Node: Redirection,  Next: Directories,  Prev: General files,  Up: Files

6.18.3 Redirection
------------------

You can redirect the output of ‘type’ and ‘emit’ and all the words that
use them (all output words that don’t have an explicit target file) to
an arbitrary file with the ‘outfile-execute’, used like this:

     : some-warning ( n -- )
         cr ." warning# " . ;

     : print-some-warning ( n -- )
         ['] some-warning stderr outfile-execute ;

   After ‘some-warning’ is executed, the original output direction is
restored; this construct is safe against exceptions.  Similarly, there
is ‘infile-execute’ for redirecting the input of ‘key’ and its users
(any input word that does not take a file explicitly).

‘outfile-execute’ ( ... xt file-id – ...  ) gforth-0.7 “outfile-execute”
   execute xt with the output of ‘type’ etc.  redirected to file-id.

‘outfile-id’ ( – file-id  ) gforth-0.2 “outfile-id”
   File-id is used by ‘emit’, ‘type’, and any output word that does not
take a file-id as input.  By default ‘outfile-id’ produces the process’s
‘stdout’, unless changed with ‘outfile-execute’.

‘infile-execute’ ( ... xt file-id – ...  ) gforth-0.7 “infile-execute”
   execute xt with the input of ‘key’ etc.  redirected to file-id.

‘infile-id’ ( – file-id  ) gforth-0.4 “infile-id”
   File-id is used by ‘key’, ‘?key’, and anything that refers to the
"user input device".  By default ‘infile-id’ produces the process’s
‘stdin’, unless changed with ‘infile-execute’.

   If you do not want to redirect the input or output to a file, you can
also make use of the fact that ‘key’, ‘emit’ and ‘type’ are deferred
words (*note Deferred Words::).  However, in that case you have to worry
about the restoration and the protection against exceptions yourself;
also, note that for redirecting the output in this way, you have to
redirect both ‘emit’ and ‘type’.


File: gforth.info,  Node: Directories,  Next: Search Paths,  Prev: Redirection,  Up: Files

6.18.4 Directories
------------------

You can split a file name into a directory and base component:

‘basename’ ( c-addr1 u1 – c-addr2 u2  ) gforth-0.7 “basename”
   Given a file name c-addr1 u1, c-addr2 u2 is the part of it with any
leading directory components removed.

‘dirname’ ( c-addr1 u1 – c-addr1 u2  ) gforth-0.7 “dirname”
   C-addr1 u2 is the directory name of the file name c-addr1 u1,
including the final ‘/’.  If caddr1 u1 does not contain a ‘/’, u2=0.

   You can open and read directories similar to files.  Reading gives
you one directory entry at a time; you can match that to a filename
(with wildcards).

‘open-dir’ ( c-addr u – wdirid wior ) gforth-0.5 “open-dir”
   Open the directory specified by c-addr, u and return dir-id for
futher access to it.

‘read-dir’ ( c-addr u1 wdirid – u2 flag wior ) gforth-0.5 “read-dir”
   Attempt to read the next entry from the directory specified by dir-id
to the buffer of length u1 at address c-addr.  If the attempt fails
because there is no more entries, ior=0, flag=0, u2=0, and the buffer is
unmodified.  If the attempt to read the next entry fails because of any
other reason, return ior<>0.  If the attempt succeeds, store file name
to the buffer at c-addr and return ior=0, flag=true and u2 equal to the
size of the file name.  If the length of the file name is greater than
u1, store first u1 characters from file name into the buffer and
indicate "name too long" with ior, flag=true, and u2=u1.

‘close-dir’ ( wdirid – wior ) gforth-0.5 “close-dir”
   Close the directory specified by dir-id.

‘filename-match’ ( c-addr1 u1 c-addr2 u2 – flag ) gforth-0.5 “match-file”
   match the file name C_ADDR1 U1 with the pattern C_ADDR2 U2.  Patterns
match char by char except for the special characters ’*’ and ’?’, which
are wildcards for several (’*’) or one (’?’) character.

‘get-dir’ ( c-addr1 u1 – c-addr2 u2 ) gforth-0.7 “get-dir”
   Store the current directory in the buffer specified by c-addr1, u1.
If the buffer size is not sufficient, return 0 0

‘set-dir’ ( c-addr u – wior ) gforth-0.7 “set-dir”
   Change the current directory to c-addr, u.  Return an error if this
is not possible

‘=mkdir’ ( c-addr u wmode – wior ) gforth-0.7 “equals-mkdir”
   Create directory c-addr u with mode wmode.

‘mkdir-parents’ ( c-addr u mode – ior  ) gforth-0.7 “mkdir-parents”
   create the directory c-addr u and all its parents with mode mode
(modified by umask)


File: gforth.info,  Node: Search Paths,  Prev: Directories,  Up: Files

6.18.5 Search Paths
-------------------

If you specify an absolute filename (i.e., a filename starting with ‘/’
or ‘~’, or with ‘:’ in the second position (as in ‘C:...’)) for
‘included’ and friends, that file is included just as you would expect.

   If the filename starts with ‘./’, this refers to the directory that
the present file was ‘included’ from.  This allows files to include
other files relative to their own position (irrespective of the current
working directory or the absolute position).  This feature is essential
for libraries consisting of several files, where a file may include
other files from the library.  It corresponds to ‘#include "..."’ in C.
If the current input source is not a file, ‘.’ refers to the directory
of the innermost file being included, or, if there is no file being
included, to the current working directory.

   For relative filenames (not starting with ‘./’), Gforth uses a search
path similar to Forth’s search order (*note Word Lists::).  It tries to
find the given filename in the directories present in the path, and
includes the first one it finds.  There are separate search paths for
Forth source files and general files.  If the search path contains the
directory ‘.’, this refers to the directory of the current file, or the
working directory, as if the file had been specified with ‘./’.

   Use ‘~+’ to refer to the current working directory (as in the
‘bash’).

‘absolute-file?’ ( addr u – flag  ) gforth-1.0 “absolute-file?”
   A filename is absolute if it starts with a / or a ~ (~ expansion), or
if it is in the form ./*, extended regexp: ^[/~]|./, or if it has a
colon as second character ("C:...").  Paths simply containing a / are
not absolute!

* Menu:

* Source Search Paths::
* General Search Paths::


File: gforth.info,  Node: Source Search Paths,  Next: General Search Paths,  Prev: Search Paths,  Up: Search Paths

6.18.5.1 Source Search Paths
............................

The search path is initialized when you start Gforth (*note Invoking
Gforth::).  You can display it and change it using ‘fpath’ in
combination with the general path handling words.

‘fpath’ ( – path-addr  ) gforth-0.4 “fpath”

‘.fpath’ ( –  ) gforth-0.4 “.fpath”
   Display the contents of the Forth search path.

‘file>fpath’ ( addr1 u1 – addr2 u2  ) gforth-1.0 “file>fpath”
   Searches for a file with the name c-addr1 u1 in the ‘fpath’.  If
successful, c-addr u2 is the absolute file name or the file name
relative to the current working directory.  Throws an exception if the
file cannot be opened.

Here is an example of using ‘fpath’ and ‘require’:

     fpath path= /usr/lib/forth/|./
     require timer.fs


File: gforth.info,  Node: General Search Paths,  Prev: Source Search Paths,  Up: Search Paths

6.18.5.2 General Search Paths
.............................

Your application may need to search files in several directories, like
‘included’ does.  To facilitate this, Gforth allows you to define and
use your own search paths, by providing generic equivalents of the Forth
search path words:

‘open-path-file’ ( addr1 u1 path-addr – wfileid addr2 u2 0 | ior  ) gforth-0.2 “open-path-file”
   Look in path PATH-ADDR for the file specified by ADDR1 U1.  If found,
the resulting path and an (read-only) open file descriptor are returned.
If the file is not found, IOR is what came back from the last attempt at
opening the file (in the current implementation).

‘file>path’ ( c-addr1 u1 path-addr – c-addr2 u2  ) gforth-1.0 “file>path”
   Searches for a file with the name c-addr1 u1 in path stored in
path-addr.  If successful, c-addr u2 is the absolute file name or the
file name relative to the current working directory.  Throws an
exception if the file cannot be opened.

‘clear-path’ ( path-addr –  ) gforth-0.5 “clear-path”
   Set the path path-addr to empty.

‘also-path’ ( c-addr len path-addr –  ) gforth-0.4 “also-path”
   add the directory c-addr len to path-addr.

‘.path’ ( path-addr –  ) gforth-0.4 “.path”
   Display the contents of the search path PATH-ADDR.

‘path+’ ( path-addr  "dir" –  ) gforth-0.4 “path+”
   Add the directory DIR to the search path PATH-ADDR.

‘path=’ ( path-addr "dir1|dir2|dir3" –  ) gforth-0.4 “path-equals”
   Make a complete new search path; the path separator is |.

   Here’s an example of creating a custom search path:
     variable mypath \ no special allocation required, just a variable
     mypath path= /lib|/usr/lib \ assign initial directories
     mypath path+ /usr/local/lib \ append directory
     mypath .path \ output:"/lib /usr/lib /usr/local/lib"

   Search file and show resulting path:
     s" libm.so" mypath open-path-file throw type close-file \ output:"/lib/libm.so"


File: gforth.info,  Node: Blocks,  Next: Other I/O,  Prev: Files,  Up: Words

6.19 Blocks
===========

When you run Gforth on a modern desk-top computer, it runs under the
control of an operating system which provides certain services.  One of
these services is FILE SERVICES, which allows Forth source code and data
to be stored in files and read into Gforth (*note Files::).

   Traditionally, Forth has been an important programming language on
systems where it has interfaced directly to the underlying hardware with
no intervening operating system.  Forth provides a mechanism, called
“blocks”, for accessing mass storage on such systems.

   A block is a 1024-byte data area, which can be used to hold data or
Forth source code.  No structure is imposed on the contents of the
block.  A block is identified by its number; blocks are numbered
contiguously from 1 to an implementation-defined maximum.

   A typical system that used blocks but no operating system might use a
single floppy-disk drive for mass storage, with the disks formatted to
provide 256-byte sectors.  Blocks would be implemented by assigning the
first four sectors of the disk to block 1, the second four sectors to
block 2 and so on, up to the limit of the capacity of the disk.  The
disk would not contain any file system information, just the set of
blocks.

   On systems that do provide file services, blocks are typically
implemented by storing a sequence of blocks within a single “blocks
file”.  The size of the blocks file will be an exact multiple of 1024
bytes, corresponding to the number of blocks it contains.  This is the
mechanism that Gforth uses.

   Only one blocks file can be open at a time.  If you use block words
without having specified a blocks file, Gforth defaults to the blocks
file ‘blocks.fb’.  Gforth uses the Forth search path when attempting to
locate a blocks file (*note Source Search Paths::).

   When you read and write blocks under program control, Gforth uses a
number of “block buffers” as intermediate storage.  These buffers are
not used when you use ‘load’ to interpret the contents of a block.

   The behaviour of the block buffers is analagous to that of a cache.
Each block buffer has three states:

   • Unassigned
   • Assigned-clean
   • Assigned-dirty

   Initially, all block buffers are unassigned.  In order to access a
block, the block (specified by its block number) must be assigned to a
block buffer.

   The assignment of a block to a block buffer is performed by ‘block’
or ‘buffer’.  Use ‘block’ when you wish to modify the existing contents
of a block.  Use ‘buffer’ when you don’t care about the existing
contents of the block(1).

   Once a block has been assigned to a block buffer using ‘block’ or
‘buffer’, that block buffer becomes the current block buffer.  Data may
only be manipulated (read or written) within the current block buffer.

   When the contents of the current block buffer has been modified it is
necessary, _before calling ‘block’ or ‘buffer’ again_, to either abandon
the changes (by doing nothing) or mark the block as changed
(assigned-dirty), using ‘update’.  Using ‘update’ does not change the
blocks file; it simply changes a block buffer’s state to assigned-dirty.
The block will be written implicitly when it’s buffer is needed for
another block, or explicitly by ‘flush’ or ‘save-buffers’.

   word ‘Flush’ writes all assigned-dirty blocks back to the blocks file
on disk.  Leaving Gforth with ‘bye’ also performs a ‘flush’.

   In Gforth, ‘block’ and ‘buffer’ use a direct-mapped algorithm to
assign a block buffer to a block.  That means that any particular block
can only be assigned to one specific block buffer, called (for the
particular operation) the victim buffer.  If the victim buffer is
unassigned or assigned-clean it is allocated to the new block
immediately.  If it is assigned-dirty its current contents are written
back to the blocks file on disk before it is allocated to the new block.

   Although no structure is imposed on the contents of a block, it is
traditional to display the contents as 16 lines each of 64 characters.
A block provides a single, continuous stream of input (for example, it
acts as a single parse area) – there are no end-of-line characters
within a block, and no end-of-file character at the end of a block.
There are two consequences of this:

   • The last character of one line wraps straight into the first
     character of the following line
   • The word ‘\’ – comment to end of line – requires special treatment;
     in the context of a block it causes all characters until the end of
     the current 64-character “line” to be ignored.

   In Gforth, when you use ‘block’ with a non-existent block number, the
current blocks file will be extended to the appropriate size and the
block buffer will be initialised with spaces.

   Gforth includes a simple block editor (type ‘use blocked.fb 0 list’
for details) but doesn’t encourage the use of blocks; the mechanism is
only provided for backward compatibility.

   Common techniques that are used when working with blocks include:

   • A screen editor that allows you to edit blocks without leaving the
     Forth environment.
   • Shadow screens; where every code block has an associated block
     containing comments (for example: code in odd block numbers,
     comments in even block numbers).  Typically, the block editor
     provides a convenient mechanism to toggle between code and
     comments.
   • Load blocks; a single block (typically block 1) contains a number
     of ‘thru’ commands which ‘load’ the whole of the application.

   See Frank Sergeant’s Pygmy Forth to see just how well blocks can be
integrated into a Forth programming environment.

‘open-blocks’ ( c-addr u –  ) gforth-0.2 “open-blocks”
   Use the file, whose name is given by c-addr u, as the blocks file.

‘use’ ( "file" –  ) gforth-0.2 “use”
   Use file as the blocks file.

‘block-offset’ ( – addr  ) gforth-0.5 “block-offset”
   User variable containing the number of the first block (default since
0.5.0: 0).  Block files created with Gforth versions before 0.5.0 have
the offset 1.  If you use these files you can: ‘1 offset !’; or add 1 to
every block number used; or prepend 1024 characters to the file.

‘get-block-fid’ ( – wfileid  ) gforth-0.2 “get-block-fid”
   Return the file-id of the current blocks file.  If no blocks file has
been opened, use ‘blocks.fb’ as the default blocks file.

‘block-position’ ( u –  ) block “block-position”
   Position the block file to the start of block u.

‘list’ ( u –  ) block-ext “list”
   Display block u.  In Gforth, the block is displayed as 16 numbered
lines, each of 64 characters.

‘scr’ ( – a-addr  ) block-ext “s-c-r”
   ‘User’ variable containing the block number of the block most
recently processed by ‘list’.

‘block’ ( u – a-addr  ) block “block”
   If a block buffer is assigned for block u, return its start address,
a-addr.  Otherwise, assign a block buffer for block u (if the assigned
block buffer has been ‘update’d, transfer the contents to mass storage),
read the block into the block buffer and return its start address,
a-addr.

‘buffer’ ( u – a-addr  ) block “buffer”
   If a block buffer is assigned for block u, return its start address,
a-addr.  Otherwise, assign a block buffer for block u (if the assigned
block buffer has been ‘update’d, transfer the contents to mass storage)
and return its start address, a-addr.  The subtle difference between
‘buffer’ and ‘block’ mean that you should only use ‘buffer’ if you don’t
care about the previous contents of block u.  In Gforth, this simply
calls ‘block’.

‘empty-buffers’ ( –  ) block-ext “empty-buffers”
   Mark all block buffers as unassigned; if any had been marked as
assigned-dirty (by ‘update’), the changes to those blocks will be lost.

‘empty-buffer’ ( buffer –  ) gforth-0.2 “empty-buffer”

‘update’ ( –  ) block “update”
   Mark the state of the current block buffer as assigned-dirty.

‘updated?’ ( n – f  ) gforth-0.2 “updated?”
   Return true if ‘updated’ has been used to mark block n as
assigned-dirty.

‘save-buffers’ ( –  ) block “save-buffers”
   Transfer the contents of each ‘update’d block buffer to mass storage,
then mark all block buffers as assigned-clean.

‘save-buffer’ ( buffer –  ) gforth-0.2 “save-buffer”

‘flush’ ( –  ) block “flush”
   Perform the functions of ‘save-buffers’ then ‘empty-buffers’.

‘load’ ( i*x u – j*x  ) block “load”
   Text-interpret block u.  Block 0 cannot be ‘load’ed.

‘thru’ ( i*x n1 n2 – j*x  ) block-ext “thru”
   ‘load’ the blocks n1 through n2 in sequence.

‘+load’ ( i*x n – j*x  ) gforth-0.2 “+load”
   Used within a block to load the block specified as the current block
+ n.

‘+thru’ ( i*x n1 n2 – j*x  ) gforth-0.2 “+thru”
   Used within a block to load the range of blocks specified as the
current block + n1 thru the current block + n2.

‘-->’ ( –  ) gforth-0.2 “chain”
   If this symbol is encountered whilst loading block n, discard the
remainder of the block and load block n+1.  Used for chaining multiple
blocks together as a single loadable unit.  Not recommended, because it
destroys the independence of loading.  Use ‘thru’ (which is standard) or
‘+thru’ instead.

‘block-included’ ( a-addr u –  ) gforth-0.2 “block-included”
   Use within a block that is to be processed by ‘load’.  Save the
current blocks file specification, open the blocks file specified by
a-addr u and ‘load’ block 1 from that file (which may in turn chain or
load other blocks).  Finally, close the blocks file and restore the
original blocks file.

   ---------- Footnotes ----------

   (1) The Standard Forth definition of ‘buffer’ is intended not to
cause disk I/O; if the data associated with the particular block is
already stored in a block buffer due to an earlier ‘block’ command,
‘buffer’ will return that block buffer and the existing contents of the
block will be available.  Otherwise, ‘buffer’ will simply assign a new,
empty block buffer for the block.


File: gforth.info,  Node: Other I/O,  Next: OS command line arguments,  Prev: Blocks,  Up: Words

6.20 Other I/O
==============

* Menu:

* Simple numeric output::    定義済みの書式
* Formatted numeric output::  書式化された(目に見える)出力
* Floating-point output::
* Miscellaneous output::
* Displaying characters and strings::  その他もろもろ
* Terminal output::          カーソル移動等
* Single-key input::
* Line input and conversion::
* Pipes::                    あなた独自のパイプラインの作り方
* Xchars and Unicode::       非ASCII文字
* i18n and l10n::            国際化(I18n)とローカライズ
* Substitute::               テキストマクロ置換
* CSV Reader::               データ・インポート機能


File: gforth.info,  Node: Simple numeric output,  Next: Formatted numeric output,  Prev: Other I/O,  Up: Other I/O

6.20.1 Simple numeric output
----------------------------

The simplest output functions are those that display numbers from the
data stack.  Numbers are displayed in the base (aka radix) stored in
‘base’ (*note Number Conversion::).

‘.’ ( n –  ) core “dot”
   Display (the signed single number) N in free-format, followed by a
space.

‘dec.’ ( n –  ) gforth-0.2 “dec.”
   Display n as a signed decimal number, followed by a space.

‘h.’ ( u –  ) gforth-1.0 “h.”
   Display u as an unsigned hex number, prefixed with a "$" and followed
by a space.

‘hex.’ ( u –  ) gforth-0.2 “hex.”
   Display u as an unsigned hex number, prefixed with a ‘$’ and followed
by a space.  Another name for this word is ‘h.’, which is present in
several other systems, but not in Gforth before 1.0.

‘u.’ ( u –  ) core “u-dot”
   Display (the unsigned single number) U in free-format, followed by a
space.

‘.r’ ( n1 n2 –  ) core-ext “dot-r”
   Display N1 right-aligned in a field N2 characters wide.  If more than
N2 characters are needed to display the number, all digits are
displayed.  If appropriate, N2 must include a character for a leading
“-”.

‘u.r’ ( u n –  ) core-ext “u-dot-r”
   Display U right-aligned in a field N characters wide.  If more than N
characters are needed to display the number, all digits are displayed.

‘dec.r’ ( u n –  ) gforth-0.5 “dec.r”
   Display u as a unsigned decimal number in a field n characters wide.

‘d.’ ( d –  ) double “d-dot”
   Display (the signed double number) D in free-format.  followed by a
space.

‘ud.’ ( ud –  ) gforth-0.2 “u-d-dot”
   Display (the signed double number) UD in free-format, followed by a
space.

‘d.r’ ( d n –  ) double “d-dot-r”
   Display D right-aligned in a field N characters wide.  If more than N
characters are needed to display the number, all digits are displayed.
If appropriate, N must include a character for a leading “-”.

‘ud.r’ ( ud n –  ) gforth-0.2 “u-d-dot-r”
   Display UD right-aligned in a field N characters wide.  If more than
N characters are needed to display the number, all digits are displayed.


File: gforth.info,  Node: Formatted numeric output,  Next: Floating-point output,  Prev: Simple numeric output,  Up: Other I/O

6.20.2 Formatted numeric output
-------------------------------

Forth traditionally uses a technique called “pictured numeric output”
for formatted printing of integers.  In this technique, digits are
extracted from the number (using the current output radix defined by
‘base’, *note Number Conversion::), converted to ASCII codes and
prepended to a string that is built in a scratch-pad area of memory
(*note Implementation-defined options: core-idef.).  Arbitrary
characters can be prepended to the string during the extraction process.
The completed string is specified by an address and length and can be
manipulated (‘TYPE’ed, copied, modified) under program control.

   All of the integer output words described in the previous section
(*note Simple numeric output::) are implemented in Gforth using pictured
numeric output.

   Three important things to remember about pictured numeric output:

   • It always operates on double-precision numbers; to display a
     single-precision number, convert it first (for ways of doing this
     *note Double precision::).
   • It always treats the double-precision number as though it were
     unsigned.  The examples below show ways of printing signed numbers.
   • The string is built up from right to left; least significant digit
     first.

   Standard Forth supports a single output buffer (aka hold area) that
you empty and initialize with ‘<#’ and for which you get the result
string with ‘#>’.

   Gforth additionally supports nested usage of this buffer, allowing,
e.g., to nest output from the debugging tracer ‘~~’ inside code dealing
with the hold area: ‘<<#’ starts a new nest, ‘#>’ produces the result
string, and ‘#>>’ unnests: the hold area for the nest is reclaimed, and
‘#>’ now produces the string for the next-outer nest.  All of Gforth’s
higher-level numeric output words use ‘<<#’ ...  ‘#>’ ...  ‘#>>’ and can
be nested inside other users of the hold area.

‘<#’ ( –  ) core “less-number-sign”
   Initialise/clear the pictured numeric output string.

‘<<#’ ( –  ) gforth-0.5 “less-less-number-sign”
   Start a hold area that ends with ‘#>>’.  Can be nested in each other
and in ‘<#’.  Note: if you do not match up the ‘<<#’s with ‘#>>’s, you
will eventually run out of hold area; you can reset the hold area to
empty with ‘<#’.

‘#’ ( ud1 – ud2  ) core “number-sign”
   Used between ‘<<#’ and ‘#>’.  Prepend the least-significant digit
(according to ‘base’) of UD1 to the pictured numeric output string.  UD2
is UD1/BASE, i.e., the number representing the remaining digits.

‘#s’ ( ud – 0 0  ) core “number-sign-s”
   Used between ‘<<#’ and ‘#>’.  Prepend all digits of UD to the
pictured numeric output string.  ‘#s’ will convert at least one digit.
Therefore, if UD is 0, ‘#s’ will prepend a “0” to the pictured numeric
output string.

‘hold’ ( char –  ) core “hold”
   Used between ‘<<#’ and ‘#>’.  Prepend the character CHAR to the
pictured numeric output string.

‘holds’ ( addr u –  ) core-ext “holds”
   Used between ‘<<#’ and ‘#>’.  Prepend the string ‘addr u’ to the
pictured numeric output string.

‘sign’ ( n –  ) core “sign”
   Used between ‘<<#’ and ‘#>’.  If N (a SINGLE number) is negative,
prepend “‘-’” to the pictured numeric output string.

‘#>’ ( xd – addr u  ) core “number-sign-greater”
   Complete the pictured numeric output string by discarding XD and
returning ADDR U; the address and length of the formatted string.  A
Standard program may modify characters within the string.  Does not
release the hold area; use ‘#>>’ to release a hold area started with
‘<<#’, or ‘<#’ to release all hold areas.

‘#>>’ ( –  ) gforth-0.5 “number-sign-greater-greater”
   Release the hold area started with ‘<<#’.

Here are some examples of using pictured numeric output:

     : my-u. ( u -- )
       \ Simplest use of pns.. behaves like Standard u.
       0              \ convert to unsigned double
       <<#            \ start conversion
       #s             \ convert all digits
       #>             \ complete conversion
       TYPE SPACE     \ display, with trailing space
       #>> ;          \ release hold area

     : cents-only ( u -- )
       0              \ convert to unsigned double
       <<#            \ start conversion
       # #            \ convert two least-significant digits
       #>             \ complete conversion, discard other digits
       TYPE SPACE     \ display, with trailing space
       #>> ;          \ release hold area

     : dollars-and-cents ( u -- )
       0              \ convert to unsigned double
       <<#            \ start conversion
       # #            \ convert two least-significant digits
       '.' hold       \ insert decimal point
       #s             \ convert remaining digits
       '$' hold       \ append currency symbol
       #>             \ complete conversion
       TYPE SPACE     \ display, with trailing space
       #>> ;          \ release hold area

     : my-. ( n -- )
       \ handling negatives.. behaves like Standard .
       s>d            \ convert to signed double
       swap over dabs \ leave sign byte followed by unsigned double
       <<#            \ start conversion
       #s             \ convert all digits
       rot sign       \ get at sign byte, append "-" if needed
       #>             \ complete conversion
       TYPE SPACE     \ display, with trailing space
       #>> ;          \ release hold area

     : account. ( n -- )
       \ accountants don't like minus signs, they use parentheses
       \ for negative numbers
       s>d            \ convert to signed double
       swap over dabs \ leave sign byte followed by unsigned double
       <<#            \ start conversion
       2 pick         \ get copy of sign byte
       0< IF ')' hold THEN \ right-most character of output
       #s             \ convert all digits
       rot            \ get at sign byte
       0< IF '(' hold THEN
       #>             \ complete conversion
       TYPE SPACE     \ display, with trailing space
       #>> ;          \ release hold area


   Here are some examples of using these words:

     1 my-u. 1
     hex -1 my-u. decimal FFFFFFFF
     1 cents-only 01
     1234 cents-only 34
     2 dollars-and-cents $0.02
     1234 dollars-and-cents $12.34
     123 my-. 123
     -123 my. -123
     123 account. 123
     -456 account. (456)


File: gforth.info,  Node: Floating-point output,  Next: Miscellaneous output,  Prev: Formatted numeric output,  Up: Other I/O

6.20.3 Floating-point output
----------------------------

Floating-point output is always displayed using base 10.

‘f.’ ( r –  ) floating-ext “f-dot”
   Display (the floating-point number) r without exponent, followed by a
space.

‘fe.’ ( r –  ) floating-ext “f-e-dot”
   Display r using engineering notation (with exponent dividable by 3),
followed by a space.

‘fs.’ ( r –  ) floating-ext “f-s-dot”
   Display r using scientific notation (with exponent), followed by a
space.

‘fp.’ ( r –  ) floating-ext “f-e-dot”
   Display r using SI prefix notation (with exponent dividable by 3,
converted into SI prefixes if available), followed by a space.

   Examples of printing the number 1234.5678E23 in the different
floating-point output formats are shown below.

     f. 123456780000000000000000000.
     fe. 123.456780000000E24
     fs. 1.23456780000000E26
     fp. 123.456780000000Y

   The length of the output is influenced by:

‘precision’ ( – u  ) floating-ext “precision”
   u is the number of significant digits currently used by ‘F.’ ‘FE.’
and ‘FS.’

‘set-precision’ ( u –  ) floating-ext “set-precision”
   Set the number of significant digits currently used by ‘F.’ ‘FE.’ and
‘FS.’ to u.

   You can control the output in more detail with:

‘f.rdp’ ( rf +nr +nd +np –  ) gforth-0.6 “f.rdp”
   Print float rf formatted.  The total width of the output is nr.  For
fixed-point notation, the number of digits after the decimal point is
+nd and the minimum number of significant digits is np.  ‘Set-precision’
has no effect on ‘f.rdp’.  Fixed-point notation is used if the number of
siginicant digits would be at least np and if the number of digits
before the decimal point would fit.  If fixed-point notation is not
used, exponential notation is used, and if that does not fit, asterisks
are printed.  We recommend using nr>=7 to avoid the risk of numbers not
fitting at all.  We recommend nr>=np+5 to avoid cases where ‘f.rdp’
switches to exponential notation because fixed-point notation would have
too few significant digits, yet exponential notation offers fewer
significant digits.  We recommend nr>=nd+2, if you want to have
fixed-point notation for some numbers; the smaller the value of np, the
more cases are shown in fixed-point notation (cases where few or no
significant digits remain in fixed-point notation).  We recommend np>nr,
if you want to have exponential notation for all numbers.

   To give you a better intuition of how they influence the output, here
are some examples of parameter combinations; in each line the same
number is printed, in each column the same parameter combination is used
for printing:

         12 13 0    7 3 4   7 3 0   7 3 1   7 5 1   7 7 1   7 0 2  4 2 1
     |-1.234568E-6|-1.2E-6| -0.000|-1.2E-6|-1.2E-6|-1.2E-6|-1.2E-6|****|
     |-1.234568E-5|-1.2E-5| -0.000|-1.2E-5|-.00001|-1.2E-5|-1.2E-5|****|
     |-1.234568E-4|-1.2E-4| -0.000|-1.2E-4|-.00012|-1.2E-4|-1.2E-4|****|
     |-1.234568E-3|-1.2E-3| -0.001| -0.001|-.00123|-1.2E-3|-1.2E-3|****|
     |-1.234568E-2|-1.2E-2| -0.012| -0.012|-.01235|-1.2E-2|-1.2E-2|-.01|
     |-1.234568E-1|-1.2E-1| -0.123| -0.123|-.12346|-1.2E-1|-1.2E-1|-.12|
     |-1.2345679E0| -1.235| -1.235| -1.235|-1.23E0|-1.23E0|-1.23E0|-1E0|
     |-1.2345679E1|-12.346|-12.346|-12.346|-1.23E1|-1.23E1|   -12.|-1E1|
     |-1.2345679E2|-1.23E2|-1.23E2|-1.23E2|-1.23E2|-1.23E2|  -123.|-1E2|
     |-1.2345679E3|-1.23E3|-1.23E3|-1.23E3|-1.23E3|-1.23E3| -1235.|-1E3|
     |-1.2345679E4|-1.23E4|-1.23E4|-1.23E4|-1.23E4|-1.23E4|-12346.|-1E4|
     |-1.2345679E5|-1.23E5|-1.23E5|-1.23E5|-1.23E5|-1.23E5|-1.23E5|-1E5|

   You can generate a string instead of displaying the number with:

‘f>str-rdp’ ( rf +nr +nd +np – c-addr nr  ) gforth-0.6 “f>str-rdp”
   Convert rf into a string at c-addr nr.  The conversion rules and the
meanings of nr +nd np are the same as for ‘f.rdp’.  The result in in the
pictured numeric output buffer and will be destroyed by anything
destroying that buffer.

‘f>buf-rdp’ ( rf c-addr +nr +nd +np –  ) gforth-0.6 “f>buf-rdp”
   Convert rf into a string at c-addr nr.  The conversion rules and the
meanings of nr nd np are the same as for ‘f.rdp’.

   There is also a primitive used for implementing higher-level
FP-to-string words:

‘represent’ ( r c-addr u – n f1 f2 ) floating “represent”
   Convert the decimal significand (aka mantissa) of r into a string in
buffer c-addr u; n is the exponent, f1 is true if r is negative, and f2
is true if r is valid (a finite number in Gforth).


File: gforth.info,  Node: Miscellaneous output,  Next: Displaying characters and strings,  Prev: Floating-point output,  Up: Other I/O

6.20.4 Miscellaneous output
---------------------------

‘cr’ ( –  ) core “c-r”
   Output a newline (of the favourite kind of the host OS). Note that
due to the way the Forth command line interpreter inserts newlines, the
preferred way to use ‘cr’ is at the start of a piece of text; e.g., ‘cr
." hello, world"’.

‘space’ ( –  ) core “space”
   Display one space.

‘spaces’ ( u –  ) core “spaces”
   Display U spaces.

‘out’ ( – addr  ) gforth-1.0 “out”
   ‘Addr’ contains a number that tries to give the position of the
cursor within the current line on the user output device: It resets to 0
on ‘cr’, increases by the number of characters by ‘type’ and ‘emit’, and
decreases on ‘backspaces’.  Unfortunately, it does not take into account
tabs, multi-byte characters, or the existence of Unicode characters with
width 0 and 2, so it only works for simple cases.

‘.\"’ ( compilation ’ccc"’ – ; run-time –  ) gforth-0.6 “dot-backslash-quote”
   Like ‘."’, but translates C-like \-escape-sequences (see ‘S\"’).

‘."’ ( compilation ’ccc"’ – ; run-time –  ) core “dot-quote”
   Compilation: Parse a string ccc delimited by a " (double quote).  At
run-time, display the string.  Interpretation semantics for this word
are undefined in standard Forth.  Gforth’s interpretation semantics are
to display the string.

‘.(’ ( compilation&interpretation "ccc<paren>" –  ) core-ext “dot-paren”
   Compilation and interpretation semantics: Parse a string ccc
delimited by a ‘)’ (right parenthesis).  Display the string.  This is
often used to display progress information during compilation; see
examples below.

   If you don’t want to worry about wether to use ‘.( hello)’ or ‘."
hello"’, you can write ‘"hello" type’, which gives you what you usually
want (but is less portable to other Forth systems).

As an example, consider the following text, stored in a file ‘test.fs’:

     .( text-1)
     : my-word
       ." text-2" cr
       .( text-3)
       "text-4" type
     ;

     ." text-5"
     "text-6" type

   When you load this code into Gforth, the following output is
generated:

     include test.fs <RET> text-1text-3text-5text-6 ok

   • Messages ‘text-1’ and ‘text-3’ are displayed because ‘.(’ is an
     immediate word; it behaves in the same way whether it is used
     inside or outside a colon definition.
   • Message ‘text-5’ is displayed because of Gforth’s added
     interpretation semantics for ‘."’.
   • Message ‘text-6’ is displayed because ‘"text-6" type’ is
     interpreted.
   • Message ‘text-2’ is not displayed, because the text interpreter
     performs the compilation semantics for ‘."’ within the definition
     of ‘my-word’.
   • Message ‘text-4’ is not displayed, because ‘"text-4" type’ is
     compiled into ‘my-word’.


File: gforth.info,  Node: Displaying characters and strings,  Next: Terminal output,  Prev: Miscellaneous output,  Up: Other I/O

6.20.5 Displaying characters and strings
----------------------------------------

‘type’ ( c-addr u –  ) core “type”
   If U>0, display U characters from a string starting with the
character stored at C-ADDR.

‘xemit’ ( xc –  ) xchar “x-emit”
   Prints an xchar on the terminal.

‘emit’ ( c –  ) core “emit”
   Send the byte c to the current output; for ASCII characters, ‘emit’
is equivalent to ‘xemit’.

‘typewhite’ ( addr n –  ) gforth-0.2 “typewhite”
   Like type, but white space is printed instead of the characters.


File: gforth.info,  Node: Terminal output,  Next: Single-key input,  Prev: Displaying characters and strings,  Up: Other I/O

6.20.6 Terminal output
----------------------

If you are outputting to a terminal, you may want to control the
positioning of the cursor:

‘at-xy’ ( x y –  ) facility “at-x-y”
   Put the curser at position x y.  The top left-hand corner of the
display is at 0 0.

‘at-deltaxy’ ( dx dy –  ) gforth-0.7 “at-deltaxy”
   With the current position at x y, put the cursor at x+dx y+dy.

   In order to know where to position the cursor, it is often helpful to
know the size of the screen:

‘form’ ( – nlines ncols  ) gforth-0.2 “form”

   And sometimes you want to use:

‘page’ ( –  ) facility “page”
   Clear the screen

   Note that on non-terminals you should use ‘12 emit’, not ‘page’, to
get a form feed.

6.20.6.1 Color output
.....................

The following words are used to create (semantic) colorful output;
further output is produced in the color and style given by the word; the
actual color and style depends on the theme (see below).

‘default-color’ ( –  ) gforth-1.0 “default-color”
   use system-default color

‘error-color’ ( –  ) gforth-1.0 “error-color”
   error color: red

‘error-hl-inv’ ( –  ) gforth-1.0 “error-hl-inv”
   color mod for error highlight inverse

‘error-hl-ul’ ( –  ) gforth-1.0 “error-hl-ul”
   color mod for error highlight underline

‘warning-color’ ( –  ) gforth-1.0 “warning-color”
   color for warnings: blue/yellow on black terminals

‘info-color’ ( –  ) gforth-1.0 “info-color”
   color for info: green/cyan on black terminals

‘success-color’ ( –  ) gforth-1.0 “success-color”
   color for success: green

‘input-color’ ( –  ) gforth-1.0 “input-color”
   color for user-input: black/white (both bold)

‘status-color’ ( –  ) gforth-1.0 “status-color”
   color mod for error highlight inverse

6.20.6.2 Color themes
.....................

Depending on wether you prefer bright or dark background the foreground
colors-theme can be changed by:

‘light-mode’ ( –  ) gforth-1.0 “light-mode”
   color theme for white background

‘dark-mode’ ( –  ) gforth-1.0 “dark-mode”
   color theme for black background

‘uncolored-mode’ ( –  ) gforth-1.0 “uncolored-mode”
   This mode does not set colors, but uses the default ones.

‘magenta-input’ ( –  ) gforth-1.0 “magenta-input”
   make input color easily recognizable (useful in presentations)


File: gforth.info,  Node: Single-key input,  Next: Line input and conversion,  Prev: Terminal output,  Up: Other I/O

6.20.7 Single-key input
-----------------------

If you want to get a single printable character, you can use ‘key’; to
check whether a character is available for ‘key’, you can use ‘key?’.

‘key’ ( – char  ) core “key”
   Receive (but do not display) one character, CHAR.

‘key-ior’ ( – char|ior  ) gforth-1.0 “key-ior”
   Receive (but do not display) one character, CHAR, in case of an error
or interrupt, return the negative IOR instead.

‘key?’ ( – flag  ) facility “key-question”
   Determine whether a character is available.  If a character is
available, FLAG is true; the next call to ‘key’ will yield the
character.  Once ‘key?’ returns true, subsequent calls to ‘key?’ before
calling ‘key’ or ‘ekey’ will also return true.

‘xkey?’ ( – flag  ) xchar “x-key-query”

   If you want to process a mix of printable and non-printable
characters, you can do that with ‘ekey’ and friends.  ‘Ekey’ produces a
keyboard event that you have to convert into a character with
‘ekey>char’ or into a key identifier with ‘ekey>fkey’.

   Typical code for using EKEY looks like this:

     ekey ekey>xchar if ( xc )
       ... \ do something with the character
     else ekey>fkey if ( key-id )
       case
         k-up                                  of ... endof
         k-f1                                  of ... endof
         k-left k-shift-mask or k-ctrl-mask or of ... endof
         ...
       endcase
     else ( keyboard-event )
       drop \ just ignore an unknown keyboard event type
     then then

‘ekey’ ( – u  ) facility-ext “e-key”
   Receive a keyboard event U (encoding implementation-defined).

‘ekey>xchar’ ( u – u false | xc true  ) xchar-ext “e-key-to-x-char”
   Convert keyboard event U into xchar ‘xc’ if possible.

‘ekey>char’ ( u – u false | c true  ) facility-ext “e-key-to-char”
   Convert keyboard event U into character ‘c’ if possible.  Note that
non-ASCII characters produce ‘false’ from both ‘ekey>char’ and
‘ekey>fkey’.  Instead of ‘ekey>char’, use ‘ekey>xchar’ if available.

‘ekey>fkey’ ( u1 – u2 f  ) facility-ext “e-key-to-f-key”
   If u1 is a keyboard event in the special key set, convert keyboard
event U1 into key id U2 and return true; otherwise return U1 and false.

‘ekey?’ ( – flag  ) facility-ext “e-key-question”
   True if a keyboard event is available.

   The key identifiers for cursor keys are:

‘k-left’ ( – u  ) facility-ext “k-left”

‘k-right’ ( – u  ) facility-ext “k-right”

‘k-up’ ( – u  ) facility-ext “k-up”

‘k-down’ ( – u  ) facility-ext “k-down”

‘k-home’ ( – u  ) facility-ext “k-home”
   aka Pos1

‘k-end’ ( – u  ) facility-ext “k-end”

‘k-prior’ ( – u  ) facility-ext “k-prior”
   aka PgUp

‘k-next’ ( – u  ) facility-ext “k-next”
   aka PgDn

‘k-insert’ ( – u  ) facility-ext “k-insert”

‘k-delete’ ( – u  ) facility-ext “k-delete”
   the <DEL> key on my xterm, not backspace

   The key identifiers for function keys (aka keypad keys) are:

‘k-f1’ ( – u  ) facility-ext “k-f-1”

‘k-f2’ ( – u  ) facility-ext “k-f-2”

‘k-f3’ ( – u  ) facility-ext “k-f-3”

‘k-f4’ ( – u  ) facility-ext “k-f-4”

‘k-f5’ ( – u  ) facility-ext “k-f-5”

‘k-f6’ ( – u  ) facility-ext “k-f-6”

‘k-f7’ ( – u  ) facility-ext “k-f-7”

‘k-f8’ ( – u  ) facility-ext “k-f-8”

‘k-f9’ ( – u  ) facility-ext “k-f-9”

‘k-f10’ ( – u  ) facility-ext “k-f-10”

‘k-f11’ ( – u  ) facility-ext “k-f-11”

‘k-f12’ ( – u  ) facility-ext “k-f-12”

   Note that ‘k-f11’ and ‘k-f12’ are not as widely available.

   You can combine these key identifiers with masks for various shift
keys:

‘k-shift-mask’ ( – u  ) facility-ext “k-shift-mask”

‘k-ctrl-mask’ ( – u  ) facility-ext “k-ctrl-mask”

‘k-alt-mask’ ( – u  ) facility-ext “k-alt-mask”

   There are a number of keys that have ASCII values, and therefore are
unlikely to be reported as special keys, but the combination of these
keys with shift keys may be reported as a special key:

‘k-enter’ ( – u  ) gforth-1.0 “k-enter”

‘k-backspace’ ( – u  ) gforth-1.0 “k-backspace”

‘k-tab’ ( – u  ) gforth-1.0 “k-tab”

   Moreover, there the following key codes for keys and other events:

‘k-winch’ ( – u  ) gforth-1.0 “k-winch”
   A key code that may be generated when the user changes the window
size.

‘k-pause’ ( – u  ) gforth-1.0 “k-pause”

‘k-mute’ ( – u  ) gforth-1.0 “k-mute”

‘k-volup’ ( – u  ) gforth-1.0 “k-volup”

‘k-voldown’ ( – u  ) gforth-1.0 “k-voldown”

‘k-sel’ ( – u  ) gforth-1.0 “k-sel”
   keycode for Android selections

‘k-eof’ ( – u  ) gforth-1.0 “k-eof”

   Note that, even if a Forth system has ‘ekey>fkey’ and the key
identifier words, the keys are not necessarily available or it may not
necessarily be able to report all the keys and all the possible
combinations with shift masks.  Therefore, write your programs in such a
way that they are still useful even if the keys and key combinations
cannot be pressed or are not recognized.

   Examples: Older keyboards often do not have an F11 and F12 key.  If
you run Gforth in an xterm, the xterm catches a number of combinations
(e.g., <Shift-Up>), and never passes it to Gforth.  Finally, Gforth
currently does not recognize and report combinations with multiple shift
keys (so the <shift-ctrl-left> case in the example above would never be
entered).

   Gforth recognizes various keys available on ANSI terminals (in MS-DOS
you need the ANSI.SYS driver to get that behaviour); it works by
recognizing the escape sequences that ANSI terminals send when such a
key is pressed.  If you have a terminal that sends other escape
sequences, you will not get useful results on Gforth.  Other Forth
systems may work in a different way.

   Gforth also provides a few words for outputting names of function
keys:

‘fkey.’ ( u –  ) gforth-1.0 “fkey-dot”
   Print a string representation for the function key u.  U must be a
function key (possibly with modifier masks), otherwise there may be an
exception.

‘simple-fkey-string’ ( u1 – c-addr u  ) gforth-1.0 “simple-fkey-string”
   c-addr u is the string name of the function key u1.  Only works for
simple function keys without modifier masks.  Any u1 that does not
correspond to a simple function key currently produces an exception.


File: gforth.info,  Node: Line input and conversion,  Next: Pipes,  Prev: Single-key input,  Up: Other I/O

6.20.8 Line input and conversion
--------------------------------

For ways of storing character strings in memory see *note String
representations::.

   Words for inputting one line from the keyboard:

‘accept’ ( c-addr +n1 – +n2  ) core “accept”
   Get a string of up to N1 characters from the user input device and
store it at C-ADDR.  N2 is the length of the received string.  The user
indicates the end by pressing <RET>.  Gforth supports all the editing
functions available on the Forth command line (including history and
word completion) in ‘accept’.

‘edit-line’ ( c-addr n1 n2 – n3  ) gforth-0.6 “edit-line”
   edit the string with length N2 in the buffer C-ADDR N1, like
‘accept’.

   Conversion words:

‘s>number?’ ( addr u – d f  ) gforth-0.5 “s>number?”
   converts string addr u into d, flag indicates success

‘s>unumber?’ ( c-addr u – ud flag  ) gforth-0.5 “s>unumber?”
   converts string c-addr u into ud, flag indicates success

‘>number’ ( ud1 c-addr1 u1 – ud2 c-addr2 u2  ) core “to-number”
   Attempt to convert the character string C-ADDR1 U1 to an unsigned
number in the current number base.  The double UD1 accumulates the
result of the conversion to form UD2.  Conversion continues,
left-to-right, until the whole string is converted or a character that
is not convertable in the current number base is encountered (including
+ or -).  For each convertable character, UD1 is first multiplied by the
value in ‘BASE’ and then incremented by the value represented by the
character.  C-ADDR2 is the location of the first unconverted character
(past the end of the string if the whole string was converted).  U2 is
the number of unconverted characters in the string.  Overflow is not
detected.

‘>float’ ( c-addr u – f:... flag ) floating “to-float”
   Actual stack effect: ( c_addr u – r t | f ).  Attempt to convert the
character string c-addr u to internal floating-point representation.  If
the string represents a valid floating-point number, r is placed on the
floating-point stack and flag is true.  Otherwise, flag is false.  A
string of blanks is a special case and represents the floating-point
number 0.

‘>float1’ ( c-addr u c – f:... flag ) gforth-1.0 “to-float1”
   Actual stack effect: ( c_addr u c – r t | f ).  Attempt to convert
the character string c-addr u to internal floating-point representation,
with c being the decimal separator.  If the string represents a valid
floating-point number, r is placed on the floating-point stack and flag
is true.  Otherwise, flag is false.  A string of blanks is a special
case and represents the floating-point number 0.

   Obsolescent input and conversion words:

‘convert’ ( ud1 c-addr1 – ud2 c-addr2  ) core-ext-obsolescent “convert”
   Obsolescent: superseded by ‘>number’.

‘expect’ ( c-addr +n –  ) core-ext-obsolescent “expect”
   Receive a string of at most +n characters, and store it in memory
starting at c-addr.  The string is displayed.  Input terminates when the
<return> key is pressed or +n characters have been received.  The normal
Gforth line editing capabilites are available.  The length of the string
is stored in ‘span’; it does not include the <return> character.
OBSOLESCENT: superceeded by ‘accept’.

‘span’ ( – c-addr  ) core-ext-obsolescent “span”
   ‘Variable’ – c-addr is the address of a cell that stores the length
of the last string received by ‘expect’.  OBSOLESCENT.


File: gforth.info,  Node: Pipes,  Next: Xchars and Unicode,  Prev: Line input and conversion,  Up: Other I/O

6.20.9 Pipes
------------

In addition to using Gforth in pipes created by other processes (*note
Gforth in pipes::), you can create your own pipe with ‘open-pipe’, and
read from or write to it.

‘open-pipe’ ( c-addr u wfam – wfileid wior ) gforth-0.2 “open-pipe”

‘close-pipe’ ( wfileid – wretval wior ) gforth-0.2 “close-pipe”

   If you write to a pipe, Gforth can throw a ‘broken-pipe-error’; if
you don’t catch this exception, Gforth will catch it and exit, usually
silently (*note Gforth in pipes::).  Since you probably do not want
this, you should wrap a ‘catch’ or ‘try’ block around the code from
‘open-pipe’ to ‘close-pipe’, so you can deal with the problem yourself,
and then return to regular processing.

‘broken-pipe-error’ ( – n  ) gforth-0.6 “broken-pipe-error”
   the error number for a broken pipe


File: gforth.info,  Node: Xchars and Unicode,  Next: i18n and l10n,  Prev: Pipes,  Up: Other I/O

6.20.10 Xchars and Unicode
--------------------------

ASCII is only appropriate for the English language.  Most western
languages however fit somewhat into the Forth frame, since a byte is
sufficient to encode the few special characters in each (though not
always the same encoding can be used; latin-1 is most widely used,
though).  For other languages, different char-sets have to be used,
several of them variable-width.  To deal with this problem, characters
are often represented as Unicode codepoints on the stack, and as UTF-8
byte strings in memory.  An Unicode codepoint often represents one
application-level character, but Unicode also supports decomposed
characters that consist of several code points, e.g., a base letter and
a combining diacritical mark.

   An Unicode codepoint can consume more than one byte in memory, so we
adjust our terminology: A char is a raw byte in memory or a value in the
range 0-255 on the stack.  An xchar (for extended char) stands for one
codepoint; it is represented by one or more bytes in memory and may have
larger values on the stack.  ASCII characters are the same as chars and
as xchars: values in the range 0-127, and a single byte with that value
in memory.

   When using UTF-8 encoding, all other codepoints take more than one
byte/char.  In most cases, you can just treat such characters as strings
in memory and don’t need to use the following words, but if you want to
deal with individual codepoints, the following words are useful.  We
currently have no words for dealing with decomposed characters.

   The xchar words add a few data types:

   • XC is an extended char (xchar) on the stack.  It occupies one cell,
     and is a subset of unsigned cell.  On 16 bit systems, only the BMP
     subset of the Unicode character set (i.e., codepoints <65536) can
     be represented on the stack.  If you represent your application
     characters as strings at all times, you can avoid this limitation.

   • XC-ADDR is the address of an xchar in memory.  Alignment
     requirements are the same as C-ADDR.  The memory representation of
     an xchar differs from the stack representation, and depends on the
     encoding used.  An xchar may use a variable number of chars in
     memory.

   • XC-ADDR U is a buffer of xchars in memory, starting at XC-ADDR, U
     chars (i.e., bytes, not xchars) long.

‘xc-size’ ( xc – u  ) xchar “x-c-size”
   Computes the memory size of the xchar XC in chars.

‘x-size’ ( xc-addr u1 – u2  ) xchar “x-size”
   Computes the memory size of the first xchar stored at XC-ADDR in
chars.

‘xc@’ ( xc-addr – xc  ) xchar-ext “xc-fetch”
   Fetchs the xchar XC at XC-ADDR1.

‘xc@+’ ( xc-addr1 – xc-addr2 xc  ) xchar “x-c-fetch-plus”
   Fetchs the xchar XC at XC-ADDR1.  XC-ADDR2 points to the first memory
location after XC.

‘xc@+?’ ( xc-addr1 u1 – xc-addr2 u2 xc  ) gforth-experimental “x-c-fetch-plus-query”
   Fetchs the first xchar XC of the string XC-ADDR1 U1.  XC-ADDR2 U2 is
the remaining string after XC.

‘xc!+?’ ( xc xc-addr1 u1 – xc-addr2 u2 f  ) xchar “x-c-store-plus-query”
   Stores the xchar XC into the buffer starting at address XC-ADDR1, U1
chars large.  XC-ADDR2 points to the first memory location after XC, U2
is the remaining size of the buffer.  If the xchar XC did fit into the
buffer, F is true, otherwise F is false, and XC-ADDR2 U2 equal XC-ADDR1
U1.  XC!+?  is safe for buffer overflows, and therefore preferred over
XC!+.

‘xc!+’ ( xc xc-addr1 – xc-addr2  ) xchar “x-c-store”
   Stores the xchar XC at XC-ADDR1.  XC-ADDR2 is the next unused address
in the buffer.  Note that this writes up to 4 bytes, so you need at
least 3 bytes of padding after the end of the buffer to avoid
overwriting useful data if you only check the address against the end of
the buffer.

‘xchar+’ ( xc-addr1 – xc-addr2  ) xchar “x-char-plus”
   Adds the size of the xchar stored at XC-ADDR1 to this address, giving
XC-ADDR2.

‘xchar-’ ( xc-addr1 – xc-addr2  ) xchar-ext “x-char-minus”
   Goes backward from XC_ADDR1 until it finds an xchar so that the size
of this xchar added to XC_ADDR2 gives XC_ADDR1.

‘+x/string’ ( xc-addr1 u1 – xc-addr2 u2  ) xchar-ext “plus-x-slash-string”
   Step forward by one xchar in the buffer defined by address XC-ADDR1,
size U1 chars.  XC-ADDR2 is the address and u2 the size in chars of the
remaining buffer after stepping over the first xchar in the buffer.

‘x\string-’ ( xc-addr u1 – xc-addr u2  ) xchar-ext “x-backslash-string-minus”
   Step backward by one xchar in the buffer defined by address XC-ADDR
and size U1 in chars, starting at the end of the buffer.  XC-ADDR is the
address and U2 the size in chars of the remaining buffer after stepping
backward over the last xchar in the buffer.

‘-trailing-garbage’ ( xc-addr u1 – xc-addr u2  ) xchar-ext “minus-trailing-garbage”
   Examine the last XCHAR in the buffer XC-ADDR U1—if the encoding is
correct and it repesents a full char, U2 equals U1, otherwise, U2
represents the string without the last (garbled) xchar.

‘x-width’ ( xc-addr u – n  ) xchar-ext “x-width”
   N is the number of monospace ASCII chars that take the same space to
display as the the xchar string starting at XC-ADDR, using U chars;
assuming a monospaced display font, i.e.  char width is always an
integer multiple of the width of an ASCII char.

‘xkey’ ( – xc  ) xchar “x-key”
   Reads an xchar from the terminal.  This will discard all input events
up to the completion of the xchar.

‘xc-width’ ( xc – n  ) xchar-ext “x-c-width”
   XC has a width of N times the width of a normal fixed-width glyph.

‘xhold’ ( xc –  ) xchar-ext “x-hold”
   Used between ‘<<#’ and ‘#>’.  Prepend XC to the pictured numeric
output string.  Alternatively, use ‘holds’.

‘xc,’ ( xchar –  ) xchar “x-c-comma”


File: gforth.info,  Node: i18n and l10n,  Next: Substitute,  Prev: Xchars and Unicode,  Up: Other I/O

6.20.11 国際化(I18n)とローカライズ
----------------------------------

Programs for end users require to address those in their native
language.  There is a decades old proposal for such a facility that has
been split from other proposals for international character sets like
Xchars (*note Xchars and Unicode::) and Substitute (*note Substitute::).
Messages displayed on the screen need to be translated from the native
language of the developers to the local languages of the user.

   Strings subject to translation are declared with ‘L" ’STRING‘"’.
This returns a locale string identifier (LSID). LSIDs are opaque types,
taking a cell on the stack.  LSIDs can be translated into a locale;
locales are languages and country-specific variants of that language.

‘L"’ ( "lsid<">" – lsid  ) gforth-experimental “l-quote”
   Parse a string and define a new lsid, if the string is uniquely new.
Identical strings result in identical lsids, which allows to refer to
the same lsid from multiple locations using the same string.

‘LU"’ ( "lsid<">" – lsid  ) gforth-experimental “l-unique-quote”
   Parse a string and always define a new lsid, even if the string is
not unique.

‘native@’ ( lsid – addr u  ) gforth-experimental “native-fetch”
   fetch native string from an LSID

‘locale@’ ( lsid – addr u  ) gforth-experimental “locale-fetch”
   fetch the localized string in the current language and country

‘locale!’ ( addr u lsid –  ) gforth-experimental “locale-store”
   Store localized string ADDR U for the current locale and country in
LSID.

‘Language’ ( "name" –  ) gforth-experimental “Language”
   define a locale.  Executing that locale makes it the current locale.

‘Country’ ( <lang> "name" –  ) gforth-experimental “Country”
   define a variant (typical: country) for the current locale.
Executing that locale makes it the current locale.  You can create
variants of variants (a country may have variants within, e.g.  think of
how many words for rolls/buns there are in many languages).

‘locale-file’ ( fid –  ) gforth-experimental “locale-file”
   read lines from FID into the current locale.

‘included-locale’ ( addr u –  ) gforth-experimental “included-locale”
   read lines from the file ADDR U into the current locale.

‘include-locale’ ( "name" –  ) gforth-experimental “include-locale”
   read lines from the file "NAME" into the current locale.

‘locale-csv’ ( "name" –  ) gforth-experimental “locale-csv”
   import comma-separated value table into locales.  first line contains
locale names, “program” and “default” are special entries; generic
languages must preceed translations for specific countries.  Entries
under “program” (must be leftmost) are used to search for the lsid; if
empty, the line number-1 is the lsid index.

‘.locale-csv’ ( –  ) gforth-experimental “dot-locale-csv”
   write the locale database in CSV format to the terminal output.

‘locale-csv-out’ ( "name" –  ) gforth-experimental “locale-csv”
   Create file "NAME" and write the locale database out to the file
"NAME" in CSV format.


File: gforth.info,  Node: Substitute,  Next: CSV Reader,  Prev: i18n and l10n,  Up: Other I/O

6.20.12 Substitute
------------------

This is a simple text macro replacement facility.  Texts in the form
‘"text %macro% text"’ are processed, and the macro variables enclosed in
‘'%'’ are replaced with their associated strings.  Two consecutive ‘%’
are replaced by one ‘%’.  Macros are defined in a specific wordlist, and
return a string upon execution; the standard defines only one way to
declare macros, ‘replaces’, which creates a macro that just returns a
string.

‘macros-wordlist’ ( – wid  ) gforth-experimental “macros-wordlist”
   wordlist for string replacement macros

‘replaces’ ( addr1 len1 addr2 len2 –  ) string-ext “replaces”
   create a macro with name ADDR2 LEN2 and content ADDR1 LEN1.  If the
macro already exists, just change the content.

‘.substitute’ ( addr1 len1 – n / ior  ) gforth-experimental “dot-substitute”
   substitute all macros in text ADDR1 LEN1 and print the result.  N is
the number of substitutions or, if negative, a throwable IOR.

‘$substitute’ ( addr1 len1 – addr2 len2 n/ior  ) gforth-experimental “string-substitute”
   substitute all macros in text ADDR1 LEN1.  N is the number of
substitutions, if negative, it’s a throwable IOR, ADDR2 LEN2 the result.

‘substitute’ ( addr1 len1 addr2 len2 – addr2 len3 n/ior  ) string-ext “substitute”
   substitute all macros in text ADDR1 LEN1, and copy the result to
ADDR2 LEN2.  N is the number of substitutions or, if negative, a
throwable IOR, ADDR2 LEN3 the result.

‘unescape’ ( addr1 u1 dest – dest u2  ) string-ext “unescape”
   double all delimiters in ADDR1 U1, so that substitute will result in
the original text.  Note that the buffer DEST does not have a size, as
in worst case, it will need just twice as many characters as U1.  DEST
U2 is the resulting string.

‘$unescape’ ( addr1 u1 – addr2 u2  ) gforth-experimental “string-unescape”
   same as ‘unescape’, but creates a temporary destination string with
‘$tmp’.


File: gforth.info,  Node: CSV Reader,  Prev: Substitute,  Up: Other I/O

6.20.13 CSV Reader
------------------

Comma-separated values (CSV) are a popular text format to interchange
data.  Gforth provides an reader in ‘csv.fs’.

‘read-csv’ ( addr u xt –  ) gforth-experimental “read-csv”
   read CVS file ADDR U and execute XT for every item found.  XT takes
‘( addr u col line -- )’, i.e.  the string, the current column (starting
with 0), and the current line (starting with 1).


File: gforth.info,  Node: OS command line arguments,  Next: Locals,  Prev: Other I/O,  Up: Words

6.21 OS command line arguments
==============================

The usual way to pass arguments to Gforth programs on the command line
is via the ‘-e’ option, e.g.

     gforth -e "123 456" foo.fs -e bye

   However, you may want to interpret the command-line arguments
directly.  In that case, you can access the (image-specific)
command-line arguments through ‘next-arg’:

‘next-arg’ ( – addr u  ) gforth-0.7 “next-arg”
   get the next argument from the OS command line, consuming it; if
there is no argument left, return ‘0 0’.

   Here’s an example program ‘echo.fs’ for ‘next-arg’:

     : echo ( -- )
         begin
     	next-arg 2dup 0 0 d<> while
     	    type space
         repeat
         2drop ;

     echo cr bye

   This can be invoked with

     gforth echo.fs hello world

   and it will print

     hello world

   The next lower level of dealing with the OS command line are the
following words:

‘arg’ ( u – addr count  ) gforth-0.2 “arg”
   Return the string for the uth command-line argument; returns ‘0 0’ if
the access is beyond the last argument.  ‘0 arg’ is the program name
with which you started Gforth.  The next unprocessed argument is always
‘1 arg’, the one after that is ‘2 arg’ etc.  All arguments already
processed by the system are deleted.  After you have processed an
argument, you can delete it with ‘shift-args’.

‘shift-args’ ( –  ) gforth-0.7 “shift-args”
   ‘1 arg’ is deleted, shifting all following OS command line parameters
to the left by 1, and reducing ‘argc @’.  This word can change ‘argv @’.

   Finally, at the lowest level Gforth provides the following words:

‘argc’ ( – addr  ) gforth-0.2 “argc”
   ‘Variable’ – the number of command-line arguments (including the
command name).  Changed by ‘next-arg’ and ‘shift-args’.

‘argv’ ( – addr  ) gforth-0.2 “argv”
   ‘Variable’ – a pointer to a vector of pointers to the command-line
arguments (including the command-name).  Each argument is represented as
a C-style zero-terminated string.  Changed by ‘next-arg’ and
‘shift-args’.


File: gforth.info,  Node: Locals,  Next: Structures,  Prev: OS command line arguments,  Up: Words

6.22 Locals
===========

Local variables can make Forth programming more enjoyable and Forth
programs easier to read.  Unfortunately, the locals of Standard Forth
are laden with restrictions.  Therefore, we provide not only the
Standard Forth locals wordset, but also our own, more powerful locals
wordset (we implemented the Standard Forth locals wordset through our
locals wordset).

   The ideas in this section have also been published in M. Anton Ertl,
‘Automatic Scoping of Local Variables
(https://www.complang.tuwien.ac.at/papers/ertl94l.ps.gz)’, EuroForth
’94.

* Menu:

* Gforth locals::
* Standard Forth locals::


File: gforth.info,  Node: Gforth locals,  Next: Standard Forth locals,  Prev: Locals,  Up: Locals

6.22.1 Gforth locals
--------------------

Locals can be defined with

     {: local1 local2 ... -- comment :}
   or
     {: local1 local2 ... :}
   or
     {: local1 local2 ... | ulocal0 ulocal1 -- comment :}

   E.g.,
     : max {: n1 n2 -- n3 :}
      n1 n2 > if
        n1
      else
        n2
      endif ;

   The similarity of locals definitions with stack comments is intended.
A locals definition often replaces the stack comment of a word.  The
order of the locals corresponds to the order in a stack comment and
everything after the ‘--’ is really a comment.

   This similarity has one disadvantage: It is too easy to confuse
locals declarations with stack comments, causing bugs and making them
hard to find.  However, this problem can be avoided by appropriate
coding conventions: Do not use both notations in the same program.  If
you do, they should be distinguished using additional means, e.g.  by
position.

   The name of the local may be preceded by a type specifier, e.g., ‘F:’
for a floating point value:

     : CX* {: F: Ar F: Ai F: Br F: Bi -- Cr Ci :}
     \ complex multiplication
      Ar Br f* Ai Bi f* f-
      Ar Bi f* Ai Br f* f+ ;

   Gforth currently supports cells (‘W:’, ‘WA:’, ‘W^’), doubles (‘D:’,
‘DA:’, ‘D^’), floats (‘F:’, ‘FA:’, ‘F^’), characters (‘C:’, ‘CA:’,
‘C^’), and xts (‘xt:’, ‘xta:’) in several flavours:

“value-flavoured”
     (*note Values::) A value-flavoured local (defined with ‘W:’, ‘D:’
     etc.)  produces its value and can be changed with ‘TO’.

“varue-flavoured”
     (*note Varues::) A varue-flavoured local l (defined with ‘WA:’
     etc.)  behaves exactly like a value-flavoured local, except that
     you can use ‘addr l’ to get its address (which becomes invalid when
     the variable’s scope is left).  Currently there is no performance
     difference, but in the long run value-flavoured locals will be
     significantly faster, because they can reside in registers.

“variable-flavoured”
     (*note Variables::) A variable-flavoured local (defined with ‘W^’
     etc.)  produces its address (which becomes invalid when the
     variable’s scope is left).  E.g., the standard word ‘emit’ can be
     defined in terms of ‘type’ like this:

          : emit {: C^ char* -- :}
              char* 1 type ;

“defer-flavoured”
     (*note Deferred Words::) A defer-flavoured local (defined with
     ‘XT:’ or ‘XTA:’) ‘execute’s the xt; you can use ‘action-of’ (*note
     Deferred Words::) to get the xt out of a defer-flavoured local.  If
     the local is defined with ‘xta:’, you can use ‘addr’ to get the
     address (valid until the end of the scope of the local) where the
     xt is stored.  E.g., the standard word ‘execute’ can be defined
     with a defer-flavoured local like this:

          : execute {: xt: x -- :}
            x ;

   A local without type specifier is a ‘W:’ local.  You can allow or
disallow the use of ‘addr’ with:

‘default-wa:’ ( –  ) gforth-experimental “default-wa:”
   Allow ‘addr’ on locals defined without a type specifyer.  On other
words, define locals without a type specifyer using ‘wa:’.

‘default-w:’ ( –  ) gforth-experimental “default-w:”
   Forbid ‘addr’ on locals defined without a type specifyer.  On other
words, define locals without a type specifyer using ‘w:’.

   All flavours of locals are initialized with values from the data or
(for FP locals) FP stack, with the exception being locals defined behind
‘|’: Gforth initializes them to 0; some Forth systems leave them
uninitialized.

   Gforth supports the square bracket notation for local buffers and
data structures.  These locals are similar to variable-flavored locals,
the size is specified as a constant expression.  A declaration looks
‘name[ size ]’.  The Forth expression ‘size’ is evaluated during
declaration, it must have the stack effect ‘( -- +n )’, giving the size
in bytes.  The square bracket ‘[’ is part of the defined name.

   Local data structures are initialized by copying size bytes from an
address passed on the stack; uninitialized local data structures (after
‘|’ in the declaration) are not erased, they just contain whatever data
there was on the locals stack before.

   Example:

     begin-structure test-struct
       field: a1
       field: a2
     end-structure

     : test-local {: foo[ test-struct ] :}
         foo[ a1 !  foo[ a2 !
         foo[ test-struct dump ;

   Gforth allows defining locals everywhere in a colon definition.  This
poses the following questions:

* Menu:

* Locals definition words::
* Where are locals visible by name?::
* How long do locals live?::
* Locals programming style::
* Locals implementation::
* Closures::


File: gforth.info,  Node: Locals definition words,  Next: Where are locals visible by name?,  Prev: Gforth locals,  Up: Gforth locals

6.22.1.1 Locals definitions words
.................................

This section documents the words used for defining locals.  Note that
the run-times for the words (like ‘W:’) that define a local are
performed from the rightmost defined local to the leftmost defined
local, such that the rightmost local gets the top of stack.

‘{:’ ( – hmaddr u latest latestnt wid 0  ) local-ext “open-brace-colon”
   Start locals definitions.

‘--’ ( hmaddr u latest latestnt wid 0 ... –  ) gforth-0.2 “dash-dash”
   During locals definitions everything from ‘--’ to ‘:}’ is ignored.
This is typically used when you want to make a locals definition serve
double duty as a stack effect description.

‘|’ ( –  ) gforth-1.0 “bar”
   Locals defined behind ‘|’ are not initialized from the stack; so the
run-time of words like ‘W:’ changes to ‘( -- )’.

‘:}’ ( hmaddr u latest latestnt wid 0 xt1 ... xtn –  ) gforth-1.0 “colon-close-brace”
   Ends locals definitions.

‘{’ ( – hmaddr u latest latestnt wid 0  ) gforth-0.2 “open-brace”
   Start locals definitions.  The Forth-2012 standard name for this word
is ‘{:’.

‘}’ ( hmaddr u latest latestnt wid 0 xt1 ... xtn –  ) gforth-0.2 “close-brace”
   Ends locals definitions.  The Forth-2012 standard name for this word
is ‘:}’.

‘W:’ ( compilation "name" – a-addr xt; run-time x –  ) gforth-0.2 “w-colon”
   Define value-flavoured cell local name ‘( -- x1 )’

‘WA:’ ( compilation "name" – a-addr xt; run-time x –  ) gforth-1.0 “w-a-colon”
   Define varue-flavoured cell local name ‘( -- x1 )’

‘W^’ ( compilation "name" – a-addr xt; run-time x –  ) gforth-0.2 “w-caret”
   Define variable-flavoured cell local name ‘( -- a-addr )’

‘D:’ ( compilation "name" – a-addr xt; run-time x1 x2 –  ) gforth-0.2 “d-colon”
   Define value-flavoured double local name ‘( -- x3 x4 )’

‘DA:’ ( compilation "name" – a-addr xt; run-time x1 x2 –  ) gforth-1.0 “w-a-colon”
   Define varue-flavoured double local name ‘( -- x3 x4 )’

‘D^’ ( compilation "name" – a-addr xt; run-time x1 x2 –  ) gforth-0.2 “d-caret”
   Define variable-flavoured double local name ‘( -- a-addr )’

‘C:’ ( compilation "name" – a-addr xt; run-time c –  ) gforth-0.2 “c-colon”
   Define value-flavoured char local name ‘( -- c1 )’

‘CA:’ ( compilation "name" – a-addr xt; run-time c –  ) gforth-1.0 “c-a-colon”
   Define varue-flavoured char local name ‘( -- c1 )’

‘C^’ ( compilation "name" – a-addr xt; run-time c –  ) gforth-0.2 “c-caret”
   Define variable-flavoured char local name ‘( -- c-addr )’

‘F:’ ( compilation "name" – a-addr xt; run-time r –  ) gforth-0.2 “f-colon”
   Define value-flavoured float local name ‘( -- r1 )’

‘FA:’ ( compilation "name" – a-addr xt; run-time f –  ) gforth-1.0 “f-a-colon”
   Define varue-flavoured float local name ‘( -- r1 )’

‘F^’ ( compilation "name" – a-addr xt; run-time r –  ) gforth-0.2 “f-caret”
   Define variable-flavoured float local name ‘( -- f-addr )’

‘XT:’ ( compilation "name" – a-addr xt; run-time xt1 –  ) gforth-1.0 “x-t-colon”
   Define defer-flavoured cell local name ‘( ... -- ... )’

‘XTA:’ ( compilation "name" – a-addr xt; run-time ... – ...  ) gforth-1.0 “x-t-a-colon”
   Define a defer-flavoured local name on which ‘addr’ can be used.

   Note that ‘|’, ‘--’, ‘:}’ and ‘}’ are not normally in the search
order (they are in the vocabulary ‘locals-types’), and they are not
necessarily words in all Forth systems; therefore they are documented as
Gforth words.


File: gforth.info,  Node: Where are locals visible by name?,  Next: How long do locals live?,  Prev: Locals definition words,  Up: Gforth locals

6.22.1.2 Where are locals visible by name?
..........................................

Basically, the answer is that locals are visible where you would expect
it in block-structured languages, and sometimes a little longer.  If you
want to restrict the scope of a local, enclose its definition in
‘SCOPE’...‘ENDSCOPE’.

‘scope’ ( compilation  – scope ; run-time  –  ) gforth-0.2 “scope”

‘endscope’ ( compilation scope – ; run-time  –  ) gforth-0.2 “endscope”

   These words behave like control structure words, so you can use them
with ‘CS-PICK’ and ‘CS-ROLL’ to restrict the scope in arbitrary ways.

   If you want a more exact answer to the visibility question, here’s
the basic principle: A local is visible in all places that can only be
reached through the definition of the local(1).  In other words, it is
not visible in places that can be reached without going through the
definition of the local.  E.g., locals defined in ‘IF’...‘ENDIF’ are
visible until the ‘ENDIF’, locals defined in ‘BEGIN’...‘UNTIL’ are
visible after the ‘UNTIL’ (until, e.g., a subsequent ‘ENDSCOPE’).

   The reasoning behind this solution is: We want to have the locals
visible as long as it is meaningful.  The user can always make the
visibility shorter by using explicit scoping.  In a place that can only
be reached through the definition of a local, the meaning of a local
name is clear.  In other places it is not: How is the local initialized
at the control flow path that does not contain the definition?  Which
local is meant, if the same name is defined twice in two independent
control flow paths?

   This should be enough detail for nearly all users, so you can skip
the rest of this section.  If you really must know all the gory details
and options, read on.

   In order to implement this rule, the compiler has to know which
places are unreachable.  It knows this automatically after ‘AHEAD’,
‘AGAIN’, ‘EXIT’ and ‘LEAVE’; in other cases (e.g., after most ‘THROW’s),
you can use the word ‘UNREACHABLE’ to tell the compiler that the control
flow never reaches that place.  If ‘UNREACHABLE’ is not used where it
could, the only consequence is that the visibility of some locals is
more limited than the rule above says.  If ‘UNREACHABLE’ is used where
it should not (i.e., if you lie to the compiler), buggy code will be
produced.

‘UNREACHABLE’ ( –  ) gforth-0.2 “UNREACHABLE”

   Another problem with this rule is that at ‘BEGIN’, the compiler does
not know which locals will be visible on the incoming back-edge.  All
problems discussed in the following are due to this ignorance of the
compiler (we discuss the problems using ‘BEGIN’ loops as examples; the
discussion also applies to ‘?DO’ and other loops).  Perhaps the most
insidious example is:
     AHEAD
     BEGIN
       x
     [ 1 CS-ROLL ] THEN
       {: x :}
       ...
     UNTIL

   This should be legal according to the visibility rule.  The use of
‘x’ can only be reached through the definition; but that appears
textually below the use.

   From this example it is clear that the visibility rules cannot be
fully implemented without major headaches.  Our implementation treats
common cases as advertised and the exceptions are treated in a safe way:
The compiler makes a reasonable guess about the locals visible after a
‘BEGIN’; if it is too pessimistic, the user will get a spurious error
about the local not being defined; if the compiler is too optimistic, it
will notice this later and issue a warning.  In the case above the
compiler would complain about ‘x’ being undefined at its use.  You can
see from the obscure examples in this section that it takes quite
unusual control structures to get the compiler into trouble, and even
then it will often do fine.

   If the ‘BEGIN’ is reachable from above, the most optimistic guess is
that all locals visible before the ‘BEGIN’ will also be visible after
the ‘BEGIN’.  This guess is valid for all loops that are entered only
through the ‘BEGIN’, in particular, for normal
‘BEGIN’...‘WHILE’...‘REPEAT’ and ‘BEGIN’...‘UNTIL’ loops and it is
implemented in our compiler.  When the branch to the ‘BEGIN’ is finally
generated by ‘AGAIN’ or ‘UNTIL’, the compiler checks the guess and warns
the user if it was too optimistic:
     IF
       {: x :}
     BEGIN
       \ x ?
     [ 1 cs-roll ] THEN
       ...
     UNTIL

   Here, ‘x’ lives only until the ‘BEGIN’, but the compiler
optimistically assumes that it lives until the ‘THEN’.  It notices this
difference when it compiles the ‘UNTIL’ and issues a warning.  The user
can avoid the warning, and make sure that ‘x’ is not used in the wrong
area by using explicit scoping:
     IF
       SCOPE
       {: x :}
       ENDSCOPE
     BEGIN
     [ 1 cs-roll ] THEN
       ...
     UNTIL

   Since the guess is optimistic, there will be no spurious error
messages about undefined locals.

   If the ‘BEGIN’ is not reachable from above (e.g., after ‘AHEAD’ or
‘EXIT’), the compiler cannot even make an optimistic guess, as the
locals visible after the ‘BEGIN’ may be defined later.

   It pessimistically assumes that all locals are visible that were
visible at the latest place outside any control structure (i.e., where
nothing is on the control-flow stack).  This means that in:

     : foo
       IF {: z :} THEN
       {: x :}
       AHEAD
         BEGIN
           ( * )
         [ 1 CS-ROLL ] THEN
         {: y :}
         ...
       UNTIL ;

   At the place marked with ‘( * )’, ‘x’ is visible, but ‘y’ is not
(although, according to the reachability rule it should); ‘z’ is not and
should not be visible there.

   However, you can use ‘ASSUME-LIVE’ to make the compiler assume that
the same locals are visible at the BEGIN as at the point where the top
control-flow stack item was created.

‘ASSUME-LIVE’ ( orig – orig  ) gforth-0.2 “ASSUME-LIVE”

E.g.,
     IF
       {: x :}
       AHEAD
         ASSUME-LIVE
         BEGIN
           x
         [ 1 CS-ROLL ] THEN
         ...
       UNTIL
     THEN

   Here ‘x’ would not be visible at the use of ‘x’, because its
definition is inside a control structure, but by using ASSUME-LIVE the
programmer tells the compiler that the locals visible at the ‘AHEAD’
should be visible at the ‘BEGIN’.

   Other cases where the locals are defined before the ‘BEGIN’ can be
handled by inserting an appropriate ‘CS-ROLL’ before the ‘ASSUME-LIVE’
(and changing the control-flow stack manipulation behind the
‘ASSUME-LIVE’).

   Cases where locals are defined after the ‘BEGIN’ (but should be
visible immediately after the ‘BEGIN’) can only be handled by
rearranging the loop.  E.g., the “most insidious” example above can be
arranged into:
     BEGIN
       {: x :}
       ... 0=
     WHILE
       x
     REPEAT

   ---------- Footnotes ----------

   (1) In compiler construction terminology, all places dominated by the
definition of the local.

