<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- このマニュアルは、 標準 Forth 言語の高速で移植可能な実装である Gforth (バージョン 0.7.9_20240418,
April 18, 2024)用です。 これはリファレンス・マニュアルとして機能しますが、 Forth の概要と Forth
チュートリアルも含まれています。

Authors: Bernd Paysan, Anton Ertl, Gerald Wodni Copyright © 1995,
1996, 1997, 1998, 2000, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
2011, 2012, 2013, 2014,2015,2016,2017,2018,2019,2020,2021,2022,2023 Free
Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant
Sections, with the Front-Cover texts being "A GNU Manual," and with the
Back-Cover Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have freedom to copy and modify this
GNU Manual, like GNU software.  Copies published by the Free Software
Foundation raise funds for GNU development." -->
<title>Performance (Gforth マニュアル)</title>

<meta name="description" content="Performance (Gforth マニュアル)">
<meta name="keywords" content="Performance (Gforth マニュアル)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Word-Index.html" rel="index" title="Word Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Engine.html" rel="up" title="Engine">
<link href="Primitives.html" rel="prev" title="Primitives">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
-->
</style>
<link rel="stylesheet" type="text/css" href="gforth.css">


</head>

<body lang="en">
<div class="section-level-extent" id="Performance">
<div class="nav-panel">
<p>
Previous: <a href="Primitives.html" accesskey="p" rel="prev">Primitives</a>, Up: <a href="Engine.html" accesskey="u" rel="up">Engine</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Word-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="Performance-1"><span>15.4 Performance<a class="copiable-link" href="#Performance-1"> &para;</a></span></h3>
<a class="index-entry-id" id="index-performance-of-some-Forth-interpreters"></a>
<a class="index-entry-id" id="index-engine-performance"></a>
<a class="index-entry-id" id="index-benchmarking-Forth-systems"></a>
<a class="index-entry-id" id="index-Gforth-performance"></a>

<p>RISC では、Gforth エンジンは限りなく最適な状態に近くなります。 逆に、 通常、 RISC以外では、
顕著に高速なスレッド化コード・エンジンを作成することは不可能です。
</p>
<p>386 アーキテクチャ・プロセッサのようにレジスターの数が不足しているマシンでは、 明示的なレジスター宣言があっても <code class="code">gcc</code>
が人間ほどにはレジスターを利用しないため、 人間による改善が可能です。 たとえば、Bernd Beuster は Forth
システムの断片をアセンブリ言語で作成し、 486 用に手動で調整しました。 このシステムは、 486DX2/66 での Sieve ベンチマークでは、
<code class="code">-DFORCE_REG</code> を使用して <code class="code">gcc-2.6.3</code> でコンパイルした Gforth よりも 1.19 倍高速です。
この状況は gcc-2.95 と gforth-0.4.9 で改善されました。 これで、
最も重要な仮想マシンのレジスターが実際のレジスターに収まるようになり(更に、 TOS 最適化を使用する余裕さえあります)、 結果として以前の結果よりも
1.14 高速化されました。  また、動的スーパー命令によりさらに高速化が実現されます(ただし、 486 では約 1.2 倍にすぎません)。
</p>
<a class="index-entry-id" id="index-Win32Forth-performance"></a>
<a class="index-entry-id" id="index-NT-Forth-performance"></a>
<a class="index-entry-id" id="index-eforth-performance"></a>
<a class="index-entry-id" id="index-ThisForth-performance"></a>
<a class="index-entry-id" id="index-PFE-performance"></a>
<a class="index-entry-id" id="index-TILE-performance"></a>
<p>アセンブリ言語で実装する潜在的な利点は、 Forth システムでは必ずしも現実のモノにはなりません。 Gforth
をアセンブリ言語で書かれたシステムと比較しました: Gforth-0.5.9 (直接スレッド化、 <code class="code">gcc-2.95.1</code> 、
<code class="code">-DFORCE_REG</code> でコンパイル)、 Gforth-0.5.9 の Win32Forth 版 1.2093
(新しいバージョンははるかに高速であると報告されています))、 LMI の NT Forth (1994年5月のベータ版)、
Eforth(スレッド化されたコードののぞき穴(peephole; 別名 針の穴(pinhole))最適化の有無)。 また、Gforth を
C言語で書かれた 3 つのシステムと比較しました: PFE-0.9.14 (Linux のデフォルト構成で <code class="code">gcc-2.6.3</code>
でコンパイル: <code class="code">-O2 -fomit-frame-pointer -DUSE_REGS -DUNROLL_NEXT</code>)、 ThisForth
Beta (<code class="code">gcc-2.6.3 -O3 -fomit-frame-pointer</code> でコンパイル; ThisForth
はスレッド化されたコードののぞき穴最適化を採用)、 TILE (<code class="code">make opt</code> でコンパイル)。 Linux 上の 486DX2/66
で、 Gforth と PFE と ThisForth と TILE のベンチマークを実行しました。 Kenneth O&rsquo;Heskin は、
Windows NT で同様のメモリー・パフォーマンスを備えた 486DX2/66 上の Win32Forth と NT Forth
の結果を親切に提供してくれました。 Marcel Hendrix は Eforth を Linux に移植し、 ベンチマークを実行できるように拡張し、
覗き穴・オプティマイザーを追加してベンチマークを実行し、 結果を報告しました。
</p>
<p>私たちは 4 つの小さなベンチマークを使用しました。 ユビキタスのふるい。 バブルソートと行列乗算はスタンフォード整数ベンチマーク由来で、 Martin
Fraeman によって Forth に変換されました。 TILE Forth パッケージに含まれているバージョンを使用しましたが、
データ・セット・サイズが大きくなりました。 そして、 呼び出しパフォーマンス(calling
performance)のベンチマークのための再帰的フィボナッチ数計算です。 以下の表は、 ベンチマークにかかる時間を Gforth
にかかった時間で換算したものです(つまり、 Gforth が他のシステムに対して達成した高速化係数を示しています)。
</p>
<div class="example">
<pre class="example-preformatted">relative       Win32-    NT       eforth       This-      
time     Gforth Forth Forth eforth  +opt   PFE Forth  TILE
sieve      1.00  2.16  1.78   2.16  1.32  2.46  4.96 13.37
bubble     1.00  1.93  2.07   2.18  1.29  2.21        5.70
matmul     1.00  1.92  1.76   1.90  0.96  2.06        5.32
fib        1.00  2.32  2.03   1.86  1.31  2.64  4.55  6.54
</pre></div>

<p>あなたは、 アセンブリ言語で書かれたシステムと比較したとき、 Gforth の優れたパフォーマンスに驚かれるかもしれません。
これら他のシステムのパフォーマンスが期待外れである重要な理由の 1 つは、 おそらく、 それらが 486
用に最適化して書かれていないことです(たとえば、<code class="code">lods</code> 命令を使用している)。 さらに、 Win32Forth は、 Forth
イメージを再配置するために快適ではありますがコストのかかる方法を使用します: これは <code class="code">cforth</code> と同様に、
実行時に実際のアドレスが計算され、 <code class="code">NEXT</code> 毎に 2 つのアドレス計算が行われます(see <a class="pxref" href="Image-File-Background.html">Image File Background</a>)。
</p>
<p>PFE や ThisForth や TILE に対する Gforth の高速化は、 前者達のシステムが標準 C
に対して自ら課した制限によって簡単に説明できます: これにより、 効率的なスレッド化が不可能になります(ただし、 観測された PFE の実装では GNU
C 拡張機能が使用されています see <a data-manual="gcc" href="https://gcc.gnu.org/onlinedocs/gcc/Global-Reg-Vars.html#Global-Reg-Vars">Defining Global Register
Variables</a> in <cite class="cite">GNU C Manual</cite>)。  さらに言えば、 現在の C コンパイラーは、 ThisForth や TILE
ソースの他の側面を最適化するのに苦労しています。
</p>
<p>386 アーキテクチャ・プロセッサ上の Gforth のパフォーマンスは、 使用する <code class="code">gcc</code> のバージョンによって大きく異なります。
たとえば、<code class="code">gcc-2.5.8</code> は、 それ自身では仮想マシン・レジスターを実マシン・レジスターに割り当てることに失敗し、 かつ、
明示的なレジスター宣言では正しく動作しないため、 (Sieve ベンチマークを実行している 486DX2/66
では、)上記で測定したエンジンよりも大幅に遅いエンジンが出来上がります。
</p>
<p>注意: ここで紹介したリリース以降、 Win32Forth のリリースがいくつかあるため、 上記の結果は現在の Win32Forth
のパフォーマンスを予測する値がほとんどない可能性があることに注意してください(i486DX2/66 での現在のリリースの結果報告をお待ちしています)。
</p>
<a class="index-entry-id" id="index-Benchres"></a>
<p><cite class="cite"><a class="uref" href="https://www.complang.tuwien.ac.at/papers/ertl&amp;maierhofer95.ps.gz">Translating Forth to Efficient C</a></cite> by M. Anton Ertl and Martin Maierhofer
(presented at EuroForth &rsquo;95) では、 Gforth の間接スレッド化バージョンが、 Win32Forth や NT
Forth や PFE や ThisForth や、 いくつかのネイティブ・コード・システムと比較されます。 そのバージョンの Gforth は、
486 ではここで使用されているバージョンよりも遅くなります。 これらの測定値の新しいバージョンは
<a class="uref" href="https://www.complang.tuwien.ac.at/forth/performance.html">https://www.complang.tuwien.ac.at/forth/performance.html</a>
で見つけることができます。  あなたは <samp class="file">Benchres</samp> でさまざまなマシン上の Gforth の数値を見つけることができます。
</p>

</div>
<hr>
<div class="nav-panel">
<p>
Previous: <a href="Primitives.html">Primitives</a>, Up: <a href="Engine.html">Engine</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Word-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
