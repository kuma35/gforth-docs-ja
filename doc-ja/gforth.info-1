This is gforth.info, produced by makeinfo version 6.8 from gforth.texi.

このマニュアルは、 標準 Forth 言語の高速で移植可能な実装である Gforth (バ
ージョン 0.7.9_20240418, April 18, 2024)用です。 これはリファレンス・マ
ニュアルとして機能しますが、 Forth の概要と Forth チュートリアルも含まれ
ています。

   Authors: Bernd Paysan, Anton Ertl, Gerald Wodni Copyright © 1995,
1996, 1997, 1998, 2000, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
2011, 2012, 2013, 2014,2015,2016,2017,2018,2019,2020,2021,2022,2023 Free
Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover texts
     being “A GNU Manual,” and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by the
     Free Software Foundation raise funds for GNU development.”
INFO-DIR-SECTION Software development
START-INFO-DIR-ENTRY
* Gforth: (gforth).          forth言語のための高速インタープリター
END-INFO-DIR-ENTRY


File: gforth.info,  Node: Top,  Next: Goals,  Prev: (dir),  Up: (dir)

Gforth
******

このマニュアルは、 標準 Forth 言語の高速で移植可能な実装である Gforth (バ
ージョン 0.7.9_20240418, April 18, 2024)用です。 これはリファレンス・マ
ニュアルとして機能しますが、 Forth の概要と Forth チュートリアルも含まれ
ています。

   Authors: Bernd Paysan, Anton Ertl, Gerald Wodni Copyright © 1995,
1996, 1997, 1998, 2000, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
2011, 2012, 2013, 2014,2015,2016,2017,2018,2019,2020,2021,2022,2023 Free
Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover texts
     being “A GNU Manual,” and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by the
     Free Software Foundation raise funds for GNU development.”

* Menu:

* Goals::                    Gforthプロジェクトについて
* Gforth Environment::       Gforthの開始(と終了)
* Tutorial::                 実践的な Forth チュートリアル
* Introduction::             標準Forth(Standard Forth)の紹介
* Literals in source code::
* Words::                    Gforth で使用可能な Forth ワード
* Error messages::           エラーメッセージをどのように読み解けばいいのか
* Tools::                    プログラム作成支援ツール
* Standard conformance::     Gforth実装用に定義されたオプションなど
* Standard vs Extensions::   Gforth拡張を使用する必要ある?
* Model::                    Gforth の抽象マシン
* Integrating Gforth::       アプリのスクリプト言語としてのForth
* Emacs and Gforth::         forth-mode(Gforth Mode)
* Image Files::              ‘.fi’
                               ファイルはコンパイル済のコード
* Engine::                   内部インタープリターとプリミティブ・ワード
* Cross Compiler::           The Cross Compiler
* MINOS2::                   The GUI library
* Bugs::                     バグの報告方法について
* Origin::                   Gforthの作者とGforthの祖先
* Forth-related information::  書籍とWeb上の情報
* Licenses::
* Word Index::               Forth ワードのインデックス
* Concept Index::            多くのトピックを網羅したインデックス

 — The Detailed Node Listing —



Goals of Gforth



* Stability Goals::

Gforth Environment



* Invoking Gforth::          Gforth を起動
* Leaving Gforth::           Gforth を終了
* Help on Gforth::           Gforth内のヘルプ
* Command-line editing::     Gforth内のラインエディタ
* Environment variables::    Gforth起動に影響する環境変数
* Gforth Files::             何が何処にインストールされるか
* Gforth in pipes::          Gforth とのパイプライン入出力
* Startup speed::            14msが満足な速度ではない場合…

Forth Tutorial



* Starting Gforth Tutorial::
* Syntax Tutorial::
* Crash Course Tutorial::
* Stack Tutorial::
* Arithmetics Tutorial::
* Stack Manipulation Tutorial::
* Using files for Forth code Tutorial::
* Comments Tutorial::
* Colon Definitions Tutorial::
* Decompilation Tutorial::
* Stack-Effect Comments Tutorial::
* Types Tutorial::
* Factoring Tutorial::
* Designing the stack effect Tutorial::
* Local Variables Tutorial::
* Conditional execution Tutorial::
* Flags and Comparisons Tutorial::
* General Loops Tutorial::
* Counted loops Tutorial::
* Recursion Tutorial::
* Leaving definitions or loops Tutorial::
* Return Stack Tutorial::
* Memory Tutorial::
* Characters and Strings Tutorial::
* Alignment Tutorial::
* Floating Point Tutorial::
* Files Tutorial::
* Interpretation and Compilation Semantics and Immediacy Tutorial::
* Execution Tokens Tutorial::
* Exceptions Tutorial::
* Defining Words Tutorial::
* Arrays and Records Tutorial::
* POSTPONE Tutorial::
* Literal Tutorial::
* Advanced macros Tutorial::
* Compilation Tokens Tutorial::
* Wordlists and Search Order Tutorial::

An Introduction to Standard Forth



* Introducing the Text Interpreter::
* Stacks and Postfix notation::
* Your first definition::
* How does that work?::
* Forth is written in Forth::
* Review - elements of a Forth system::
* Where to go next::
* Exercises::

Forth Words



* Notation::
* Case insensitivity::
* Comments::
* Boolean Flags::
* Arithmetic::
* Stack Manipulation::
* Memory::
* Strings and Characters::
* Control Structures::
* Defining Words::
* Interpretation and Compilation Semantics::
* Tokens for Words::
* Compiling words::
* The Text Interpreter::
* The Input Stream::
* Word Lists::
* Environmental Queries::
* Files::
* Blocks::
* Other I/O::
* OS command line arguments::
* Locals::
* Structures::
* Object-oriented Forth::
* Regular Expressions::
* Programming Tools::
* Multitasker::
* C Interface::
* Assembler and Code Words::
* Carnal words::
* Passing Commands to the OS::
* Keeping track of Time::
* Miscellaneous Words::

Arithmetic



* Single precision::
* Double precision::         2倍長整数演算
* Mixed precision::          1倍長整数と2倍長整数の操作
* Integer division::
* Two-stage integer division::
* Bitwise operations::
* Numeric comparison::
* Floating Point::

Stack Manipulation



* Data stack::
* Floating point stack::
* Return stack::
* Locals stack::
* Stack pointer manipulation::

Memory



* Memory model::
* Dictionary allocation::
* Heap Allocation::
* Memory Access::
* Special Memory Accesses::
* Address arithmetic::
* Memory Blocks::

Strings and Characters



* Characters::
* String representations::
* String and character literals::
* String words::
* ＄tring words::
* Counted string words::

Control Structures



* Selection::                IF ... ELSE ... ENDIF
* Simple Loops::             BEGIN ...
* Counted Loops::            DO
* BEGIN loops with multiple exits::
* General control structures with CASE::
* Arbitrary control structures::
* Calls and returns::
* Exception Handling::

Defining Words



* CREATE::
* Variables::                Variables and user variables
* Constants::
* Values::                   Initialised variables
* Varues::
* Colon Definitions::
* Anonymous Definitions::    名前無しのワード定義
* Quotations::
* Supplying names::          定義ワードの名前を文字列として渡す
* User-defined Defining Words::
* Deferred Words::           前方参照の許容
* Forward::                  自動解決される前方参照
* Aliases::

User-defined Defining Words



* User-defined defining words with colon definitions::
* User-defined defining words using CREATE::
* CREATE..DOES> applications::
* CREATE..DOES> details::
* Advanced does> usage example::
* User-defined TO and DEFER@::
* User-defined compile-comma::
* Creating from a prototype::
* Making a word current::
* Const-does>::

Interpretation and Compilation Semantics



* Combined words::

Tokens for Words



* Execution token::          実行/インタープリター
                               機能(execution/interpretation semantics)
* Name token::               名前付きワード
* Compilation token::        コンパイル機能(compilation semantics)

Compiling words



* Literals::                 データ値をコンパイルします
* Macros::                   Compiling words

The Text Interpreter



* Input Sources::
* Number Conversion::
* Interpret/Compile states::
* Interpreter Directives::
* Recognizers::
* Text Interpreter Hooks::

Recognizers



* Default Recognizers::
* Dealing with existing Recognizers::
* Defining Recognizers::

Word Lists



* Vocabularies::
* Why use word lists?::
* Word list example::

Files



* Forth source files::
* General files::
* Redirection::
* Directories::
* Search Paths::

Search Paths



* Source Search Paths::
* General Search Paths::

Other I/O



* Simple numeric output::    定義済みの書式
* Formatted numeric output::  書式化された(目に見える)出力
* Floating-point output::
* Miscellaneous output::
* Displaying characters and strings::  その他もろもろ
* Terminal output::          カーソル移動等
* Single-key input::
* Line input and conversion::
* Pipes::                    あなた独自のパイプラインの作り方
* Xchars and Unicode::       非ASCII文字
* i18n and l10n::            国際化(I18n)とローカライズ
* Substitute::               テキストマクロ置換
* CSV Reader::               データ・インポート機能

Locals



* Gforth locals::
* Standard Forth locals::

Gforth locals



* Locals definition words::
* Where are locals visible by name?::
* How long do locals live?::
* Locals programming style::
* Locals implementation::
* Closures::

Structures



* Why explicit structure support?::
* Structure Usage::
* Structure Naming Convention::
* Structure Implementation::
* Structure Glossary::
* Forth200x Structures::

Object-oriented Forth



* Why object-oriented programming?::
* Object-Oriented Terminology::
* Objects::
* OOF::
* Mini-OOF::
* Mini-OOF2::
* Comparison with other object models::

The ‘objects.fs’ model



* Properties of the Objects model::
* Basic Objects Usage::
* The Objects base class::
* Creating objects::
* Object-Oriented Programming Style::
* Class Binding::
* Method conveniences::
* Classes and Scoping::
* Dividing classes::
* Object Interfaces::
* Objects Implementation::
* Objects Glossary::

The ‘oof.fs’ model



* Properties of the OOF model::
* Basic OOF Usage::
* The OOF base class::
* Class Declaration::
* Class Implementation::

The ‘mini-oof.fs’ model



* Basic Mini-OOF Usage::
* Mini-OOF Example::
* Mini-OOF Implementation::

Programming Tools



* Locating source code definitions::  and editing
* Locating uses of a word::  ‘where’.
* Locating exception source::  バックトレースの検証(examing)
* Examining compiled code::  ‘see’ and friends.
* Examining data::           スタック と メモリ
* Forgetting words::         通常、再ロード前に使われます
* Debugging::                トレーサー ‘~~’
                               を適宜挿入することによって
* Assertions::               あなたのプログラムを自己チェックさせます
* Singlestep Debugger::      あなたのプログラムをワート単位で実行します
* Code Coverage::            実行頻度を測定します

Multitasker



* Pthreads::                 ネイティブ Unix 用マルチタスカー
* Cilk::                     Cilk風の spawn+sync 実装

Pthreads



* Basic multi-tasking::
* Task-local data::
* Semaphores::
* Hardware operations for multi-tasking::
* Message queues::

C Interface



* Calling C Functions::
* Declaring C Functions::
* Calling C function pointers::
* Defining library interfaces::
* Declaring OS-level libraries::
* Callbacks::
* C interface internals::
* Low-Level C Interface Words::
* Automated interface generation using SWIG::
* Migrating the C interface from earlier Gforth::

Assembler and Code Words



* Assembler Definitions::    Definitions in assembly language
* Common Assembler::         アセンブラ文法
* Common Disassembler::
* 386 Assembler::            逸脱(deviations)と特殊ケース
* AMD64 Assembler::
* Alpha Assembler::          逸脱(deviations)と特殊ケース
* MIPS assembler::           逸脱(deviations)と特殊ケース
* PowerPC assembler::        逸脱(deviations)と特殊ケース
* ARM Assembler::            逸脱(deviations)と特殊ケース
* Other assemblers::         アセンブラ自体の書き方

Carnal words



* Header fields::
* Header methods::
* Threading Words::

Tools



* Standard Report::          使用されたワードをワードセットごとにソートして報告します
* Stack depth changes::      このスタック値はどこから来たのか?

Standard conformance



* The Core Words::
* The optional Block word set::
* The optional Double Number word set::
* The optional Exception word set::
* The optional Facility word set::
* The optional File-Access word set::
* The optional Floating-Point word set::
* The optional Locals word set::
* The optional Memory-Allocation word set::
* The optional Programming-Tools word set::
* The optional Search-Order word set::

The Core Words



* core-idef::                実装毎オプション(Implementation Defined
                               Options;idef)
* core-ambcond::             あいまいな条件
* core-other::               その他のシステム・ドキュメント

The optional Block word set



* block-idef::               実装毎オプション(Implementation Defined
                               Options;idef)
* block-ambcond::            あいまいな条件
* block-other::              その他のシステム・ドキュメント

The optional Double Number word set



* double-ambcond::           あいまいな条件

The optional Exception word set



* exception-idef::           実装毎オプション(Implementation Defined
                               Options;idef)

The optional Facility word set



* facility-idef::            実装毎オプション(Implementation Defined
                               Options;idef)
* facility-ambcond::         あいまいな条件

The optional File-Access word set



* file-idef::                実装毎オプション(Implementation Defined
                               Options;idef)
* file-ambcond::             あいまいな条件

The optional Floating-Point word set



* floating-idef::            実装毎オプション(Implementation Defined
                               Options;idef)
* floating-ambcond::         あいまいな条件

The optional Locals word set



* locals-idef::              実装毎オプション(Implementation Defined
                               Options;idef)
* locals-ambcond::           あいまいな条件

The optional Memory-Allocation word set



* memory-idef::              実装毎オプション(Implementation Defined
                               Options;idef)

The optional Programming-Tools word set



* programming-idef::         実装毎オプション(Implementation Defined
                               Options;idef)
* programming-ambcond::      あいまいな条件

The optional Search-Order word set



* search-idef::              実装毎オプション(Implementation Defined
                               Options;idef)
* search-ambcond::           あいまいな条件

Emacs and Gforth



* Installing gforth.el::     Emacs に Forth を認識させる
* Emacs Tags::               ワードのソースを Emacs で閲覧
* Hilighting::               Forth コードの見栄えを良くします
* Auto-Indentation::         自動インデントのカスタマイズ
* Blocks Files::             ブロック・ファイルの読み書き

Image Files



* Image Licensing Issues::   イメージの配布条件
* Image File Background::    なぜイメージ・ファイルがあるのですか?
* Non-Relocatable Image Files::  ※これは常に機能するとは限りません
* Data-Relocatable Image Files::  ※こちらの方がよいです
* Fully Relocatable Image Files::  ※こちらの方がもっといいです
* Stack and Dictionary Sizes::  イメージでのデフォルト・サイズを設定
* Running Image Files::      ‘gforth -i file’ or file.
* Modifying the Startup Sequence::  ターンキー・アプリケーションにする事もできる

Fully Relocatable Image Files



* gforthmi::                 通常の方法
* cross.fs::                 困難な方法

Engine



* Portability::
* Threading::
* Primitives::
* Performance::

Threading



* Scheduling::
* Direct or Indirect Threaded?::
* Dynamic Superinstructions::
* DOES>::

Primitives



* Automatic Generation::
* TOS Optimization::
* Produced code::

Cross Compiler



* Using the Cross Compiler::
* How the Cross Compiler Works::

MINOS2, a GUI library



* MINOS2 object framework::
* MINOS2 tutorial::

MINOS2 object framework



* actor methods::
* widget methods::

Licenses



* GNU Free Documentation License::  このマニュアルのコピー時のライセンス
* Copying::                  GPL (このソフトウェアのコピー用)



File: gforth.info,  Node: Goals,  Next: Gforth Environment,  Prev: Top,  Up: Top

1 Goals of Gforth
*****************

Gforth プロジェクトの目標(goal)は 標準Forth(Standard Forth)のための標準
の模範(model)を開発することです。 これは以下のように、 幾つかの副目標に
落とし込めます:

   • Gforth は Forth 標準(Forth Standard)に準拠すべきです。
   • これは模範(model)になるべきです。 つまり、 実装に依存するものをすべ
     て定義する必要があります。
   • これは標準、つまり、広く受け入れられ、使用されるべきです。 この目標
     は最も難しい目標です。

   上記の目標を達成するには Gforth は以下のようにするべきです
   • 以前の模範(model)(fig-Forth, F83)に似にせること。
   • 強力であること。 今日必要であると考えられているすべてのものと、 ま
     だ必要であると考えられていないものさえも提供する必要があります。
   • 効率的であること。 異常に遅いという評判を得るべきではありません。
   • 無料であること。
   • 多くのマシンで利用可能かつ移植も簡単であること。

   私達はこれらの目標を達成できているでしょうか？ Gforth は、 Forth-94
(ANS Forth) と Forth-2012 標準に準拠しています。 内部データ構造の一部 (特
にヘッダー) は時間の経過とともに変更されているため、 Gforth は安定してい
るモデルとは見なさていません。 確かにまだ事実上​​の標準にはなっていませ
んが、 かなり人気があるようです。 以前のモデルとの類似点と相違点がいくつ
かあります。 いくつかの強力な機能がありますが、 まだ私たちが想像していた
もの全てを備えているわけではありません。 私たちは確かに実行速度の目標を
達成しました(*note Performance::)(1)。 Gforth は無料で、多くのマシンで利
用できます。

* Menu:

* Stability Goals::

   ---------- Footnotes ----------

   (1) ただし、 1998 年に主要な商用 Forth ベンダーがネイティブ・コード・
コンパイラーに切り替えたとき、 その基準は引き上げられてしまいました。


File: gforth.info,  Node: Stability Goals,  Prev: Goals,  Up: Goals

1.1 Stability Goals
===================

(Gforthの安定性)Gforth の以前のバージョンで動作するプログラムは、 新しい
バージョンでも動作するはずです。 ただし、 以下のようないくつかの注意点が
あります:

   Gforth の内部データ構造 (コンパイル済みコードの表現を含む) は、 文書
化されていない限り、 バージョン間で変更される可能性があります。

   さらに、 私達は、 標準のワード (つまり、 標準のワードセットにある名前
のワード)と、 永続的な Gforth 拡張機能として文書化されたワード(ワードセ
ット名が ‘gforth’ または ‘gforth-<version>’ であるワード)(*note
Notation:: 参照)は、 保持する義務があると考えています。 他のワードは新し
いリリースでは削除される可能性があります。

   とりわけ、 あなたは ‘locate’ を使用するか、 または、 Gforth のソース
・コードを調べることでワードを見つけることができ、 スタック効果コメント
の直後のコメントでワードセットを確認できます。 そのワードにワードセット
がない場合、 それは内部実装であり、 将来のバージョンでは削除される可能性
があります。 ワードセットが ‘gforth-experimental’ または
‘gforth-internal’ または ‘gforth-obsolete’ の場合、 そのワードは将来のバ
ージョンで削除される可能性があります。

   あなたが永続的としてマークされていない特定のワードを使用したい場合、
私達にご連絡ください。 そのワードを永続的ワードとして追加することを検討
します(または、このワードに代わる代替案を提案する場合もあります)。


File: gforth.info,  Node: Gforth Environment,  Next: Tutorial,  Prev: Goals,  Up: Top

2 Gforth Environment
********************

メモ: Gforth のマニュアル・ページ(man page)は、 結局のところ、 この章の
内容から自動生成されています。

* Menu:

* Invoking Gforth::          Gforth を起動
* Leaving Gforth::           Gforth を終了
* Help on Gforth::           Gforth内のヘルプ
* Command-line editing::     Gforth内のラインエディタ
* Environment variables::    Gforth起動に影響する環境変数
* Gforth Files::             何が何処にインストールされるか
* Gforth in pipes::          Gforth とのパイプライン入出力
* Startup speed::            14msが満足な速度ではない場合…

   イメージの作成に関する関連情報については *note Image Files:: を参照し
てください。


File: gforth.info,  Node: Invoking Gforth,  Next: Leaving Gforth,  Prev: Gforth Environment,  Up: Gforth Environment

2.1 Invoking Gforth
===================

Gforth は 2 つの部分から成ります。 実行可能「エンジン」(‘gforth’ または
‘gforth-fast’ という名前)と、イメージ・ファイルです。 Gforth を開始する
には、 通常は ‘gforth’ とするだけです。 これにより、 デフォルトのイメー
ジ・ファイル ‘gforth.fi’ が自動的にロードされます。 他の多くの場合、 デ
フォルトの Gforth イメージは以下のように呼び出されます:
     gforth [file | -e forth-code] ...
これにより、 ファイルの内容や、 (訳注:コマンドラインに記述された、)
Forth コードが、 指定の順序で通訳(interpret)されます。

   ‘gforth’ エンジンに加えて、 ‘gforth-fast’ というエンジンもあります。
これは高速ですが、 表示されるエラー・メッセージ(*note Error messages::)の
情報が少なく、 そして、 一部のエラーのキャッチ(特に、 スタック・アンダー
フローや整数除算エラーなど)が遅れて発生するか、 あるいはまったく発生しま
せん。 デバッグ済みの、 パフォーマンスが重要なプログラムに対して使用する
べきです。

   さらに、 ‘gforth-itc’ というエンジンがあり、 下位互換性が必要な状況
(*note Direct or Indirect Threaded?::)で役に立ちます。

   一般に、 コマンドラインは以下のようになります:

     gforth[-fast] [engine options] [image options]

   エンジン・オプションは、 コマンド・ラインの他の部分より前に指定する必
要があります。 それらは以下のとおりです:

‘--image-file file’
‘-i file’
     デフォルトの ‘gforth.fi’ の代わりに、 指定の Forth イメージ・ファイ
     ルをロードします(*note Image Files::)。

‘--appl-image file’
     指定のイメージ・ファイルをロードし、 これ以降のコマンドライン引数は
     (エンジンのオプションとして処理するのではなく)、 すべてそのイメージ
     が処理する為に残します。 これは、 ‘gforthmi --application ...’ で構
     築された、 Unix 上で実行可能なアプリケーション・イメージを構築する
     場合に便利です。

‘--path path’
‘-p path’
     デフォルトである環境変数 ‘GFORTHPATH’ 、 またはインストール時に指定
     されたパス(例: ‘/usr/local/share/gforth/0.2.0:.’)と作業ディレクトリ
     ‘.’ の代わりに、 指定のパスを使用してイメージ・ファイルと Forth ソ
     ース・コード・ファイルを検索します。 パスは ‘:’ で区切られたディレ
     クトリのリストとして指定されます(以前のバージョンには他の OS 用に
     ‘;’ がありましたが、 Cygwin は現在は ‘/cygdrive/<letter>’ のみを受
     け入れ、 かつ、 私達は OS/2 や MS-DOS のサポートは終了してしまった
     ため、 どこでも全部 ‘:’ になりました)。

‘--dictionary-size size’
‘-m size’
     イメージで指定されているデフォルト(通常は 256K)を使用する代わりに、
     Forth ディクショナリ用のスペースに指定サイズ(size)のスペースを割り
     当てます。 このオプションと、下記のオプションのサイズ(size)指定は整
     数と単位で構成されます(例: ‘4M’)。 単位は ‘b’ (バイト)、 ‘e’
     (elementの略。セル単位)、 ‘k’ (キロバイト)、 ‘M’ (メガバイト)、 ‘G’
     (ギガバイト)、 ‘T’ (テラバイト)のいずれかになります。 単位が指定さ
     れていない場合 ‘e’ が使用されます。

‘--data-stack-size size’
‘-d size’
     イメージで指定されているデフォルト(通常は 16K) を使用する代わりに、
     データ・スタックに指定のサイズ(size)のスペースを割り当てます。サイ
     ズ(size)指定は整数と単位で構成されます(例: ‘4M’)。 単位は ‘b’ (バイ
     ト)、 ‘e’ (elementの略。セル単位)、 ‘k’ (キロバイト)、 ‘M’ (メガバ
     イト)、 ‘G’ (ギガバイト)、 ‘T’ (テラバイト)のいずれかになります。 単
     位が指定されていない場合 ‘e’ が使用されます。

‘--return-stack-size size’
‘-r size’
     イメージで指定されたデフォルト(通常は 15K)を使用する代わりに、 リタ
     ーン・スタックに指定のサイズ(size)のスペースを割り当てます。 サイズ
     (size)指定は整数と単位で構成されます(例: ‘4M’)。 単位は ‘b’ (バイト
     )、 ‘e’ (elementの略。セル単位)、 ‘k’ (キロバイト)、 ‘M’ (メガバイ
     ト)、 ‘G’ (ギガバイト)、 ‘T’ (テラバイト)のいずれかになります。 単
     位が指定されていない場合 ‘e’ が使用されます。

‘--fp-stack-size size’
‘-f size’
     イメージで指定されているデフォルト(通常は 15.5K)を使用する代わりに
     、 浮動小数点スタックに指定のサイズ(size)のスペースを割り当てます。
     この場合、単位指定子 ‘e’ は浮動小数点数を参照します。 サイズ
     (size)指定は整数と単位で構成されます(例: ‘4M’)。 単位は ‘b’ (バイト
     )、 ‘e’ (elementの略。セル単位)、 ‘k’ (キロバイト)、 ‘M’ (メガバイ
     ト)、 ‘G’ (ギガバイト)、 ‘T’ (テラバイト)のいずれかになります。 単
     位が指定されていない場合 ‘e’ が使用されます。

‘--locals-stack-size size’
‘-l size’
     イメージで指定されているデフォルト(通常は 14.5K)を使用する代わりに
     、 ローカル・スタック(locals stack)に指定サイズ(size)のスペースを割
     り当てます。 サイズ(size)指定は整数と単位で構成されます(例: ‘4M’)。
     単位は ‘b’ (バイト)、 ‘e’ (elementの略。セル単位)、 ‘k’ (キロバイト
     )、 ‘M’ (メガバイト)、 ‘G’ (ギガバイト)、 ‘T’ (テラバイト)のいずれ
     かになります。 単位が指定されていない場合 ‘e’ が使用されます。

‘--vm-commit’
     通常 Gforth は、 ディクショナリとスタックに十分な仮想メモリ(virtual
     memory)がない場合でも起動しようとします(OS がサポートしていれば
     ‘MAP_NORESERVE’ を使用します)。 したがって、 あなたは非常に大きなデ
     ィクショナリやスタックを要求することができ、 利用可能なのを超える仮
     想メモリを使用しない限り、 すべて問題ありません(ただし、それを超え
     て使用すると、 プロセスが強制終了(kill)されます)。 このオプションを
     使用すると、 OS のデフォルトの割り当てポリシーを使用するようになり
     ます。 とりわけ、 オーバーコミットしない OS (Solaris など) の場合、
     これは、 大きなディクショナリやスタックを要求することはできませんし
     、 要求すべきではないことを意味しますが、 しかし、 Gforth が正常に
     起動する事に成功したならば、 メモリ不足によって強制終了(kill)させら
     れることはありません。

‘--help’
‘-h’
     コマンドライン・オプションに関するメッセージを出力します

‘--version’
‘-v’
     バージョンを出力して終了(exit)

‘--debug’
     起動時のデバッグに役立ついくつかの情報を出力します。

‘--offset-image’
     それ以外の場合に使用される位置とはわずかに異なる位置でディクショナ
     リを開始します (データ再配置可能イメージ(data-relocatable images)の
     作成に役立ちます *note Data-Relocatable Image Files::)。

‘--no-offset-im’
     ディクショナリを通常の位置で開始します。

‘--clear-dictionary’
     イメージをロードする前に、 ディクショナリ内の全てのバイトを 0 に初
     期化します(*note Data-Relocatable Image Files::)。

‘--die-on-signal’
     通常、 Gforth はほとんどのシグナル(例えば、 ユーザー割り込みの
     SIGINT や、 セグメンテーション違反 SIGSEGV)を Forth の ‘THROW’ に変
     換することで処理します。 このオプションを使用すると、 Gforth はその
     ようなシグナルを受信すると終了(exit)します。 このオプションは、 (最
     初のシグナルから回復する前に別のシグナルが発生するなど、)エンジンや
     イメージがひどく壊れている可能性がある場合に役立ちます。 このオプシ
     ョンは、 そのような場合の無限ループを回避します。

‘--no-dynamic’
‘--dynamic’
     レプリケーション(replication)を伴う動的スーパー命令(dynamic
     superinstructions)を無効または有効にします(*note Dynamic
     Superinstructions::)。

‘--no-super’
     動的スーパー命令(dynamic superinstructions)を無効にし、 動的レプリ
     ケーション(dynamic replication)のみを使用します。 これは、 スレッド
     化コード(threaded code)にパッチを適用する場合に便利です(*note
     Dynamic Superinstructions::)。

‘--ss-number=N’
     エンジンにコンパイル済みの最初の N 個の静的スーパー命令(static
     superinstructions)のみを使用します(デフォルトでは全てを使用します。
     注意: ‘gforth-fast’ のみのオプションです)。 このオプションは、 静的
     スーパー命令(static superinstructions)のパフォーマンスへの影響を測
     定するのに役立ちます。

‘--ss-min-codesize’
‘--ss-min-ls’
‘--ss-min-lsu’
‘--ss-min-nexts’
     指定のメトリックを使用して、 静的スーパー命令の選択(static
     superinstruction selection)をするためにプリミティブまたは静的スーパ
     ー命令のコストを決定します。 ‘Codesize’ はプリミティブまたは静的ス
     ーパー命令のネイティブ・コード・サイズ、 そして、 ‘ls’ はロードとス
     トアの数、 そして、 ‘lsu’ はロードとストアと更新の数、 そして、
     ‘nexts’ は(動的スーパー命令を考慮しない)ディスパッチの数です。 ここ
     で、 すべてのプリミティブまたは静的スーパー命令のコストは 1 です。
     デフォルトでは、 動的コード生成を使用する場合は ‘codesize’、 それ以
     外の場合は ‘nexts’ です。

‘--ss-greedy’
     このオプションは、 静的スーパー命令のパフォーマンスへの影響を測定す
     るのに役立ちます。 デフォルトでは、 静的スーパー命令の選択には最適
     な最短パス・アルゴリズム(shortest-path algorithm)が使用されます。
     ‘--ss-greedy’ を使用すると、 そのアルゴリズムは、 現在検討中の静的
     スーパー命令以降は静的スーパー命令に結合されないと想定するように変
     更されます。 ‘--ss-min-nexts’ を使用すると、 その時点で利用可能な最
     長のスーパー命令を常に選択する貪欲なアルゴリズムと同じ結果が生成さ
     れます。 たとえば、スーパー命令 AB と BCD がある場合、 シーケンス A
     B C D に対して、 最適アルゴリズムは A BCD を選択し、 貪欲アルゴリズ
     ムは AB C D を選択します。

‘--print-metrics’
     静的スーパー命令の選択中に使用されるいくつかのメトリックを出力しま
     す。 ‘code size’ は、 動的に生成されたコードの実際のサイズです。
     ‘Metric codesize’ は、静的スーパー命令の選択によって確認できるコー
     ドサイズ・メトリック(codesize metrics)の合計で、 ‘code size’ とは異
     なります。 これは、 すべてのプリミティブと静的スーパー命令が動的に
     生成されるコードにコンパイルされるわけではないことと、 マーカーがあ
     るためです。 他のメトリクスは ‘ss-min-...’ オプションに対応します。
     このオプションは、‘--ss-...’ オプションの効果を評価するのに役立ちま
     す。

   上記にて説明したように、 デフォルト・イメージである ‘gforth.fi’ のイ
メージ固有のコマンドライン引数は、 一連のファイル名と、 指定した順序で通
訳(interpret)される ‘-e FORTH-CODE’ オプションで構成されます。 ‘-e
FORTH-CODE’ または ‘--evaluate FORTH-CODE’ オプションは Forth コードを評
価(evaluate)します。 このオプションは引数を 1 つだけ取ります。 あなたが
、もし、 さらに多くの Forth ワードを評価したい場合は、 ワードを引用符で
囲むか、 ‘-e’ を複数回使用する必要があります。 コマンド・ラインの処理後
に(対話モードに入るのではなく、)終了(exit)するには、 コマンド・ラインに
‘-e bye’ を追加します。 Forth プログラムではコマンド・ライン引数を処理す
ることもできます(*note OS command line arguments::)。

   複数のバージョンの Gforth がインストールされている場合、 ‘gforth’ は
最後にインストールされたバージョンを呼び出します。 ‘gforth-<version>’ は
特定のバージョンを呼び出します。 あなたの環境に環境変数 ‘GFORTHPATH’ が
ある場合、 ‘--path’ オプションを使用してこの環境変数をオーバーライドでき
ます。

   起動時、 イメージ・オプションを処理する前に、 環境変数 ‘GFORTH_ENV’ で
指定されたユーザー初期化ファイル、 またはその環境変数が設定されていない
場合は(存在する場合、) ‘~/.config/gforthrc0’ がインクルードされます。
‘GFORTH_ENV’ が「‘off’」の場合は何もインクルードしません。 すべてのイメ
ージ・オプションを処理した後、 ブート・メッセージを出力する直前に、 オプ
ション ‘--no-rc’ が指定されていない限り、 ホーム・ディレクトリのユーザー
初期化ファイル ‘~/.config/gforthrc’ がインクルードされます。

   警告レベルは以下のように設定できます

‘-W’
     警告(warnings)をオフにする

‘-Won’
     警告(warnings)をオンにする(レベル 1)

‘-Wall’
     初心者向け警告をオンにする(レベル 2)

‘-Wpedantic’
     細かい構文的な警告(pedantic warnings)をオンにする(レベル 3)

‘-Werror’
     警告をエラーとして出す(レベル 4)


File: gforth.info,  Node: Leaving Gforth,  Next: Help on Gforth,  Prev: Invoking Gforth,  Up: Gforth Environment

2.2 Leaving Gforth
==================

‘bye’ または (行の先頭で、) ‘Ctrl-d’ または (‘--die-on-signal’ オプショ
ンを指定して Gforth を起動した場合、) ‘Ctrl+C’ を入力すると、 Gforth を
終了できます。 Gforth を終了すると、 あなたの定義とデータはすべて破棄さ
れます。 Gforth を終了する前にシステムの状態を保存する方法については、
*note Image Files:: を参照してください。

   ‘bye’ ( – ) \ gforth を正常に終了する。


File: gforth.info,  Node: Help on Gforth,  Next: Command-line editing,  Prev: Leaving Gforth,  Up: Gforth Environment

2.3 Help on Gforth
==================

Gforth には、 シンプルなテキストベースのオンライン・ヘルプ・システムがあ
ります。

‘help’ ( "rest-of-line" –  ) gforth-1.0 “help”
   名前が指定されていない場合は、 基礎的なヘルプが表示されます。 ドキュ
メント・ノード名に ‘::‘ が続く場合、 ノードの最初を表示します。 ワードの
名前が指定されている場合、 そのワードのドキュメントが存在する場合はその
ドキュメントを、 存在しない場合はソース・コードを表示します。 ‘g’ を使用
して、 ‘help’ で表示された場所でエディタに入ります。 ‘Help’ は現在の位置
をマークするため、 ‘n’ と ‘b’ を使用してテキストの詳細を表示したり、 ‘g’
を使用してエディターでドキュメントにアクセスしたりできます(*note
Locating source code definitions::)。

‘authors’ ( –  ) gforth-1.0 “authors”
   著者のリストを表示

‘license’ ( –  ) gforth-0.2 “license”
   ライセンス声明を出力します


File: gforth.info,  Node: Command-line editing,  Next: Environment variables,  Prev: Help on Gforth,  Up: Gforth Environment

2.4 Command-line editing
========================

Gforth は、 テキスト・インタープリターに入力したすべての行を記録するヒス
トリ・ファイルを維持しています。 このファイルはセッションをまたいで保存
され、 コマンドラインの再呼び出し機能を提供するために使用されます。
‘Ctrl-P’ を繰り返し入力すると、このセッション(または前のセッション)から
古いコマンドを連続して呼び出すことができます。 コマンドライン編集機能の
完全なリストは以下のとおりです:

   • ‘Ctrl-p’ (“previous”) (または「↑」上矢印)を使用して、 ヒストリ・バ
     ッファーから古い行を順に呼び出します。
   • ‘Ctrl-n’ (“next”)(または「↓」下矢印)を押すと、 ヒストリ・バッファー
     からより新しい行を連続して呼び出します。 以前に古い行に移動し、 そ
     れをテキスト解釈(text-interpretation)のために Gforth に与えた場合、
     最初の編集コマンドとして「nextコマンド」を要求すると、 最後に選択し
     た行の次の行が表示されます。
   • ‘Ctrl-f’ (または「→」右矢印)を使用して、 非破壊的にカーソルを右に移
     動します。
   • ‘Ctrl-b’ (または「←」左矢印)を使用して、 非破壊的にカーソルを左に移
     動します。
   • ‘Ctrl-h’ (backspace) カーソルの左側の文字を削除し、 桁を詰めます。
   • ‘Ctrl-k’ カーソルから行末までを削除 (“kill”) します。
   • ‘Ctrl-a’ カーソルを行頭に移動します。
   • ‘Ctrl-e’ カーソルを行末に移動します。
   • <RET> (‘Ctrl-m’) または <LFD> (‘Ctrl-j’) 現在行を gforth へ送ります
   • <TAB> 現在入力中のワードの、 可能なすべての全ワード補完をステップ実
     行します。
   • ‘Ctrl-d’ 空行で押すと Gforth を終了(terminate)します。 (‘bye’ 使用
     すると正常に終了します)。
   • ‘Ctrl-x’ (空行以外では ‘Ctrl-d’ も使えます) カーソル位置の文字を削
     除します。

   編集中、 表示可能な文字はカーソル位置の左側に挿入されます。 行は常に
(「上書きモード」(overstrike)ではなく、)「挿入モード」(insert)です。

   Unix システムでは、 ヒストリ・ファイルは デフォルトでは
‘$HOME/.local/share/gforth/history’です(1)。 以下のコマンドを使用して、
ヒストリ・ファイルの名前と場所を確認できます:

     history-file type \ Unix-class systems

     history-file type \ Other systems
     history-dir  type

   あなたが長い定義を手入力した場合、 テキスト・エディターを使用してヒス
トリ・ファイルから Forth ソース・ファイルに貼り付け、 後で再利用できます
。

   Gforth はヒストリ・ファイルのサイズを決して削減しないため、 あなたは
必要に応じて定期的にヒストリ・ファイルのサイズを削減する必要があります。

   ---------- Footnotes ----------

   (1) つまり、 ユーザーのホーム・ディレクトリに保存されます。


File: gforth.info,  Node: Environment variables,  Next: Gforth Files,  Prev: Command-line editing,  Up: Gforth Environment

2.5 Environment variables
=========================

Gforth は以下の環境変数を使用します:

   • ‘GFORTHHIST’ – (Unix系のみ) ヒストリ・ファイル ‘.gforth-history’ の
     パスを指定。 デフォルト: ‘$HOME/.local/share/gforth/history’.

   • ‘GFORTHPATH’ – gforth イメージ・ファイルと Forth ソースコード・ファ
     イル を検索するときに使用するパスを指定(通常 ‘.’ 、現在の作業ディレ
     クトリ)。 パス区切り文字は ‘:’ です。
     ‘/usr/local/share/gforth/1.0:.’ みたいなのが典型です。

   • ‘LANG’ – ‘LC_CTYPE’ 参照

   • ‘LC_ALL’ – ‘LC_CTYPE’ 参照

   • ‘LC_CTYPE’ – Gforth の起動時にこの環境変数が “UTF-8” を含んでいる場
     合、 Gforth は内部で文字列に UTF-8 エンコーディングを使用し、 UTF-8
     エンコーディングでの入力を期待し、 UTF-8 エンコーディングで出力を生
     成します。 それ以外の場合、 エンコーディングは 8 ビットです(*note
     Xchars and Unicode::)。 この環境変数が設定されていない場合、 Gforth
     は ‘LC_ALL’ を調べ、 それも設定されていない場合は ‘LANG’ を調べます
     。

   • ‘GFORTHSYSTEMPREFIX’ – C言語 の ‘system()’ に渡す前に ‘system’ の引
     数に何を付加するかを指定します。 デフォルト: Windows では
     ‘"./$COMSPEC /c "’で、他の OS では ‘""’ です。 このプレフィックスと
     コマンドは直接連結されるため、 間にスペースが必要な場合はプレフィッ
     クスに追加してください。

   • ‘GFORTH’ – ‘gforthmi’ によって使用されます(*Note gforthmi::)。

   • ‘GFORTHD’ – ‘gforthmi’ によって使用されます(*Note gforthmi::)。

   • ‘TMP’, ‘TEMP’ - (Unix系以外) ヒストリ・ファイルの場所として暗黙に使
     用されます。

   すべての Gforth 環境変数は、 設定されていない場合、 デフォルトで適切
な値になります。


File: gforth.info,  Node: Gforth Files,  Next: Gforth in pipes,  Prev: Environment variables,  Up: Gforth Environment

2.6 Gforth files
================

Gforth を Unix系にインストールすると、 デフォルトでは以下の場所にファイ
ルがインストールされます:

   • ‘/usr/local/bin/gforth’
   • ‘/usr/local/bin/gforthmi’
   • ‘/usr/local/man/man1/gforth.1’ - man page.
   • ‘/usr/local/info’ - the Info version of this manual.
   • ‘/usr/local/lib/gforth/<version>/...’ - Gforth ‘.fi’ files.
   • ‘/usr/local/share/gforth/<version>/TAGS’ - Emacs TAGS file.
   • ‘/usr/local/share/gforth/<version>/...’ - Gforth source files.
   • ‘.../emacs/site-lisp/gforth.el’ - Emacs gforth mode.

   ‘configure’ のオプションを使用すると、 インストール先に違う場所を選択
できます(どんなオプションがあるかは ‘configure --help’ してください)。


File: gforth.info,  Node: Gforth in pipes,  Next: Startup speed,  Prev: Gforth Files,  Up: Gforth Environment

2.7 Gforth in pipes
===================

Gforth は、他の場所で作成されたパイプラインを使用できます(以下で説明しま
す)。 独自にパイプラインを作成することもできます(*note Pipes::)。

   Gforth にパイプライン入力する場合、 プログラムは ‘stdin’ から
‘read-file’ または ‘read-line’ を使用して読み取る必要があります(*note
General files::)。 ‘Key’ は入力の終わりを認識しません。 ‘accept’ のよう
なワードは入力をエコーするため、 通常はパイプラインからの読み取りには役
に立ちません。 あなたは、 (Forthのテキスト・インタープリターはパイプライ
ン入力を通訳(interpret)しようとしてしまうため、)Forth内のコマンド・ライ
ンを使用する機会はなく、 OSのコマンド・ライン・オプションを使用して
Forth プログラムを呼び出す必要があります。

   あなたは ‘type’、 ‘emit’、 ‘cr’ などでパイプラインへ出力できます。

   もう一方の端で既に閉じられているパイプラインに書き込むと、 Gforth は
SIGPIPE シグナル(「パイプが壊れた」シグナル)を受け取ります。 Gforth はこ
れを例外 ‘broken-pipe-error’ に変換します。 あなたのアプリケーションがそ
の例外をキャッチしない場合、 システムはその例外をキャッチして、 通常は黙
って終了(exit)します(Forth コマンド・ラインで作業している場合を除き、 エ
ラー・メッセージを出力して終了します)。 これは通常、 望ましい動作です。

   この振る舞いが気に入らない場合は、 自分で例外をキャッチし、 対応する
必要があります。

   ここで、 パイプライン内で使用できる Gforth の呼び出しの例を以下に示し
ます:

     gforth -e ": foo begin pad dup 10 stdin read-file throw dup while \
      type repeat ; foo bye"

   この例では、 入力をそのまま出力にコピーするだけです。 この例を含む非
常に単純なパイプラインは以下のようになります:

     cat startup.fs |
     gforth -e ": foo begin pad dup 80 stdin read-file throw dup while \
      type repeat ; foo bye"|
     head

   Gforth の ‘stderr’ 出力に関連するパイプラインは機能しません。


File: gforth.info,  Node: Startup speed,  Prev: Gforth in pipes,  Up: Gforth Environment

2.8 Startup speed
=================

Gforth を CGI スクリプトやシェルスクリプトで使用する場合、 起動速度が問
題になる場合があります。 libc-2.7 を搭載した 64 ビット Linux 2.6.27.8 上
の 3GHz Core 2 Duo E8400 では、 ‘gforth-fast -e bye’ でユーザー時間は
13.1 ミリ秒、システム時間は 1.2 ミリ秒かかります(‘gforth -e bye’ は、 下
記で説明するオプションの一部を組み込んでいるため、 ユーザー時間は約 3.4
ミリ秒、 システム時間は 1.2 ミリ秒で起動がより高速になります)。

   起動速度が問題になる場合は、 以下の改善方法を検討してください。 また
は、 起動の数を減らす方法(Fast-CGI の使用など)を検討することもできます。
以下の最初の手順では、 (コンパイル時間を含む)実行時間を犠牲にして起動時
間を短縮するため、 それで利益が得られるかどうかはあなたのアプリケーショ
ンでのこれらの時間のバランスによって決まることに注意してください。

   Gforth の起動速度に影響を及ぼす簡単な手順は、 実行時間(run-time)を増
加させながらイメージの読み込み時間(image-loading time)を短縮する多数のオ
プションを使用してみることです。

   最初に試す必要があるのは ‘--ss-number=0 --ss-states=1’ です。 このオ
プションは実行時の高速化が比較的わずかなのに、 起動時にかなりの時間がか
かるためです。 ‘gforth-fast --ss-number=0 --ss-states=1 -e bye’ には、 ユ
ーザー時間が約 2.8 ミリ秒、 システム時間が約 1.5 ミリ秒かかります。

   次のオプションは ‘--no-dynamic’ です。 これは実行時間に大きな影響を及
ぼします(いくつかのプラットフォームでは約 2 倍です)が、 それでも起動速度
が若干速くなります。 ‘gforth-fast -- ss-number=0 --ss-states=1
--no-dynamic -e bye’ は、 約 2.6 ミリ秒のユーザー時間と 1.2 ミリ秒のシス
テム時間を消費します。

   起動速度を向上させるための次のステップは、 データ再配置可能イメージ
(data-relocatable image)を使用することです(*note Data-Relocatable Image
Files::)。 これにより、 イメージ内のコードの再配置コストが回避されます
(ただし、 データの再配置コストは回避されません)。 イメージは、 使用して
いる特定のバイナリ(つまり、 ‘gforth’、 ‘gforth-fast’、さらには特定のビル
ド)に固有であることに注意してください。 ‘./gforth-fast’ で動作するデータ
再配置可能イメージを作成するには、 ‘GFORTHD="./gforth-fast --no-dynamic"
gforthmi gforthdr.fi’ とします(これには ‘--no-dynamic’ が必要です。そう
しないとこのイメージは機能しません)。 そして、 ‘gforth-fast -i
gforthdr.fi ... -e bye’ で実行します(上記で説明したフラグは、 再配置可能
なコードでのみ機能するため、ここでは重要ではありません)。 ‘gforth-fast
-i gforthdr.fi -e bye’ では、 ユーザー時間は約 1.1 ミリ秒、 システム時間
は約 1.2 ミリ秒かかります。

   さらにもう 1 つのステップは、 再配置不可イメージ(non-relocatable
image)を使用することで、 すべての再配置コストと書き換え時コピー
(copy-on-write;COW)コストの一部を回避することです(*note Non-Relocatable
Image Files::)。ただし、 アドレス空間のランダム化が行われているオペレー
ティング・システム(最近の Linux 等ではこれがデフォルト)や、 その他の理由
でディクショナリが移動した場合(OS カーネルの変更や、 ライブラリ更新など
の場合)には機能しないという欠点があるため、 あまりお勧めできません。再配
置不可イメージ(non-relocatable image)を作成するために ‘gforth-fast
--no-dynamic -e "savesystem gforthnr.fi bye"’ とします(ここでも
‘--no-dynamic’ が必要です)。 そして、 ‘gforth-fast -i gforthnr.fi ... -e
bye’ として実行します(ここでも、 上記で説明したフラグは重要ではありませ
ん)。 ‘gforth-fast -i gforthdr.fi -e bye’ はユーザー時間は約 0.9 ミリ秒
、 システム時間は約 0.9 ミリ秒かかります。

   実行するスクリプトに大量のコードが含まれている場合は、 起動時のコンパ
イルのコストを避けるために、 それをイメージにコンパイルすると有益な場合
があります。


File: gforth.info,  Node: Tutorial,  Next: Introduction,  Prev: Gforth Environment,  Up: Top

3 Forth Tutorial
****************

この章と Introduction(*note Introduction::) の違いは、 このチュートリア
ルの方がハイペースで、 かつ、 あなたがコンピューターをさわれるときに読む
必要があり、 かつ、 より多くの内容をカバーしていますが、 しかし、 Forth
システムがどのように機能するかについては説明してい無いことです。

   このチュートリアルは、 標準に準拠した任意の Forth でご利用できます。
Gforth 固有の機能はすべてその旨の目印が付けられており、 別の Forth を使
用する場合はその部分はスキップできます。 このチュートリアルでは、 Forth
のすべての機能について説明するわけではありませんが、 あなたが Forth を使
い始めて、 Forth で使用できる機能についていくつかのアイデアを得るには十
分です。 このチュートリアルが終わったら、 マニュアルの残りの部分をお読み
ください。

   このチュートリアルの使用目的は、 あなたがコンソールの前に座って作業を
進め、 例を見てその結果を予測してから、 自分で試してみるというものです。
結果が期待どおりでない場合は、 何が起こっているのかを理解できるように(類
似の例を試すなどして)理由を調べます。 いくつか課題も出題してあります。

   このチュートリアルでは、 あなたが以前にプログラミングをしたことがあり
、 例えば、 ループとは何か、とかを理解していることを前提としています。

* Menu:

* Starting Gforth Tutorial::
* Syntax Tutorial::
* Crash Course Tutorial::
* Stack Tutorial::
* Arithmetics Tutorial::
* Stack Manipulation Tutorial::
* Using files for Forth code Tutorial::
* Comments Tutorial::
* Colon Definitions Tutorial::
* Decompilation Tutorial::
* Stack-Effect Comments Tutorial::
* Types Tutorial::
* Factoring Tutorial::
* Designing the stack effect Tutorial::
* Local Variables Tutorial::
* Conditional execution Tutorial::
* Flags and Comparisons Tutorial::
* General Loops Tutorial::
* Counted loops Tutorial::
* Recursion Tutorial::
* Leaving definitions or loops Tutorial::
* Return Stack Tutorial::
* Memory Tutorial::
* Characters and Strings Tutorial::
* Alignment Tutorial::
* Floating Point Tutorial::
* Files Tutorial::
* Interpretation and Compilation Semantics and Immediacy Tutorial::
* Execution Tokens Tutorial::
* Exceptions Tutorial::
* Defining Words Tutorial::
* Arrays and Records Tutorial::
* POSTPONE Tutorial::
* Literal Tutorial::
* Advanced macros Tutorial::
* Compilation Tokens Tutorial::
* Wordlists and Search Order Tutorial::


File: gforth.info,  Node: Starting Gforth Tutorial,  Next: Syntax Tutorial,  Prev: Tutorial,  Up: Tutorial

3.1 Starting Gforth
===================

あなたが Gforth を開始するには、その名前をタイプします:

     gforth

   これにより、 対話モードに入ります。 ‘bye’ と入力すると Gforth を終了
できます。 Gforth では、 bash と同様に、 コマンド・ラインを編集し、 カー
ソル・キーを使用してコマンド・ライン・ヒストリ(履歴)にアクセスできます。


File: gforth.info,  Node: Syntax Tutorial,  Next: Crash Course Tutorial,  Prev: Starting Gforth Tutorial,  Up: Tutorial

3.2 Syntax
==========

“word” は、任意の文字のシーケンスです(空白(white space)を除く)。 ワード
は空白(white space)で区切られます。 たとえば、 以下の各行には正確にただ
1 つのワードが含まれています:

     word
     !@#$%^&*()
     1234567890
     5!a

   初心者によくある間違いは、 必要な空白を省略することです。 その結果、
‘Undefined word’ のようなエラーが発生します。そのため、 このようなエラー
が表示された場合は、 必要な場所に空白を入れてあるかどうかを確認してくだ
さい。

     ." hello, world" \ correct
     ."hello, world"  \ gives an "Undefined word" error

   Gforth および他のほとんどの Forth システムは、 大文字と小文字の違いを
無視します(大文字と小文字は区別されません)。 つまり、 ‘word’ は ‘Word’ と
同一です。 あなたのシステムで大文字と小文字が区別される場合は、 ここに示
されているすべての例を大文字で入力する必要がある場合があります。


File: gforth.info,  Node: Crash Course Tutorial,  Next: Stack Tutorial,  Prev: Syntax Tutorial,  Up: Tutorial

3.3 Crash Course
================

Forth は、 自分の足を撃つような馬鹿げた事を妨げたりはしません。 以下のよ
うに Gforth をクラッシュさせるいくつかの方法を試してみましょう:

     0 0 !
     here execute
     ' catch >body 20 erase abort
     ' (quit1) >body 20 erase

   最後の 2 つの例は、Gforth (および他のほとんどのシステム) の重要な部分
を破壊することが保証されているため、 (Gforth が自動的に終了していない場
合、) この後は Gforth を終了させたほうがよいでしょう。 一部のシステムで
は、 外部から gforth を強制終了する必要がある場合があります(例: Unix系 で
は ‘kill’ を使用します)。

   これらの行が何を行うのか、 なぜクラッシュが発生するのかは後ほど分かり
ます。

   クラッシュを発生させる方法がわかったので(そして、 それは大したことが
ない事がわかったので)、 今度は意味のあるプログラムを作成する方法を学ぶと
しましょう。


File: gforth.info,  Node: Stack Tutorial,  Next: Arithmetics Tutorial,  Prev: Crash Course Tutorial,  Up: Tutorial

3.4 Stack
=========

Forth の最も明々白々な機能はスタックです。 数値を入力すると、 その数値が
スタックにプッシュされます。 ‘.s’ を使用してスタックの内容を表示できます
。

     1 2 .s
     3 .s

   ‘.s’ はスタックの最上位(top-of-stack)が一番右になるように表示します。
つまり、 数値は入力時に表記されたとおりに ‘.s’ 出力に表れます。

   ‘.’ を使用してスタックの最上位要素を出力できます。

     1 2 3 . . .

   一般に、 ワードはスタック引数を消費します(‘.s’ は例外です)。

     研究課題(assignment): ‘5 6 7 .’ の後、 スタックには何が含まれていま
     すか？


File: gforth.info,  Node: Arithmetics Tutorial,  Next: Stack Manipulation Tutorial,  Prev: Stack Tutorial,  Up: Tutorial

3.5 Arithmetics
===============

‘+’ や ‘-’ や ‘*’ や ‘/’ や ‘mod’ というワードは、 常に頂上から見て 2 つ
のスタック項目に作用します:

     2 2 .s
     + .s
     .
     2 1 - .
     7 3 mod .

   ‘-’ や ‘/’ や ‘mod’ のオペランドは、 対応する中置式と同じ順序になりま
す(これが Forth における一般的なケースです)。

   ワードの順序によって評価の順序とオペランドが明確に決定されるため、 括
弧は不要です(そして、 括弧は使用不可です):

     3 4 + 5 * .
     3 4 5 * + .

     研究課題(assignment): 上記の Forth コードに対応する中置式はどうなる
     でしょうか？ また、 ‘6-7*8+9’ を Forth 表記で記述してください(1)。

   符号を変更するには、 以下のように ‘negate’ を使用します:

     2 negate .

     研究課題(assignment): ‘-(-3)*4-5‘ を Forth に変換してみましょう。

   ‘/mod’ は ‘/’ と ‘mod’ の両方を実行します。

     7 3 /mod . .

   詳しくはこちらを参照ください: *note Arithmetic::

   ---------- Footnotes ----------

   (1) この表記法は、 後値記法(postfix notation) または RPN (逆ポーラン
ド記法) と呼ばれます。


File: gforth.info,  Node: Stack Manipulation Tutorial,  Next: Using files for Forth code Tutorial,  Prev: Arithmetics Tutorial,  Up: Tutorial

3.6 Stack Manipulation
======================

スタック操作ワードはスタックのデータを並べ替えます。

     1 .s drop .s
     1 .s dup .s drop drop .s
     1 2 .s over .s drop drop drop
     1 2 .s swap .s drop drop
     1 2 3 .s rot .s drop drop drop

   上記は最も重要なスタック操作ワードです。 以下のように2つペアでスタッ
ク項目を操作する亜種もあります:

     1 2 3 4 .s 2swap .s 2drop 2drop

   さらに 2 つ、 以下のスタック操作ワードがあります:

     1 2 .s nip .s drop
     1 2 .s tuck .s 2drop drop

     研究課題(assignment): ‘nip’ と ‘tuck’ を他のスタック操作ワードの組
     み合わせに置き換えてみましょう。

          以下の結果になるスタック操作を考えてみましょう
          Given:          How do you get:
          1 2 3           3 2 1
          1 2 3           1 2 3 2
          1 2 3           1 2 3 3
          1 2 3           1 3 3
          1 2 3           2 1 3
          1 2 3 4         4 3 2 1
          1 2 3           1 2 3 1 2 3
          1 2 3 4         1 2 3 4 1 2
          1 2 3
          1 2 3           1 2 3 4
          1 2 3           1 3

     5 dup * . \ 5^2

     研究課題(assignment): ‘17’ を複数回書かずに、 Forth で 17^3 と 17^4
     を書いてみましょう。 また、 スタック上の 2 つの数値 (A と B、 スタ
     ック頂上を B とする) を想定し、‘(a-b)(a+1)’ を計算する Forth コード
     を作成してみましょう。

   こちらも参照してください: *note Stack Manipulation::


File: gforth.info,  Node: Using files for Forth code Tutorial,  Next: Comments Tutorial,  Prev: Stack Manipulation Tutorial,  Up: Tutorial

3.7 Using files for Forth code
==============================

Forth コマンド・ラインでの作業は、 1 行の例や短い 1 回限りのコードの場合
には便利ですが、 あなたは編集や永続化に便利なように、 ソース・コードをフ
ァイルに保存したいと思うかもしれません。 お気に入りのエディター(なお、
Gforth には Emacs サポートがあります *note Emacs and Gforth::)を使用して
FILE.FS を作成し以下のようにします

     s" FILE.FS" included

   こうすると、 FILE.FS ファイルを Forth システムにロードします。 私達は
Forth ファイルの拡張子には ‘.fs’ を使っています。

   以下のようにいくつかのファイルをロードして、 Gforth を簡単に開始でき
ます:

     gforth FILE1.FS FILE2.FS

   これらのファイルのロード中にエラーが発生した場合、 Gforth は終了
(terminate)しますが、 Gforth 内で ‘INCLUDED’ 中にエラーが発生すると、 通
常は Gforth コマンド・ラインになります。 Forth システムを毎回開始させれ
ば、 あなたの以前の試行の結果に影響されることなく、 毎回クリーンな開始が
可能になります。

   私達は多くの場合、 すべてのテストをファイルに入れて、 それからそのコ
ードをロードし以下のようにしてテストを実行します

     gforth CODE.FS TESTS.FS -e bye

   (多くの場合、 Emacs内 で ‘C-x C-e’ を使用してこのコマンドを実行します
。) ‘-e bye’ により、 テスト後に Gforth が確実に終了(terminate)するので
、 面倒なくこのコマンドを再度開始できます。

   このアプローチの利点は、 プログラムが変更されるたびにテストを簡単に繰
り返すことができ、 変更によって生じたバグを簡単に発見できることです。

   こちらも参照してください: *note Forth source files::


File: gforth.info,  Node: Comments Tutorial,  Next: Colon Definitions Tutorial,  Prev: Using files for Forth code Tutorial,  Up: Tutorial

3.8 Comments
============

     \ これはコメントです。これは行末で終わります
     ( もう一つのコメント。 これはこのように閉じ丸括弧で終わります: )  .s

   ‘\’ と ‘(’ は通常の Forth ワードであるため、 その後ろのテキストと空白
(white space)で区切る必要があります。

     \This gives an "Undefined word" error

   最初にあらわれる ‘)’ が ‘(’ で始まるコメントを終了するため、 「‘(’ 型
のコメント」を入れ子(nest)にすることはできません。 そして、 ‘( ... )’ を
使用して ‘)’ を含むテキストをコメントアウトすることはできません(1)。

   私達は、 説明テキストや、 1 行以上のコードのコメントアウトに ‘\’ コメ
ントを使用します。 ‘(’ コメントは、 スタック効果やスタックの内容を説明し
たり、 コードの下位部分をコメントアウトしたりするために使用します。

   Emacs モード ‘gforth.el’ (*note Emacs and Gforth::) は、 ‘C-x \’ でリ
ージョンをコメントアウトし、 ‘C-u C-x \’ でリージョンのコメントを解除し
、 ‘\’ でコメントされた領域を ‘M-q’ でフィル(fill)します。

   こちらも参照してください: *note Comments::

   ---------- Footnotes ----------

   (1) したがって、 ワード名には ‘)’ を使用しないことをお勧めします。


File: gforth.info,  Node: Colon Definitions Tutorial,  Next: Decompilation Tutorial,  Prev: Comments Tutorial,  Up: Tutorial

3.9 Colon Definitions
=====================

コロン定義(Colon Definitions)は、 他のプログラミング言語のプロシージャや
関数に似ています。

     : squared ( n -- n^2 )
        dup * ;
     5 squared .
     7 squared .

   ‘:’ はコロン定義を開始します。 その名前は ‘squared’ です。 それに続く
コメントは、 そのスタック効果について説明しています。 ‘dup *’ というワー
ドは実行はされませんが、 定義にコンパイルされます(compiled into the
definition)。 ‘;’ はコロン定義を終了します。

   新しく定義されたワードは、 他の定義での使用を含め、 他のワードと同様
に使用できます:

     : cubed ( n -- n^3 )
        dup squared * ;
     -5 cubed .
     : fourth-power ( n -- n^4 )
        squared squared ;
     3 fourth-power .

     研究課題(assignment): ‘nip’ や ‘tuck’ や ‘negate’ や ‘/mod’ のコロ
     ン定義を他の Forth ワードで記述し、 それらが機能するかどうかを確認
     してみましょう (ヒント: 最初にオリジナルであなたの作成したテストコ
     ードをテストして結果を確認してから、 その後あなたが定義して、 再度
     テストして結果を比較しましょう)。 ‘redefine’ メッセージに驚かないで
     ください。 これらは単なる警告です。 (訳注: redefine; 同じ名前のワー
     ドを定義したという警告。 置き換えではなく追加となる。 これ以降の通
     訳(interpret)・コンパイルは新しい方のワードを参照するが、 通常は新
     しい方のワード定義後も、 既にコンパイル済みのワードは古い方のワード
     を参照しつづける。 詳しくはディクショナリ等の項目を参照)

   こちらも参照してください: *note Colon Definitions::


File: gforth.info,  Node: Decompilation Tutorial,  Next: Stack-Effect Comments Tutorial,  Prev: Colon Definitions Tutorial,  Up: Tutorial

3.10 Decompilation
==================

‘see’: を使用してコロン定義を逆コンパイルできます:

     see squared
     see cubed

   Gforth では、 ‘see’ は実行可能コードからソース・コードを再構築したも
のを示します。 ソースには存在するが、 実行可能コードには存在しない情報
(コメントなど)は失われます。

   最初から義済みのワードを逆コンパイルすることもできます:

     see .
     see +


File: gforth.info,  Node: Stack-Effect Comments Tutorial,  Next: Types Tutorial,  Prev: Decompilation Tutorial,  Up: Tutorial

3.11 Stack-Effect Comments
==========================

慣例により、 定義名の後のコメントはスタック効果を説明します。 ‘--’ の前
の部分は、 定義の実行前のスタックの状態、 つまりコロン定義に渡されるパラ
メータを説明します。 ‘--’ の後ろの部分は、 定義の実行後のスタックの状態
、 つまり定義の実行結果です。 スタック・コメントには、 定義がアクセス、
または、変更する、 (訳注: 定義の外部から見える、 )スタック項目のみを記述
します。

   たとえ スタック効果が ‘( -- )’ (訳注: スタックに何の効果も及ぼさない
)であっても、 あなたは、 すべての定義に正しいスタック効果を記述するべき
です。 また、 より複雑なワードには説明的なコメントを追加する必要がありま
す(通常、 これは ‘:’ の後ろに続けます)。 これを行わないと、 あなたコード
の行動は解読不能になります(なぜなら、 とある定義を理解するためには、 全
ての定義を辿るハメになるから)。

     研究課題(assignment): 例えば ‘swap’ のスタック効果は、 ‘x1 x2 -- x2
     x1’ のように記述できます。 同様に、 ‘-’ や ‘drop’ や ‘dup’ や
     ‘over’ や ‘rot’ や ‘nip’ や ‘tuck’ のスタック効果を書いてみましょう
     。 ヒント: 書けたら、 このマニュアルに書いてあるスタック効果と合っ
     ているかどうかチェックしましょう(*note Word Index::)。

   プログラマーは、 コロン定義内のさまざまな場所に、 その場所のスタック
の内容を説明するコメント(スタック・コメント)を挿入することがあります。 つ
まり、 スタック効果コメントの最初の部分のようなものです。 例えば以下のよ
うなのです

     : cubed ( n -- n^3 )
        dup squared  ( n n^2 ) * ;

   この場合、 ワードが十分に単純であるため、 スタック・コメントは割と余
計です。 あなたが、 読みやすさを高めるためにそのようなコメントを追加する
ことが良いと思った場合、 ワードをいくつかの単純なワードにファクタリング
(因数分解)することも検討する必要があります(*note Factoring: Factoring
Tutorial.)。 ファクタリングにより、 通常はスタック・コメントが不要になり
ます。 ただし、 あなたが結果としてリファクタリングしないことに決めた場合
は、 そのようなコメントがある方が、 無いよりも良いです。

   標準や、 このマニュアルや、 多くのプログラムの、 スタック効果およびス
タック・コメント内のスタック項目の名前は、 Fortran やハンガリアン記法と
同様に、 型プレフィックスによって型を指定します。 最も頻繁に使用されるプ
レフィックスは以下のとおりです:

‘n’
     符号付き整数
‘u’
     符号なし整数
‘c’
     文字(character)
‘f’
     二値フラグ(Boolean flags)。 つまり ‘false’ または ‘true’
‘a-addr,a-’
     セル・アライメント・アドレス
‘c-addr,c-’
     文字(char)アライメント・アドレス(注意: Windows NT では文字(char)は
     2 バイトになる場合があることに注意)
‘xt’
     実行トークン(Execution token)。 セルと同一サイズ
‘w,x’
     セル(cell)。 セルには整数またはアドレスを含めることができます。 通
     常は 32ビットまたは 64 ビットまたは 16 ビットを必要とします(プラッ
     トフォームと Forth システムによって異なります)。 cell は一般には
     machine word として知られていますが、 Forth では _word_ という用語
     はすでに別の意味を持っています。
‘d’
     符号付き2倍長整数(signed double-cell integer)
‘ud’
     符号無し2倍長整数(unsigned double-cell integer)
‘r’
     浮動小数点数(Float)(FP スタック上に置かれる)

   より完全なリストは *note Notation:: にあります。

     研究課題(assignment): あなたがここまでで記述したすべての定義に対し
     てスタック効果コメントを記述してみましょう。


File: gforth.info,  Node: Types Tutorial,  Next: Factoring Tutorial,  Prev: Stack-Effect Comments Tutorial,  Up: Tutorial

3.12 Types
==========

Forth では、 演算子の名前はオーバーロードされません。 したがって、 異な
る型に対する同様の演算には異なる名前が必要です。 たとえば、 ‘+’ は整数の
加算をしますが、 浮動小数点数を加算するには ‘f+’ を使用する必要がありま
す。 以下のプレフィックスは、 さまざまな型の関連する演算によく使用されま
す:

‘(none)’
     符号付き整数
‘u’
     符号なし整数
‘c’
     文字(character)
‘d’
     符号付き2倍長整数(signed double-cell integer)
‘ud, du’
     符号無し2倍長整数(unsigned double-cell integer)
‘2’
     2 つのセル(必ずしも 2倍長整数(double-cell numbers)とは限りません)
‘m, um’
     単一セルとダブル・セルの混合操作
‘f’
     浮動小数点(注意: スタック・コメントでは、 ‘f’ はフラグを表し、 ‘r’
     は FP 数値を表すことに注意してください。 また、 リテラル FP 数値に
     は指数部分を含める必要があります *note Floating Point Tutorial::)。

   符号付きのバリエーションと符号なしのバリエーションに違いがない場合(例
えば ‘+’ の場合)、 プレフィックスのないバリエーションのみが存在します。

   Forth は、 コンパイル・モード時もインタープリター・モード時も型チェッ
クを実行しません。 以下のように間違った操作を行うと、 データが正しく通訳
(interpret)されません:

     -1 u.

   あなたが、 これまで型チェック言語しか使用したことがなく、 型チェック
がいかに重要であるかを聞いたことがある場合でも、 パニックに陥る必要はあ
りません。 著者の経験(および他の Forth 利用者(Forthers)の経験)では、
Forth コードの型エラーは通常(慣れてしまえば)簡単に見つかります。 プログ
ラマの警戒心が高まると、 ほとんどの型エラーに加えて、 より困難なエラーも
発見される傾向があります。 型システムを回避する必要がまったくないため、
ほとんどの状況では型チェックがないことが利点であるようです(Forth に型チ
ェックを追加するプロジェクトは普及していません)。


File: gforth.info,  Node: Factoring Tutorial,  Next: Designing the stack effect Tutorial,  Prev: Types Tutorial,  Up: Tutorial

3.13 Factoring
==============

あなたが長ったらしい定義を書こうとすると、 スタックの内容を追跡するのが
すぐに困難になることがわかります。 したがって、優れた Forth プログラマは
短い定義 (たとえば 3 行)のみを記述する傾向があります。 意味のある短い定
義を見つける技術は、 (多項式の因数分解(factoring polynomials)と同様に)フ
ァクタリング(factoring)として知られています。

   よくファクタリングされたプログラムには、 追加の利点もあります。 つま
り、小さくて一般的なワードは、 大きくて特殊なワードよりもテストとデバッ
グが容易で、より再利用性に富みます。

   したがって、 あなたが、 スタック管理に問題を抱えてるなら、 コードを記
述するときにワードに意味のある要素を定義し、 それらの観点からワードを定
義するようにしてください。 たった 2 つのワードしかしか含まれないような定
義でも、 多くの場合役に立ちます。

   上手なファクタリングは簡単ではなく、 コツを掴むにはある程度の練習が必
要です。 しかし、経験豊富な Forth プログラマーであっても、 すぐには適切
な解決策を見つけられないことが多く、 プログラムの書き直し時に見つかるの
です。 したがって、 すぐに良い解決策が思い浮かばなくても、 絶望しないで
試し続けてください。(訳注: 参考: 拙訳 Thinking Forth 第6章 ファクタリン
グ <https://thinking-forth-ja.readthedocs.io/ja/latest/chapter6.html>)


File: gforth.info,  Node: Designing the stack effect Tutorial,  Next: Local Variables Tutorial,  Prev: Factoring Tutorial,  Up: Tutorial

3.14 Designing the stack effect
===============================

他の言語では、 関数(function)のパラメータに任意の順序を使用できます。 ま
た、 結果は 1 つだけなので、 結果の順序を扱う必要もありません。

   Forth (および他のスタック・ベースの言語、 たとえば PostScript)では、
定義のパラメーターの順序と結果の順序が重要であり、 適切に設計する必要が
あります。 一般的なガイドラインは、 ワードの実装が複雑になる場合でも、 ワ
ードがほとんどの場合に簡単に使用できるようにスタック効果を設計することで
す。 いくつかの具体的なルールは以下のとおりです:

   • ワードがパラメータの全てを消費する(例: ‘.’)。

   • パラメータの順序に関する慣習がある場合(数学や他のプログラミング言語
     など)、 それに従ってください(例: ‘-’)。

   • 1 つのパラメータが通常短い計算のみを必要とする場合(たとえば、それが
     定数である場合)、 それをスタック頂上(top of stack;TOS)に渡します。
     逆に、 通常、 計算に長いコード シーケンスが必要なパラメータは、 ス
     タック底(bottom) (つまり、最初の) パラメータとして渡す必要がありま
     す。 これにより、 リーダーはコードの長いシーケンス(またはスタック操
     作)を通じてスタック底の項目(bottom item)を追跡する必要がなくなるた
     め、 コードが読みやすくなります。 たとえば、 ‘!’(「ストア」 *note
     Memory::)は、 通常、 格納されている値よりも計算が簡単であるため、 ス
     タック頂上にアドレスがあるのを期待します(多くの場合、 アドレスは単
     なる変数です)。

   • 同様に、 通常すぐに消費される結果はスタック頂上(top of stack)に返さ
     れるべきですが、 長い計算でよく使用される結果はスタック底(bottom)の
     結果として渡される必要があります。 たとえば、 ‘open-file’ のような
     ファイル・ワードは、スタック頂上にエラー・コードを返します。 これは
     、 通常、 ‘throw’ によってすぐに消費されるためです。 さらに言えば、
     他の結果に対して何かを行う前に、 エラー・コードをチェックする必要が
     あります。

   これらのルールは一般的なガイドラインに過ぎません。 ワードを使いやすく
するという全体的な目標を見失わないでください。 例えば、 慣習のルールが計
算長のルールと衝突する場合、 ワードがあまり使われない場合は慣習を優先す
るかもしれません。 一方、 ワードが頻繁に使われる場合は、 計算長のルール
を優先するかもしれません(だからといって頻繁に使うと、 計算長のルールを破
るコストが非常に高くなりますし、 頻繁に使うことで非慣習的な順序を覚えて
しまいがちになります)。


File: gforth.info,  Node: Local Variables Tutorial,  Next: Conditional execution Tutorial,  Prev: Designing the stack effect Tutorial,  Up: Tutorial

3.15 Local Variables
====================

コロン定義内でローカル変数(local)を定義できます:

     : swap { a b -- b a }
       b a ;
     1 2 swap .s 2drop

   (あなたの Forth システムがこの構文をサポートしていない場合は、 最初に
‘compat/anslocal.fs’ をインクルードしてください)

   この例では、 ‘{ a b -- b a }’ がローカル変数定義です。 スタックから 2
つのセルを取得し、 スタック頂上を ‘b’ に入れ、 その次のスタック要素を
‘a’ に入れます(訳注: a b はスタック上から取り除かれる)。 ‘--’ は ‘}’ で
終わるコメントを開始します。 ローカル変数の定義後、 ローカル変数の名前を
使用すると、 その値がスタックに積まれます。 コメント部分(‘-- b a’)は省略
できます:

     : swap ( x1 x2 -- x2 x1 )
       { a b } b a ;

   Gforth では、 コロン定義内の任意の場所に複数のローカル変数定義を含め
ることができます。 対照的に、 標準Forthのプログラムでは、 コロン定義ごと
にローカル変数定義を 1 つだけしか持つことができず、 そのローカル変数定義
は制御構造の外側にある必要があります。

   ローカル変数を使用すると、 スタックの問題に遭遇することなく、 少し長
い定義を書くことができます。 ただし、重要な、ファクタリング技能を身につ
けるための演習として、 ローカル変数を使用せずにコロン定義を記述してみる
ことをお勧めします。

     研究課題(assignment): ここまでのあなたの定義をローカル変数を使って
     書き換えてみましょう。

   こちらも参照下さい: *note Locals::


File: gforth.info,  Node: Conditional execution Tutorial,  Next: Flags and Comparisons Tutorial,  Prev: Local Variables Tutorial,  Up: Tutorial

3.16 Conditional execution
==========================

Forth では、 コロン定義内でのみ制御構造を使用できます。 ‘if’ 構造は以下
のようになります:

     : abs ( n1 -- +n2 )
         dup 0 < if
             negate
         endif ;
     5 abs .
     -5 abs .

   ‘if’ はスタックからフラグを取得します。 フラグがゼロ以外 (true) の場
合は、 その次のコードが実行されます。 そうでない場合は、 ‘endif’ (または
‘else’) の後から実行が続けられます。 ‘<’ は、 頂上から 2 つのスタック要
素を比較し、 フラグを生成します。

     1 2 < .
     2 1 < .
     1 1 < .

   実は、 ‘endif’ の標準Forthでの名前は ‘then’ です。 このチュートリアル
では、 ‘endif’ を使用した例を示します。 なぜなら、 ‘then’ が異なる意味を
持つ他のプログラミング言語に慣れている人々にとっては、 ‘endif’ を使用す
る方が混乱が少ないからです。 システムに ‘endif’ がない場合は、 以下のよ
うに定義します

     : endif postpone then ; immediate

   あなたはオプションで ‘else’ 部分を使用できます:

     : min ( n1 n2 -- n )
       2dup < if
         drop
       else
         nip
       endif ;
     2 3 min .
     3 2 min .

     研究課題(assignment): ‘else’ 部分を付けずに ‘min’ を記述してみまし
     ょう。 (ヒント: ‘nip’ の定義は何ですか?)。

   こちらも参照下さい: *note Selection::


File: gforth.info,  Node: Flags and Comparisons Tutorial,  Next: General Loops Tutorial,  Prev: Conditional execution Tutorial,  Up: Tutorial

3.17 Flags and Comparisons
==========================

false フラグはすべてのビットがクリアです(整数として通訳(interpret)される
場合は 0)。 正規化された true フラグは、 すべてのビットがセットされてい
ます(2の補数の符号付き整数として -1)。 多くの文脈(例: ‘if’)では、ゼロ以
外の値はすべて true フラグとして扱われます。

     false .
     true .
     true hex u. decimal

   比較ワードは正規化フラグを生成します:

     1 1 = .
     1 0= .
     0 1 < .
     0 0 < .
     -1 1 u< . \ 型エラー。 u< は -1 を 大きな符号なし数として扱ってしまいます
     -1 1 < .

   Gforth は、接頭辞 ‘0 u d d0 du f f0’ (または「 接頭辞なし」)との比較
‘= <> < > <= >=’ のすべての組み合わせをサポートします。 これらの組み合わ
せの一部のみが標準Forthです (詳細については、標準Forth または *note
Numeric comparison:: または *note Floating Point:: または *note Word
Index:: を参照してください)。

   ‘and or xor invert’ を正規化フラグ用の演算子として使用できます。 実際
には、 これらはビット単位演算です:

     1 2 and .
     1 2 or .
     1 3 xor .
     1 invert .

   ‘0<>’ を使用して ゼロ/非ゼロ フラグを正規化フラグに変換できます(そし
て、 その途中で ‘0=’ を使用して ゼロ/非ゼロ フラグの余数(complement)を取
ります。 実際、 正規化フラグでは ‘invert’ の代わりに ‘0=’ を使用するのが
一般的です)。

     1 0= .
     1 0<> .

   ‘0<>’ 無しでも ‘if’ で ゼロ/非ゼロ をテストすることはできますが、 ゼ
ロ/非ゼロ 値を ‘and or xor’ と組み合わせる場合、 ‘and or xor’ はビット単
位での操作なので、 ‘0<>’ を使用する必要がある場合があります。 最も単純で
、 エラーが少なく、 おそらく最も明確な方法は、 これらすべての場合に
‘0<>’ を使用することですが、 場合によっては、 使用する ‘0<>’ の数を減ら
すこともできます。 以下にいくつかのスタック効果を示します。 fc は正規化
フラグ(canonical flag)を表し、 fz は ゼロ/非ゼロ を表します(すべての fc
は fz としても機能します):

     or  ( fz1 fz2 -- fz3 )
     and ( fz1 fc  -- fz2 )
     and ( fc  fz1 -- fz2 )

   したがって、 以下のようなコードの場合:

     ( n1 n2 ) 0<> and if

   これは、 n1 and n2 (n1 かつ n2)がゼロ以外であるかどうかをテストし、 イ
エスの場合は ‘if’ の後のコードを実行します。 n1 を ゼロ/非ゼロ として扱
い、 ‘0<>’ を使用して n2 を正規化フラグに変換します。 ‘and’ は fz を生成
し、 それは ‘if’ によって消費されます。

   正規化フラグの全ビットセット機能とブール演算のビット単位の演算を使用
して、 ‘if’ を回避することもできます:

     : foo ( n1 -- n2 )
       0= if
         14
       else
         0
       endif ;
     0 foo .
     1 foo .

     : foo ( n1 -- n2 )
       0= 14 and ;
     0 foo .
     1 foo .

     研究課題(assignment): ‘min’ を ‘if’ 無しで書いてみましょう。

   こちらも参照下さい: *note Boolean Flags::, *note Numeric
comparison::, *note Bitwise operations::


File: gforth.info,  Node: General Loops Tutorial,  Next: Counted loops Tutorial,  Prev: Flags and Comparisons Tutorial,  Up: Tutorial

3.18 General Loops
==================

無限ループは非常に単純です:

     : endless ( -- )
       0 begin
         dup . 1+
       again ;
     endless

   (Gforth の場合、) ‘Ctrl-C’ を押してこのループを終了します。 ‘begin’ は
実行時に何も行わず、 ‘again’ は ‘begin’ にジャンプします。

   任意の場所に 1 つの出口があるループは以下のようになります:

     : log2 ( +n1 -- n2 )
     \ logarithmus dualis of n1>0, rounded down to the next integer
       assert( dup 0> )
       2/ 0 begin
         over 0> while
           1+ swap 2/ swap
       repeat
       nip ;
     7 log2 .
     8 log2 .

   実行時には ‘while’ はフラグを1つ消費します。 フラグが 0 の場合、
‘repeat’ の後ろへ飛んで実行が継続されます。 フラグがゼロ以外の場合、 実
行は ‘while’ の後ろから継続されます。 ‘Repeat’ は、 ‘again’ と全く同じよ
うに、 ‘begin’ に戻ります。

   Forth には、 ‘1+’ など、多数の 組み合わせ/省略形 があります。 しかし
、 ‘2/’ は 組み合わせ/省略形 ではありません。 これは引数を 1 ビット右に
シフトし、 Gforth の (Gforth 0.7 以降の) ‘/’ と同様、 常に負の無限大方向
に向かって小数点以下を丸める除算(フロア除算)と見なされますが、 他の多く
の Forth システムの ‘/’ とは異なります。

     -5 2 / . \ -2 or -3
     -5 2/ .  \ -3

   ‘assert(’ は標準Forthのワードではありませんが、 Gforth 以外のシステム
でも ‘compat/assert.fs’ を含めることで取得できます。 それが何をするかは
、 以下のように試してみることで確認できます。

     0 log2 .

   以下は、 最後に出口があるループです:

     : log2 ( +n1 -- n2 )
     \ logarithmus dualis of n1>0, rounded down to the next integer
       assert( dup 0 > )
       -1 begin
         1+ swap 2/ swap
         over 0 <=
       until
       nip ;

   ‘Until’ はフラグを消費します。 フラグがゼロの場合は ‘begin’ から実行
が継続され、 それ以外の場合は ‘until’ の後から実行が継続されます。

     研究課題(assignment): 最大公約数を計算する定義を書いてみましょう。

   こちらも参照ください: *note Simple Loops::


File: gforth.info,  Node: Counted loops Tutorial,  Next: Recursion Tutorial,  Prev: General Loops Tutorial,  Up: Tutorial

3.19 Counted loops
==================

     : ^ ( n1 u -- n )
     \ n = the uth power of n1
       1 swap 0 u+do
         over *
       loop
       nip ;
     3 2 ^ .
     4 3 ^ .

   ‘U+do’ (あなたの Forth システムにない場合は ‘compat/loops.fs’ をイン
クルードしてください)は、 ‘( u3 u4 -- )’ 、 つまり、 スタックから 2 つの
数値を取得し、 ‘u+do’ と ‘loop’ の間のコードを ‘u3 - u4’ 回実行します(‘
u3 - u4 < 0’ の場合はまったく実行しません)。

   ループ開始ワードのスタック効果を見れば、スタック効果の設計ルールが機
能していることがわかります。 ループの開始値は終了値と比べて定数であるこ
とが多いため、 開始値はスタック頂上(top-of-stack)に渡されます。

   ‘i’ を使用して、 ループ・カウンターにアクセスできます:

     : fac ( u -- u! )
       1 swap 1+ 1 u+do
         i *
       loop ;
     5 fac .
     7 fac .

   ‘+do’ もあります。 これは符号付きの数値を期待します(それはループに入
るかどうかを決定するために重要です)。

     研究課題(assignment): n 番目のフィボナッチ数を計算するための定義を
     記述してみましょう。

   増分として 1 以外も使用できます:

     : up2 ( n1 n2 -- )
       +do
         i .
       2 +loop ;
     10 0 up2

     : down2 ( n1 n2 -- )
       -do
         i .
       2 -loop ;
     0 10 down2

   こちらも参照ください: *note Counted Loops::


File: gforth.info,  Node: Recursion Tutorial,  Next: Leaving definitions or loops Tutorial,  Prev: Counted loops Tutorial,  Up: Tutorial

3.20 Recursion
==============

通常、 定義の名前はその定義内に表れません。ただし、 それ以前の(同名の)定
義は普通に表れます(訳注: 下記例は再帰呼出しではなくて、 ’/’ の古いバージ
ョンを呼び出しているに過ぎない事に注意。同じ名前の古いバージョンが存在し
なければエラーになるが、存在すればエラーにならないので注意。):

     1 0 / . \ "Floating-point unidentified fault" in Gforth on some platforms
     : / ( n1 n2 -- n )
       dup 0= if
         -10 throw \ report division by zero
       endif
       /           \ old version
     ;
     1 0 /

   再帰定義の場合は、 ‘recursive’ (非標準) または ‘recurse’ を使用できま
す:

     : fac1 ( n -- n! ) recursive
      dup 0> if
        dup 1- fac1 *
      else
        drop 1
      endif ;
     7 fac1 .

     : fac2 ( n -- n! )
      dup 0> if
        dup 1- recurse *
      else
        drop 1
      endif ;
     8 fac2 .

     研究課題(assignment): n 番目のフィボナッチ数を計算するための再帰定
     義を記述してみましょう。

   こちらも参照ください (間接再帰に関してもコチラ): *Note Calls and
returns::


File: gforth.info,  Node: Leaving definitions or loops Tutorial,  Next: Return Stack Tutorial,  Prev: Recursion Tutorial,  Up: Tutorial

3.21 Leaving definitions or loops
=================================

‘EXIT’ は、 現在の定義をすぐに終了(exit)します。 ‘EXIT’ の実行前に、 (残
ったループ・カウンタ達を全て取り除くために、)ネストしたカウンタ付きルー
プの数だけ ‘UNLOOP’ を実行する必要があります(訳注: 下記例は1重のループな
ので unloop が1つ。 2重ループになったら unloop unloop と2つ必要):

     : ...
      ... u+do
        ... if
          ... unloop exit
        endif
        ...
      loop
      ... ;

   ‘LEAVE’ は、 (‘LEAVE’ から見て)最も内側にあるカウンタ付きループを直ち
に終了します:

     : ...
      ... u+do
        ... if
          ... leave
        endif
        ...
      loop
      ... ;

   こちらも参照ください: *note Calls and returns::, *note Counted
Loops::


File: gforth.info,  Node: Return Stack Tutorial,  Next: Memory Tutorial,  Prev: Leaving definitions or loops Tutorial,  Up: Tutorial

3.22 Return Stack
=================

データ・スタックに加えて、 Forth には 2 番目のスタックであるリターン・ス
タックもあります。 ほとんどの Forth システムは、プロシージャ呼び出しの戻
りアドレスをそこに保存します(したがって、 リターン・スタックという名前が
付けられています)。 プログラマもリターン・スタックを利用することができま
す。

     : foo ( n1 n2 -- )
      .s
      >r .s
      r@ .
      >r .s
      r@ .
      r> .
      r@ .
      r> . ;
     1 2 foo

   ‘>r’ はデータ・スタックから1つの要素を取得し、 それをリターン・スタッ
クにプッシュします。 逆に、 ‘r>’ は1つの要素をリターンからデータ・スタッ
クに移動します。 ‘r@’ は、リターン・スタック頂上のコピーをデータ・スタッ
クにプッシュします。

   Forth プログラマーは通常、 データ・スタックのみを使用すると複雑すぎて
、 かつ、 ファクタリングやローカル変数が選択肢に無い場合、 データを一時
的に保存するためにリターン・スタックを使用します。

     : 2swap ( x1 x2 x3 x4 -- x3 x4 x1 x2 )
      rot >r rot r> ;

   定義のリターン・アドレスとカウント付きループのループ制御パラメータは
通常、 リターン・スタック上に存在するため、 コロン定義またはカウント付き
ループでリターン スタックにプッシュしたすべての項目を、定義の終了やルー
プの終了の前にリターン・スタックから取得する必要があります。 ある定義の
外側やループの外側でリターン・スタックにプッシュしたアイテムに、 ループ
の定義内からアクセスすることはできません。

   リターン・スタック項目の数を間違えると、 通常はクラッシュします:

     : crash ( n -- )
       >r ;
     5 crash

   ローカル変数の使用とリターン・スタックの使用を混在させることはできま
せん(標準Forthの場合。 Gforth では問題ありません)。 ただし、 これらは同
一の問題の解決なので、 問題にはなりません。

     研究課題(assignment): リターン・スタックを使用して、 ここまでにあな
     たが書いた定義をより良い方法で書き直すことができるでしょうか？

   こちらも参照ください: *note Return stack::


File: gforth.info,  Node: Memory Tutorial,  Next: Characters and Strings Tutorial,  Prev: Return Stack Tutorial,  Up: Tutorial

3.23 Memory
===========

以下使用してグローバル変数 ‘v’ を作成できます:

     variable v ( -- addr )

   ‘v’ は、スタックにメモリ内の、とあるセルのアドレスをプッシュします。
このセルは ‘variable’ によって予約されています。 ‘!’(ストア)を使用してス
タックからこのセルに値を保存し、 ‘@’(フェッチ)を使用して値をメモリからス
タックにロードできます:

     v .
     5 v ! .s
     v @ .

   ‘dump’ を使用すると、 メモリの生のダンプ(メモリー・ダンプ)を確認でき
ます:

     v 1 cells .s dump

   ‘Cells ( n1 -- n2 )’ は、 n1 個のセル が占めるバイト数(より一般的には
アドレス単位(address units)(aus))を与えます。 そして、 あなたは、 さらに
多くのメモリを予約することもできます:

     create v2 20 cells allot
     v2 20 cells dump

   変数のようなワード ‘v2’ を作成し、 20 個の初期化されていないセルを予
約します。 ‘v2’ によってプッシュされたアドレスは、 これら 20 個のセルの
先頭を指します(*note CREATE::)。 あなたは、 アドレス演算を使用して、 こ
れらのセルにアクセスできます:

     3 v2 5 cells + !
     v2 20 cells dump

   ‘,’ を使用してメモリを予約 かつ 初期化できます:

     create v3
       5 , 4 , 3 , 2 , 1 ,
     v3 @ .
     v3 cell+ @ .
     v3 2 cells + @ .
     v3 5 cells dump

     研究課題(assignment): 最初のセルは ‘addr’ 、 次のセルは ‘addr
     cell+’ などとして、 ‘u’ 個のセルの値の合計を計算する定義 ‘vsum (
     addr u -- n )’ を記述してみましょう。

   ‘variable’ と ‘create’ の違いは、‘variable’ がセルを割り当てる
(allots)ことと、 標準 Forth では変数(variable)に追加のメモリを割り当てる
ことができないことです。

   新しいワードを作成せずにメモリを予約することもできます:

     here 10 cells allot .
     here .

   最初の ‘here’ は(最初の ‘here’ 時点の)ディクショナリ領域の後のアドレ
スをプッシュし、 メモリ領域の開始アドレスとして使い、 2 番目の ‘here’ は
(2 番目の ‘here’ 時点の)ディクショナリ領域の後のアドレスをプッシュします
。 この開始アドレスはどこかに保存する必要があります。 そうしないと、 あ
なたはこのメモリ領域を再度見つけるのが困難になります。

   ‘Allot’ はディクショナリ・メモリを管理します。 ディクショナリ・メモリ
には、 Gforth や他のほとんどの Forth システムの、 ワードなどのシステムの
データ構造が含まれています。 これはスタックのように管理されます。 あなた
は以下のようにして割り当て(‘allot’)したメモリを解放できます:

     -10 cells allot
     here .

   注意: その合間に新しいワードを作成した場合、 それを実行できないことに
注意してください(‘allot’ で作成されたメモリが、 もはやディクショナリ「ス
タック」の頂上ではなくなるため)。

   その代わりに、 ‘allocate’ や ‘free’ を使用すると、 任意の順序でメモリ
を解放できます:

     10 cells allocate throw .s
     20 cells allocate throw .s
     swap
     free throw
     free throw

   ‘throw’ はエラー(メモリ不足など)を処理します。

   また、 ガベージ・コレクター
(https://www.complang.tuwien.ac.at/forth/garbage-collection.zip) なら、
メモリを明示的に解放(‘free’)する必要がなくなります。

   こちらも参照ください: *note Memory::


File: gforth.info,  Node: Characters and Strings Tutorial,  Next: Alignment Tutorial,  Prev: Memory Tutorial,  Up: Tutorial

3.24 Characters and Strings
===========================

スタック上では、 数と同様に文字がセルを占めます。 メモリ内では文字は独自
のサイズ(ほとんどのシステムでは 8 ビットのバイト値)であるため、 メモリ・
アクセスには文字独自のワードが必要です:

     create v4
       104 c, 97 c, 108 c, 108 c, 111 c,
     v4 4 chars + c@ .
     v4 5 chars dump

   スタック上の文字列の推奨される表現は ‘addr u-count’ です。ここで、
‘addr’ は文字列の最初の文字のアドレスで、 ‘u-count’ は文字列の文字数です
。

     v4 5 type

   以下を使用すると文字列定数を取得できます

     s" hello, world" .s
     type

   ‘s"’ と文字列の間にスペースがあることを確かめてください。 ‘s"’ は通常
の Forth ワードであり、 空白(white space)で区切る必要があります(スペース
を削除するとどうなるかを試してみましょう)。

   ただし、 この ‘s"’ のインタープリターでの使用(interpretive use)は非常
に制限されています。 文字列は、 ‘s"’ が次に呼び出されるまでの間だけ存在
します(一部の Forth システムはこれらの文字列を複数保持しますが、 普通は
未だ限られた寿命です)。

     s" hello," s" world" .s
     type
     type

   あなたは定義内で ‘s"’ を使用することもでき、 (定義が続く限り、)その結
果の文字列は永久に存続します:

     : foo s" hello," s" world" ;
     foo .s
     type
     type

     研究課題(assignment): ‘Emit ( c -- )’ は ‘c’ を(数値ではなく)文字と
     して出力します。 これを使って ‘type ( addr u -- )’ を実装してみまし
     ょう。

   こちらも参照ください: *note Memory Blocks::


File: gforth.info,  Node: Alignment Tutorial,  Next: Floating Point Tutorial,  Prev: Characters and Strings Tutorial,  Up: Tutorial

3.25 Alignment
==============

多くのプロセッサでは、 ‘@’ と ‘!’ を使用してセルにアクセスする場合、 メ
モリ内でセ​​ルをアライメントする必要があります (プロセッサがアライメント
を必要としない場合でも、 アライメントされたセルへのアクセスは高速です)。

   ‘Create’ は ‘here’(つまり、 次の割り当てが行われる場所、 そして
‘create’されたワードが指す場所)でアライメントします。 同様に、
‘allocate’によって生成されたメモリはアライメントしたアドレスから始まりま
す。 アライメントしたアドレスに ‘cells’ の数値 を足すと、 次のアライメン
トされたアドレスが生成されます。

   ただし、 ‘char+’ および ‘chars’ を含むアドレス演算では、セルにアライ
メントしていないアドレスが作成される可能性があります。 ‘Aligned ( addr
-- a-addr )’ は、 その次のアライメントせされたアドレスを生成します:

     v3 char+ aligned .s @ .
     v3 char+ .s @ .

   同様に、 ‘align’ は ‘here’ を次のアライメントされたアドレスに進めます
:

     create v5 97 c,
     here .
     align here .
     1000 ,

   注意: プログラムを移植可能にしたい場合は、 プロセッサがそれらを必要と
しない場合でも、 アライメントれたアドレスを使用する必要があることに注意
してください。

   こちらも参照ください: *note Address arithmetic::


File: gforth.info,  Node: Floating Point Tutorial,  Next: Files Tutorial,  Prev: Alignment Tutorial,  Up: Tutorial

3.26 Floating Point
===================

Forth の浮動小数点(floating-point)(FP)の、 数値と算術演算は、 ほぼ期待さ
れた通りに機能しますが、 特筆すべき点がいくつかあります:

   最初の点は Forth に固有のものではありませんが、 非常に重要で、 まだ広
く知られていないため、 ここで言及します。 浮動小数点数は実数(real)ではあ
りません。 実数(real)が持ち、 あらゆる種類の数値に期待される多くの性質
(算術法則など)は、 浮動小数点数には当てはまりません。 浮動小数点演算した
い場合、 浮動小数点演算の問題とその回避方法について学ぶ必要があります。
良い出発点は ‘David Goldberg, What Every Computer Scientist Should Know
About Floating-Point Arithmetic
(https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html), ACM
Computing Surveys 23(1):5−48, March 1991’ です(訳注:
<https://docs.oracle.com/cd/E19957-01/806-4847/ncg_goldberg.html> これが
合ってるかどうか不明。一部文字化けあり2024/06現在)。

   Forth ソース・コードでは、リテラル浮動小数点数には指数が必要です(例:
‘1e0’)。これは、 ‘1e’ のように短く書くことも、 ‘+1.0e+0’ のように長く書
くこともでき、 その間にはさまざまなバリエーションがあります。 その理由は
、 歴史的な理由により、 Forth は小数点のみ(例: ‘1.’) の数を 2 セル整数を
示すものとして通訳(interpret)するためです。 例:

     2e 2e f+ f.

   リテラル浮動小数点数のもう 1 つの要件は、 現在の基数が 10 進数である
ことです。 16 進数の ‘1e’ は整数として通訳(interpret)されます:

   Forth には、Forth-2012 に準拠した浮動小数点数用の別個のスタックがあり
ます。 このモデルの利点の 1 つは、 浮動小数点数にアクセスするときにセル
が邪魔にならないこと、 またその逆も同様であることです。 Forth には、 浮
動小数点スタック(FP スタック)を操作するためのワードのセットがあります:
‘fdup fswap fdrop fover frot’ や (非標準の、) ‘fnip ftuck fpick’

   FP 算術ワードには ‘F’ という接頭辞が付きます。 通常の ‘f+ f- f* f/
f** fnegate’ のほか、 他の、 関数用の多数のワード (例: ‘fsqrt fsin fln
fmin’) があります。 期待されるワードの 1 つが ‘f=’ ですが、 ‘f=’ は標準
にはありません。 浮動小数点数の計算結果は通常不正確であるため、 正確な比
較は通常間違いであり、 近似的な比較を使用する必要があります。 残念ながら
、この目的のための標準のワードである ‘f~’ は適切に設計されていないため、
Gforth では ‘f~abs’ と ‘f~rel’ も提供しています。

   そしてもちろん、 メモリ内の浮動小数点数にアクセスするためのワード(‘f@
f!’)や、 アドレス演算用のワード(‘floats float+ faligned’)もあります。 メ
モリ内の IEEE 書式の単精度および倍精度数にアクセスするために、 ‘sf’ およ
び ‘df’ プレフィックスを付けた、 これらのワードのバリエーションもありま
す。 その主な目的は、 外部浮動小数点数データ(ファイルから読み取られた、
またはファイルに書き込まれるデータなど)にアクセスすることです。

   以下は、 ドット出力ワード(dot-product word)とその使用例です:

     : v* ( f_addr1 nstride1 f_addr2 nstride2 ucount -- r )
       >r swap 2swap swap 0e r> 0 ?DO
         dup f@ over + 2swap dup f@ f* f+ over + 2swap
       LOOP
       2drop 2drop ;

     create v 1.23e f, 4.56e f, 7.89e f,

     v 1 floats  v 1 floats  3  v* f.

     研究課題(assignment): 二次方程式を解くプログラムを作成してみましょ
     う。 次に、 ‘Henry G. Baker, You Could Learn a Lot from a Quadratic
     (https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.111.4448&rep=rep1&type=pdf),
     ACM SIGPLAN Notices, 33(1):30−39, January 1998’ を読んで、 そのプロ
     グラムを改善できるかどうか確認してください。 最後に、 元のバージョ
     ンと改良されたバージョンで異なる結果が生成されるテスト・ケースを探
     しましょう。

   こちらも参照ください: *note Floating Point::; *note Floating point
stack::; *note Number Conversion::; *note Memory Access::; *note Address
arithmetic::.


File: gforth.info,  Node: Files Tutorial,  Next: Interpretation and Compilation Semantics and Immediacy Tutorial,  Prev: Floating Point Tutorial,  Up: Tutorial

3.27 Files
==========

このセクションでは、 Forth 内でファイルを使用する方法について簡単に説明
します。 それは 5 つの簡単なステップに分かれています:

  1. 入力用に ASCII テキスト・ファイルを開きます
  2. 出力用にファイルを開く
  3. 文字列が一致する (または他の条件が満たされる) まで入力ファイルを読
     み取ります
  4. 入力 (が変更されたかどうかに関係なく、) から数行を出力に書き込みま
     す
  5. ファイルを閉じます。

   こちらも参照ください: *note General files::

3.27.1 Open file for input
--------------------------

     s" foo.in"  r/o open-file throw Value fd-in

3.27.2 Create file for output
-----------------------------

     s" foo.out" w/o create-file throw Value fd-out

   使用可能なファイル・モードは、 読み取り専用アクセスの場合は r/o 、 読
み取り/書き込み アクセスの場合は r/w 、書き込み専用アクセスの場合は w/o
です。 必要に応じて、 読み取りと書き込みの両方のファイルを r/w で開くこ
ともできます。 すべてのファイル用ワードはエラーコードを返します。 ほとん
どのアプリケーションでは、 ‘throw’ を使用してエラー・コードを外部のエラ
ー・ハンドラーに渡すのが最善(best)です。

   開いたり(opening)割り当てたり(assigning)するためのワードが必要な場合
は、 以下のように定義します:

     0 Value fd-in
     0 Value fd-out
     : open-input ( addr u -- )  r/o open-file throw to fd-in ;
     : open-output ( addr u -- )  w/o create-file throw to fd-out ;

   使用例:

     s" foo.in" open-input
     s" foo.out" open-output

3.27.3 ファイルの特定の行をスキャン
-----------------------------------

     256 Constant max-line
     Create line-buffer  max-line 2 + allot

     : scan-file ( addr u -- )
       begin
           line-buffer max-line fd-in read-line throw
       while
              >r 2dup line-buffer r> compare 0=
          until
       else
          drop
       then
       2drop ;

   ‘read-line ( addr u1 fd -- u2 flag ior )’ は、 addr からのバッファー
に最大 u1 バイトを読み取り、 読み取ったバイト数と、 ファイルの終わりに達
した場合に false になるフラグと、 エラーコードを返します。

   ‘compare ( addr1 u1 addr2 u2 -- n )’ は 2 つの文字列を比較し、 両方の
文字列が等しい場合は 0 を返します。 最初の文字列の方が字句的に大きい
(lexically greater)場合は正の数値を返し、 2 番目の文字列の方が字句的に大
きい(lexically greater)場合は負の数値を返します。

   このループは、 まだ見たことがないですよね。 このループは出口が2つあり
ます。 ‘while’ はスタック上にある読み取ったバイト数で終了するため、 それ
を個別にクリーンアップする必要があります。 そのクリーンアップする部分は
‘else’ の後にあります。

   使用例:

     s" The text I search is here" scan-file

3.27.4 Copy input to output
---------------------------

     : copy-file ( -- )
       begin
           line-buffer max-line fd-in read-line throw
       while
           line-buffer swap fd-out write-line throw
       repeat
       drop ;

3.27.5 Close files
------------------

     fd-in close-file throw
     fd-out close-file throw

   これも、同様に、 定義に組み込むことができます:

     : close-input ( -- )  fd-in close-file throw ;
     : close-output ( -- )  fd-out close-file throw ;

     研究課題(assignment): ‘copy-file’ を変更して、 2 行目が一致するまで
     コピーするようにするにはどうすればよいでしょうか？ セクションの開始
     行と終了行を指定して、 テキスト・ファイルのセクションを抽出するプロ
     グラムを作成できますか？


File: gforth.info,  Node: Interpretation and Compilation Semantics and Immediacy Tutorial,  Next: Execution Tokens Tutorial,  Prev: Files Tutorial,  Up: Tutorial

3.28 Interpretation and Compilation Semantics and Immediacy
===========================================================

ワードがコンパイルされる時と、 通訳(interpret)される時では異なる振る舞い
をします。 たとえば、 ‘+’ について考えてみましょう:

     1 2 + .
     : foo + ;

   これらの 2 つの振る舞いは、 コンパイル機能(compilation semantics)とイ
ンタプリタ機能(interpretation semantics)として知られています。 通常のワ
ード(例: ‘+’)の場合、 コンパイル機能は、 現在定義中のワード(上記の例では
‘foo’)にインタープリター機能を追加します。 つまり、 後で ‘foo’ が実行さ
れると、 ‘+’ のインタープリター機能(interpretation semantics)(つまり、2
つの数値の加算)が実行されます。

   ただし、 ‘if’ のような制御フロー・ワードなど、 デフォルト以外のコンパ
イル機能を持つワードが存在します。 ‘immediate’ を使用すると、 最後に定義
されたワードのコンパイル機能をインタープリター機能と等しくなるように変更
できます:

     : [FOO] ( -- )
      5 . ; immediate

     [FOO]
     : bar ( -- )
       [FOO] ;
     bar
     see bar

   デフォルト以外のコンパイル機能をもつワードだと知らしめる 2 つの慣習は
、 名前を括弧で囲む(より頻繁に使用される)ことと、 名前をすべて大文字で記
述する(あまり使用されない)ことです。

   ‘if’ などの一部のワードについては、 インタープリター機能を使用するの
は通常間違いであるため、 それらを ‘compile-only’ としてマークし、 インタ
ープリター機能を使用すると警告が表示されます。

     : flip ( -- )
      6 . ; compile-only \ but not immediate
     flip

     : flop ( -- )
      flip ;
     flop

   この例では、 最初に ‘flip’ のインタープリター機能を使用します(警告が
表示されます)。 ‘flip’ の 2 番目の使用では、 コンパイル機能を使用します
(警告は表示されません)。 この例では、 compile-only が実行時(run-time)で
はなくテキスト・インタープリター時に評価される属性であることもわかります
。

   テキスト・インタープリターには 2 つの状態があります。 インタープリタ
ー・モード(interpret)は、 遭遇したワードのインタープリター機能
(interpretation semantics)を実行します。 コンパイル・モードでは、 これら
のワードのコンパイル機能(compilation semantics)が実行されます。

   特に、 ‘:’ はコンパイル状態に切り替え、 ‘;’ はインタープリター状態に
戻します。 これらには、 状態を切り替えるだけの効果である ‘]’ (コンパイル
状態に切り替える) と ‘[’ (インタープリター状態に切り替える) が含まれてい
ます。

     : xxx ( -- )
       [ 5 . ]
     ;

     xxx
     see xxx

   これらの角括弧(brackets)は、 上記の命名慣習の源でもあります。

   こちらも参照ください: *note Interpretation and Compilation
Semantics::


File: gforth.info,  Node: Execution Tokens Tutorial,  Next: Exceptions Tutorial,  Prev: Interpretation and Compilation Semantics and Immediacy Tutorial,  Up: Tutorial

3.29 Execution Tokens
=====================

‘' word’ は、 ワードの実行トークン(execution token)(XT)を提供します。 XT
は、 ワードのインタープリター機能(interpretation semantics)表すセルです
。 これは ‘execute’ で実行できます:

     ' + .s
     1 2 rot execute .

   XT は C の関数ポインターに似ています。 ただし、 パラメータがスタック
で渡されるため、もう少し柔軟になります:

     : map-array ( ... addr u xt -- ... )
     \ addr で始まり u 個の要素を含む配列のすべての要素に対して
     \ xt ( ... x -- ... ) を実行します
       { xt }
       cells over + swap ?do
         i @ xt execute
       1 cells +loop ;

     create a 3 , 4 , 2 , -1 , 4 ,
     a 5 ' . map-array .s
     0 a 5 ' + map-array .

     s" max-n" environment? drop .s \ 下記比較初期値用に整数最大値を得る
     a 5 ' min map-array . \ 最初の要素は、 environment? で取得した整数最大値と比較

   生成するより消費する要素が 1 つ多いワードの XT に対して map-array を
使用できます。 理論的には、他の XT でも使用できますが、 スタック効果は配
列のサイズに依存するため、理解するのが困難です。

   XT はセルサイズであるため、 メモリに保存し、 他のセルと同様にスタック
上で操作できます。 ‘compile,’ を使用して XT をワードにコンパイルすること
もできます:

     : foo1 ( n1 n2 -- n )
        [ ' + compile, ] ;
     see foo1

   ‘compile,’ は標準ではコンパイル機能(compilation semantics)がないため
、 上記は標準ではないけれども、 良い Forth システムでは動作します。 うま
くいかなかったモノついては、 以下を使用してください

     : [compile,] compile, ; immediate

     : foo1 ( n1 n2 -- n )
        [ ' + ] [compile,] ;
     see foo1

   ‘'’ は、 デフォルトでコンパイル機能(compilation semantics)を持つワー
ドです。 そのワードのインタープリター機能(interpretation semantics)を実
行すると、 その次のワードを構文解析(parse)します。

     : foo ( -- xt )
       ' ;
     see foo
     : bar ( ... "word" -- ... )
       ' execute ;
     see bar
     1 2 bar + .

   コンパイル中にワードを解析(parse)し、 その XT をコンパイルして、 実行
時にスタックにプッシュされるようにしたいことがよくあります。 ‘[']’ はこ
れを行います:

     : xt-+ ( -- xt )
       ['] + ;
     see xt-+
     1 2 xt-+ execute .

   多くのプログラマーは、 ‘'’ とそれが解析(parse)するワードを 1 つの単位
として認識し、 コンパイル時に ‘[']’ のように動作することを期待し、 実際
の動作に混乱する傾向があります。 あなたがもしそうなら、 Forth システムは
‘'’ を 1 つの単位として捉えているだけであり、 それが解析(parse)ワードで
あるとはまったく考えていないことを覚えておいてください(この問題でプログ
ラマーの便宜を図る試みは、 通常、 さらにひどい落とし穴につながります。
‘State’-smartness—Why it is evil and How to Exorcise it
(https://www.complang.tuwien.ac.at/papers/ertl98.ps.gz))。

   XT の作成および実行は、 インタープリターの状態には影響を受けないこと
に注意してください。 つまり、 コンパイル状態で ‘'’ を実行した場合でも、
インタープリター機能(interpretation semantics)が得られます。 そして、 そ
こでの状態が何であれ、 ‘execute’ は XT によって表されるコード(つまり、
‘'’ で生成された XT の場合はインタープリター機能(interpretation
semantics))を実行します。

   こちらも参照ください: *note Tokens for Words::


File: gforth.info,  Node: Exceptions Tutorial,  Next: Defining Words Tutorial,  Prev: Execution Tokens Tutorial,  Up: Tutorial

3.30 Exceptions
===============

‘throw ( n -- )’ は、 n がゼロでない限り例外を引き起こします。

     100 throw .s
     0 throw .s

   ‘catch ( ... xt -- ... n )’ は ‘execute’ と同様に動作しますが、 例外
をキャッチし、 スタック上に例外の数値(または XT が例外なしで実行された場
合は 0)をプッシュします。 例外があった場合、 スタックの深さは ‘catch’ の
実行直前と同一です。

     .s
     3 0 ' / catch .s
     3 2 ' / catch .s

     研究課題(assignment): ‘catch’ の代わりに ‘execute’ を使用して同じこ
     とを試してみましょう。

   ‘throw’ は、常に動的に直近にこの ‘throw’ を囲んでいる(定義の) ‘catch’
にジャンプします、 たとえそのジャンプを達成するために複数の呼び出しレベ
ルを飛び越す必要がある場合でもです:

     : foo 100 throw ;
     : foo1 foo ." after foo" ;
     : bar ['] foo1 catch ;
     bar .

   多くの場合、 定義が例外によって終了した場合でも、 定義を終了したとき
に値を復元することが重要です。 以下のようにしてみるのはどうでしょうか:

     : ...
        save-x
        ['] word-changing-x catch ( ... n )
        restore-x
        ( ... n ) throw ;

   しかし、 これでも、 たとえば、‘catch’ と ‘restore-x’ の間を実行中にユ
ーザーが ‘Ctrl-C’ を押すなどしたら安全ではありません。

   Gforth は、そのような場合に対して安全な代替例外処理構文(alternative
exception handling syntax) ‘try ...restore ... endtry’ を提供します。
‘try’ と ‘endtry’ の間のコードに例外があった場合、 スタックの深さが復元
され、 例外数値がスタックにプッシュされ、 ‘restore’ の直後から実行が続行
されます。

   以下は、 上記のコードと同等の、 より安全なコードです

     : ...
       save-x
       try
         word-changing-x 0
       restore
         restore-x
       endtry
       throw ;

   こちらも参照ください: *note Exception Handling::


File: gforth.info,  Node: Defining Words Tutorial,  Next: Arrays and Records Tutorial,  Prev: Exceptions Tutorial,  Up: Tutorial

3.31 Defining Words
===================

これまでに出てきた ‘:’ や ‘create’ や ‘variable’ は定義ワードです。 これ
らは他のワードを定義します。 ‘Constant’ はもう一つの定義ワードです:

     5 constant foo
     foo .

   ‘variable’ や ‘constant’ でも接頭辞 ‘2’ (2倍長セル) や ‘f’ (浮動小数
点) を使用することができます。

   あなた独自の定義ワードを定義することもできます。 例:

     : variable ( "name" -- )
       create 0 , ;

   また、 単にアドレスを生成する以外のことを行うワードを作成する定義ワー
ドを定義することもできます:

     : constant ( n "name" -- )
       create ,
     does> ( -- n )
       ( addr ) @ ;

     5 constant foo
     foo .

   上記の ‘constant’ の定義は ‘does>’ で終了します。 つまり、 ‘does>’ は
‘;’ を置き換えるのですが、 他のことも行います。 最後に定義されたワードを
変更して、 ワード本体(body)のアドレスをプッシュし、 呼び出されるたびに
‘does>’ の後のコードを実行します。

   上の例では、 ‘constant’ は ‘,’ を使用して ‘foo’ の本体に 5 を格納しま
す。 ‘foo’ が実行されると、 本体のアドレスがスタックにプッシュされ、
(‘does>’ の後のコードにより、)そこから 5 がフェッチされます。

   ‘does>’ の脇のスタック・コメントは、 ‘does>’ の後のコードのスタック効
果ではなく、 定義されたワードのスタック効果です(違いは、 ‘does>’ の後の
コードは ‘does>’ の脇のスタック・コメントには書いてない、 ワード本体
(body)のアドレスを期待している点です)。

   これらの定義ワードを使用すると、 (他の)定義ワードが関係する場合にファ
クタリングを行うことができます。 たとえば、 フィールド・オフセットは常に
アドレスに加算するものですが、 その代わりに以下を定義します

     2 cells constant offset-field1

   この offset-field1 は以下のように使います

     ( addr ) offset-field1 +

   ここで、 あなたは以下のような定義ワードをを定義できます

     : simple-field ( n "name" -- )
       create ,
     does> ( n1 -- n1+n )
       ( addr ) @ + ;

   フィールド・オフセットの定義と使用は以下のようになります:

     2 cells simple-field field1
     create mystruct 4 cells allot
     mystruct .s field1 .s drop

   ‘does>’ の後のコードを実行せずに、 そのワードで何かをしたい場合は、
‘>body ( xt -- addr )’ を使用すれば ‘create’ したワードの本体(body)にア
クセスできます:

     : value ( n "name" -- )
       create ,
     does> ( -- n1 )
       @ ;
     : to ( n "name" -- )
       ' >body ! ;

     5 value foo
     foo .
     7 to foo
     foo .

     研究課題(assignment): (‘abort’ の XT の先頭に、) XT を格納するワー
     ドを作成する、 ‘defer ( "name" -- )’ を定義し、 実行時に XT を
     ‘execute’ で実行するようにしてみましょう。 間接再帰は ‘defer’ の応
     用の 1 つです。

   こちらも参照ください: *note User-defined Defining Words::


File: gforth.info,  Node: Arrays and Records Tutorial,  Next: POSTPONE Tutorial,  Prev: Defining Words Tutorial,  Up: Tutorial

3.32 Arrays and Records
=======================

Forth には配列を定義するための標準ワードはありませんが、 アドレス演算に
基づいて自分で配列を構築できます。 配列とレコードを定義するためのワード
を定義することもできます(*note Defining Words: Defining Words
Tutorial.)。

   Forth の初心者がワードの定義について学ぶときに最初に着手するプロジェ
クトの 1 つが配列定義ワード(ことによっては n 次元配列)です。 さぁあなた
もやってみましょう。 あなたはそこから何かを学ぶでしょう。 ただし、 後か
らこれらのワードをほとんど使用しないことがわかってもがっかりしないでくだ
さい(不適切に使用するとさらに悪いことになります)。 著者はまだ有用な配列
ワードのセットを見つけられていません。 ニーズがあまりにも多様で、 (定義
ワードを単純に使用した結果である、)名前付きのグローバル配列は、 柔軟性が
十分ではないことがよくあります(たとえば、 どのようにしてパラメーターを渡
すか、など)。 同様のプロジェクトのもう 1 つは、 文字列の処理に役立つワー
ドのセットです。

   その一方、 レコード・ワードには便利なセットがあり、
‘compat/struct.fs’ で定義されています。 これらのワードは Gforth で事前定
義されています。 これらについては、 このマニュアルの他の場所で詳しく説明
されています(*note Structures:: 参照)。 上記の ‘simple-field’ の例は、 こ
のパッケージのフィールドの簡略化されたバリエーションです。


File: gforth.info,  Node: POSTPONE Tutorial,  Next: Literal Tutorial,  Prev: Arrays and Records Tutorial,  Up: Tutorial

3.33 ‘POSTPONE’
===============

‘POSTPONE’ (訳注: (期限が定まってる)延期)を使用すると、 (そのワードのイ
ンタプリタ機能(interpretation semantics)をコンパイルする代わりに、) その
ワードのコンパイル機能(compilation semantics)をコンパイルできます:

     : MY-+ ( Compilation: -- ; Run-time of compiled code: n1 n2 -- n )
      POSTPONE + ; immediate
     : foo ( n1 n2 -- n )
      MY-+ ;
     1 2 foo .
     see foo

   ‘foo’ の定義中に、 テキスト・インタープリターは ‘MY-+’ のコンパイル機
能(compilation semantics)を実行し、 そのコンパイル機能が ‘+’ のコンパイ
ル機能を実行します。 つまり、 ‘+’ を ‘foo’ 内にコンパイルします。

   この例では、 コンパイル機能(compilation semantics)とコンパイルされた
コードのスタック効果について個別のスタック・コメントも表示します。 デフ
ォルトのコンパイル機能を持つワードの場合、 通常、 これらのスタック効果は
表示されません。 これらのワードのコンパイル機能のスタック効果は常に ‘(
-- )’ であり、 コンパイルされたコードのスタック効果はインタープリター機
能(interpretation semantics)のスタック効果です。

   注意: この方法でコンパイル機能(compilation semantics)を実行する場合、
インタプリタの状態には影響を受けないことに注意してください。 あなたはそ
れを対話的(interpretively)に実行することもできます。 例:

     : foo2 ( n1 n2 -- n )
      [ MY-+ ] ;
     1 2 foo2 .
     see foo2

   ただし、 これが常に機能するとは限らない、良くない Forth システムがい
くつかあるため、 この方法は 1999 年に非標準となりました。

   ‘POSTPONE’ を使用する別の例を以下に示します:

     : MY-- ( Compilation: -- ; Run-time of compiled code: n1 n2 -- n )
      POSTPONE negate POSTPONE + ; immediate compile-only
     : bar ( n1 n2 -- n )
       MY-- ;
     2 1 bar .
     see bar

   ‘ENDIF’ は以下の方法で定義できます:

     : ENDIF ( Compilation: orig -- )
       POSTPONE then ; immediate

     研究課題(assignment): ‘2dup’ と同等のコンパイル機能(compilation
     semantics)を持つ ‘MY-2DUP’ を作成しますが、 コンパイルされるのは
     ‘over over’ になるようにしてみましょう。


File: gforth.info,  Node: Literal Tutorial,  Next: Advanced macros Tutorial,  Prev: POSTPONE Tutorial,  Up: Tutorial

3.34 ‘Literal’
==============

数値を ‘POSTPONE’ することはできません:

     : [FOO] POSTPONE 500 ; immediate

   代わりに ‘LITERAL (compilation: n --; run-time: -- n )’ を使用します:

     : [FOO] ( compilation: --; run-time: -- n )
       500 POSTPONE literal ; immediate

     : flip [FOO] ;
     flip .
     see flip

   ‘LITERAL’ は、 コンパイル時(コンパイル機能(compilation semantics)が実
行される時)に数値を消費し、 実行時(コンパイルされたコードが実行されると
き)にそれをプッシュします。 ‘LITERAL’ のよくある使用法は、 コンパイル時
に計算された数値を現在のワードにコンパイルすることです:

     : bar ( -- n )
       [ 2 2 + ] literal ;
     see bar

     研究課題(assignment): 上記の例を ‘: bar ( -- n ) [ 2 2 + ]L ;’ と記
     述できるような ‘]L’ を定義してみましょう。


File: gforth.info,  Node: Advanced macros Tutorial,  Next: Compilation Tokens Tutorial,  Prev: Literal Tutorial,  Up: Tutorial

3.35 Advanced macros
====================

*note Execution Tokens: Execution Tokens Tutorial. の ‘map-array’ につい
て再検討してみましょう。 ‘map-array’ は ‘execute’ を頻繁に実行しますが、
これは一部の Forth 実装では比較的高価な操作です。 ‘compile,’ と
‘POSTPONE’ を使用すると、 これらの ‘execute’ を削除し、 直接実行されるワ
ードを含むワードを生成できます:

     : compile-map-array ( compilation: xt -- ; run-time: ... addr u -- ... )
     \ at run-time, execute xt ( ... x -- ... ) for each element of the
     \ array beginning at addr and containing u elements
       { xt }
       POSTPONE cells POSTPONE over POSTPONE + POSTPONE swap POSTPONE ?do
         POSTPONE i POSTPONE @ xt compile,
       1 cells POSTPONE literal POSTPONE +loop ;

     : sum-array ( addr u -- n )
      0 rot rot [ ' + compile-map-array ] ;
     see sum-array
     a 5 sum-array .

   コードの生成には Forth の機能を最大限に活用できます。 以下に、 コード
がループ内で生成される例を示します:

     : compile-vmul-step ( compilation: n --; run-time: n1 addr1 -- n2 addr2 )
     \ n2=n1+(addr1)*n, addr2=addr1+cell
       POSTPONE tuck POSTPONE @
       POSTPONE literal POSTPONE * POSTPONE +
       POSTPONE swap POSTPONE cell+ ;

     : compile-vmul ( compilation: addr1 u -- ; run-time: addr2 -- n )
     \ n=v1*v2 (inner product), where the v_i are represented as addr_i u
       0 postpone literal postpone swap
       [ ' compile-vmul-step compile-map-array ]
       postpone drop ;
     see compile-vmul

     : a-vmul ( addr -- n )
     \ n=a*v, where v is a vector that's as long as a and starts at addr
      [ a 5 compile-vmul ] ;
     see a-vmul
     a a-vmul .

   この例では ‘compile-map-array’ を使用していますが、 代わりに
‘map-array’ を使用することもできます(是非試してみてください)。

   この手法を使用すると、 巨大な行列を効率的に乗算できます。 行列の乗算
では、 一方の行列のすべての行ともう一方の行列のすべての列を乗算します。
1 行のコードを 1 回生成し、 それをすべての列に使用できます。 この手法の
唯一の欠点は、 生成されたコードによって消費されたメモリを完了時に開放す
るのが面倒なことです(さらに複雑な場合は移植可能ではありません)。


File: gforth.info,  Node: Compilation Tokens Tutorial,  Next: Wordlists and Search Order Tutorial,  Prev: Advanced macros Tutorial,  Up: Tutorial

3.36 Compilation Tokens
=======================

このセクションは Gforth 固有です。 スキップしても構いません。

   ‘' word compile,’ はインタープリター機能(interpretation semantics)を
コンパイルします。 デフォルトのコンパイル機能(compilation semantics)を持
つワードの場合、 これはコンパイル機能を実行するのと同じです。 他のワード
のコンパイル機能(インタープリター機能を持たない ‘if’ などのワード)を表す
ために、 Gforth にはコンパイル・トークン(CTと略します。 2つのセルで構成
)と、 ワード ‘comp'’ と、 ワード ‘[comp']’ の概念があります。 ‘execute’
を使用して、 CT によって表されるコンパイル機能を実行できます:

     : foo2 ( n1 n2 -- n )
        [ comp' + execute ] ;
     see foo2

   ‘postpone,’ を使用して、 CT によって表されるコンパイル機能をコンパイ
ルできます:

     : foo3 ( -- )
       [ comp' + postpone, ] ;
     see foo3

   ‘[ comp' word postpone, ]’ ‘POSTPONE word’ と同等です。 ‘comp'’ は、
インタープリター・モード用のコードを持たないワードに対して特に役立ちます
:

     ' if
     comp' if .s 2drop

   こちらも参照ください: *note Tokens for Words::


File: gforth.info,  Node: Wordlists and Search Order Tutorial,  Prev: Compilation Tokens Tutorial,  Up: Tutorial

3.37 Wordlists and Search Order
===============================

ディクショナリ(辞書)は、 ‘allot’ でメモリを割り当てることができる、 単な
るメモリ領域ではなく、 複数のワード・リスト(wordlist)上にある Forth ワー
ド達も含まれています。 ワード・リスト内のワードを検索するとき、 概念的に
は、 最も新しいワードから検索を開始し、 古いワードに向かって進みます(実
際には、 最近のほとんどのシステムはハッシュ・テーブルを使用します)。 つ
まり、 古いワードと同一の名前のワードを定義すると、 新しいワードが古いワ
ードを隠します。

   どのワードリストがどの順序で検索されるかは、 検索順序スタック(the
search order)によって決まります。 ‘order’ で検索順序を表示できます。 最
初に検索されるワードリストから順に検索順序を表示し、 その次に、 新しく定
義されるワードを含むワードリストを表示します。

   ‘wordlist ( -- wid )’ を使用して、 新しい空のワード・リスト
(wordlist)を作成できます:

     wordlist constant mywords

   ‘Set-current ( wid -- )’ は、 新しく定義されたワードを入れるワード・
リストを設定します(the current wordlist):

     mywords set-current
     order

   このワード・リストは ‘wordlist’ を使用して匿名で作成されたため、
Gforth は ‘mywords’ のワード・リスト名を表示しません。

   ‘get-current ( -- wid)’ で現在のワード・リストを取得できます。 現在の
ワード・リストに影響を与えずに、 指定のワード・リストに何かを入れたい場
合、 通常は以下のようにします:

     get-current mywords set-current ( wid )
     create someword
     ( wid ) set-current

   検索順序スタック(the search order)は ‘set-order ( wid1 .. widn n --
)’ で記述し、 ‘get-order ( -- wid1 .. widn n )’ で読み取ることができます
。 ( n を除いて) もっとも TOS 側のワード・リストが最初に検索されます。

     get-order mywords swap 1+ set-order
     order

   ええ、 ‘order’ の出力内のワードリストの順序は、 スタック・コメントや
‘.s’ の出力とは逆になっているため、 直感的ではありません。

     研究課題(assignment): ‘>order ( wid -- )’ を定義して、 最初に検索さ
     れるワード・リスト(wordlist)として ‘wid’ を検索順序スタック(the
     search order)に追加してみましょう。 ‘previous ( -- )’ を定義してみ
     ましょう。 これは、 最初に検索されたワードリスト(wordlist)を検索順
     序スタックから削除するものです。 定義したら、 境界条件を試してみま
     しょう(クラッシュや、 そこから抜け出すことが困難または不可能な状況
     がいくつか見られる事でしょう)。

   検索順序スタック(the search order)は、 Modula-2 モジュールや、 C++ の
名前空間と同様の機能を提供するための強力な基盤です。 ただし、 この方法で
プログラムをモジュール化しようとすると、 デバッグや 再利用/ファクタリン
グ に関しては、 (大規模なプロジェクトの経験はありませんけれども、)著者の
経験では利点を上回る欠点があります。 他の言語/プログラミング環境では、 デ
バッグや再利用がそれほど強力ではないため、 これらの欠点はそれほど目立ち
ません。

   こしらも参照ください: *note Word Lists::


File: gforth.info,  Node: Introduction,  Next: Literals in source code,  Prev: Tutorial,  Up: Top

4 An Introduction to Standard Forth
***********************************

この章とチュートリアル(*note Tutorial::)との違いは、 急ぎ足のチュートリ
アルと違ってじっくり腰を据えて、 チュートリアルではカバーしきれていない
、 Forth の内部を詳しく説明していることです。 それはさておき、 この章で
取り上げる内容はチュートリアルに比べはるかに少ないので、 パソコンを使わ
ずに読むのに適しています。

   このマニュアルの主な目的は、 Gforth を文書化することです。 ただし、
Forth は広く知られている言語ではなく、 最新の教材が不足しているため、 入
門用の教材を提供する価値があると思われます。 巷の Forth 関連情報その他の
情報源については *note Forth-related information:: を参照下さい。

   このセクションの例は、 どの標準 Forth でも動作するはずです。 示されて
いる出力は Gforth を使用して生成されました。 各例では、 Gforth が生成す
る正確な出力を再現しようとしています。 あなたが例を試してみれば(そして、
あなたはそうするべきです)、 入力すべき内容は ‘like this’ と示され、
Gforth の応答は ‘like this’ で示されます。 唯一の例外は、 例で <RET> が
示されている場合、 これは「Enter」キー(機種によりReturnキー)を押す必要が
あることを意味します。 残念ながら、 このマニュアルの一部の出力形式では
‘this’ と ‘this’ の違いを表示できないため、 例を試してみるのが困難かもし
れません(ただし、 不可能ではありません)。

   Forth は珍しい言語です。 インタープリターとコンパイラーの両方を含む対
話型開発環境を提供します。 Forth のプログラミング・スタイルでは、 問題を
いくつかの要素に分割することが推奨されます 小さな断片を作成し(ファクタリ
ング)、 各断片を対話的に開発・テストします。 Forth の支持者は、 従来のプ
ログラミング言語で使用されている編集・コンパイル・テストのサイクルを打ち
破ることで、 生産性の大幅な向上につながる可能性があると主張しています。

* Menu:

* Introducing the Text Interpreter::
* Stacks and Postfix notation::
* Your first definition::
* How does that work?::
* Forth is written in Forth::
* Review - elements of a Forth system::
* Where to go next::
* Exercises::


File: gforth.info,  Node: Introducing the Text Interpreter,  Next: Stacks and Postfix notation,  Prev: Introduction,  Up: Introduction

4.1 Introducing the Text Interpreter
====================================

Forth イメージを呼び出すと、 起動バナーが出力されますが、 他には何も表示
されません (システムに Gforth がインストールされている場合は、
‘gforth<RET>’ と入力して今すぐ呼び出してみてください)。 今、 Forth は、
テキスト・インタープリター(Text Interpreter)と呼ばれるコマンド・ライン・
インタプリタを実行しています(外部インタープリターとも呼ばれます;訳注: 別
途存在する 内部インタープリター(inner interpreter)に対してこう呼ばれる
)。 (この章を読み進ればテキスト・インタープリターについて多くのことを学
ぶことができます。 詳細については *note The Text Interpreter:: を参照し
てください)。

   明白ではなくて分かりにくいですが、 今や Forth はユーザーの入力を待っ
ています。 数字の 4 と 5 を入力し <RET> キーを押します:

     45<RET>  ok

   テキスト・インタープリターは、 次の入力を促すプロンプトを表示するので
はなく、 入力行を処理した後に(改行無しで)ステータス・メッセージを出力し
ます。 この場合のステータス・メッセージ(<RET> (「エンター」(リターン)キ
ー押下)の後の ‘ ok’ )は、 テキスト・インタープリターがすべての入力を正常
に処理できたことを示します。 それでは次に、 不正な文字列を入力してみまし
ょう:

     qwer341<RET>
     *the terminal*:2: Undefined word
     >>>qwer341<<<
     Backtrace:
     $2A95B42A20 throw
     $2A95B57FB8 no.extensions

   ‘Undefined word‘ 以外の文章はシステムによって若干異なる場合があります
が、 意味は同じです。 テキスト・インタープリターがエラーを検出すると、 行
に残っているテキストを破棄し、 特定の内部状態をリセットして、 エラー・メ
ッセージを出力します。 エラー・メッセージの詳細な説明については、 *note
Error messages:: を参照してください。

   テキスト・インタープリターは、エンター・キー(リターン・キー)が押され
るのを待ち、 その後入力行を処理します。 行頭から開始して、 行をスペース
で区切られた文字のグループに分割します。 文字のグループごとに、 以下の順
番で、 何かするために計 2 回の試みを行います:

   • その文字のグループをコマンドとして扱おうとします。 これは、 名前デ
     ィクショナリ(name dictionary)を検索することによって行われます。 そ
     の文字のグループが名前ディクショナリのエントリと一致する場合、 名前
     ディクショナリは、 いくつかのアクションを実行できるようにする情報を
     テキスト・インタープリターに提供します。 Forth 流に言うと、文字のグ
     ループを「ワードの名前」といい、 ディクショナリ検索でワードの定義
     (definition)に対応する実行トークン(execution token;xt)が返され、 テ
     キスト・インタープリターは xt を実行します。 多くの場合、「ワード」
     (word)と「定義」(definition)という用語は同じ意味で使用されます。
   • テキスト・インタープリターが名前ディクショナリ内で一致するものを見
     つけられなかった場合、 文字のグループを現在の基数の数値として処理し
     ようとします(Forth を起動したときの、 現在の基数は 10 です)。 文字
     のグループが正当な数値を表す場合、 テキスト・インタープリターはその
     数値をスタックにプッシュします(これについては次のセクションで詳しく
     説明します)。

   テキスト・インタープリターが文字グループに対して上記のいずれも実行不
可能な場合、 その文字グループと行の残りの部分が破棄され、 エラー・メッセ
ージが出力されます。 テキスト・インタープリターがエラーなく行末に到達す
ると、 ステータス・メッセージ ‘ ok’ に続いて改行を出力します。

   以下は、 テキスト・インタープリターに与えることができる最もシンプルな
コマンドです:

     <RET>  ok

   ここで、 テキスト・インタープリターは、 私たちが要求したことをすべて
(何もせずに)エラーなしで実行したため、 すべてが ‘ ok’ であると表示しまし
た。 今度は少し長いコマンドを試して見ましょう:

     12 dup fred dup<RET>
     *the terminal*:3: Undefined word
     12 dup >>>fred<<< dup
     Backtrace:
     $2A95B42A20 throw
     $2A95B57FB8 no.extensions

   エンター・キー(リターン・キー)を押すと、 テキスト・インタープリターが
行に沿って動作を開始します:

   • ‘2’ の後のスペースに到達すると、 文字グループ ‘12’ を取得し、 それ
     らを名前ディクショナリで検索します(1)。 名前ディクショナリにはこの
     文字グループに一致するものがないため、それらを数値として処理しよう
     とし、 そして、 数値として処理するのは正常に実行できたので、 (それ
     が何を意味するにせよ) 数値 12 を「スタック上」に置きます。
   • テキスト・インタープリターは行のスキャンを再開し、 次の文字グループ
     ‘dup‘ を取得します。 ‘dup‘ を名前ディクショナリで探し、 (これは著者
     の言葉を信じてもらうしかありませんが) ‘dup‘ を名前ディクショナリで
     見付けて、 ワード ‘dup’ を実行します(それが何を意味していても)。
   • 更に再び、 テキスト・インタープリターは行のスキャンを再開し、 文字
     グループ ‘fred’ を取得します。 名前ディクショナリで調べますが、見つ
     かりません。 それらを数値として扱おうとしますが、 正当な数値を表す
     ものではありませんでした。

   この時点で、 テキスト・インタープリターは諦めてエラー・メッセージを出
力します。 エラー・メッセージには、 テキスト・インタープリターが行の処理
でどこまで到達したかが正確に示されます。 これは、 特に、 テキスト・イン
タープリターが最後の文字グループ ‘dup’ に対して何も行おうとしなかったこ
とを示しています。 テキスト・インタプリタがそのワード ‘dup’ を検索して、
一度はちゃんと実行されたのですから、 もう一度実行することに何の問題はな
いはずなのに、 です。

   ---------- Footnotes ----------

   (1) 見つかったかどうかはわかりませんが、いまのところ、 見つからなかっ
たと仮定します。 訳注: 12 というワードを定義することもでき、その場合はワ
ード 12 の方が数値 12 より優先される


File: gforth.info,  Node: Stacks and Postfix notation,  Next: Your first definition,  Prev: Introducing the Text Interpreter,  Up: Introduction

4.2 Stacks, postfix notation and parameter passing
==================================================

手続き型プログラミング言語(C や Pascal など)では、 プログラムの構成要素
は関数(function)やプロシージャ(procedure)です。 これらの関数またはプロシ
ージャは、 明示的なパラメータを使用して呼び出されます。 たとえば、 C で
は以下のように記述できます:

     total = total + new_volume(length,height,depth);

ここで、 new_volume は別のコード片への関数呼び出し(function-call)であり
、 total, length, height, depth はすべて変数です。 length, height, depth
は関数呼び出しのパラメータです。

   Forth では、 関数またはプロシージャに相当するのは「定義」
(definition)であり、 パラメータはプログラマから見える共有スタックを使用
して定義間で暗黙的に渡されます。 Forth は変数をサポートしていますが、 ス
タックの存在は、 他のほとんどのプログラミング言語よりも変数が使用される
頻度がはるかに低いことを意味します。 テキスト・インタープリターは数値を
検出すると、 それをスタックに置きます(プッシュ)。 何種類かのスタックがあ
り(いくつあるかは実装依存です)、 操作に使用されるスタックは、 実行される
操作によって明確に示されます。 すべての整数演算に使用されるスタックは「
データ・スタック」と呼ばれ、 これが最も一般的に使用されるスタックである
ため、 「データ・スタック」への参照は多くの場合「スタック」と省略されま
す。

   スタックには後入れ先出し(last-in, first-out;LIFO)構成が採用されていま
す。 以下のように打ち込むと:

     1 2 3<RET>  ok
   これはテキスト・インタープリターに 3 つの数値を (データ)スタック に配
置するように指示します。 スタックの振る舞いはトランプの扱いに例えられま
す。 トランプの箱から、 (スートは何でもいいですが、) エース(1)のカードと
2のカードと3のカードをテーブルの上の山に配ります。 3のカードは山の最後の
カード (last-in)であり、 山からカードを 1 枚取ると、 あなたがシャッフル
とか何もいじってない限り、 取り出すカードは 3のカードになります
(first-out)。 スタックから最初に取り出されるであろう(スタック上の)数値は
スタック頂上(スタック・トップ;top of stack)と呼ばれ、 多くの場合「TOS」
と省略されます。

   Forth でパラメーターがどのように渡されるかを理解するために、 定義 ‘+’
(「プラス」と発音します) の振る舞いを見てみましょう。 あなたは、 この定
義が加算を実行することを知っても驚かないでしょう。 より正確には、 これは
2 つの数値を加算して結果を生成します。 さて、 その 2 つの数値はどこから
取得されるのでしょうか？ これはスタック頂上から上位 2 つの数値を取り除き
ます。 その結果はどこに配置されるのでしょうか？ それはスタックです。 あ
なたは以下のように、 トランプを使って ‘+’ の振る舞いを演ずることができま
す。

   • テーブル上の山(the steck)カードを 2 枚取り出します
   • あなたは、 それらをじっと見つめて、 「これら 2 つの数字の合計は何で
     あるか」を自問してください。
   • 答えは 5 であると判明しました
   • 2 枚のカードをシャッフルしてトランプの箱に戻し、 トランプの箱の中か
     ら 5のカード を見つけます
   • テーブル上にある残りのエース(1)のカードの上に 5のカードを置きます。

   トランプの箱はないですが、 Forth の実行中は、 定義 ‘.s’ を使用して、
スタックに影響を与えることなく、 スタックの現在の状態を表示できます。 以
下の様に打ち込みます:

     clearstacks 1 2 3<RET> ok
     .s<RET> <3> 1 2 3  ok

   テキスト・インタープリターはワード ‘clearstacks’ を検索して実行します
。 スタック(データおよび浮動小数点スタック)を整理し、 以前の例の実行によ
ってスタックに残された可能性のあるエントリをすべて削除します。 続けてテ
キスト・インタプリタは、 3 つの数値をそれぞれ順番にスタックにプッシュし
ます。 最後に、 テキスト・インタープリターはワード ‘.s’ を検索して実行し
ます。 ‘.s’ を実行すると、「<3>」 (スタック上の項目の合計数) に続いて、
スタック上のすべての項目のリストが出力されます。 一番右側の項目が TOS で
す。

   あなたは今や以下のように打ち込めます:

     + .s<RET> <2> 1 5  ok

現在スタックには 2 つの項目があり、 (そのうちの項目の1つである)加算の結
果は 5 となっていれば正解です。

   あなたが引き続きトランプで遊んでいるなら、 この結果に対して 2 回目の
足し算を行ってみましょう。 2 枚のカードを手に取り、 その合計が 6 である
ことを計算し、手に取った2枚のカードをシャッフルして箱に入れ、 箱から 6の
カード を探してテーブルに置きます。 これで、 スタックにはアイテムが 1 つ
だけになりました。 あなたが 3 回目の足し算を実行しようとするとどうなるで
しょうか？ あなたは、 1枚目のカードを手に取り、 2枚目のカードを手に取ろ
うとします – ああ!  でも 2枚目のカードはありません。 これは「スタック・
アンダーフロー」と呼ばれ、エラーとなります。 Forth で同じことを行おうと
すると、 多くの場合、 エラーが報告されます(おそらく、 スタック・アンダー
フロー(Stack Underflow)エラー、 または、 無効なメモリアクセス(Invalid
Memory Address)エラー)。

   スタック・アンダーフローの逆の状況が「スタック・オーバーフロー」です
。 これは、 あなたがたが、 スタック用に予約されている有限量のストレージ
・スペースがあることを単に受け入れるだけで済みます。 トランプの例えを拡
張すると、 沢山の数のトランプのカードがあり、 それらのカードをテーブルに
積み上げた場合、 天井にぶつかってしまい、 最終的には別のカードを追加でき
なくなります。 Gforth を使用すると、 スタックの最大サイズを設定できます
。 一般に、 スタック・オーバーフローが発生するのは、 定義にバグがあり、
制御不能にスタック上にデータを生成している場合のみです。

   トランプの例えには、 最後にもう 1 つ適用例があります。 トランプを使用
してスタックをモデル化した場合、 スタック上のアイテムの最大数は 52 にな
ります(ジョーカーを使用しなかったと仮定して)。 スタック上のアイテムの最
大値は13(キング)です。 実際は、 使用できる数値は 1 ～ 13 の正の整数のみ
(つまり、 13個の数)です。 (たとえば) 0や27や3.52や-2は使用できません。 そ
こで、 一部のカードについて考え方を変え、 さまざまな数値に対応できるよう
にします。 たとえば、ジャックは 0 を表し、 クイーンは -1 を表し、 キング
は -2 を表すと見なします。 すると、 表現できる数値の幅は変更されません
(合計 13 個の数値のみを表すことができます)が、 -2 から 10 の数値を表す事
ができるようになりました。

   この例えでは、 制限は 1 つのスタック・エントリが保持できる情報の量で
あり、 Forth にも同様の制限があります。 Forth では、 スタック・エントリ
のサイズは「セル」(cell)と呼ばれます。 セルの実際のサイズは実装に依存し
、 スタック・エントリが保持できる最大値に影響します。 標準 Forth は少な
くとも 16 ビットのセル・サイズを提供し、 ほとんどのデスクトップ・システ
ムは 32 ビットのセル・サイズを使用します。

   Forth は型チェックを一切行わないため、 スタック項目を自由に操作したり
組み合わせたりできます。 スタック項目を 2 の補数の符号付き整数として扱う
便利な方法は、 ‘+’ などの標準ワードもやっています。 それゆえ、 以下のよ
うに入力できます:

     -5 12 + .s<RET> <1> 7  ok

   あなたが、 Forth を電卓にするために、 数値や ‘+’ のような定義を使用す
ると、 それが通常の電卓とはかなり異なることがわかるでしょう。 あなたは 2
+ 3 = と入力するのではなく、 2 3 + と入力する必要があります(ここでは、 結
果を確認するには ‘.s’ を使用する必要があるという事実は無視してください
)。 この違いを説明するために使用される用語は、 電卓は「中置記法」(Infix
Notation;パラメーターと演算子が混合されている)を使用するのに対し、 Forth
は「後置記法」(Postfix Notation;パラメーターと演算子が分かれている)、 ま
たの名を「逆ポーランド記法」(Reverse Polish Notation)と呼ばれるものを使
用します。

   後置記法は最初はわかりにくいように見えるかもしれませんが、 いくつかの
重要な利点があります:

   • 明白です
   • より簡潔です
   • スタックベースのシステムに自然に適合します

   これらの主張をさらに詳しく調べるために、 以下の計算について見てみまし
ょう:

     6 + 5 * 4 =
     4 * 5 + 6 =

   あなたが、算数を勉強中の場合、 または算数が非常に苦手な場合は、 最初
の答えは 44、 2 番目の答えは 26 になるでしょう。 あなたが算数に少し詳し
い人なら、 乗算は加算よりも優先されるという法則を覚えているでしょう。 そ
して、 どちらの場合も答えは 26 になるでしょう。 答え 44 だと言った人に、
なぜ答えが 26 かを説明するには、 最初の計算を以下のように書き換えること
になるでしょう:

     6 + (5 * 4) =

   あなたが、 もし、 乗算より優先して加算を実行したい場合は、 かっこを使
用して強制的に加算させる必要があります。

   上記 2 つの計算を電卓で計算する場合、 以下のキーストローク・シーケン
スを使用して、 入力ミスしない限り、 おそらく正しい答えが得られるでしょう
:

     6 + 5 = * 4 =
     4 * 5 = + 6 =

   Postfix notation is unambiguous because the order that the operators
are applied is always explicit; that also means that parentheses are
never required後置記法では演算子が適用される順序は常に明示的です。 これ
は、 括弧が決して必要ないことも意味します。 演算子はアクティブです(演算
子を引用する行為によって演算操作が実行されます)。 これにより、「=」が必
要なくなります。

   計算 6 + 5 * 4 は、 以下の 2 つの同等の方法で(後置表記で)書くことがで
きます:

     6 5 4 * +
     または:
     5 4 * 6 +

   この表記法に関して注意すべき重要な点は、 数値の順番は変わらないことで
す。 10 から 2 を減算する場合は、 ‘10 2 -’ と入力します。

   Forth が後置表記を使用する理由は非常に簡単に説明できます。 これにより
実装が非常に単純になり、 パラメータを渡すためのメカニズムとしてスタック
を使用することが自然な流れになります。 これについての別の考え方としては
、 すべての Forth 定義がアクティブであると認識することです。 これらは、
テキスト・インタープリターによって検出されると実行されます。 この結果、
Forth の構文は何の努力も必要とせずシンプルになります。


File: gforth.info,  Node: Your first definition,  Next: How does that work?,  Prev: Stacks and Postfix notation,  Up: Introduction

4.3 Your first Forth definition
===============================

これまで私たちが見てきた例はこまごまとしたものでした。 私たちは Forth を
大きめの電卓として使用してきました。 また、 これまでに示した各計算は「1
回限り」のものです – それを繰り返すには、もう一度入力する必要があります
(1)。 このセクションでは、 Forth の語彙(vocabulary)に新しいワードを追加
する方法を説明します。

   新しいワードを作成する最も簡単な方法は、「コロン定義」を使用すること
です。 それらがどのように機能するかについて思い悩む前に、 いくつか定義し
て試してみましょう。 以下の例を入力してみてください。 スペースを正確に反
映するように注意してください:

     : add-two 2 + . ;
     : greet ." Hello and welcome" ;
     : demo 5 add-two ;

この例を打ち込んだら、 すぐ試してみましょう:

     greet<RET> Hello and welcome  ok
     greet greet<RET> Hello and welcomeHello and welcome  ok
     4 add-two<RET> 6  ok
     demo<RET> 7  ok
     9 greet demo add-two<RET> Hello and welcome7 11  ok

   ここで導入した最初の新しいモノは、 ‘:’ と ‘;’ というワードのペアです
。 これらは、それぞれ新しい定義を開始および終了するために使用されます。
‘:’ の後の最初の単語(word)は、 新しい定義の名前です。

   例からわかるように、 定義はすでに定義されているワードから構成されます
。 Forth では、 システムの起動時に存在した定義と、 ユーザーが自分で定義
した定義とを区別しません。

   この例では、 ‘.’ (ドット) や、 ‘."’ (ドット・クォート)や、 ‘dup’ (デ
ュープ) というワードも紹介しています。 ドットはスタック頂上から数詞を取
得して表示します。 これは ‘.s’ に似ていますが、 スタック頂上の項目のみを
表示する点と破壊的である点が異なります。 実行後、スタック上にその数値は
最早ありません。 数値の前はスペース無しで、 後ろには常に 1 つのスペース
が表示されます。 ドット・クォートは、 ワードの実行時に出力される文字列
(string)を定義します。 文字列には、 ‘"’ を除く任意の印刷可能な文字を含め
ることができます。 ‘"’ には特別な機能があります。 これは Forth ワードで
はありませんが、 区切り文字として機能します(区切り文字の仕組みについては
次のセクションで説明します)。 最後に、 ‘dup’ はスタック頂上の値を複製し
ます。 ‘5 dup .s’ と入力して、 ‘dup’ がやることを確認してください。

   あなたは、 既に、 テキスト・インタープリターが名前を見つけるためにデ
ィクショナリを検索することを知っています。 あなたが上記の例の通りにした
場合、 ‘add-two’ という定義がすでにあるはずです。 それでは、 この定義に
対して、 更に新しい定義を入力して変更してみるとしましょう:

     : add-two dup . ." + 2 = " 2 + . ;<RET> redefined add-two  ok

   Forth は、私たちがすでに存在するワードを定義しようとしていることを認
識し、 それを警告するメッセージを出力しました。 さて、 それでは、 新しい
定義を試してみましょう:

     9 add-two<RET> 9 + 2 = 11  ok

ただし、 ここで実際に行ったことは、 特定の名前を付けて新しい定義を作成す
ることだけです。 同一の名前の定義がすでに存在するという事実は、 (Forth が
警告メッセージを出力することを除いて、)新しい定義の作成方法に何の違いも
ありません。 add-two の古い定義はいまだ存在します(これが正しいかどうかを
確認するには、 ‘demo’ をもう一度試してください)。 ‘add-two’ の新しい定義
以降に定義するワードは ‘add-two’ の新しい定義を利用しますが、 ‘demo’ の
定義は、 古い定義は ‘demo’ をコンパイルする時点で既に存在していた
‘add-two’ の古い定義のバージョンを引き続き使用します。

   次のセクションに進む前に、 あなた自身のワードをいくつか定義したり再定
義したりしてみましょう。

   ---------- Footnotes ----------

   (1) それは完全には真実ではありません。 キーボードの上矢印キーを押すと
、 以前のコマンドにスクロールして戻り、 編集して再入力できます。


File: gforth.info,  Node: How does that work?,  Next: Forth is written in Forth,  Prev: Your first definition,  Up: Introduction

4.4 How does that work?
=======================

ここで、 前のセクションの ‘add-two’ の定義をもう一度見てみましょう。 テ
キスト・インタープリターの動作方法に関する知識から、 ‘add-two’ を定義し
ようとしたとき、 私達は以下の結果を予期したかもしれません:

     : add-two 2 + . ;<RET>
     *the terminal*:4: Undefined word
     : >>>add-two<<< 2 + . ;

   しかし、 これが起こらなかった理由は、 ‘:’ の動作方法に関係しています
。 ‘:’ というワードは 2 つの特別な働きをします。 1つ目の特別な機能は、 テ
キスト・インタープリターが ‘add-two’ という文字を認識できないようにする
ことです。 テキスト・インタープリターは、 ‘>IN’ (to-in;トゥーイン)という
変数を使用して、 入力行のどこを追跡するかを保持し、 ‘:’ というワードに遭
遇すると、 他のワードの場合とまったく同じように動作します。 名前ディクシ
ョナリでそれを検索し、 その xt を見つけて実行します。 実行される ‘:’ は
、 入力バッファーを調べてワード ‘add-two’ を見つけ、 ‘>IN’ の値をその後
ろを指すように進めておきます。 次に、 新しい定義の作成に関連するその他の
処理を実行します(名前ディクショナリに ‘add-two’ のエントリを作成する等
)。 ‘:’ の実行が完了すると、 制御はテキスト・インタープリターに戻ります
。 テキスト・インタープリターは、 このトリックにより入力行の一部をスキッ
プしていることに気づきません。

   ‘:’ のようなワード(‘>IN’ の値を進めて、 テキスト・インタープリターが
入力行全体に作用するのを妨げるワード)は、 「構文解析ワード」(parsing
words)と呼ばれます。

   ‘:’ が行う 2 つ目の特別な処理は、 ‘state’ と呼ばれる変数の値を変更す
ることです。 これは、 テキスト・インタープリターの振る舞いに影響します。
Gforth が起動するとき、 ‘state’ の値は 0 であり、 テキスト・インタープリ
ターはインタープリター状態(“interpreting”)であると言われます。 (‘:’ で始
まる)コロン定義中 、 ‘state’ は -1 に設定され、テキスト・インタープリタ
ーはコンパイル状態(“compiling”)と言われます。

   この例では、 テキスト・インタープリターは文字列 “‘2 + . ;’”。引き続き
同じ方法で文字列を文字シーケンスに分割します。ただし、数値 ‘2’ をスタッ
クにプッシュする代わりに、 数値 ‘2’ を取得する魔法を ‘add-two’ の定義に
組み込み(コンパイル)、 ‘add-two’ が「実行」されたときスタックにプッシュ
されます。 同様に、 ‘+’ と ‘.’ の振る舞いも定義にコンパイルされます。

   特定の種類のワードはコンパイルされません。 これらのいわゆる「即実行ワ
ード」(immediate word)は、 テキスト・インタープリターがインタープリター
状態であるかコンパイル状態であるかに関係なく、 実行されます(今、 直ちに
実行されます)。 ‘;’ というワードは即実行ワードです。 定義にコンパイルさ
れるのではなく、 実行されます。 その効果は、 ‘state’ の値を 0 に戻すこと
を含む、 現在の定義を終了することです。

   あなたが ‘add-two’ を実行すると、 その定義の外で ‘2 + . <RET>’ と入力
した場合とまったく同一の「実行時効果」(run-time effect) が生じます。

   Forth では、 すべてのワードまたは数値は以下の 2 つの性質を持ちます:

   • その インタープリター機能(interpretation semantics)は、 テキスト・
     インタープリターがインタープリター状態でどのように動作するかを記述
     します。 ワードのインタープリター機能は、 その「実行トークン」
     (execution token)(*note Execution token::)によって表されます。
   • その コンパイル機能(compilation semantics)は、 テキスト・インタープ
     リターがコンパイル状態でどのように動作するかを記述します。 ワードの
     コンパイル機能は、 その「コンパイル・トークン」(*note Compilation
     token::)によって表されます。

数値は常に決まった方法で処理されます:

   • その数値が通訳(interpret)される場合、 その振る舞いは、 その数値をス
     タックにプッシュすることです。
   • その数値がコンパイルされる場合、 実行時にその数値をプッシュするコー
     ドが現在の定義に追加されます。 (言い換えれば、 数値のコンパイル機能
     (compilation semantics)は、 コンパイルされる定義の実行時まで、 その
     数値のインタープリター機能(interpretation semantics)の実行を延期
     (postpone)します。)

   ワードは常にこのような通常の振る舞いをするとは限りませんが、 ほとんど
のワードにはデフォルトの機能(default semantics)があり、 以下のように振る
舞うことを意味します:

   • ワードのインタープリター機能(“interpretation semantics”)は、 何かし
     ら役に立つことを行うことです。
   • ワードのコンパイル機能(compilation semantics)は、 そのワードのイン
     タープリター機能(interpretation semantics)を現在の定義に追加します
     (よって、 それは実行時に何かしら役に立つことを行います)。

   特定のワードの実際の振る舞いは、 ワードの定義時に ‘immediate’ や
‘compile-only’ というワードを使用することで制御できます。 これらのワード
は、 最後に定義されたワードの名前ディクショナリ・エントリにフラグを設定
します。 これらのフラグは、 名前ディクショナリでワードが見つかったときに
テキスト・インタープリターによって取得されます。

   “immediate” としてマークされたワードは、 そのインタープリター機能
(interpretation semantics)と同じコンパイル機能(compilation semantics)を
持ちます。 つまり、 以下のように振る舞います:

   • ワードのインタープリター機能(“interpretation semantics”)は、 何かし
     ら役に立つことを行うことです。
   • このワードのコンパイル機能(compilation semantics)は、 何かしら役に
     立つことを行うことです(実際にはインタープリター機能と同一のことを行
     うことです)。 つまり、 このワードのコンパイル機能はコンパイル中に実
     行されます。

   ワードを “compile-only” としてマークすると、 インタープリター状態
(interpretation state)でこのワードを検出したときにテキスト・インタープリ
ターが警告を生成することを意味します。 (‘'’ または ‘[']’ を使用して) ワ
ードをティックすると、 警告が生成されます。

   ‘compile-only’ を使用する必要はありません(多くの実装によって提供され
てはいますが、 標準 Forth の一部でもありません)が、 インタープリター態
(interpret state)で正しく振る舞わないワードに ‘compile-only’ を適用する
のは良いエチケットです(そして予期しない副作用が発生する可能性があります
)。 たとえば、 定義内で条件ワード ‘IF’ を使用することのみが正当です。 こ
れを忘れて別の場所で使用しようとすると、 (Gforth では) ‘compile-only’ と
してマークされているため、 テキスト・インタープリターが有用な警告を生成
できます。

   以下の例は、 即実行ワードと非即実行ワードの違いを示しています:

     : show-state state @ . ;
     : show-state-now show-state ; immediate
     : word1 show-state ;
     : word2 show-state-now ;

   ‘show-state-now’ の定義の後にあるワード ‘immediate’ は、そのワードを
即実行ワードにします。 これらの定義では、 ‘@’(「フェッチ」と発音します)
という新しいワードが導入されています。 このワードは変数の値を取り出し(フ
ェッチし)、 それをスタックに残します。 したがって、 ‘show-state’ の振る
舞いは、 ‘state’ の現在の値を表す数値を出力することです。

   ‘word1’ を実行すると、 システムがインタープリター状態であることを示す
数値 0 が出力されます。 テキスト・インタープリターが ‘word1’ の定義をコ
ンパイルしたときに、 コンパイル機能が現在の定義に実行時コードを追加する
‘show-state’ に遭遇しました。 ‘word1’ を実行すると、 ‘show-state’ のイン
タプリタ機能(interpretation semantics)が実行されます。 ‘word1’ (つまり
‘show-state’) が実行される時点で、 システムはインタープリター状態です。

   ‘word2’ の定義を入力した後に <RET> を押すと、 数値 -1 が出力され、 そ
の後に ‘ ok’ が表示されるはずです。 テキスト・インタープリターが ‘word2’
の定義をコンパイルすると、 即実行ワードである ‘show-state-now’ が検出さ
れたため、 そのコンパイル機能(compilation semantics)はインタプリタ機能
(interpretation semantics)を実行します。 これは直ちにに実行されます(テキ
スト・インタープリターが次の文字グループ(この例では ‘;’)の処理に移る前に
)。 これを実行すると、 ‘word2’ の定義途中の ‘state’ の値が表示されます。
-1 を出力するので、 システムがその時点でコンパイル状態であることがわかり
ます。 もし あなたが ‘word2’ を「実行」しても何も行いません。

   即実行ワードの話題を離れる前に、 前のセクションの ‘greet’ の定義にお
ける ‘."’ の振る舞いについて検討してみましょう。 このワードは構文解析ワ
ード(parsing word)でもあり、 かつ、 即実行ワードでもあります。 ‘."’ とそ
のテキストの先頭 ‘Hello and welcome’ の間にはスペースがありますが、
‘welcome’ の最後の文字と ‘"’ 文字の間にはスペースがありません。 これは、
‘."’ が Forth ワードであるということです。 テキスト・インタープリターが
その Forth ワード ‘."’ を識別できるように、 ‘."’ の後ろにスペースが必要
です。 ‘"’ は Forth ワードではなく、 区切り文字(delimiter)です。 先の例
では、 文字列が表示されるときに、 ‘H’ の前にも ‘e’ の後ろにもスペースが
ないことを示しています。 ‘."’ は即実行ワードなので、 ‘greet’ の定義中に
実行されます。 実行されると、 入力行内を前方に走査して区切り文字を探しま
す。 区切り文字が見つかると、 区切り文字の後ろを指すように ‘>IN’ を更新
します。 また、 いくつかのマジック・コード、 つまりテキスト文字列を出力
する実行時コード xtを ‘greet’ の定義にコンパイルします。 文字列 ‘Hello
and welcome’ をメモリにコンパイルして、 後で出力できるようにします。 そ
の後、 テキスト・インタープリターが制御を取得すると、 入力ストリーム内で
次に検出されるワードは ‘;’ であるため、 ‘greet’ の定義を終了します。


File: gforth.info,  Node: Forth is written in Forth,  Next: Review - elements of a Forth system,  Prev: How does that work?,  Up: Introduction

4.5 Forth is written in Forth
=============================

あなたが Forth コンパイラーを起動すると、 すでに多数の定義が存在していま
す。 Forth では、 ボトムアップ・プログラミング手法を使って新しいアプリケ
ーションを開発し、 既存の定義に基づいて定義される新しい定義を作成します
。 作成した各定義は、 対話的にテストおよびデバッグできます。

   この章の例を試したことがあるなら、 あなたは、それらをおそらく手動で入
力したことがあるでしょう。 Gforth を終了すると、 あなたが定義したモノは
失われてしまいます。 これを回避するには、 テキスト・エディタを使用して
Forth ソース・コードをファイルに入力し、 ‘include’ を使用してファイルか
らコードをロードします(*note Forth source files::)。 Forth のソース・フ
ァイルは、 あたかも手入力したかのように、 テキスト・インタープリターによ
って処理されます(1)。

   Gforth は、 プログラム入力 にテキスト・ファイルを使用する、 伝統的な
Forth の代替手段もサポートしています(*note Blocks::)。

   ほとんどというほどではないにしても、 多くの Forth コンパイラーと共通
して、 Gforth のほとんどは実際には Forth で書かれています。 インストール
・ディレクトリ(2)内のすべての ‘.fs’ ファイルは Forth ソース・ファイルで
あり、 あなたは それらを Forth プログラミングの例として拝んで学ぶことが
できます。

   Gforth は、 テキスト・インタープリターに入力したすべての行を記録する
履歴(history)ファイルを維持します。 このファイルはセッションをまたいで維
持され、 コマンドラインの呼び出し機能を提供するために使用されます。 長い
定義を手動で入力した場合は、 テキスト・エディターを使用して履歴ファイル
から後で再利用するために Forth ソース・ファイルに貼り付けることができま
す(詳細については *note Command-line editing::)。

   ---------- Footnotes ----------

   (1) 実際には、 いくつか微妙な違いがあります – *note The Text
Interpreter::

   (2) For example, ‘/usr/local/share/gforth...’


File: gforth.info,  Node: Review - elements of a Forth system,  Next: Where to go next,  Prev: Forth is written in Forth,  Up: Introduction

4.6 Review - elements of a Forth system
=======================================

この章を要約すると:

   • Forth プログラムはファクタリングを使用して、 問題を「ワード」または
     「定義」と呼ばれる小さな断片に分割します。
   • Forth プログラムの開発は対話型のプロセスです。
   • 入力を受け付け、 通訳(interpret)とコンパイルの両方を制御するメイン
     ・コマンド・ループは、「テキスト・インタープリター」と呼ばれます(外
     部インタープリターとも呼ばれます)。
   • Forth の構文は非常に単純で、 スペースまたは改行文字で区切られた単語
     (word)と数値で構成されます。 追加の構文は構文解析ワード(parsing
     words)によります。
   • Forth はスタックを使用してワード間でパラメーターを渡します。 その結
     果、 後置記法が使用されます。
   • 以前に定義されたワードを使用するために、 テキスト・インタープリター
     は「名前ディクショナリ」でそのワードを探します。
   • ワードはインタープリター機能(“interpretation semantics”)とコンパイ
     ル機能(“compilation semantics”)を持っています。
   • テキスト・インタープリターは、 ‘state’ の値を使用して、 探し出した
     ワードのインタプリタ機能(interpretation semantics)を使用するかコン
     パイル機能(compilation semantics)を使用するかを選択します。
   • ワードのインタープリター機能(interpretation semantics)とコンパイル
     機能(compilation semantics)の関係は、 そのワードが定義された方法(た
     とえば、 それが「即実行ワード」(“immediate” word)であるかどうか)に
     よって異なります。
   • Forth 定義は、 Forth で実装(「高レベル定義」と呼ばれます)、 または
     、 その他のいくつかの方法(通常は低レベル言語で、 「低レベル定義」、
     「コード定義」、「プリミティブ」と呼ばれる事もある)で実装できます。
   • 多くの Forth システムは主に Forth で記述されています。


File: gforth.info,  Node: Where to go next,  Next: Exercises,  Prev: Review - elements of a Forth system,  Up: Introduction

4.7 Where To Go Next
====================

信じられないかもしれませんが、 あなたがここまで読んで(そして理解していれ
ば)、 Forth システムの内部動作についての基本をほぼすべて知っていることに
なります。 あなたは今や確実に、 このマニュアルの残りの部分と標準 Forth ド
キュメントを読んで理解し、 Forthの一般的な機能と、 特に Gforth が提供す
る機能について詳しく学ぶのに十分な知識を持っています。 更に恐るべきこと
に、 あなたは独自の Forth システムを実装するのにほぼ十分な知識を持ってい
ますが、 独自の Forth システムを実装するには時期尚早かもしれません。 そ
の前に、 あなたは Gforth でいくつかのプログラムを書いてみたほうがいいで
しょう。

   Forth には非常に豊富な語彙があるため、 学ぶにも、 どこから手を付けれ
ばいいかわからない場合があります。 このセクションでは、 小さいながらも有
用なプログラムを作成するのに十分なワードのセットをいくつか提案します。 こ
のドキュメントのワード索引を使用して各ワードについて詳しく学び、 それを
試して、 それを使用して簡単な定義を書いてみてください。 まずは以下のワー
ド達を試してみてください:

   • 算術演算: ‘+ - * / /MOD */ ABS INVERT’
   • 比較: ‘MIN MAX =’
   • 論理演算: ‘AND OR XOR NOT’
   • スタック操作: ‘DUP DROP SWAP OVER’
   • ループと条件判断: ‘IF ELSE ENDIF ?DO I LOOP’
   • 入出力: ‘. ." EMIT CR KEY’
   • 定義ワード: ‘: ; CREATE’
   • メモリ割り当てワード: ‘ALLOT ,’
   • ツール: ‘SEE WORDS .S MARKER’

   上記をマスターできたら、 以下に進みましょう:

   • さらなる 定義ワード いくつか: ‘VARIABLE CONSTANT VALUE TO CREATE
     DOES>’
   • メモリ・アクセス: ‘@ !’

   これらをマスターしたら、 あなたは、 このマニュアルのすべてに目を通し
、 あなたのプログラムに欠けているものを探し出す必要があります。


File: gforth.info,  Node: Exercises,  Prev: Where to go next,  Up: Introduction

4.8 Exercises
=============

TODO: すでに完了した内容やマニュアルの他のセクションにリンクされた一連の
プログラミング演習を提供したい。 すべての演習に対する回答を、 ディストリ
ビューション内の .fs ファイルで提供するようにしたいです。


File: gforth.info,  Node: Literals in source code,  Next: Words,  Prev: Introduction,  Up: Top

5 Literals in source code
*************************

整数値をデータ・スタックにプッシュするために、 あなたはソース・コードに
数値を書きます。 たとえば ‘123’ です。 数字の連なりの前に ‘-’ を付けると
、 負の数値を示すことができます。 たとえば ‘-123’ です。 これはコロン定
義の内部と外部の両方で機能します。 数値は ‘base’ (基数) の値に従って通訳
(interpret)されます(*note Number Conversion::)。 「数字」は ‘0’ ～ ‘9’ 、
‘a’ (10進数の10) ～ ‘z’ (10進数の35) です。 ただし、 基数(base)より小さ
い「数字」のみが認識されます。 変換では大文字と小文字が区別されないため
、‘A’ と ‘a’ は同じ「数字」になります。

   以下のプレフィックスを使用すると、 数値の基数(base)を明示的に指定でき
ます:

   • ‘#’ – 10進数(decimal)
   • ‘%’ – 2進数(binary)
   • ‘$’ – 16進数(hexadecimal)
   • ‘&’ – 10進数(decimal)(非標準)
   • ‘0x’ – 16進数(hexadecimal), if base<33 (非標準)

   基数プレフィックスと符号を含む組み合わせの場合、 標準的な順序では基数
プレフィックスを最初に配置します(例: ‘#-123’)。 Gforth は両方の順番をサ
ポートします。

   小数点 ‘.’ を数値の末尾(または非標準的に、 プレフィックスの前を除く他
の場所)に置くと、 2倍長整数double-cell integer)として扱われます(例:
‘#-123.’ または ‘#-.123’ (この2つは同一の数値です))。 別のプログラミング
言語の経験があるユーザーは、 基数プレフィックスのない、 このような数値
(例: ‘-123.’) を見たり書いたりする場合、 その数値が浮動小数点値を表すも
のと期待する可能性があります。 混乱を早期に解決するために、 Gforth はそ
のような使用法について警告しています。 警告を回避するには、 常に基数プレ
フィックスを付けて 2倍長整数(double-cell integer)を記述することをお勧め
します(例: ‘#-123.’)

   以下にいくつかの例を示します。 なお、 同値の 10 進数が括弧内に示され
ています:

   ‘$-41’ (-65), ‘%1001101’ (205), ‘%1001.0001’ (145 ; 2倍長整数),
‘#905’ (905), ‘$abc’ (2478), ‘$ABC’ (2478).

   (文字)コード・ポイントの数値を取得するには、 文字を ‘'’ で囲みます (例
: ‘'a'’)。 末尾の ‘'’ は標準では必須ですが、Gforth では省略できます。 注
意: これは非 ASCII 文字でも機能することに注意してください。 多くの用途で
は、 文字をセルとしてではなく文字列として持つ方が便利です。 文字列の構文
については、 以下を参照してください。

   Forth の浮動小数点数は、 その指数によって認識されます。 つまり、 ‘1.’
は 2倍長整数(double-cell integer)で、 そして ‘1e0’ は浮動小数点数です。
後者は ‘1e’ に短縮できます(通常は短縮します)。 仮数部(‘e’ や ‘E’ より前
の部分)と指数の部分の両方に符号(‘+’ を含む)を含めることができます。 仮数
部には少なくとも 1 つの数字が含まれている必要があり、 小数点を含めること
ができます。 指数は空であってもかまいません。 浮動小数点数は仮数と指数の
両方に常に 10 進数の基数を使用し、 基数が 10 進数の場合にのみ認識されま
す。 例: ‘1e 1e0 1.e 1.e0 +1e+0’ (これらは全て同一の数値です)、
‘+12.E-4’

   Gforth 拡張機能 (1.0 以降)では、 浮動小数点数をスケーリングされた表記
で書くことができます。 オプションで符号、 その次に 1 つ以上の数字を指定
し、その後ろに、 主に SI で定義されたスケーリング記号(別名 メトリック・
プレフィックス)または ‘%’ のうちの 1 つを使用でき、 その後に、 オプショ
ンで更に多くの桁を指定できます。 Gforth が受け入れるスケーリング記号の完
全なリストは以下のとおりです:

   • ‘Q’ ‘e30’ quetta(クエタ)
   • ‘R’ ‘e27’ ronna(ロナ)
   • ‘Y’ ‘e24’ yotta(ヨタ)
   • ‘Z’ ‘e21’ zetta(ゼタ)
   • ‘X’ ‘e18’ exa(エクサ)(‘E’ じゃ無いので注意)
   • ‘P’ ‘e15’ peta(ペタ)
   • ‘T’ ‘e12’ tera(テラ)
   • ‘G’ ‘e9’ giga(ギガ)
   • ‘M’ ‘e6’ mega(メガ)
   • ‘k’ ‘e3’ kilo(キロ)
   • ‘h’ ‘e2’ hecto(ヘクト)
   • ‘d’ ‘e-1’ deci(デシ)
   • ‘%’ ‘e-2’ percent(パーセント)(‘c’ じゃ無いので注意)(訳注: 一般の
     centi(センチ) と違うので注意)
   • ‘m’ ‘e-3’ milli(ミリ)
   • ‘u’ ‘e-6’ micro(マイクロ)(‘μ’ じゃ無いので注意)
   • ‘n’ ‘e-9’ nano(ナノ)
   • ‘p’ ‘e-12’ pico(ピコ)
   • ‘f’ ‘e-15’ femto(フェムト)
   • ‘a’ ‘e-18’ atto(アト)
   • ‘z’ ‘e-21’ zepto(ゼプト)
   • ‘y’ ‘e-24’ yocto(ヨクト)
   • ‘r’ ‘e-27’ ronto(ロント)
   • ‘q’ ‘e-30’ quecto(クエント)

   Gforth の残りのほとんどとは異なり、 スケーリング・シンボルは大文字と
小文字が区別されて扱われます。 スケール表記を使用するということは、 スケ
ール記号の代わりに小数点を使用し、 末尾に指数表記を追加することと同じで
す。 スケール表記の例: ‘6k5’ (6500e), ‘23%’ (0.23e)

   文字列を ‘"’ で囲んで入力できます(例: ‘"abc"’、‘"a b"’)。 その結果は
、データスタック上の、 文字列の開始アドレスと、 バイト(=char)のカウント
です。

   文字列内の ‘"’ は ‘\’ でエスケープする必要があります(例:
‘"double-quote->\"<-"’)。 さらに、 この文字列構文は、 ‘s\"’ でサポートさ
れている制御文字を記述するすべての方法をサポートしています(*note String
and character literals::)。 この文字列構文の欠点は、 標準ではないことで
す。 標準プログラムの場合は、 ‘"…"’ の代わりに ‘s\"’ を使用してください
。

   環境変数を取得するには、 最初に ‘rec-env.fs’ をロードし、 次に環境変
数の前に ‘$’ を付けます (例: ‘$HOME’)。 結果は、 上で説明した形式のデー
タ・スタック上の文字列記述子(string descriptor)になります。 これは
‘"HOME" getenv’ と同等です。つまり、 環境変数は実行時(run-time)に解決さ
れます。

   ワード名の前に ‘`’ を付けることで、 ワードの実行トークン (xt) を取得
できます (例: ‘`dup’)。 ‘'’ または ‘[']’ を使うよりも有利な点は、 コロン
定義の内側から外側へ、 またはその逆にコードをコピーして貼り付けるときに
、 これらを切り替える必要がないことです。 欠点は、 この構文が標準ではな
いことです。

   ワード名の前に ‘``’ を付けることで、 ワードのの名前トークン (nt) を取
得できます (例: ‘``dup’)。 この構文も非標準です。

   ワードの本体アドレスを ‘<’ と ‘>’ で囲むことで取得できます (例:
‘<spaces>’)。 ワード名と末尾の ‘>’ の間に ‘+’ と数値を入れることで、 そ
の本体アドレスから正のオフセットのアドレス(通常はそのワードの本体内のア
ドレス)を取得することもできます(例: ‘<spaces+$15>’, ‘spaces+-3’)。 例え
ば ‘<spaces+$15>’ とか ‘<spaces+-3>’) とすると、 その本体アドレスに数値
を足したのを得るでしょう。 この非標準機能は、 ‘...’ の出力をコピーして貼
り付けることを可能にするために存在します(*note Examining data::)。


File: gforth.info,  Node: Words,  Next: Error messages,  Prev: Literals in source code,  Up: Top

6 Forth Words
*************

* Menu:

* Notation::
* Case insensitivity::
* Comments::
* Boolean Flags::
* Arithmetic::
* Stack Manipulation::
* Memory::
* Strings and Characters::
* Control Structures::
* Defining Words::
* Interpretation and Compilation Semantics::
* Tokens for Words::
* Compiling words::
* The Text Interpreter::
* The Input Stream::
* Word Lists::
* Environmental Queries::
* Files::
* Blocks::
* Other I/O::
* OS command line arguments::
* Locals::
* Structures::
* Object-oriented Forth::
* Regular Expressions::
* Programming Tools::
* Multitasker::
* C Interface::
* Assembler and Code Words::
* Carnal words::
* Passing Commands to the OS::
* Keeping track of Time::
* Miscellaneous Words::


File: gforth.info,  Node: Notation,  Next: Case insensitivity,  Prev: Words,  Up: Words

6.1 Notation
============

Forth のワードは、 以下にあるように、 Forth テキストのデファクトスタンダ
ード(事実上の標準)となっている表記にて説明されます:

word     Stack effect   wordset   pronunciation
   Description

WORD
     ワード名。

STACK EFFECT
     スタック効果(stack effect)は、 ‘before -- after’ という表記で記述さ
     れます。 ここで、before と after は、 ワード実行前と実行後のスタッ
     ク・エントリの頂上部を表します。 スタックの残りの部分にはワードは触
     れません。 スタックの頂上は右端です。 つまり、 スタック・シーケンス
     はあなたが入力したとおりに書き込まれます。 注意: Gforth は別個の浮
     動小数点スタックを使用しますが、 統一されたスタック表記法を使用する
     ことに注意してください。 また、 リターンスタック効果は「スタック効
     果」には表示されませんが、 「説明」(Description)に表示されます。 ス
     タック項目の名前は、 項目の型や機能を説明します。 型の説明について
     は、 下記を参照してください。

     すべてのワードには、 コンパイル・モードのスタック効果とインタープリ
     ター・モードのスタック効果という 2 つのスタック効果があります。 ほ
     とんどのワードのコンパイル・モードのスタック効果は – です。 ワード
     のコンパイル・モードのスタック効果がこの標準の振る舞いから逸脱して
     いる場合、 またはワードがコンパイル・モードに他の通常でない振る舞い
     を行う場合、 両方のスタック効果が表示されます。 それ以外の場合、 イ
     ンタープリター・モードのスタック効果のみが表示されます。

     また、 コード・テンプレートまたはサンプルでは、​​ その時点でのスタ
     ックの状態表示するコメントが括弧内にある場合があることにも注意して
     ください。 これらのスタックの状態表示には ‘--’ はありません。 なぜ
     なら前・後という状況が無いためです。

PRONUNCIATION
     ワードの発音

WORDSET
     ワードセット(wordset)は、 ワードが標準化されたものか、 または環境ク
     エリ文字列であるか、 または Gforth 固有のワードであるかを指定します
     。 Gforth 固有のワードの場合、 ワードセット名には文字列 ‘gforth’ が
     含まれており、 他のワードセット名は ‘environment’ または標準のワー
     ドセット(standard word sets)を参照します。

     Forth 標準はいくつかのワードセットに分かれています。 理論上、 標準
     システムはそれらすべてをサポートする必要はありませんが、 実際には、
     組み込み用途な超小型のマシン以外の本格的なシステムは、 ほぼすべての
     標準化されたワードをサポートします(ただし、一部のシステムでは一部の
     ワードセットを明示的にロードする必要があります)。 そのため、 実際の
     ところはワードセットの使用をケチったところでその分移植性が上がる訳
     ではありません。

     Gforth 固有のワードについては、 以下のカテゴリがあります:

     ‘gforth’
     ‘gforth-<version>’
          我々はこのワードを Gforth で永続的にサポートするつもりであり、
          Gforth <version> 以降で有効です(おそらくその <version> 時点で
          はサポートされていないワードです)。

     ‘gforth-experimental’
          このワードは現在のバージョンで使用できますが、 永続的なワード
          になるか、 Gforth の将来のリリースで削除されるか分かりません。
          あなたのフィードバックをお待ちしています。

     ‘gforth-internal’
          このワードは内部用であり、 サポート対象のワードではないため、
          Gforth の将来のリリースでは削除される可能性があります。

     ‘gforth-obsolete’
          このワードは、 Gforth の将来のリリースでは削除される予定です。

DESCRIPTION
     そのワードの振る舞いを説明します。

   スタック項目の型は、 以下のように、 スタック項目名のはじめの文字が何
であるかによって指定されます:

‘f’
     二値フラグ(Boolean flags)。 つまり ‘false’ または ‘true’
‘c’
     Char
‘w’
     セル。 整数(an integer)やアドレス(an address)も格納可能。
‘n’
     符号付き整数
‘u’
     符号なし整数
‘d’
     符号付き2倍長整数
‘ud’
     符号無し2倍長整数
‘r’
     浮動小数点数(Float)(FP スタック上に置かれる)
‘a-’
     セル・アライメント・アドレス
‘c-’
     文字(char)アライメント・アドレス(注意: Windows NT では文字(char)は
     2 バイトになる場合があることに注意)
‘f-’
     浮動小数点数アライメントのアドレス
‘df-’
     IEEE倍精度浮動小数点数アライメントのアドレス
‘sf-’
     IEEE単精度浮動小数点数アライメントのアドレス
‘xt’
     実行トークン(Execution token)。 セルと同一サイズ
‘wid’
     ワード・リストID。セルと同一サイズ
‘ior, wior’
     セルサイズの入出力結果コード。 Gforth では iors を ‘throw’ できます
     。
‘f83name’
     名前構造体へのポインター
‘"’
     (スタック上ではなく、)入力ストリーム内の文字列。 終端文字はデフォル
     トでは空白(a blank)です。 終端文字が空白でない場合は、 ‘<>’ でクォ
     ートして表示します。


File: gforth.info,  Node: Case insensitivity,  Next: Comments,  Prev: Notation,  Up: Words

6.2 Case insensitivity
======================

Gforth では英大文字小文字を区別しません(case-insensitive)。 大文字、 小
文字、 または大文字と小文字の混合を使用して、 定義を入力したり標準のワー
ドを呼び出したりできます(ただし、 こちらも参照ください *note
Implementation-defined options: core-idef.)

   標準 Forth では、 標準のワードが完全に大文字で入力された場合にのみ実
装が認識する必要があります。 したがって、 標準のプログラムでは、 すべて
の標準ワードに大文字を使用する必要があります。 あなたの定義したワードに
は大文字と小文字を自由に使用できますが、 標準のプログラムでは、 ワードを
定義したときと同じ大文字と小文字で使用する必要があります。

   Gforth は、 ‘cs-wordlist’ (英大文字小文字を区別する(case-sensitive)ワ
ード・リスト *note Word Lists::) を通じて英大文字小文字の区別をサポート
します。

   何人かは Gforth を英大文字小文字を区別する(case-sensitive)ように変換
する方法を質問しました。 これは悪い考え(bad idea)だとは思いますが、 すべ
てのワードリストを以下のようなテーブルに変更できます:

     ' table-find forth-wordlist wordlist-map  !

   注意: このように、 Gforth を英大文字小文字を区別する
(case-sensitive)ように変換した場合、 定義済みのワードは、 定義したときと
同一の大文字と小文字の組み合わせで入力する必要があることに注意してくださ
い。 大文字と小文字は異なります。 この操作を実行する前に、 それらをあな
た好みの大文字と小文字の組み合わせに変換するとよいでしょう(その方法につ
いては説明しません。 Gforth を英大文字小文字を区別する(case-sensitive)よ
うに変換することを実行することを検討している場合でも、 すでに定義済みワ
ードのワード名をあなた好みの大文字と小文字の組み合わせに変換するその方法
を知っているくらいの Forth システムの知識があったほうがよいと思います)。


File: gforth.info,  Node: Comments,  Next: Boolean Flags,  Prev: Case insensitivity,  Up: Words

6.3 Comments
============

Fors は 2 つのスタイルのコメントをサポートしています。 従来の行中コメン
トである ‘(’ と、 その現代的な親戚である、 行末までのコメント ‘\’ です。

‘(’ ( compilation ’ccc<close-paren>’ – ; run-time –  ) core,file “paren”
   通常は次の ‘)’ までがコメントです。 「)」 が見つかるまで、 パース領域
内の後続の文字をすべてパースして破棄します。 対話入力中は、 行末はコメン
ト終了文字としても機能します。 ただし、 ファイル入力の場合はそうではあり
ませんので、 「)」区切り文字のパース中にファイルの終わりに遭遇すると、
Gforth は警告を出します。

‘\’ ( compilation ’ccc<newline>’ – ; run-time –  ) core-ext,block-ext “backslash”
   行末までがコメントです。 ブロックからのロード中を除き、 パース領域内
の残りの文字をすべてパースして破棄します。 ブロックからのロード中は、 1行
64バイトと見なすので、 その 64 バイト行の残りの文字をすべてパースして破
棄します。

‘\G’ ( compilation ’ccc<newline>’ – ; run-time –  ) gforth-0.2 “backslash-gee”
   ‘\’ と同等ですが、 ドキュメントの定義コメントに注釈(annotate)を付ける
ためのタグとして使用されます。


File: gforth.info,  Node: Boolean Flags,  Next: Arithmetic,  Prev: Comments,  Up: Words

6.4 Boolean Flags
=================

ブール値フラグはセル・サイズです。 すべてのビットがクリアされているセル
はフラグ ‘false’ を表し、 すべてのビットがセットされているセルはフラグ
‘true’ を表します。 フラグをチェックするワード (‘IF’ など) は、 セルの任
意のビットがセットされているものを ‘true’ として扱います。

‘true’ ( – f  ) core-ext “true”
   定数 – f は全てのビットがセットされたセルです。

‘false’ ( – f  ) core-ext “false”
   定数 – f は全てのビットがクリアされたセルです。

‘on’ ( a-addr –  ) gforth-0.2 “on”
   指定の a-addr の変数の値を ‘true’ にセットする。

‘off’ ( a-addr –  ) gforth-0.2 “off”
   指定の a-addr の変数の値を ‘false’ にセットする。

‘select’ ( u1 u2 f – u ) gforth-1.0 “select”
   f が false なら u2 を u として返し、 そうでなければ u1 を u として返
す。


File: gforth.info,  Node: Arithmetic,  Next: Stack Manipulation,  Prev: Boolean Flags,  Up: Words

6.5 Arithmetic
==============

Forth の算術演算はチェックを行いません。 つまり、 加算または乗算での整数
のオーバーフローについては問い詰められませんが、 運が良ければゼロによる
除算については問い詰められることができるかもしれません。 演算子はオペラ
ンドの後に記述されますが、 オペランドは元の順序のままです。 つまり、 中
置記法での ‘2-1’ は ‘2 1 -’ に対応します。 Forth はさまざまな除算演算子
を提供します。 あなたが、 潜在的に負になりうるオペランドを使用して除算を
実行する場合、 実装により振る舞いが異なる ‘/’ や ‘/mod’ を使用せず、 た
とえば、 ‘/f’ や ‘/modf’ や ‘fm/mod’ を使用します(*note Integer
division::)。

* Menu:

* Single precision::
* Double precision::         2倍長整数演算
* Mixed precision::          1倍長整数と2倍長整数の操作
* Integer division::
* Two-stage integer division::
* Bitwise operations::
* Numeric comparison::
* Floating Point::


File: gforth.info,  Node: Single precision,  Next: Double precision,  Prev: Arithmetic,  Up: Arithmetic

6.5.1 Single precision
----------------------

デフォルトでは、 Forth の数値は 1 セルのサイズの1倍長整数です。 扱い方に
応じて、 符号付きまたは符号無しにすることができます。 1倍長整数を認識す
るためにテキスト・インタープリターで使用されるルールについては、 *note
Number Conversion:: を参照してください。

   これらのワードは、 すべて符号付きオペランドに対して定義されていますが
、 一部のワードは符号無しの数値に対しても機能します: ‘+’, ‘1+’, ‘-’,
‘1-’, ‘*’

‘+’ ( n1 n2 – n ) core “plus”

‘1+’ ( n1 – n2 ) core “one-plus”

‘under+’ ( n1 n2 n3 – n n2 ) gforth-0.3 “under-plus”
   n3 を n1 に足し込む(n を得る)

‘-’ ( n1 n2 – n ) core “minus”

‘1-’ ( n1 – n2 ) core “one-minus”

‘*’ ( n1 n2 – n ) core “star”

‘negate’ ( n1 – n2 ) core “negate”

‘abs’ ( n – u ) core “abs”

‘min’ ( n1 n2 – n ) core “min”

‘max’ ( n1 n2 – n ) core “max”

‘umin’ ( u1 u2 – u ) gforth-0.5 “umin”

‘umax’ ( u1 u2 – u ) gforth-1.0 “umax”


File: gforth.info,  Node: Double precision,  Next: Mixed precision,  Prev: Single precision,  Up: Arithmetic

6.5.2 Double precision
----------------------

テキスト・インタープリターが2倍長整を認識するために使用するルールについ
ては、 *note Number Conversion:: を参照してください。

   数値は 2 の補数演算を使用する Gforth で表されるため、符号付き単精度浮
動小数点数を (符号付き) 倍精度浮動小数点に変換するには、最上位セル全体で
符号拡張が必要です。 倍精度整数はセルのペアで表され、 上位側のセルが TOS
にあります。 符号無しの1倍長整数を2倍長整数に変換するのは簡単で、 ‘0’ を
TOS にプッシュするだけです。 整数値は Gforth では 2 の補数表現を使うため
、 符号付き1倍長整数を(符号付き)2倍長整数に変換するには、 上位側セル全体
で符号拡張が必要です。 これは ‘s>d’ を使用して実現できます。 このことか
ら分かるとおり、 それが符号無し整数を表しているのか、 符号有り整数を表し
ているのか分からなければ、 数値を変換できないということです。

   これらのワードはすべて符号付きオペランドに対して定義されていますが、
一部のワードは符号無しの数値に対しても機能します: ‘d+’、‘d-’

‘s>d’ ( n – d  ) core “s-to-d”

‘d>s’ ( d – n  ) double “d-to-s”

‘d+’ ( ud1 ud2 – ud ) double “d-plus”

‘d-’ ( d1 d2 – d ) double “d-minus”

‘dnegate’ ( d1 – d2 ) double “d-negate”

‘dabs’ ( d – ud  ) double “d-abs”

‘dmin’ ( d1 d2 – d  ) double “d-min”

‘dmax’ ( d1 d2 – d  ) double “d-max”


File: gforth.info,  Node: Mixed precision,  Next: Integer division,  Prev: Double precision,  Up: Arithmetic

6.5.3 Mixed precision
---------------------

‘m+’ ( d1 n – d2 ) double “m-plus”

‘m*’ ( n1 n2 – d ) core “m-star”

‘um*’ ( u1 u2 – ud ) core “u-m-star”


File: gforth.info,  Node: Integer division,  Next: Two-stage integer division,  Prev: Mixed precision,  Up: Arithmetic

6.5.4 Integer division
----------------------

以下にあるように、 除算を扱うために相当な数のワードがあることが分かりま
す。 これらの主な違いは、 符号付き除算の処理にあります。 これらのワード
はどのようにして符号付き除算に対応するのでしょうか？ (‘U’ プレフィックス
が付いたワードでは符号付き除算に対応しません)

   商を四捨五入して整数に丸める場合、 負の無限大に向かって丸めるのでしょ
うか(floored division(床除算)、 接尾辞 ‘F’)、 それとも 0 に向かって丸め
るのでしょうか(symmetric division、接尾辞 ‘S’)。 標準では、 ほとんどの標
準ワード(‘/ mod /mod */ */mod m*/’)について、 問題なのは、 各々の実装依
存のままであり、 システムごとに異なる選択が行われています。 Gforth では
、こ​​れらのワードをfloorとして実装します(Gforth 0.7 以降)。 floored
division と symmetric division の違いは、 割られる数と割る数の符号が異な
り、 かつ、 割られる数が割る数の倍数で無い場合のみです。 以下の表に組み
合わせの結果を示します:

                           floored          symmetric
     割られる  割る数      余り 商            余り 商
         10      7           3   1              3   1
        -10      7           4  -2             -3  -1
         10     -7          -4  -2              3  -1
        -10     -7          -3   1             -3   1

   floored と symmetric とが違いを生む一般的なケースは、 様々な符号の被
除数(割られる数) n1 が、 同一の正の除数(割る数) n2 で除算される場合です
。 同一の正の除数(割る数) n2 で除算される場合、 通常は floored division
が必要で、なぜなら、 同一の正の除数(割る数) n2 で除算される場合、 余りは
常に正となり、 被除数(割られる数)に応じて符号が変化しないからです。 また
、 floored division では、 n1 が n2 増加すると商は常に 1 増加しますが、
symmetric division では、 -n2<n1<n2 の場合は商は増加しません(この範囲で
は商は 0 です)。

   いずれの場合でも、 floored と symmetric とで違いが生ずる数値を除算す
る場合は、 どのバリエーションが適切であるかを考えてから、 適切な接尾辞を
付けた Gforth ワードか、 標準ワードの ‘fm/mod’ または ‘sm/rem’ のいずれ
かを使用する必要があります。

   1倍長セル同士の除算:

‘/’ ( n1 n2 – n  ) core “slash”
   n=n1/n2

‘/s’ ( n1 n2 – n ) gforth-1.0 “slash-s”

‘/f’ ( n1 n2 – n ) gforth-1.0 “slash-f”

‘u/’ ( u1 u2 – u ) gforth-1.0 “u-slash”

‘mod’ ( n1 n2 – n  ) core “mod”
   n は n1/n2 の余り(modulus)

‘mods’ ( n1 n2 – n ) gforth-1.0 “mod-s”

‘modf’ ( n1 n2 – n ) gforth-1.0 “modf”

‘umod’ ( u1 u2 – u ) gforth-1.0 “umod”

‘/mod’ ( n1 n2 – n3 n4  ) core “slash-mod”
   n1/n2 を行い、 n3 が余り(modulus)、 n4 が商です(n1=n2*n4+n3)。

‘/mods’ ( n1 n2 – n3 n4 ) gforth-1.0 “slash-mod-s”
   n3 が余り(remainder)、 n4 が商

‘/modf’ ( n1 n2 – n3 n4 ) gforth-1.0 “slash-mod-f”
   n3 が余り(modulus)、 n4 が商

‘u/mod’ ( u1 u2 – u3 u4 ) gforth-1.0 “u-slash-mod”
   u3 が余り(modulus)、 u4 が商

   2倍長セルを1倍長セルで割って1倍長セルの結果を得る; これらのワードは、
一部のアーキテクチャ(AMD64 など)では上記ワードとほぼ同じ速度ですが、 他
のアーキテクチャ(さまざまな Aarch64 CPU など)でははるかに遅くなります。

‘fm/mod’ ( d1 n1 – n2 n3 ) core “f-m-slash-mod”
   Floored division: d1 = n3*n1+n2, n1>n2>=0 or 0>=n2>n1.

‘sm/rem’ ( d1 n1 – n2 n3 ) core “s-m-slash-rem”
   Symmetric division: d1 = n3*n1+n2, sign(n2)=sign(d1) or 0.

‘um/mod’ ( ud u1 – u2 u3 ) core “u-m-slash-mod”
   ud=u3*u1+u2, 0<=u2<u1

‘du/mod’ ( d u – n u1 ) gforth-1.0 “du-slash-mod”
   d=n*u+u1, 0<=u1<u; PolyForth スタイルの混合除算

‘*/’ ( ( n1 n2 n3 – n4  ) core “star-slash”
   n4=(n1*n2)/n3 中間結果は2倍長

‘*/s’ ( n1 n2 n3 – n4 ) gforth-1.0 “star-slash-s”
   n4=(n1*n2)/n3 中間結果は2倍長

‘*/f’ ( n1 n2 n3 – n4 ) gforth-1.0 “star-slash-f”
   n4=(n1*n2)/n3 中間結果は2倍長

‘u*/’ ( u1 u2 u3 – u4 ) gforth-1.0 “u-star-slash”
   u4=(u1*u2)/u3 中間結果は2倍長

‘*/mod’ ( n1 n2 n3 – n4 n5  ) core “star-slash-mod”
   n1*n2=n3*n5+n4 中間結果(n1*n2)は2倍長、 n4 は剰余、 n5 は商。

‘*/mods’ ( n1 n2 n3 – n4 n5 ) gforth-1.0 “star-slash-mod-s”
   n1*n2=n3*n5+n4, 中間結果(n1*n2)は2倍長、 n4 は余り(remainder)、 n5 は
商

‘*/modf’ ( n1 n2 n3 – n4 n5 ) gforth-1.0 “star-slash-mod-f”
   n1*n2=n3*n5+n4 中間結果(n1*n2)は2倍長。 n4 余り(modulus)、n5 は商

‘u*/mod’ ( u1 u2 u3 – u4 u5 ) gforth-1.0 “u-star-slash-mod”
   u1*u2=u3*u5+u4 中間結果(u1*u2)は2倍長。

   除算結果を2倍長セル(double-cell)で得ます。 以下のワード群は上記のワー
ド群よりもはるかに遅いです。

‘ud/mod’ ( ud1 u2 – urem udquot  ) gforth-0.2 “ud/mod”
   符号無し2倍長 ud1 を u2 で割る。 結果は、符号なし2倍長の商 udquot と
、 1倍長の余り(remainder) urem です。

‘m*/’ ( d1 n2 u3 – dquot  ) double “m-star-slash”
   dquot=(d1*n2)/u3, 中間結果は3倍長です。 ANS Forth では u3 は正の符号
付き数値のみです。

   環境クエリ(environmental query) ‘floored’ を使用すると、 ‘/ mod /mod
*/ */mod m*/’ が floored division か symmetric division かを確認できます
(*note Environmental Queries::)。

   整数除算ワードのもう 1 つの側面は、 整数除算ワードのほとんどがオーバ
ーフローする可能性があり、 かつ、 ゼロによる除算が数学的に定義されていな
いことです。 これらの条件のいずれかに該当した場合に何が起こるかは、 エン
ジンやハードウェアやオペレーティング・システムによって異なります。
‘gforth’ エンジンは、適切なエラーである -10 (Division by zero;ゼロ除算)
または -11 (Result out of range;範囲外の結果) を throw しようと懸命に試
みます、 が、 しかし、 一部のプラットフォームでは -55（浮動小数点未確認
エラー;Floating-point unidentified fault）が throw されます。
‘gforth-fast’ エンジンでは、 不適切な throw コード(およびエラー・メッセ
ージ)を生成する場合や、 エラーを生成せずに嘘の値のみを生成する場合があり
ます。 つまり、 あなたは、 そのような条件が throw されることに賭けるべき
ではありません。 そして、 あなたが迅速なデバッグを行うためには、
‘gforth’ エンジンは ‘gforth-fast’ エンジンよりも多くのエラーをキャッチし
、 より正確なエラーを生成します。


File: gforth.info,  Node: Two-stage integer division,  Next: Bitwise operations,  Prev: Integer division,  Up: Arithmetic

6.5.5 Two-stage integer division
--------------------------------

(Two-stage integer divison;2段階除算)ほとんどのハードウェアでは、 乗算は
除算よりも大幅に高速です。 したがって、 多くの数値を同じ除数(割る数)で除
算する必要がある場合は、 通常、 除数の逆数を一度求めて、 その逆数を数値
に乗算する方が高速です。 整数の場合、 これは技巧的になってしまうため、
Gforth ではこの作業をこのセクションで説明するワード群にパッケージ化して
います。

   以下の例から始めるとしましょう。 あなたがセルの配列のすべての要素を同
じ数値 n で除算したいとします。 これを素直に実装すると以下のようになりま
す:

     : array/ ( addr u n -- )
       -rot cells bounds u+do
         i @ over / i !
       1 cells +loop
       drop ;

   より効率的なバージョンは以下のようになります:

     : array/ ( addr u n -- )
       {: | reci[ staged/-size ] :}
       reci[ /f-stage1m
       cells bounds u+do
         i @ reci[ /f-stage2m i !
       1 cells +loop ;

   この例では、 まず、 逆数データを格納するためのサイズ ‘staged/-size’ の
ローカル・バッファー ‘reci[’ を作成します。 次に、 ‘/f-stage1m’ は n の
逆数を計算し、 ‘reci[’ に格納します。 最後に、 ループ内で ‘/f-stage2m’ が
‘reci[’ のデータを使用して除算の商を計算します。

   これにはいくつかの制限があります。 ‘/f-stage1m’ では正の除数のみがサ
ポートされます。 ‘u/-stage1m’ には 2 以上の数を使用できます。 サポートさ
れていない除数を使用しようとすると、 エラーが発生します。 floored 第2ス
テージ・ワードの相互(reciprocal)バッファーは ‘/f-stage1m’ で初期化し、 符
号な無しの第2ステージ・ワードの相互バッファーは ‘u/-stage1m’ で初期化す
る必要があります。 最初のステージと2番目のステージの間で相互バッファーを
変更してはなりません。 基本的に、 これはメモリ・バッファーとして扱うので
はなく、 最初のステージでのみ変更可能なものとして扱います。 このルールの
ポイントは、 Gforth の将来のバージョンではこのバッファーのエイリアスが考
慮されないということです。

   これらのワードが以下です:

‘staged/-size’ ( – u  ) gforth-1.0 “staged-slash-size”
   ‘u/-stage1m’ または ‘/f-stage1m’ のバッファーのサイズ。

‘/f-stage1m’ ( n addr-reci –  ) gforth-1.0 “slash-f-stage1m”
   n の逆数を計算し、 サイズ ‘staged/-size’ のバッファー addr-reci に格
納します。 n<1 の場合、 エラーを出します(throw)。

‘/f-stage2m’ ( n1 a-reci – nquotient ) gforth-1.0 “slash-f-stage2m”
   Nquotient は、n1 を a-reci で表される除数で除算した結果であり、
‘/f-stage1m’ によって計算されます。

‘modf-stage2m’ ( n1 a-reci – umodulus ) gforth-1.0 “mod-f-stage2m”
   Umodulus は、 n1 を a-reci で表される除数で割った余り(remainder)で、
‘/f-stage1m’ によって計算されます。

‘/modf-stage2m’ ( n1 a-reci – umodulus nquotient ) gforth-1.0 “slash-mod-f-stage2m”
   Nquotient は商で、 umodulus は n1 を a-reci で表される除数で割った余
り(remainder)で、 ‘/f-stage1m’ によって計算されます。

‘u/-stage1m’ ( u addr-reci –  ) gforth-1.0 “u-slash-stage1m”
   u の逆数を計算し、 サイズ ‘staged/-size’ のバッファー addr-reci に格
納します。 u<2 の場合、 エラーを出します(throw)。

‘u/-stage2m’ ( u1 a-reci – uquotient ) gforth-1.0 “u-slash-stage2m”
   Uquotient は、 u1 を a-reci で表される除数で除算した結果であり、
‘u/-stage1m’ によって計算されます。

‘umod-stage2m’ ( u1 a-reci – umodulus ) gforth-1.0 “u-mod-stage2m”
   Umodulus は、 u1 を a-reci で表される除数で割った余り(remainder)で、
‘u/-stage1m’ によって計算されます。

‘u/mod-stage2m’ ( u1 a-reci – umodulus uquotient ) gforth-1.0 “u-slash-mod-stage2m”
   Uquotient は商で、 umodulus は a-reci で表される除数で u1 を割った余
り(remainder)で、‘u/-stage1m’ によって計算されます。

   Gforth は現在、 段階的対称除算(staged symmetrical division)をサポート
していません。

   ‘staged/-divisor @’ を使用すると、 逆数(のアドレス)から除数を復旧
(recover)できます:

‘staged/-divisor’ ( addr1 – addr2  ) gforth-1.0 “staged-slash-divisor”
   Addr1 は逆数のアドレス、 addr2 は逆数の計算元となった除数を含むアドレ
スです。

   これは、Gforth の逆コンパイラー出力を確認するときに役立ちます。 定数
による除算は、 多くの場合、 逆数のアドレスとその後に続く第2ステージ・ワ
ードを含むリテラルにコンパイルされます。

   これらのワードを使用した場合のパフォーマンスへの影響は、 アーキテクチ
ャ(ハードウェア除算があるかどうか)と、 特定の実装(ハードウェア除算の速さ
はどれくらいか)に大きく依存しますが、 これらのワードの相対的なパフォーマ
ンスについてのアイデアを提供するために、 以下を示します。 2 つの AMD64 実
装でのマイクロ・ベンチマークの反復ごとのサイクルを以下に示します。 norm
列は通常の除算ワード(例: ‘u/’)を示し、stg2 列は対応する stage2 ワード(例
: ‘u/-stage2m’)を示します:

     intel Skylake       AMD Zen2
     norm stg2           norm stg2
     41.3 15.8 u/        35.2 21.4 u/
     39.8 19.7 umod      36.9 25.8 umod
     44.0 25.3 u/mod     43.0 33.9 u/mod
     48.7 16.9 /f        36.2 22.5 /f
     47.9 20.5 modf      37.9 27.1 modf
     53.0 24.6 /modf     45.8 35.4 /modf
         227.2 u/stage1      101.9 u/stage1
         159.8 /fstage1       97.7 /fstage1


File: gforth.info,  Node: Bitwise operations,  Next: Numeric comparison,  Prev: Two-stage integer division,  Up: Arithmetic

6.5.6 Bitwise operations
------------------------

‘and’ ( w1 w2 – w ) core “and”

‘or’ ( w1 w2 – w ) core “or”

‘xor’ ( w1 w2 – w ) core “x-or”

‘invert’ ( w1 – w2 ) core “invert”

‘mux’ ( u1 u2 u3 – u ) gforth-1.0 “mux”
   multiplex(多重化): u3 の各ビットについて、 そのビットが 1 の場合は u1
から対応するビットを選択し、 それ以外の場合は u2 から対応するビットを選
択します。 たとえば、 ‘%0011 %1100 %1010 mux’ は ‘%0110’ となります。

‘lshift’ ( u1 u – u2 ) core “l-shift”
   u1 を u ビット左シフトします。

‘rshift’ ( u1 u – u2 ) core “r-shift”
   u1 (セル) を u ビットだけ右にシフトし、 シフトインされたビットを 0 で
埋めます(論理/符号無しシフトです)。

‘arshift’ ( n1 u – n2 ) gforth-1.0 “ar-shift”
   n1 (セル) を u ビット右にシフトし、n1 の符号ビットからシフトインされ
たビットを埋めます (算術シフト)。

‘dlshift’ ( ud1 u – ud2 ) gforth-1.0 “dlshift”
   ud1 (2倍長セル) を u ビット左にシフトします。

‘drshift’ ( ud1 u – ud2 ) gforth-1.0 “drshift”
   ud1 (2倍長セル) を u ビットだけ右にシフトし、 シフトインされたビット
を 0 で埋めます (論理/符号なしシフト)。

‘darshift’ ( d1 u – d2 ) gforth-1.0 “darshift”
   d1 (2倍長セル) を u ビット右にシフトし、d1 の符号ビットからシフトイン
されたビットで埋めます (算術シフト)。

‘2*’ ( n1 – n2 ) core “two-star”
   1 つ左にシフトします。符号なしの数値でも機能します

‘2/’ ( n1 – n2 ) core “two-slash”
   1 つ右に算術シフトします。 符号付き数値の場合、 これは 2 による
floored division になります(‘/’ は必ずしも floors ではないことに注意して
ください)。

‘d2*’ ( d1 – d2 ) double “d-two-star”
   2倍長セルを左に 1 シフトします。 符号なしの数値でも機能します

‘d2/’ ( d1 – d2 ) double “d-two-slash”
   1 つ右に算術シフトします。 符号付き数値の場合、これは 2 による
floored division になります。

‘>pow2’ ( u1 – u2 ) gforth-1.0 “to-pow2”
   u2 は、u2>=u1 の最小の 2 のべき乗数です。

‘log2’ ( u – n ) gforth-1.0 “log2”
   N は u の切り捨て2進対数、 つまり最初に設定されたビットのインデックス
です。 u=0 の場合は n=-1 です。

‘pow2?’ ( u – f  ) gforth-1.0 “pow-two-query”
   f は、 u が 2 の累乗の場合、 つまり u のビットが 1 つだけセットされて
いる場合に true になります。

‘ctz’ ( x – u  ) gforth-1.0 “c-t-z”
   x の2進数表現で末尾からのゼロの数を数える

   他のほとんどの操作とは異なり、 幅の狭いユニットのローテートと幅の広い
ユニットのローテートを簡単に合成することはできないため、 1倍長セル幅およ
び 2倍幅のセル幅のローテート操作を使用すると、 結果がセル幅に依存するこ
とになります。 公開されたアルゴリズムまたはセル幅に依存しない結果の場合
、 通常は固定幅のローテート操作を使用する必要があります。

‘wrol’ ( u1 u – u2 ) gforth-1.0 “wrol”
   u1 の下位側 16 ビットを u ビットだけ左に回転し、 他のビットを 0 にセ
ットします。

‘wror’ ( u1 u – u2 ) gforth-1.0 “wror”
   u1 の下位側 16 ビットを u ビットだけ右回転し、 他のビットを 0 にセッ
トします。

‘lrol’ ( u1 u – u2 ) gforth-1.0 “lrol”
   u1 の下位側 32 ビットを u ビットだけ左に回転し、 他のビットを 0 にセ
ットします。

‘lror’ ( u1 u – u2 ) gforth-1.0 “lror”
   u1 の下位側 32 ビットを u ビットだけ右回転し、 他のビットを 0 にセッ
トします。

‘rol’ ( u1 u – u2 ) gforth-1.0 “rol”
   u1 のすべてのビットを u ビットだけ左に回転します。

‘ror’ ( u1 u – u2 ) gforth-1.0 “ror”
   u1 のすべてのビットを u ビットだけ右回転します。

‘drol’ ( ud1 u – ud2 ) gforth-1.0 “drol”
   ud1 (2倍長セル) のすべてのビットを u ビットだけ左に回転します。

‘dror’ ( ud1 u – ud2 ) gforth-1.0 “dror”
   ud1 (2倍長セル) のすべてのビットを u ビット右に回転します。


File: gforth.info,  Node: Numeric comparison,  Next: Floating Point,  Prev: Bitwise operations,  Up: Arithmetic

6.5.7 Numeric comparison
------------------------

注意: 等しいかどうかを比較するワード(‘= <> 0= 0<> d= d<> d0= d0<>’) は、
符号付き数値と符号なし数値の両方に対して機能することに注意してください。

‘<’ ( n1 n2 – f ) core “less-than”

‘<=’ ( n1 n2 – f ) gforth-0.2 “less-or-equal”

‘<>’ ( n1 n2 – f ) core-ext “not-equals”

‘=’ ( n1 n2 – f ) core “equals”

‘>’ ( n1 n2 – f ) core “greater-than”

‘>=’ ( n1 n2 – f ) gforth-0.2 “greater-or-equal”

‘0<’ ( n – f ) core “zero-less-than”

‘0<=’ ( n – f ) gforth-0.2 “zero-less-or-equal”

‘0<>’ ( n – f ) core-ext “zero-not-equals”

‘0=’ ( n – f ) core “zero-equals”

‘0>’ ( n – f ) core-ext “zero-greater-than”

‘0>=’ ( n – f ) gforth-0.2 “zero-greater-or-equal”

‘u<’ ( u1 u2 – f ) core “u-less-than”

‘u<=’ ( u1 u2 – f ) gforth-0.2 “u-less-or-equal”

‘u>’ ( u1 u2 – f ) core-ext “u-greater-than”

‘u>=’ ( u1 u2 – f ) gforth-0.2 “u-greater-or-equal”

‘within’ ( u1 u2 u3 – f ) core-ext “within”
   u2<u3 かつ u1 が [u2,u3) にある(u2 < u3 and u2 <= u1 < u3 )、 または
u2 >= u3 かつ u1 が [u3,u2) にない( u2 >= u3 and (u1 not in (u3 <= and <
u2)。 これは、 符号なしの数値と符号付きの数値に対して機能します(ただし、
混ぜてはいけません)。 このワードについて考えるもう 1 つの方法は、 数値を
循環として考えることです(符号なしの数値の場合は ‘max-u’ から 0 まで、 符
号付きの数値の場合は ‘max-n’ から min-n まで循環します)。ここで、 u2 か
ら u3 までの増加する数値(u3 を除く)の範囲を検討します(u2=u3 の場合は空の
範囲を与えます)。 u1 がこの範囲内にある場合、 ‘within’ は true を返しま
す。

‘d<’ ( d1 d2 – f ) double “d-less-than”

‘d<=’ ( d1 d2 – f ) gforth-0.2 “d-less-or-equal”

‘d<>’ ( d1 d2 – f ) gforth-0.2 “d-not-equals”

‘d=’ ( d1 d2 – f ) double “d-equals”

‘d>’ ( d1 d2 – f ) gforth-0.2 “d-greater-than”

‘d>=’ ( d1 d2 – f ) gforth-0.2 “d-greater-or-equal”

‘d0<’ ( d – f ) double “d-zero-less-than”

‘d0<=’ ( d – f ) gforth-0.2 “d-zero-less-or-equal”

‘d0<>’ ( d – f ) gforth-0.2 “d-zero-not-equals”

‘d0=’ ( d – f ) double “d-zero-equals”

‘d0>’ ( d – f ) gforth-0.2 “d-zero-greater-than”

‘d0>=’ ( d – f ) gforth-0.2 “d-zero-greater-or-equal”

‘du<’ ( ud1 ud2 – f ) double-ext “d-u-less-than”

‘du<=’ ( ud1 ud2 – f ) gforth-0.2 “d-u-less-or-equal”

‘du>’ ( ud1 ud2 – f ) gforth-0.2 “d-u-greater-than”

‘du>=’ ( ud1 ud2 – f ) gforth-0.2 “d-u-greater-or-equal”


File: gforth.info,  Node: Floating Point,  Prev: Numeric comparison,  Up: Arithmetic

6.5.8 Floating Point
--------------------

浮動小数点数を認識するためにテキスト・インタープリターで使用されるルール
については、 *note Number Conversion:: を参照してください。

   Gforth には別個の浮動小数点スタックがありますが、 ドキュメントでは一
緒に統一した表記が使用されています(1)。

   浮動小数点数は、 不注意な人にとっては多くの不快な驚きをもたらします
(たとえば、浮動小数点の加算は結合的(associative)ではありません)。 また、
用心深い人にとってもいくつかの不快な驚きさえあります。 自分が何をしてい
るのか理解していない場合、 または得られる結果が完全に偽物であることを気
にしない場合を除き、 これらを使用すべきではありません。 浮動小数点数の問
題(およびその回避方法)について知りたい場合は、 ‘David Goldberg, What
Every Computer Scientist Should Know About Floating-Point Arithmetic
(https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html), ACM
Computing Surveys 23(1):5−48, March 1991’ から始めると良いでしょう(訳注:
<https://docs.oracle.com/cd/E19957-01/806-4847/ncg_goldberg.html> これが
合ってるかどうか不明。一部文字化けあり2024/06現在)。

   整数と浮動小数点の間の変換:

‘s>f’ ( n – r ) floating-ext “s-to-f”

‘d>f’ ( d – r ) floating “d-to-f”

‘f>s’ ( r – n ) floating-ext “f-to-s”

‘f>d’ ( r – d ) floating “f-to-d”

   算術演算:

‘f+’ ( r1 r2 – r3 ) floating “f-plus”

‘f-’ ( r1 r2 – r3 ) floating “f-minus”

‘f*’ ( r1 r2 – r3 ) floating “f-star”

‘f/’ ( r1 r2 – r3 ) floating “f-slash”

‘fnegate’ ( r1 – r2 ) floating “f-negate”

‘fabs’ ( r1 – r2 ) floating-ext “f-abs”

‘fcopysign’ ( r1 r2 – r3  ) gforth-1.0 “fcopysign”
   r3 は r1 から絶対値を取得し r2 から符号を取得します

‘fmax’ ( r1 r2 – r3 ) floating “f-max”

‘fmin’ ( r1 r2 – r3 ) floating “f-min”

‘floor’ ( r1 – r2 ) floating “floor”
   次に小さい整数値に向かって丸めます。 つまり、 負の無限大に向かって丸
めます。

‘fround’ ( r1 – r2 ) floating “f-round”
   最も近い整数値に丸めます(訳注: 0.5e – 0, 0.50e – 0, 0.51e – 1, 1.5e –
2, ...  ??)

‘ftrunc’ ( r1 – r2  ) floating-ext “f-trunc”
   0 に向かって丸める(正数でも負数でも)

‘f**’ ( r1 r2 – r3 ) floating-ext “f-star-star”
   r3 は r1 の r2 乗です

‘fsqrt’ ( r1 – r2 ) floating-ext “f-square-root”

‘fexp’ ( r1 – r2 ) floating-ext “f-e-x-p”

‘fexpm1’ ( r1 – r2 ) floating-ext “f-e-x-p-m-one”
   r2=e**r1−1

‘fln’ ( r1 – r2 ) floating-ext “f-l-n”

‘flnp1’ ( r1 – r2 ) floating-ext “f-l-n-p-one”
   r2=ln(r1+1)

‘flog’ ( r1 – r2 ) floating-ext “f-log”
   常用対数(decimal logarithm)

‘falog’ ( r1 – r2 ) floating-ext “f-a-log”
   r2=10**r1

‘f2*’ ( r1 – r2  ) gforth-0.2 “f2*”
   r1 に 2.0e0 を掛けた値

‘f2/’ ( r1 – r2  ) gforth-0.2 “f2/”
   r1 に 0.5e0 を掛けた値

‘1/f’ ( r1 – r2  ) gforth-0.2 “1/f”
   1.0e0 を r1 で割った値

   ベクトル演算:

‘v*’ ( f-addr1 nstride1 f-addr2 nstride2 ucount – r ) gforth-0.5 “v-star”
   ドット積(dot-product): r=v1*v2 v1 の最初の要素は f_addr1 にあり、 次
の要素は f_addr1+nstride1 というようになります(v2 も同様)。 どちらのベク
トルにも ucount の数の要素があります。

‘faxpy’ ( ra f-x nstridex f-y nstridey ucount – ) gforth-0.5 “faxpy”
   vy=ra*vx+vy

   浮動小数点演算の角度はラジアン(radians)で指定します(完全な円は 2πラジ
アンです)。

‘fsin’ ( r1 – r2 ) floating-ext “f-sine”

‘fcos’ ( r1 – r2 ) floating-ext “f-cos”

‘fsincos’ ( r1 – r2 r3 ) floating-ext “f-sine-cos”
   r2=sin(r1), r3=cos(r1)

‘ftan’ ( r1 – r2 ) floating-ext “f-tan”

‘fasin’ ( r1 – r2 ) floating-ext “f-a-sine”

‘facos’ ( r1 – r2 ) floating-ext “f-a-cos”

‘fatan’ ( r1 – r2 ) floating-ext “f-a-tan”

‘fatan2’ ( r1 r2 – r3 ) floating-ext “f-a-tan-two”
   r1/r2=tan(r3) ANS Forth ではそこまで求められてはいないのですが、 おそ
らくこれが ‘fsincos’ の逆になることを意図していて、 gforth ではそのよう
になっています。

‘fsinh’ ( r1 – r2 ) floating-ext “f-cinch”

‘fcosh’ ( r1 – r2 ) floating-ext “f-cosh”

‘ftanh’ ( r1 – r2 ) floating-ext “f-tan-h”

‘fasinh’ ( r1 – r2 ) floating-ext “f-a-cinch”

‘facosh’ ( r1 – r2 ) floating-ext “f-a-cosh”

‘fatanh’ ( r1 – r2 ) floating-ext “f-a-tan-h”

‘pi’ ( – r  ) gforth-0.2 “pi”
   ‘Fconstant’(定数) – r は値 pi です(π)。 円の面積と直径の比率。

   浮動小数点演算に関する特別な問題の 1 つは、 等価性の比較が、 成功する
はずなのに失敗することがよくあることです。 このため、 多くの場合、 近似
的等価性が好まれます(ただし、 自分が何をしているのかを理解しておく必要が
あります)。 また、 IEEE NaN の比較があなたの予想とは異なる場合があること
にも注意してください。 比較ワードは以下のとおりです:

‘f~rel’ ( r1 r2 r3 – flag  ) gforth-0.5 “f~rel”
   相対誤差を含む近似等価性: |r1-r2|<r3*|r1+r2|

‘f~abs’ ( r1 r2 r3 – flag  ) gforth-0.5 “f~abs”
   Approximate equality with absolute error: |r1-r2|<r3.< 絶対誤差を伴う
近似等価性: |r1-r2|<r3

‘f~’ ( r1 r2 r3 – flag  ) floating-ext “f-proximate”
   r1 と r2 が等しいかどうかを比較するための ANS Forth ワードごたまぜ:
r3>0 なら ‘f~abs’; r3=0 なら ビット単位の比較; r3<0 なら ‘fnegate f~rel’

‘f=’ ( r1 r2 – f ) gforth-0.2 “f-equals”

‘f<>’ ( r1 r2 – f ) gforth-0.2 “f-not-equals”

‘f<’ ( r1 r2 – f ) floating “f-less-than”

‘f<=’ ( r1 r2 – f ) gforth-0.2 “f-less-or-equal”

‘f>’ ( r1 r2 – f ) gforth-0.2 “f-greater-than”

‘f>=’ ( r1 r2 – f ) gforth-0.2 “f-greater-or-equal”

‘f0<’ ( r – f ) floating “f-zero-less-than”

‘f0<=’ ( r – f ) gforth-0.2 “f-zero-less-or-equal”

‘f0<>’ ( r – f ) gforth-0.2 “f-zero-not-equals”

‘f0=’ ( r – f ) floating “f-zero-equals”

‘f0>’ ( r – f ) gforth-0.2 “f-zero-greater-than”

‘f0>=’ ( r – f ) gforth-0.2 “f-zero-greater-or-equal”

   IEEE754 の特別な値は、 たとえばゼロで除算することによって導出できます
。 最も一般的なものは、使いやすいように浮動小数点定数として定義されてい
ます。

‘infinity’ ( – r  ) gforth-1.0 “infinity”
   浮動小数点数 (正の)無限大(floating point infinity)

‘-infinity’ ( – r  ) gforth-1.0 “-infinity”
   浮動小数点数 負の無限大(-infinity)

‘NaN’ ( – r  ) gforth-1.0 “NaN”
   浮動小数点数 NaN(Not a Number)

   ---------- Footnotes ----------

   (1) この一緒にした表記から、 浮動小数点数だけを分離するだけで、 簡単
に分離された表記にできます。 例えば: ‘( n r1 ur2 -- r3 )’ は ‘( n u -- )
( F: r1 r2 -- r3 )’ になります


File: gforth.info,  Node: Stack Manipulation,  Next: Memory,  Prev: Arithmetic,  Up: Words

6.6 Stack Manipulation
======================

Gforth は、 いくつかの個別のスタックを維持します:

   • データ・スタック(「パラメータ・スタック」とも呼ばれます) – 文字
     (characters)と、 セル(cells)と、 アドレス(addresses)と、 2倍長セル
     (double cells) 用

   • 浮動小数点スタック – 浮動小数点 (FP) 数を保持します。

   • リターン・スタック – コロン定義およびその他の(FP 以外の)データのリ
     ターン・アドレスを保持します。

   • ローカル・スタック – ローカル変数を保持します。

* Menu:

* Data stack::
* Floating point stack::
* Return stack::
* Locals stack::
* Stack pointer manipulation::


File: gforth.info,  Node: Data stack,  Next: Floating point stack,  Prev: Stack Manipulation,  Up: Stack Manipulation

6.6.1 Data stack
----------------

‘drop’ ( w – ) core “drop”

‘nip’ ( w1 w2 – w2 ) core-ext “nip”

‘dup’ ( w – w w ) core “dupe”

‘over’ ( w1 w2 – w1 w2 w1 ) core “over”

‘third’ ( w1 w2 w3 – w1 w2 w3 w1 ) gforth-1.0 “third”

‘fourth’ ( w1 w2 w3 w4 – w1 w2 w3 w4 w1 ) gforth-1.0 “fourth”

‘tuck’ ( w1 w2 – w2 w1 w2 ) core-ext “tuck”

‘swap’ ( w1 w2 – w2 w1 ) core “swap”

‘pick’ ( S:... u – S:... w ) core-ext “pick”
   実際のスタック効果は ‘ x0 ... xu u -- x0 ... xu x0 ’ です。

‘rot’ ( w1 w2 w3 – w2 w3 w1 ) core “rote”

‘-rot’ ( w1 w2 w3 – w3 w1 w2 ) gforth-0.2 “not-rote”

‘?dup’ ( w – S:... w ) core “question-dupe”
   実際のスタック効果は次のとおりです: ‘( w -- 0 | w w )’ つまり w がゼ
ロ以外の場合、 ‘dup’ が実行されます。

‘roll’ ( x0 x1 .. xn n – x1 .. xn x0  ) core-ext “roll”

‘2drop’ ( w1 w2 – ) core “two-drop”

‘2nip’ ( w1 w2 w3 w4 – w3 w4 ) gforth-0.2 “two-nip”

‘2dup’ ( w1 w2 – w1 w2 w1 w2 ) core “two-dupe”

‘2over’ ( w1 w2 w3 w4 – w1 w2 w3 w4 w1 w2 ) core “two-over”

‘2tuck’ ( w1 w2 w3 w4 – w3 w4 w1 w2 w3 w4 ) gforth-0.2 “two-tuck”

‘2swap’ ( w1 w2 w3 w4 – w3 w4 w1 w2 ) core “two-swap”

‘2rot’ ( w1 w2 w3 w4 w5 w6 – w3 w4 w5 w6 w1 w2 ) double-ext “two-rote”


File: gforth.info,  Node: Floating point stack,  Next: Return stack,  Prev: Data stack,  Up: Stack Manipulation

6.6.2 Floating point stack
--------------------------

‘fdrop’ ( r – ) floating “f-drop”

‘fnip’ ( r1 r2 – r2 ) gforth-0.2 “f-nip”

‘fdup’ ( r – r r ) floating “f-dupe”

‘fover’ ( r1 r2 – r1 r2 r1 ) floating “f-over”

‘fthird’ ( r1 r2 r3 – r1 r2 r3 r1 ) gforth-1.0 “fthird”

‘ffourth’ ( r1 r2 r3 r4 – r1 r2 r3 r4 r1 ) gforth-1.0 “ffourth”

‘ftuck’ ( r1 r2 – r2 r1 r2 ) gforth-0.2 “f-tuck”

‘fswap’ ( r1 r2 – r2 r1 ) floating “f-swap”

‘fpick’ ( f:... u – f:... r ) gforth-0.4 “fpick”
   実際のスタック効果は ‘ r0 ... ru u -- r0 ... ru r0 ’

‘frot’ ( r1 r2 r3 – r2 r3 r1 ) floating “f-rote”

‘f-rot’ ( r1 r2 r3 – r3 r1 r2 ) floating “f-not-rote”


File: gforth.info,  Node: Return stack,  Next: Locals stack,  Prev: Floating point stack,  Up: Stack Manipulation

6.6.3 Return stack
------------------

Forth システムは、 リターン・スタックにローカル変数を保持することができ
ます。 通常、 ローカル変数を使用すると、 リターン・スタックを明示的に使
用する必要がなくなるため、 これは合理的です。 したがって、 標準に準拠し
たプログラムを作成する場合で、 ワード内でローカル変数を使用している場合
は、 そのワード内でのリターン・スタック操作のことは忘れてください(正確な
ルールについては標準ドキュメントを参照してください)。

‘>r’ ( w – R:w ) core “to-r”

‘r>’ ( R:w – w ) core “r-from”

‘r@’ ( – w ; R: w – w  ) core “r-fetch”

‘rdrop’ ( R:w – ) gforth-0.2 “rdrop”

‘2>r’ ( w1 w2 – R:w1 R:w2 ) core-ext “two-to-r”

‘2r>’ ( R:w1 R:w2 – w1 w2 ) core-ext “two-r-from”

‘2r@’ ( R:w1 R:w2 – R:w1 R:w2 w1 w2 ) core-ext “two-r-fetch”

‘2rdrop’ ( R:w1 R:w2 – ) gforth-0.2 “two-r-drop”

‘n>r’ ( x1 .. xn n – r:xn..x1 r:n  ) tools-ext “n-to-r”

‘nr>’ ( r:xn..x1 r:n – x1 .. xn n  ) tools-ext “n-r-from”


File: gforth.info,  Node: Locals stack,  Next: Stack pointer manipulation,  Prev: Return stack,  Up: Stack Manipulation

6.6.4 Locals stack
------------------

Gforth で追加のローカル・スタックを使用します。 これは、 その存在理由を
含めて *note Locals implementation:: にて説明されています。


File: gforth.info,  Node: Stack pointer manipulation,  Prev: Locals stack,  Up: Stack Manipulation

6.6.5 Stack pointer manipulation
--------------------------------

‘sp0’ ( – a-addr  ) gforth-0.4 “sp0”
   ユーザー変数 – データ・スタック・ポインターの初期値。

‘sp@’ ( S:... – a-addr ) gforth-0.2 “sp-fetch”

‘sp!’ ( a-addr – S:... ) gforth-0.2 “sp-store”

‘fp0’ ( – a-addr  ) gforth-0.4 “fp0”
   ユーザー変数 – 浮動小数点スタック・ポインターの初期値。

‘fp@’ ( f:... – f-addr ) gforth-0.2 “fp-fetch”

‘fp!’ ( f-addr – f:... ) gforth-0.2 “fp-store”

‘rp0’ ( – a-addr  ) gforth-0.4 “rp0”
   ユーザー変数 – リターン・スタック・ポインターの初期値。

‘rp@’ ( – a-addr ) gforth-0.2 “rp-fetch”

‘rp!’ ( a-addr – ) gforth-0.2 “rp-store”

‘lp0’ ( – a-addr  ) gforth-0.4 “lp0”
   ユーザー変数 – ローカル・スタック・ポインターの初期値。

‘lp@’ ( – c-addr ) gforth-0.2 “lp-fetch”
   C_addr は、 ローカル・スタック・ポインターの現在の値です。

‘lp!’ ( c-addr – ) gforth-internal “lp-store”


File: gforth.info,  Node: Memory,  Next: Strings and Characters,  Prev: Stack Manipulation,  Up: Words

6.7 Memory
==========

* Menu:

* Memory model::
* Dictionary allocation::
* Heap Allocation::
* Memory Access::
* Special Memory Accesses::
* Address arithmetic::
* Memory Blocks::

標準 Forth のメモリ割り当てワードに加えて ガベージ・コレクター(garbage
collector)
(https://www.complang.tuwien.ac.at/forth/garbage-collection.zip) もあり
ます。


File: gforth.info,  Node: Memory model,  Next: Dictionary allocation,  Prev: Memory,  Up: Memory

6.7.1 Memory model
------------------

標準 Forth は、 Forth システムが複数のアドレス空間で構成されているとみな
します。 そのうちの「データ空間」(data space)のみを管理し、 メモリ・ワー
ドでアクセスできます。 メモリには、 スタックと、 コード(コード空間(code
space))と呼ばれる)と、 ヘッダー(名前空間(name space)と呼ばれる)とが含ま
れ、 それらは必ずしもデータ空間にある必要はありません。 Gforth ではすべ
てがデータ空間内にありますが、 プリミティブのコードは通常読み取り専用で
す。

   データ空間は、 いくつかの領域に分割されます。 ディクショナリ
(dictionary)(1)と、 ヒープと、 システムによって割り当てられた多数のバッ
ファーから成ります。

   Gforth は 1 つの大きなアドレス空間を提供し、 その任意のアドレス間でア
ドレス演算を実行できます。 ただし、 ディクショナリではヘッダーまたはコー
ドがデータと代わる代わる出てくるため(interleaved)、 連続するデータ空間領
域は、 標準 Forth で連続していると記述されているものだけがほとんどです。
しかし、 連続する領域間であっても、 増加するアドレス方向にディクショナリ
が確実に割り当てられます。 ヒープ内でのメモリ割り当ての順序はプラットフ
ォームに依存します(また、実行ごとに異なる可能性もあります)。

   ---------- Footnotes ----------

   (1) 「ディクショナリ」(辞書)という用語は、 従来の辞書と同じように名前
を検索するために使用される、 ワード・リストやヘッダーに組み込まれた検索
データ構造を指すために使用されることがあります


File: gforth.info,  Node: Dictionary allocation,  Next: Heap Allocation,  Prev: Memory model,  Up: Memory

6.7.2 Dictionary allocation
---------------------------

ディクショナリの割り当てはスタック指向の割り当てスキーム(stack-oriented
allocation scheme)です。 つまり、 X の割り当てを解除したい場合は、 X の
後に割り当てられたすべての割り当ても解除します。

   以下のワード達を使用した割り当ては連続しており、 アドレスの増加方向に
向けて領域が拡張されます。 あらゆる種類のディクショナリ・メモリを割り当
てる他のワード(つまり、 ‘:noname’ を含む定義ワード)は、 連続領域
(contiguous region)を終了し、 新しい領域を開始します。

   標準 Forth では、 ‘create’ されたワードのみが、 後続の連続領域の開始
となるアドレスを生成することが保証されています。 特に、 ‘variable’ によ
って割り当てられたセルが、 後続の ‘allot’ で割り当てられたメモリと連続し
ていることは保証されません。

   ‘allot’ に負の引数を指定して使用すると、 メモリの割り当てを解除できま
す(いくつかの制限があります。 ‘allot’ を参照してください)。 大規模な割り
当て解除の場合は、 ‘marker’ を使用します。

‘here’ ( – addr  ) core “here”
   データ空間内の次の空き位置のアドレスを返します。

‘unused’ ( – u  ) core-ext “unused”
   ‘here’ でアドレス指定された領域(以降)に残っている空き領域の量をアドレ
ス単位(address units)で返します。

‘allot’ ( n –  ) core “allot”
   初期化せずに、 データ空間に n アドレス単位を予約します。 n は符号付き
の数値で、 負の n を渡すとメモリが解放されます。 ANS Forth では、この方
法で現在の連続領域からメモリの割り当てを解除することしかできません。
Gforth では、この方法で名前付きワード以外のあらゆるものを割り当て解除で
きます。 システムはこの制限をチェックしません。

‘->here’ ( addr –  ) gforth-1.0 “to-here”
   ‘here’ の値を addr に変更します。

‘c,’ ( c –  ) core “c-comma”
   文字(char)用に1つのデータ空間を予約し、 その空間に c を格納します。

‘f,’ ( f –  ) gforth-0.2 “f,”
   浮動小数点数(floating-point number)用の1つのデータ空間を予約し、 その
空間に f を格納します。

‘,’ ( w –  ) core “comma”
   セル(cell)用の1つのデータ空間を予約し、 その空間に w を格納します。

‘2,’ ( w1 w2 –  ) gforth-0.2 “2,”
   2つのセル用のデータ空間を予約し、 そこに w1 w2 格納します。 最初(低位
アドレス側)に w2 を格納します。

‘w,’ ( w –  ) gforth-1.0 “w-comma”

‘l,’ ( l –  ) gforth-1.0 “l-comma”

‘x,’ ( x –  ) gforth-1.0 “x-comma”

‘xd,’ ( xd –  ) gforth-1.0 “x-d-comma”

‘A,’ ( addr –  ) gforth-0.2 “A,”
   1 つのセル用のデータ空間を予約し、 そこに addr を格納します。 私達の
クロス・コンパイラーの場合には、 再配置可能なイメージに必要な型情報(type
information)を提供します。 ただし、 通常では、 これは ‘,’ と同等です。

‘mem,’ ( addr u –  ) gforth-0.6 “mem,”

   ‘save-mem-dict’ ( addr1 u – addr2 u ) \ 訳注:文字列をhereからのディク
ショナリに書き込み、その(ディクショナリ上の)文字列を返します

   メモリ・アクセスはアライメントする必要があります(*note Address
arithmetic::)。 したがって、 メモリ割り当てもアライメントされるべきです
。 つまり、 セルを割り当てる前に、 ‘here’ をセル・アライメントする必要が
あります。 以下のワード達は、 ‘here’ が既に指定の型のアライメントに合っ
ている状態で無い場合は合わせます。 基本的に、 既に割り当てたのがその型の
サイズの倍数であり、 かつ、 ‘here’ が以前にその型のアライメントに対して
合うようにしてあった場合にのみ、 その型のアライメントに対して既にすでに
合っているということが言えます。

   新しくワードを ‘create’ した後、‘here’ は 標準 Forth では ‘align’ さ
れます(Gforth では ‘maxalign’ されます)。

‘align’ ( –  ) core “align”
   データ空間ポインターがアライメントできてない場合は、 アライメントする
のに十分な空間を予約します。

‘falign’ ( –  ) floating “f-align”
   データ空間ポインターが浮動小数点数にアライメントされていない場合は、
アライメントするのに十分な空間を予約します。

‘sfalign’ ( –  ) floating-ext “s-f-align”
   データ空間ポインターが単精度浮動小数点数にアライメントされていない場
合は、 アライメントするのに十分な空間を予約します。

‘dfalign’ ( –  ) floating-ext “d-f-align”
   データ空間ポインターが倍精度浮動小数点数にアライメントされていない場
合は、 アライメントするのに十分な空間を予約します。

‘maxalign’ ( –  ) gforth-0.2 “maxalign”
   すべてのアライメント要件に合わせてデータ空間ポインターをアライメント
します。

‘cfalign’ ( –  ) gforth-0.2 “cfalign”
   データ空間ポインターをコード・フィールドの要件に合わせてアライメント
します(つまり、 対応する本体が maxalign された状態になるようにする)。


File: gforth.info,  Node: Heap Allocation,  Next: Memory Access,  Prev: Dictionary allocation,  Up: Memory

6.7.3 Heap allocation
---------------------

ヒープ割り当ては、 割り当てられたメモリの割り当て解除を任意の順序でサポ
ートします。 ディクショナリの割り当ては影響を受けません(つまり、 連続領
域(contiguous region)は終了しません)。 Gforth では、 これらのワードは標
準の C ライブラリ呼び出しである malloc() や free() や realloc() を使用し
て実装されます。

   ‘allocate’ または ‘resize’ の 1 回の呼び出しによって生成されるメモリ
領域は、 内部的に連続しています。 このような領域と他の領域(ヒープから割
り当てられた他の領域を含む)との間には連続性はありません。

‘allocate’ ( u – a_addr wior  ) memory “allocate”
   連続したデータ空間を u アドレス単位分割り当てます。 データ空間の初期
内容は未定義です。 割り当てが成功した場合、 a-addr は割り当てられた領域
の開始アドレスで、 wior は 0 になります。 割り当てが失敗した場合、
a-addr は未定義で、 wior ゼロ以外の I/O 結果コードです。

‘free’ ( a_addr – wior  ) memory “free”
   a-addr で始まるデータ空間の領域をシステムに返します。 領域は元々
‘allocate’ または ‘resize’ を使用して取得されている必要があります。 操作
が成功した場合、 wior は 0 になります。 操作が失敗した場合、 wior はゼロ
以外の I/O 結果コードになります。

‘resize’ ( a_addr1 u – a_addr2 wior  ) memory “resize”
   a-addr1 に割り当てられた領域のサイズを u アドレス単位に変更します。 但
し内容を別の領域に移動する可能性があります。 a-addr2 は、 結果の領域のア
ドレスです。 操作が成功した場合、 wior は 0 になります。 操作が失敗した
場合、 wior はゼロ以外の I/O 結果コードになります。 a-addr1 が 0 の場合
、 Gforth の (非標準の ) ‘resize’ は u アドレス単位の割り当てを行います
。

   以下のワード達はメモリ・ブロックを扱うのに役立ちます:

‘save-mem’ ( addr1 u – addr2 u  ) gforth-0.2 “save-mem”
   指定のメモリ・ブロックをヒープ内で新しく割り当てられた領域にコピーし
ます。

‘free-mem-var’ ( addr –  ) gforth-experimental “free-mem-var”
   addr は、 メモリ範囲のアドレスとサイズを含む 2variable のアドレスです
。 これはメモリを解放し、 2variable をクリアします。

‘extend-mem’ ( addr1 u1 u – addr addr2 u2  ) gforth-experimental “extend-mem”
   u (アドレス単位)によってヒープから割り当てられたメモリ・ブロック
addr1 u1 を拡張します。 (おそらく再割り当てされた)開始アドレスは addr2 で
、 その合計長さは u2 で、 拡張部分の開始アドレスは addr です(訳注: 例え
ば元々長さ10のブロックを5拡張すると( addr1 10 5 – addr2+10 addr2 10+5))

   $tring ワード群は、 メモリ・ブロックの処理にも使用できます。 *Note
＄tring words:: (訳注: $tring (ダラー tring)と String (エス string) とあ
ることに注意)

   拡張可能なメモリ・バッファーの場合は、 $trings または以下のワード群を
使用できます。 ‘adjust-buffer’ で管理されるバッファーに割り当てられたメ
モリは縮小できないため、 これまでに確認された最大サイズよりも小さいサイ
ズにバッファーを調整(adjust)するときはヒープ管理のオーバーヘッドは発生し
ません。

‘buffer%’ ( – u1 u2  ) gforth-experimental “buffer%”
   u1 は アライメント(alignment)、 u2 は バッファー・デスクリプタのサイ
ズです。

‘init-buffer’ ( addr –  ) gforth-experimental “init-buffer”

‘adjust-buffer’ ( u addr –  ) gforth-experimental “adjust-buffer”
   addr の buffer% を長さ u に調整します。 これにより、 割り当てられた領
域が拡大する可能性がありますが、 決して縮小されることはありません。

   ‘2@’ を使用すると、 このようなバッファーの現在のアドレスと長さを取得
できます。

   典型的な使い方:

     create mybuf  buffer% %size allot  mybuf init-buffer
     s" frobnicate" mybuf adjust-buffer  mybuf 2@ move
     mybuf 2@ type
     s" foo"        mybuf adjust-buffer  mybuf 2@ move
     mybuf 2@ type


File: gforth.info,  Node: Memory Access,  Next: Special Memory Accesses,  Prev: Heap Allocation,  Up: Memory

6.7.4 Memory Access
-------------------

‘@’ ( a-addr – w ) core “fetch”
   a_addr に保存されているセルを w に取得します。

‘!’ ( w a-addr – ) core “store”
   w を a-addr のセルに格納します。

‘+!’ ( n a-addr – ) core “plus-store”
   a-addr のセルに n を加算します。

‘c@’ ( c-addr – c ) core “c-fetch”
   c_addr に保存されている文字(char) を c に取得します。

‘c!’ ( c c-addr – ) core “c-store”
   c を c-addr の char に格納します。

‘2@’ ( a-addr – w1 w2 ) core “two-fetch”
   w2 は a-addr に格納されているセルの内容、 w1 はその次のセルの内容です
。

‘2!’ ( w1 w2 a-addr – ) core “two-store”
   w2 を c-addr のセルに格納し、 w1 をその次のセルに格納します。

‘f@’ ( f-addr – r ) floating “f-fetch”
   アドレス f-addr の浮動小数点数を r に取得します。

‘f!’ ( r f-addr – ) floating “f-store”
   r をアドレス f-addr の浮動小数点数として格納します。

‘sf@’ ( sf-addr – r ) floating-ext “s-f-fetch”
   アドレス sf-addr から 単精度 IEEE 浮動小数点値を r に取得します。

‘sf!’ ( r sf-addr – ) floating-ext “s-f-store”
   r を単精度 IEEE 浮動小数点値としてアドレス sf-addr に格納します。

‘df@’ ( df-addr – r ) floating-ext “d-f-fetch”
   アドレス df-addr からの倍精度 IEEE 浮動小数点値を r に取得します。

‘df!’ ( r df-addr – ) floating-ext “d-f-store”
   r を 倍精度 IEEE 浮動小数点値としてアドレス df-addr からに保存します
。


File: gforth.info,  Node: Special Memory Accesses,  Next: Address arithmetic,  Prev: Memory Access,  Up: Memory

6.7.5 Special Memory Accesses
-----------------------------

このセクションでは、 他のソフトウェアや他のコンピュータと通信する際に役
立つメモリ・アクセスについて説明します。 これは、 アクセスが特定のビット
幅であり(Gforth のセル幅とは独立)、 自然な並びでない可能性があり、 通常
、 Gforth が実行されるシステムのネイティブなバイト順序(バイト・オーダー
)とは異なる可能性がある特定のバイト順序を持つことを意味します。

   私達は以下のプレフィックスを使います:

‘c’
     8ビット(文字;character)
‘w’
     16ビット
‘l’
     32ビット
‘x’
     64 ビットを 1 つのセルとして表現
‘xd’
     64 ビットを 2 つのセルとして表現

   ‘x’ プレフィックスのワードは 32 ビット・システムでは正しく機能しない
ため、 32 ビット・システムに移植することを目的としたコードの場合は、
‘xd’ プレフィックスのワードを使用する必要があります。 注意: ‘xd’ プレフ
ィックスのワードは 64 ビット・システムでも動作することに注意してください
。 64 ビット・システムでは、 上位のセルは単なる 0 (符号なし値の場合)、 ま
たは下位のセルの符号拡張です。

   以下のメモリ・アクセス・ワード群はすべて、 任意の(非)アライメントされ
たアドレスで動作します(一部のハードウェアでアライメントが必要な ‘@’ や
‘!’ や ‘f@’ や ‘f!’ とは異なります)。

‘w@’ ( c-addr – u ) gforth-0.5 “w-fetch”
   u は c_addr に格納されているゼロ拡張された 16 ビット値(zero-extended
16-bit value)です。

‘w!’ ( w c-addr – ) gforth-0.7 “w-store”
   w の下位 16 ビットを c_addr に格納します。

‘l@’ ( c-addr – u ) gforth-0.7 “l-fetch”
   u は、 c_addr に格納されているゼロ拡張された 32 ビット値
(zero-extended 32-bit value)です。

‘l!’ ( w c-addr – ) gforth-0.7 “l-store”
   w の下位 32 ビットを c_addr に格納します。

‘x@’ ( c-addr – u ) gforth-1.0 “x-fetch”
   u は、 c_addr に格納されているゼロ拡張された 64 ビット値です。

‘x!’ ( w c-addr – ) gforth-1.0 “x-store”
   w の下位 64 ビットを c_addr に格納します。

‘xd@’ ( c-addr – ud ) gforth-1.0 “x-d-fetch”
   ud は、 c_addr に格納されているゼロ拡張された 64 ビット値です。

‘xd!’ ( ud c-addr – ) gforth-1.0 “x-d-store”
   ud の下位 64 ビットを c_addr に格納します。

   特定のバイト順序(byte order)でアクセスする場合は、 取得直後(符号拡張
の前)、 または格納の直前にバイト順序調整を行う必要があります。 これらの
バイト順調整ワードの結果は常にゼロ拡張(zero-extended)されます。

‘wbe’ ( u1 – u2  ) gforth-1.0 “wbe”
   u1 の 16 ビット値をネイティブ・バイト順からビッグ・エンディアンに、 ま
たはビッグ・エンディアンからネイティブ・バイト順に変換します(両方は同一
の操作です)

‘wle’ ( u1 – u2  ) gforth-1.0 “wle”
   u1 の 16 ビット値をネイティブ・バイト順からリトル・エンディアンに、 ま
たはリトル・エンディアンからネイティブ・バイト順に変換します(両方の操作
は同一の操作です)

‘lbe’ ( u1 – u2  ) gforth-1.0 “lbe”
   u1 の 32 ビット値をネイティブ・バイト順からビッグ・エンディアンに、 ま
たはビッグ・エンディアンからネイティブ・バイト順に変換します(両方は同一
の操作です)

‘lle’ ( u1 – u2  ) gforth-1.0 “lle”
   u1 の 32 ビット値をネイティブ・バイト順からリトル・エンディアンに、 ま
たはリトル・エンディアンからネイティブ・バイト順に変換します(両方は同一
の操作です)

‘xbe’ ( u1 – u2  ) gforth-1.0 “xbe”
   u1 の 64 ビット値をネイティブ・バイト順からビッグ・エンディアンに、 ま
たはビッグ・エンディアンからネイティブ・バイト順に変換します(両方は同一
の操作です)

‘xle’ ( u1 – u2  ) gforth-1.0 “xle”
   u1 の 64 ビット値をネイティブ・バイト順からリトル・エンディアンに、 ま
たはリトル・エンディアンからネイティブ・バイト順に変換します(両方は同一
の操作です)

‘xdbe’ ( ud1 – ud2  ) gforth-1.0 “xdbe”
   ud1 の 64 ビット値をネイティブ・バイト順からビッグ・エンディアンに、
またはビッグ・エンディアンからネイティブ・バイト順に変換します(両方は同
一の操作です)

‘xdle’ ( ud1 – ud2  ) gforth-1.0 “xdle”
   ud1 の 64 ビット値をネイティブ・バイト順からリトル・エンディアンに、
またはリトル・エンディアンからネイティブ・バイト順に変換します(両方は同
一の操作です)

   特定のバイト順序での符号付きでの取得の場合、 符号なし取得とバイト順序
修正の後に符号拡張ワードを実行する必要があります:

‘c>s’ ( x – n ) gforth-1.0 “c-to-s”
   x の 8 ビット値をセル n に符号拡張します。

‘w>s’ ( x – n ) gforth-1.0 “w-to-s”
   x の 16 ビット値をセル n に符号拡張します。

‘l>s’ ( x – n ) gforth-1.0 “l-to-s”
   x の 32 ビット値をセル n に符号拡張します。

‘x>s’ ( x – n  ) gforth-1.0 “x>s”
   x の 64 ビット値をセル n に符号拡張します。

‘xd>s’ ( xd – d  ) gforth-1.0 “xd>s”
   XD の 64 ビット値を 2倍長セル D に符号拡張します。

   これら全般を、 以下のような流れで使います:

     w@ wbe w>s   \ 16ビット 非アライメント 符号付き ビッグ・エンディアン を取得し、
     >r lle r> l!  \ 32-bit 非アライメント リトル・エンディアン として 格納


File: gforth.info,  Node: Address arithmetic,  Next: Memory Blocks,  Prev: Special Memory Accesses,  Up: Memory

6.7.6 Address arithmetic
------------------------

アドレス演算は、 配列やレコード(*note Structures::)やオブジェクト(*note
Object-oriented Forth::)のようなデータ構造を構築可能な基礎基盤です。

   標準 Forth では、 データ型のサイズは規定されていません。 代わりに、 サ
イズを計算したりアドレス演算を行うための多数のワードが提供されます。 ア
ドレス演算はアドレス単位(au;Address Unit, aus;Address UnitS)で実行されま
す。 ほとんどのシステムでは、 1アドレス単位は 1 バイトです。 注意: 1 つ
の文字に複数 au が含まれる可能性があるため、 ‘chars’ は何もしない
(noop)訳ではないことに注意してください(noop であるプラットフォームでは、
‘chars’ は何もコンパイルしません)。

   基本的なアドレス算術ワードは ‘+’ と ‘-’ です。 たとえば、 セルのアド
レスがわかっている場合、 ‘1 cells +’ を実行すると、 次のセルのアドレスが
わかります。

   標準 Forth では、 特定の型のアドレスをアライメントするためのワードも
定義されています。 多くのコンピュータでは、 特定のデータ型へのアクセスは
特定のアドレスでのみ行われる必要があります。 たとえば、 セルは 4 で割り
切れるアドレスでのみアクセスできます。 マシンが非アライメント・アクセス
を許可する場合でも、 通常はアライメント・アクセスの方が高速に実行できま
す。

   パフォーマンス重視で行く場合: 通常、 アライメント操作はデータ構造の定
義中にのみ必要であり、 (より頻繁な)データ構造へのアクセス中には必要あり
ません。

   標準 Forth では、 文字のアドレス・アライメント用ワードは定義されてい
ません。 Forth-2012 では、すべてのアドレスが文字単位でアライメントされて
います(all addresses are character-aligned)

   標準 Forth は、 ‘CREATE’ されたワードによって返されるアドレスがセル・
アライメントされていることを保証します。 さらに、Gforth は、 こ​​れらの
アドレスがあらゆる目的に合わせてアライメント済みであることを保証します
(addresses are aligned for all purposes)。

   注意: 標準の Forth ワード ‘char’ はアドレス演算とは何の関係もないこと
に注意してください。

‘chars’ ( n1 – n2  ) core “chars”
   n1 文字(char)が何アドレス単位になるかを n2 に返します。

‘char+’ ( c-addr1 – c-addr2 ) core “char-plus”
   ‘1 chars +’.

‘char-’ ( c-addr1 – c-addr2  ) gforth-0.7 “char-minus”

‘cells’ ( n1 – n2 ) core “cells”
   n1 個のセルのアドレス単位の数を n2 に取得します。

‘cell+’ ( a-addr1 – a-addr2 ) core “cell-plus”
   ‘1 cells +’

‘cell-’ ( a-addr1 – a-addr2 ) core “cell-minus”
   ‘1 cells -’

‘cell/’ ( n1 – n2 ) gforth-1.0 “cell-divide”
   n1 個のアドレス単位の幅の中に入れられるセルの数が n2 です

‘cell’ ( – u  ) gforth-0.2 “cell”
   定数 – ‘1 cells’

‘aligned’ ( c-addr – a-addr ) core “aligned”
   a-addr は、 c-addr 以上の最初にアライメントされたアドレスです。

‘floats’ ( n1 – n2 ) floating “floats”
   n2 は n1 個の浮動小数点数(float)のアドレスユニットの数です。

‘float+’ ( f-addr1 – f-addr2 ) floating “float-plus”
   ‘1 floats +’.

‘float’ ( – u  ) gforth-0.3 “float”
   定数 – 浮動小数点数に対応するアドレスユニットの数。

‘float/’ ( n1 – n2 ) gforth-1.0 “float-divide”

‘faligned’ ( c-addr – f-addr ) floating “f-aligned”
   f-addr は、c-addr 以上の、 浮動小数点数にアライメントされた最初のアド
レスです。

‘sfloats’ ( n1 – n2 ) floating-ext “s-floats”
   n2 は、 n1 個の単精度 IEEE 浮動小数点数のアドレス単位の数です。

‘sfloat+’ ( sf-addr1 – sf-addr2  ) floating-ext “s-float-plus”
   ‘1 sfloats +’.

‘sfloat/’ ( n1 – n2 ) gforth-1.0 “dfloat-divide”

‘sfaligned’ ( c-addr – sf-addr ) floating-ext “s-f-aligned”
   sf-addr は、 c-addr 以上の、 最初の単精度浮動小数点数アライメント・ア
ドレスです。

‘dfloats’ ( n1 – n2 ) floating-ext “d-floats”
   n2 は、 n1 個の倍精度 IEEE 浮動小数点数のアドレス単位の数です。

‘dfloat+’ ( df-addr1 – df-addr2  ) floating-ext “d-float-plus”
   ‘1 dfloats +’.

‘dfloat/’ ( n1 – n2 ) gforth-1.0 “sfloat-divide”

‘dfaligned’ ( c-addr – df-addr ) floating-ext “d-f-aligned”
   df-addr は、 c-addr 以上の、 最初の倍精度浮動小数点数アライメント・ア
ドレスです。

‘maxaligned’ ( addr1 – addr2  ) gforth-0.2 “maxaligned”
   addr2 は、 すべてのアライメント制限を満たす addr1 以上の最初のアドレ
スです。

‘cfaligned’ ( addr1 – addr2  ) gforth-0.2 “cfaligned”
   addr2 は、 addr1 以上の最初のアドレスで、 コード・フィールド用にアラ
イメントされています(つまり、 対応する本体(body)が maxalign されるように
します)。

‘*aligned’ ( addr1 n – addr2  ) gforth-1.0 “*aligned”
   ADDR1 以上で、 N でアライメントされた(N で割り切れる)アドレスを ADDR2
に返します。

‘*align’ ( n –  ) gforth-1.0 “*align”
   ‘here’ を N で割り切れるアドレスにアライメントします。

‘waligned’ ( addr – addr’  ) gforth-1.0 “waligned”
   Addr’ は、 addr 以上、かつ、次の偶数アドレスです。

‘walign’ ( –  ) gforth-1.0 “walign”
   ‘here’ を 偶数アドレスにアライメントします。

‘laligned’ ( addr – addr’  ) gforth-1.0 “laligned”
   Addr’ は、 addr 以上、 かつ、 4 で割り切れるアドレスです。

‘lalign’ ( –  ) gforth-1.0 “lalign”
   ‘here’ を 4 で割り切れるアドレスにアライメントします。

‘xaligned’ ( addr – addr’  ) gforth-1.0 “xaligned”
   Addr’ を addr 以上、 かつ、 8 で割り切れるアドレスにします。

‘xalign’ ( –  ) gforth-1.0 “xalign”
   ‘here’ を 8 で割り切れるアドレスにアライメントします。

   環境クエリ ‘address-unit-bits’ (*note Environmental Queries::) と、 以
下のワード群は、 バイトアドレスを持たないマシン(non-byte-addressed
machines)に移植可能なソフトウェアを作成したい人に役立つかもしれません。

‘/w’ ( – u  ) gforth-0.7 “slash-w”
   16ビット値に必要なアドレス単位

‘/l’ ( – u  ) gforth-0.7 “slash-l”
   32ビット値に必要なアドレス単位

‘/x’ ( – u  ) gforth-1.0 “slash-x”
   64ビット値に必要なアドレス単位


File: gforth.info,  Node: Memory Blocks,  Prev: Address arithmetic,  Up: Memory

6.7.7 Memory Blocks
-------------------

メモリ・ブロックは多くの場合、 文字の連なり(character strings)を表します
。 文字の連なりをメモリに保存する方法については、 *note String
representations:: を参照してください。 他の連なり処理ワード
(string-processing words)については、 *note Displaying characters and
strings:: を参照してください。

   これらのワードのいくつかは、 アドレス単位ブロック(address unit
blocks)で機能します。 その場合、 文字の連なり(character strings)を扱う際
には通常、 ワードの前に ‘CHARS’ を挿入する必要があります。 ほとんどのワ
ードは文字ブロック(character blocks)で機能し、 文字アライメント・アドレ
ス(char-aligned address)を期待します。

   重複するメモリ領域間で文字達をコピーする場合は、 ‘move’ を使用します
。 ‘cmove’ と ‘cmove>’ は、 適切に実装された ‘move’ よりも遅くなる傾向が
あります。

‘move’ ( c-from c-to ucount – ) core “move”
   c-from アドレスにある ucount 個のcharの内容を c-to アドレスにコピーし
ます。 ‘move’ は、 2 つの領域が重なっている場合でも正しく機能します。

‘cmove’ ( c-from c-to u – ) string “c-move”
   データ空間で c-from アドレスから ucount 個のcharの内容を c-to アドレ
スにコピーします。コピーは、 1 ‘char’ ずつコピーしながら下位アドレスから
上位アドレス方向へ進めます。 つまり、 重複領域の場合、 c-to <= c-from で
あれば安全です。

‘cmove>’ ( c-from c-to u – ) string “c-move-up”
   データ空間で c-from アドレスから ucount 個のcharの内容を c-to アドレ
スにコピーします。 コピーは、 1 ‘char’ ずつコピーし上位アドレスから下位
アドレス方向に進みます。 つまり、 重複領域の場合、 c-to >= c-from であれ
ば安全です。

‘fill’ ( c-addr u c – ) core “fill”
   c を c-addr から u 個char単位で格納します。

‘erase’ ( addr u –  ) core-ext “erase”
   addr から始まる u aus のすべてのビットをクリアします。

‘blank’ ( c-addr u –  ) string “blank”
   スペース文字を c-addr アドレスから u 個char単位で格納します。

‘insert’ ( string length buffer size –  ) gforth-0.7 “insert”
   バッファーの先頭に文字列を挿入します。 残りのバイトは後ろにずらされま
す(訳注: sizeを超えた分は捨てられます)。

‘delete’ ( buffer size u –  ) gforth-0.7 “delete”
   最初の U バイトをバッファーから削除し、 その分前にずらして、 残りの最
後のバイトを空白(0x20)で埋めます。

‘compare’ ( c-addr1 u1 c-addr2 u2 – n ) string “compare”
   連なり(string)内のバイトの値に基づいて、 2 つの連なり(strings)を(英語
の)辞書順(lexicographically)に比較します(つまり、 英大文字と小文字が区別
され、 ロケール固有の照合順序は無視されます)。 2つが等しい場合、 n は 0
です。 最初の連なり(string)が小さい場合、 n は -1 です。 最初の連なり
(string)が大きい場合、 n は 1 です。

‘pad’ ( – c-addr  ) core-ext “pad”
   C-ADDR は、 一時的なデータ・ストレージとして使用できる一時領域のアド
レスです。 少なくとも 84 文字分の空間が使用可能です。


File: gforth.info,  Node: Strings and Characters,  Next: Control Structures,  Prev: Memory,  Up: Words

6.8 Strings and Characters
==========================

* Menu:

* Characters::
* String representations::
* String and character literals::
* String words::
* ＄tring words::
* Counted string words::


File: gforth.info,  Node: Characters,  Next: String representations,  Prev: Strings and Characters,  Up: Strings and Characters

6.8.1 Characters
----------------

Forth は、 ‘c@’ などのワードで使用される char (別名バイト)をサポートしま
す。 これらは ASCII 文字を表すために使用できます。

   Forth は、 複数のバイト(つまり、 複数の char)のシーケンスで表現できる
拡張文字(extended characters)もサポートしています。 一般的な文字エンコー
ディングは、 ユニコードの UTF-8 表現です。

   一般に、 ほとんどのプログラム・コードは拡張文字(extended characters)に
ついて心配する必要はありません。 連なり(string)表現では、 当該バイトが拡
張文字の一部であるか、 それ自体が1つの文字であるかは問題ではありません。
拡張文字が char のシーケンスとして転送される場合、 (‘emit’ のような)
char を消費するワードも機能します。 Forth は未だ、 拡張文字を処理するた
めのワード群を提供しています(*note Xchars and Unicode::)。

   ユニコード用語では、 char コード・ユニット、 拡張文字は コード・ポイ
ント です。 Unicode 抽象文字(abstract character) はコード・ポイントのシ
ーケンスとしで構成されますが、 (他のプログラミング言語と同様、 ) Forth に
は抽象文字個々のデータ型はないことに注意してください。 もちろん、 これら
は連なり(string)として表すことができます。

   スタック上の char および Xchar には通常の整数ワードを使用できますが、
Gforth にはスタック上の char を処理するためのワードもいくつかあります:

‘toupper’ ( c1 – c2 ) gforth-0.2 “toupper”
   c1 が小文字の ASCII 文字である場合、 c2 は同等の大文字です。 それ以外
の場合、 c2 と c1 は同じです。


File: gforth.info,  Node: String representations,  Next: String and character literals,  Prev: Characters,  Up: Strings and Characters

6.8.2 String representations
----------------------------

Forth は通常、 文字列(strings)をスタック上のセルのペア c-addr u として表
します。 u はバイト単位の文字列の長さ(別名 文字数)、 c-addr は文字列の最
初のバイトのアドレスです。 コード・ポイントは、 文字列内の複数の文字
(char)のシーケンスによって表される場合があることに注意してください(また
、 ユニコード の「抽象文字」(abstract character)は複数のコード・ポイント
で構成される場合があります)。 *Note String words::

   もう一つの文字列表現が、 ‘$’ を含む文字列ライブラリ・ワード群で使用さ
れます。 それらは、 変数などに配置できるセルサイズの文字列ハンドル
(cell-sized string handle)のアドレスを通じてスタック上の文字列を表します
。 *Note ＄tring words::

   旧来からの文字列表現は「カウンタ付き文字列」(counted strings)で、 ス
タック上では c-addr と表現されます。 c-addr によって指定される char には
、 文字列の文字数 n が含まれており、 その文字列はメモリ内の後続の n char
アドレスを占有します。 カウントされる文字列の長さは 255 バイトに制限され
ます。 カウンタ付き文字列は、 必要なスタック項目が 1 つだけであるため魅
力的に見えるかもしれませんが、 この制限があるため、 特にワードの入力パラ
メータとしては使用しないことをお勧めします。 *Note Counted string
words::


File: gforth.info,  Node: String and character literals,  Next: String words,  Prev: String representations,  Up: Strings and Characters

6.8.3 String and Character literals
-----------------------------------

文字列リテラル(string literal)を記述する至高の方法は、 ‘"STRING"’ と記述
することです。 ‘s\"’ の場合と同じく、 バックスラッシュによるエスケープ
(\-escapes)を使用できます。 ただし、 この方法は標準ではないため
(non-standard)、 移植性を高めるためには以下のいずれかのワードを使用する
ことをお勧めします:

‘s\"’ ( compilation ’ccc"’ – ; run-time – c-addr u  ) core-ext,file-ext “s-backslash-quote”
   これは ‘s"’ と似ていますが、 C言語のようなバックスラッシュ・エスケー
プ・シーケンス(\-escape-sequences)を次のように変換します: ‘\a’ BEL (ビー
プ音)、 ‘\b’ BS 、 ‘\e’ ESC (not in C99)、 ‘\f’ FF 、 ‘\n’ 改行
(newline)、 ‘\r’ CR 、 ‘\t’ HT 、‘\v’ VT 、‘\"’ " 、 ‘\\’ \ 、
‘\’[0-7]{1,3} 8進数(非標準)、 ‘\x’[0-9a-f]{0,2} 16進指定char値(標準は2桁
のみ)、 ‘\u’[0-9a-f]{4} ユニコード・コードポイント(サロゲート・ペア自動
マージ;auto-merges surrogate pairs)、 ‘\U’[0-9a-f]{8} 拡張ユニコード・コ
ード・ポイント。 ‘\’ は他の文字よりも前に予約されています。
注意: ‘\x’XX は生のバイトを生成することに注意してください。 一方、
‘\u’XXXX と ‘\U’XXXXXXXX は、 現在のエンコーディングのコード・ポイントを
生成します。 たとえば、 UTF-8 エンコーディングを使用し、 ä (コード・ポイ
ント U+00E4)をエンコードしたい場合は、 次のように指定できます: 文字 ä 自
体を記述するか、 ‘\xc3\xa4’ (このコード・ポイントの UTF-8 バイト) または
‘\u00e4’ または ‘\U000000e4’ を記述します。
注意: C言語とは異なり、 ‘\n’ はホストOS に適した改行シーケンスを生成しま
す。 これは複数の文字で構成される場合があります。 つまり、 ‘"\n"’ は
‘newline’ と同等です。

‘S"’ ( compilation ’ccc"’ – ; run-time – c-addr u  ) core,file “s-quote”
   コンパイル・モード用コードは ‘"’ (二重引用符) を区切り文字として文字
列 ccc をパースします。 その実行時コードは、 長さ u と 文字列の開始アド
レス c-addr を返します。 インタープリター時: 同様に文字列をパースし、
c-addr と u 返します。 Gforth では文字列(string)を ‘allocate’ します。 結
果として生じるメモリ・リークは通常は問題ではありません。 例外は、 ‘S"’ を
含む文字列を作成し、 その文字列を ‘evaluate’ する場合です。 その場合、 リ
ークはインタプリトされたファイルのサイズに制限されないため、 文字列を
‘free’ することもできます。 Forth-2012 では、それぞれ 80 文字のバッファ
ーが 2 つしか保証されないため、 標準プログラムでは、 文字列は 2 つ前の
‘s"’ までしか存続していない想定する必要があります。

   同様に、 ‘'C'’ を使用すると、 文字 C のコード xc を取得できます。 こ
の方法は Forth-2012 から標準化されています。 これを取得する古い方法は、
以下のいずれかのワードを使用することです:

‘char’ ( ’<spaces>ccc’ – c  ) core,xchar-ext “char”
   先頭のスペース達をスキップします。 文字列 ccc をパースし、 ccc の最初
の文字の文字コード c を返します(訳注:ASCII以外の文字コードもいけるっぽい
(LANG=ja_JP.UTF-8) char あ hex .  decimal 3042 ok)

‘[char]’ ( compilation ’<spaces>ccc’ – ; run-time – c  ) core,xchar-ext “bracket-char”
   コンパイル状態: 先頭のスペース達をスキップします。 文字列 ccc をパー
スします。 その実行時コード: ccc の最初の文字の文字コード c を返します。
このワードのインタープリター機能(interpretation semantics)は未定義です。

   通常は、 コロン定義の外側で ‘char’ 使用するか、 コロン定義の内側で
‘[char]’ を使用するか、 単にその両方で ‘'C'’ を使用するかです。

   注意: 例えば、

     "C" type

の方が下記よりも(わずかに)効率的です

     'C' xemit

なぜなら、 後者はコード・ポイントをバイトのシーケンスに変換し、 それらを
個別に ‘emit’ するからです。 同様に、 一般的な文字達を扱う場合は、 通常
、 コード・ポイントではなく文字列として表す方が効率的です。

   ‘S"’ または ‘'C'’ では生成できない、 一般的に使用される文字や文字列を
生成するために以下のワード群があります:

‘newline’ ( – c-addr u ) gforth-0.5 “newline”
   ホストOSの改行シーケンスを含む文字列(訳注: 文字コードを返す訳では無い
ことに注意。 文字列の内容は LF だったり CRLF だったりする)

‘bl’ ( – c-char  ) core “b-l”
   c-char は空白(space)の文字コード値です。

‘#tab’ ( – c  ) gforth-0.2 “number-tab”

‘#lf’ ( – c  ) gforth-0.2 “number-l-f”

‘#cr’ ( – c  ) gforth-0.2 “number-c-r”

‘#ff’ ( – c  ) gforth-0.2 “number-f-f”

‘#bs’ ( – c  ) gforth-0.2 “number-b-s”

‘#del’ ( – c  ) gforth-0.2 “number-del”

‘#bell’ ( – c  ) gforth-0.2 “number-bell”

‘#esc’ ( – c  ) gforth-0.5 “number-esc”

‘#eof’ ( – c  ) gforth-0.7 “number-e-o-f”
   実際には EOT (ASCII コード 4 別名 ‘^D’)


File: gforth.info,  Node: String words,  Next: ＄tring words,  Prev: String and character literals,  Up: Strings and Characters

6.8.4 String words
------------------

メモリ・ブロックに使用されるワードは文字列(string)にも役立つため、 文字
列(string)の移動やコピーや比較や検索を行うワードについては、 *note
Memory Blocks:: を参照してください。 文字や文字列を表示するワードについ
ては、 see *note Displaying characters and strings:: を参照してください
。

   以下のワード群は、 既に存在している文字列(strings)に対して機能します:

‘str=’ ( c-addr1 u1 c-addr2 u2 – f  ) gforth-0.6 “str-equals”

‘str<’ ( c-addr1 u1 c-addr2 u2 – f  ) gforth-0.6 “str-less-than”

‘string-prefix?’ ( c-addr1 u1 c-addr2 u2 – f  ) gforth-0.6 “string-prefix-question”
   C-ADDR2 U2 が C-ADDR1 U1 の接頭辞部分と合致しますか？

‘string-suffix?’ ( c-addr1 u1 c-addr2 u2 – f  ) gforth-1.0 “string-suffix-question”
   C-ADDR2 U2 が C-ADDR1 U1 の接尾辞部分と合致しますか？

‘search’ ( c-addr1 u1 c-addr2 u2 – c-addr3 u3 flag  ) string “search”
   文字列 c-addr1, u1 の中で、 文字列 c-addr2, u2 を検索します。 flag が
true の場合: 見つかったアドレスを c-addr3 に、 文字列 c-addr2, u2 を含む
それ以降の文字数を u3 に返します(訳注: s" GNU gforth マニュアル" s" ニュ
ア" search drop ."  [" type ."  ]"  [ニュアル] ok )。 flag が false の場
合: 一致するものが見つかりませんでした。 c-addr3, u3 は c-addr1, u1 と同
じです。

‘scan’ ( c-addr1 u1 c – c-addr2 u2 ) gforth-0.2 “scan”
   c に等しくないすべての文字をスキップします。 結果は c で始まる
(c-addr2 u2)か空(empty; c-addr2+u2, 0)です。 ‘Scan’ はシングルバイト文字
(ASCII)に限定されます。 マルチバイト文字を検索するには、 ‘search’ を使用
します。

‘scan-back’ ( c-addr u1 c – c-addr u2  ) gforth-0.7 “scan-back”

‘skip’ ( c-addr1 u1 c – c-addr2 u2 ) gforth-0.2 “skip”
   c に等しいすべての文字をスキップします。 結果は最初の非 C 文字で始ま
る(アドレス、長さ)か、 空(文字列の長さ0)になります。 ‘skip’ はシングルバ
イト文字(ASCII)に限定されます。

‘-trailing’ ( c_addr u1 – c_addr u2  ) string “dash-trailing”
   c-addr, u1 で指定された文字列の末尾をトリムします(末尾のスペースをす
べて削除します)。 u2 は変更後の文字列の長さです。

‘/string’ ( c-addr1 u1 n – c-addr2 u2 ) string “slash-string”
   c-addr1, u1 で指定された文字列の先頭から n 文字削除します(訳注:
c-addr1+n, u1-n するだけっぽい…)。

‘safe/string’ ( c-addr1 u1 n – c-addr2 u2 ) gforth-1.0 “safe-slash-string”
   c-addr1, u1 で指定された文字列の先頭から n 文字を削除します。
‘/string’ とは異なり、‘safe/string’ は少なくとも 0 文字、 最大で u1 文字
を削除します。

‘cstring>sstring’ ( c-addr – c-addr u  ) gforth-0.2 “cstring-to-sstring”
   C-addr はゼロで終わる文字列の開始アドレス、 u はその長さです。

   以下のワード群は、 ASCII 文字については大文字と小文字を区別せずに比較
しますが、 (ワードリストの検索のような)非 ASCII 文字については大文字と小
文字を区別します 。

‘capscompare’ ( c-addr1 u1 c-addr2 u2 – n ) gforth-0.7 “capscompare”
   文字列内のバイトの値に基づいて、 2 つの文字列(string)を辞書順
(lexicographically)に比較します。ただし、 ASCII 文字は大文字と小文字を区
別せずに比較し、 非 ASCII 文字は大文字と小文字を区別して、 かつ、 ロケー
ル固有の照合順序を使用せずに比較します。 それらが等しい場合 n は 0 です
。 最初の文字列が小さい場合 n は -1 です。 最初の文字列が大きい場合n は
1 です。

‘capsstring-prefix?’ ( c-addr1 u1 c-addr2 u2 – f  ) gforth-1.0 “capsstring-prefix?”
   ‘string-prefix?’ と似ていますが、 ASCII 文字の大文字と小文字は区別さ
れません: C-ADDR2 U2 は C-ADDR1 U1 の接頭辞か？

‘capssearch’ ( c-addr1 u1 c-addr2 u2 – c-addr3 u3 flag  ) gforth-1.0 “capssearch”
   ‘search’ と似ていますが、 ASCII 文字の大文字と小文字は区別されません:
c-addr1 u1 内で c-addr2 u2 を検索します。 見つかった場合 flag は true に
なります。

   以下のワード群は、 ヒープに文字列(string)を作成、 またはヒープの文字
列(string)を拡張します。

‘s+’ ( c-addr1 u1 c-addr2 u2 – c-addr u  ) gforth-0.7 “s-plus”
   c-addr u は、c-addr1 u1 (最初) と c-addr2 u2 (2 番目) を連結したのを
含む、 新しく ‘allocate’ された文字列です。

‘append’ ( c-addr1 u1 c-addr2 u2 – c-addr u  ) gforth-0.7 “append”
   C-addr u は、c-addr1 u1 (最初) と c-addr2 u2 (2 番目) を連結したもの
です。 c-addr1 u1 は ‘allocate’ された文字列であり、 u 文字の領域に対応
するために(可能なら)サイズ変更(resize)して c-addr2 u2 の文字列を追加
(append)します(サイズ変更できなくて、新しいアドレスに移動する可能性があ
ります)。

‘>string-execute’ ( ... xt – ... addr u  ) gforth-1.0 “>string-execute”
   xt を実行(execute)すると、 標準出力 (‘type’ や ‘emit’ やそれらを使用
するすべてのもの) を文字列にリダイレクトします。 結果の文字列は addr u で
、これは割り当てられた(‘allocate’)メモリ内にあります。 この文字列を開放
(‘free’)するのは、 ‘>string-execute’ の呼び出し元の責任です。

   以下のようにして、‘>string-execute’ を使用して ‘s+’ を定義できます:

   : s+ ( c-addr1 u1 c-addr2 u2 – c-addr u ) [: 2swap type type ;]
>string-execute ;

   2 つの文字列だけを連結する場合、 ‘>string-execute’ は効率的ではありま
せんが、 多くの文字列を連結する場合は、 ‘>string-execute’ の方が効率的で
す。

