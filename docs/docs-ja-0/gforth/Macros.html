<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- このマニュアルは、 標準 Forth 言語の高速で移植可能な実装である Gforth (バージョン 0.7.9_20240418,
April 18, 2024)用です。 これはリファレンス・マニュアルとして機能しますが、 Forth の概要と Forth
チュートリアルも含まれています。

Authors: Bernd Paysan, Anton Ertl, Gerald Wodni Copyright © 1995,
1996, 1997, 1998, 2000, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
2011, 2012, 2013, 2014,2015,2016,2017,2018,2019,2020,2021,2022,2023 Free
Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant
Sections, with the Front-Cover texts being "A GNU Manual," and with the
Back-Cover Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have freedom to copy and modify this
GNU Manual, like GNU software.  Copies published by the Free Software
Foundation raise funds for GNU development." -->
<title>Macros (Gforth マニュアル)</title>

<meta name="description" content="Macros (Gforth マニュアル)">
<meta name="keywords" content="Macros (Gforth マニュアル)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Word-Index.html" rel="index" title="Word Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Compiling-words.html" rel="up" title="Compiling words">
<link href="Literals.html" rel="prev" title="Literals">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
pre.format-preformatted {font-family: inherit}
span:hover a.copiable-link {visibility: visible}
ul.mark-bullet {list-style-type: disc}
-->
</style>
<link rel="stylesheet" type="text/css" href="gforth.css">


</head>

<body lang="en">
<div class="subsection-level-extent" id="Macros">
<div class="nav-panel">
<p>
Previous: <a href="Literals.html" accesskey="p" rel="prev">Literals</a>, Up: <a href="Compiling-words.html" accesskey="u" rel="up">Compiling words</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Word-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h4 class="subsection" id="Macros-1"><span>6.13.2 Macros<a class="copiable-link" href="#Macros-1"> &para;</a></span></h4>
<a class="index-entry-id" id="index-Macros"></a>
<a class="index-entry-id" id="index-compiling-compilation-semantics"></a>

<p><code class="code">Literal</code> とその仲間たちは、 データ値を現在の定義にコンパイルします。
他のワードを現在の定義にコンパイルするワードを記述することもできます。 例えば:
</p>
<div class="example">
<pre class="example-preformatted">: compile-+ ( -- ) \ compiled code: ( n1 n2 -- n )
  POSTPONE + ;

: foo ( n1 n2 -- n )
  [ compile-+ ] ;
1 2 foo .
</pre></div>

<p>これは <code class="code">: foo + ;</code> と同等です(確認するには <code class="code">see foo</code> としてください)。
この例では何が起こっているのでしょうか? <code class="code">Postpone</code> は、 <code class="code">+</code> のコンパイル機能(compilation
semantics)を <code class="code">compile-+</code> にコンパイルします。 その後、 テキスト・インタープリターは <code class="code">compile-+</code>
を実行し、 + のコンパイル機能(compilation semantics)を実行します。 これにより、<code class="code">+</code>
(の実行機能(execution semantics)) が <code class="code">foo</code> にコンパイルされます<a class="footnote" id="DOCF23" href="#FOOT23"><sup>23</sup></a>。
</p>
<a class="index-entry-id" id="index-postpone-_0028-_0022name_0022-_002d_002d-_0029-core"></a>
<a class="index-entry-id" id="index-postpone"></a>
<a class="index-entry-id" id="index-postpone-1"></a>
<div class="format">
<pre class="format-preformatted"><code class="code">postpone</code> ( <i class="i">&quot;name&quot; &ndash;  </i>) core &ldquo;postpone&rdquo;
</pre></div>
<p><i class="i">name</i> の コンパイル機能(compilation semantics)をコンパイルする。
</p>


<p><code class="code">compile-+</code> のようなコンパイル・ワード(compiling
words)のコンパイルは通常即実行ワード(または即実行同様)であるため、 それらを実行するためにインタプリタ状態に切り替える必要はありません。
最後の例をそれに応じて変更すると、 以下のようになります:
</p>
<div class="example">
<pre class="example-preformatted">: [compile-+] ( compilation: --; interpretation: -- )
  \ compiled code: ( n1 n2 -- n )
  POSTPONE + ; immediate

: foo ( n1 n2 -- n )
  [compile-+] ;
1 2 foo .
</pre></div>

<p>場合によっては、 複数のワードを POSTPONE する必要があることに気づくでしょう。 このような各ワードの前に POSTPONE
を置くのは面倒なので、 Gforth ではより便利な構文 <code class="code">]] ... [[</code> を提供しています。  これにより、
<code class="code">[compile-+]</code> を以下のように記述できるようになります:
</p>
<div class="example">
<pre class="example-preformatted">: [compile-+] ( compilation: --; interpretation: -- )
  ]] + [[ ; immediate
</pre></div>

<a class="index-entry-id" id="index-_005d_005d-_0028-_002d_002d-_0029-gforth_002d0_002e6"></a>
<a class="index-entry-id" id="index-_005d_005d"></a>
<a class="index-entry-id" id="index-_005d_005d-1"></a>
<div class="format">
<pre class="format-preformatted"><code class="code">]]</code> ( <i class="i">&ndash;  </i>) gforth-0.6 &ldquo;right-bracket-bracket&rdquo;
</pre></div>
<p>postpone 状態に切り替え: すべてのワードと認識器(recognizers)は、 その前に <code class="code">postpone</code>
があるかのように処理されます。  <code class="code">[[</code> が認識されると、 postpone 状態は終了します。
</p>


<p>角括弧の珍しい方向はその機能を示しています。 <code class="code">]</code> が即時実行(インタープリター状態)からコンパイルに切り替えるのと同じように、
<code class="code">]]</code> はコンパイルから postpone 状態(つまり、 コンパイル機能のコンパイル)に切り替えます。  逆に、 <code class="code">[[</code> は
postpone 状態からコンパイル状態に切り替えます。 これは、 コンパイル状態から即時実行(インタープリター状態)に切り替える <code class="code">[</code>
に似ています。
</p>
<p><code class="code">]] </code>...<code class="code"> [[</code> の本当の利点は、 POSTPONE するワードがたくさんある場合に明らかになります。  たとえば、
ワード <code class="code">compile-map-array</code> (see <a class="pxref" href="Advanced-macros-Tutorial.html">Advanced macros</a>) は、
以下のようにさらに短く書くことができます:
</p>
<div class="example">
<pre class="example-preformatted">: compile-map-array ( compilation: xt -- ; run-time: ... addr u -- ... )
\ at run-time, execute xt ( ... x -- ... ) for each element of the
\ array beginning at addr and containing u elements
  {: xt: xt :}
  ]] cells over + swap ?do
    i @ xt 1 cells +loop [[ ;

: sum-array ( addr u -- n )
  0 [ ' + compile-map-array ] ;
</pre></div>

<p><code class="code">see sum-array</code> すると、 以下のコードが表示されます:
</p>
<div class="example">
<pre class="example-preformatted">: sum-array
  #0 over + swap ?do
    i &nbsp;+ #8 +LOOP
;
</pre></div>

<p><code class="code">]]</code>...<code class="code">[[</code> に加えて、 この例では他の機能もいくつかお披露目しています:
</p>
<ul class="itemize mark-bullet">
<li>(<code class="code">xt:</code> を指定する) defer フレーバーのローカル変数 <code class="code">xt</code> を使用しています。
<code class="code">]]</code>...<code class="code">[[</code> 内でローカル変数 xt に遭遇すると、 ローカル変数 xt を <code class="code">compile,</code> します。

</li><li><code class="code">]]</code>...<code class="code">[[</code> 内でリテラル <code class="code">1</code> を使用します。  これにより、 <code class="code">1</code> が postpone
(延期)されます。 つまり、 <code class="code">compile-map-array</code> の実行時にコンパイルされます。

</li><li><code class="code">compile-map-array</code> が実行されると、 <code class="code">1 cells</code> がコンパイルされ、 Gforth
の定数折りたたみによって <code class="code">#8</code> に最適化(optimize)されます。

</li></ul>

<p>注意: <code class="code">s\&quot;</code> などのワードのパースは postpone 指定時にはパースされないため、 <code class="code">]]</code>...<code class="code">[[</code>
内ではパースされないことに注意してください。 <code class="code">s\&quot; mystring\n&quot;</code> の代わりに、 文字列認識器(string
recognizer)を使用して、 <code class="code">]]</code>...<code class="code">[[</code> 内で動作する <code class="code">&quot;mystring\n&quot;</code>
で記述することができます。これは <code class="code">]]</code>...<code class="code">[[</code> 内で機能します。 同様に、 パース・ワード <code class="code">[']</code>
についても、  <code class="code">`</code> で始まる認識器(recognizer)表記で記述することができます。
</p>
<p>ただし、 あなたが <code class="code">s\&quot;</code> を使用したい場合(または、 認識器(recognizer)置換がないパース・ワードがある場合)、
以下のようにコンパイル状態に切り替えることで実行できます:
</p>
<div class="example">
<pre class="example-preformatted">]] ... [[ s\&quot; mystring\n&quot; ]] 2literal ... [[
</pre></div>

<p>標準 Forth での <code class="code">]]</code> と、 その仲間の定義は、 <samp class="file">compat/macros.fs</samp> で提供されます。
</p>
<p>即時コンパイル・ワード(immediate compiling words)は、 他の言語(特に Lisp)のマクロに似ています。
C言語などのマクロとの重要な違いは以下のとおりです:
</p>
<ul class="itemize mark-bullet">
<li>マクロの定義と処理には、 別個の前処理用の言語や処理器ではなく、 同一の言語を使用します。

</li><li>したがって、 Forth の全機能をマクロ定義で利用できます。 たとえば、 任意の複雑な計算を実行したり、
条件付きまたはループで異なるコードを生成したりできます (例: see <a class="pxref" href="Advanced-macros-Tutorial.html">Advanced macros</a>)。  この能力は、
パーサ・ジェネレータや、 その他のコード生成ソフトウェアを作成するときに非常に役立ちます。

</li><li><code class="code">postpone</code> などを使用して定義されたマクロは、 文字列よりも高いレベルで言語を扱います。 名前との結び付け(name
binding)はマクロ定義時に行われるため、 C言語のマクロで発生する可能性のある名前の衝突の落とし穴を回避できます。 もちろん、 Forth
は自由主義の言語(liberal language)であり、 以下のようなテキスト解釈マクロ(text-interpreted
macros)を使用して自分自身を攻撃することもできます

<div class="example">
<pre class="example-preformatted">: [compile-+] s&quot; +&quot; evaluate ; immediate
</pre></div>

<p>マクロ使用時に名前を結びつける(bind)だけでなく、 <code class="code">evaluate</code> を使用すると、 あなたの定義は
<code class="code">state</code>-smart (see <a class="pxref" href="Combined-words.html#state_002dsmartness">state-smartness</a>) になります。
</p></li></ul>

<p>マクロで数値をワードにコンパイルすることが必要な場合があります。  これを行うためのワードは <code class="code">literal</code> ですが、
<code class="code">postpone</code> する必要があるため、 <code class="code">literal</code> のコンパイル機能(compilation
semantics)はマクロがコンパイルされる時ではなくマクロの実行時に効果を発揮します:
</p>
<div class="example">
<pre class="example-preformatted">: [compile-5] ( -- ) \ compiled code: ( -- n )
  5 POSTPONE literal ; immediate

: foo [compile-5] ;
foo .
</pre></div>

<p>マクロにパラメータを渡して、 マクロを現在の定義にコンパイルする必要がある場合があります。  パラメータが数値の場合は、 <code class="code">postpone
literal</code> を使用できます(他の値の場合も同様)。
</p>
<p>コンパイルされるワードを渡したい場合、 通常の方法は、実行トークンと <code class="code">compile,</code> を渡すことです:
</p>
<div class="example">
<pre class="example-preformatted">: twice1 ( xt -- ) \ compiled code: ... -- ...
  dup compile, compile, ;

: 2+ ( n1 -- n2 )
  [ ' 1+ twice1 ] ;
</pre></div>

<a class="index-entry-id" id="index-compile_002c-_0028-xt-_002d_002d-_0029-core_002dext"></a>
<a class="index-entry-id" id="index-compile_002c"></a>
<a class="index-entry-id" id="index-compile_002c-1"></a>
<div class="format">
<pre class="format-preformatted"><code class="code">compile,</code> ( <i class="i">xt &ndash;  </i>) core-ext &ldquo;compile-comma&rdquo;
</pre></div>
<p><i class="i">xt</i> で表される機能(semantics)を現在の定義に追加します。 結果のコード断片が実行されると、 <i class="i">xt</i> が
<code class="code">execute</code> されたのと同一の振る舞いをします。
</p>


<p>Gforth で利用可能な代替方法では、 コンパイル機能をパラメータ(compilation semantics)として渡すことができる、
コンパイル・トークンを使用します(see <a class="pxref" href="Compilation-token.html">Compilation token</a>)。 以下は、 上記と同じ例にこの方法を使ったものです:
</p>
<div class="example">
<pre class="example-preformatted">: twice ( ... ct -- ... ) \ compiled code: ... -- ...
  2dup 2&gt;r execute 2r&gt; execute ;

: 2+ ( n1 -- n2 )
  [ comp' 1+ twice ] ;
</pre></div>

<p>この例では、 <code class="code">2&gt;r</code> と <code class="code">2r&gt;</code> により、 実行(execute)されるコンパイル機能(compilation
semantics)がデータ・スタックに影響を与える場合でも、 <code class="code">twice</code> が確実に機能するようにします(訳注: 2dup ( ct ct
) 2&gt;r ( ct r:ct ) execute ( ?? r:ct ) 2r&gt; ( ?? ct ) execute ( ??? ) 。 最初の
execute でデータ・スタックのTOSがどうなろうとも、 2つ目の execute のために ct を tos に与えるため。 ct は
2セル単位なので、 2dupで複製、 2&gt;r ... 2r&gt; で ct を1つ退避となる)
</p>
<p>これらのワードを使用して完全な定義を定義することもできます。 これは、 <code class="code">does&gt;</code>
を使用する代わりの方法を提供します(see <a class="pxref" href="User_002ddefined-Defining-Words.html">User-defined Defining Words</a>)。  たとえば以下の代わりに
</p>
<div class="example">
<pre class="example-preformatted">: curry+ ( n1 &quot;name&quot; -- )
    CREATE ,
DOES&gt; ( n2 -- n1+n2 )
    @ + ;
</pre></div>

<p>以下のように定義することができます
</p>
<div class="example">
<pre class="example-preformatted">: curry+ ( n1 &quot;name&quot; -- )
  \ name execution: ( n2 -- n1+n2 )
  &gt;r : r&gt; POSTPONE literal POSTPONE + POSTPONE ; ;

-3 curry+ 3-
see 3-
</pre></div>

<p>n1 にアクセスするために <code class="code">&gt;r : r&gt;</code> というシーケンスが必要です。 なぜなら、 <code class="code">:</code> はデータ・スタックに
colon-sys をプッシュし、 それより下にある全てのモノにアクセスできなくなるためです。
</p>
<p>ワードを定義するこの方法は、 <code class="code">does&gt;</code> を使用するよりも便利な場合もあれば、 そうでない場合もあります(see <a class="pxref" href="Advanced-does_003e-usage-example.html">Advanced does&gt; usage example</a>)。  この方式の利点の 1 つは、 コンパイラーは、  <code class="code">literal</code>
でコンパイルされた値が固定されているのに対して、 <code class="code">create</code> されたワードに関連付けられたデータは変更可能なことを認識しているため、
より適切に最適化できることです。
</p>
<a class="index-entry-id" id="index-_005bcompile_005d-_0028-compilation-_0022name_0022-_002d_002d-_003b-run_002dtime-_003f-_002d_002d-_003f-_0029-core_002dext"></a>
<a class="index-entry-id" id="index-_005bcompile_005d"></a>
<a class="index-entry-id" id="index-_005bcompile_005d-1"></a>
<div class="format">
<pre class="format-preformatted"><code class="code">[compile]</code> ( <i class="i">compilation &quot;name&quot; &ndash; ; run-time ? &ndash; ?  </i>) core-ext &ldquo;bracket-compile&rdquo;
</pre></div>
<p>古いワード(lLegacy word)です。  代わりに <code class="code">postpone</code> を使用してください。  <i class="i">name</i>
がデフォルト以外のコンパイル機能(compilation semantics)を持つ場合は、 <code class="code">postpone</code> と同様に機能します。
<i class="i">name</i> がデフォルトのコンパイル機能を持つ(つまり、 通常のワードである)場合、 <code class="code">[compile] <i class="i">name</i></code>
をコンパイルすることは、 <i class="i">name</i> をコンパイルすることと同じです(つまり、 この場合 <code class="code">[compile]</code> は冗長です)。
</p>


</div>
<div class="footnotes-segment">
<hr>
<h4 class="footnotes-heading">Footnotes</h4>

<h5 class="footnote-body-heading"><a id="FOOT23" href="#DOCF23">(23)</a></h5>
<p>最近の RFI の回答では、
ワードのコンパイルはコンパイル状態でのみ実行する必要があるとしているため、 この例はすべての標準システムで動作することは保証されませんが、
ちゃんとした(decent)システムであれば動作します</p>
</div>
<hr>
<div class="nav-panel">
<p>
Previous: <a href="Literals.html">Literals</a>, Up: <a href="Compiling-words.html">Compiling words</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Word-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
