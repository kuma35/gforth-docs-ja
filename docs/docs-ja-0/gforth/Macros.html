<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- このマニュアルは、 標準 Forth 言語の高速で移植可能な実装である Gforth (バージョン 0.7.9_20240418,
April 18, 2024)用です。 これはリファレンス・マニュアルとして機能しますが、 Forth の概要と Forth
チュートリアルも含まれています。

Authors: Bernd Paysan, Anton Ertl, Gerald Wodni Copyright (C) 1995,
1996, 1997, 1998, 2000, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
2011, 2012, 2013, 2014,2015,2016,2017,2018,2019,2020,2021,2022,2023 Free
Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant
Sections, with the Front-Cover texts being "A GNU Manual," and with the
Back-Cover Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have freedom to copy and modify this
GNU Manual, like GNU software.  Copies published by the Free Software
Foundation raise funds for GNU development." -->
<title>Macros (Gforth マニュアル)</title>

<meta name="description" content="Macros (Gforth マニュアル)">
<meta name="keywords" content="Macros (Gforth マニュアル)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Word-Index.html" rel="index" title="Word Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Compiling-words.html" rel="up" title="Compiling words">
<link href="Literals.html" rel="prev" title="Literals">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="gforth.css">


</head>

<body lang="en">
<div class="subsection" id="Macros">
<div class="header">
<p>
Previous: <a href="Literals.html" accesskey="p" rel="prev">Literals</a>, Up: <a href="Compiling-words.html" accesskey="u" rel="up">Compiling words</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Word-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Macros-1"></span><h4 class="subsection">6.13.2 Macros</h4>
<span id="index-Macros"></span>
<span id="index-compiling-compilation-semantics"></span>

<p><code>Literal</code> とその仲間たちは、 データ値を現在の定義にコンパイルします。
他のワードを現在の定義にコンパイルするワードを記述することもできます。 例えば:
</p>
<div class="example">
<pre class="example">: compile-+ ( -- ) \ compiled code: ( n1 n2 -- n )
  POSTPONE + ;

: foo ( n1 n2 -- n )
  [ compile-+ ] ;
1 2 foo .
</pre></div>

<p>これは <code>: foo + ;</code> と同等です(確認するには <code>see foo</code> としてください)。
この例では何が起こっているのでしょうか? <code>Postpone</code> は、 <code>+</code> のコンパイル機能(compilation
semantics)を <code>compile-+</code> にコンパイルします。 その後、 テキスト・インタープリターは <code>compile-+</code>
を実行し、 + のコンパイル機能(compilation semantics)を実行します。 これにより、<code>+</code>
(の実行機能(execution semantics)) が <code>foo</code> にコンパイルされます<a id="DOCF23" href="#FOOT23"><sup>23</sup></a>。
</p>
<span id="index-postpone-_0028--_0022name_0022-_002d_002d--_0029-core"></span>
<span id="index-postpone"></span>
<span id="index-postpone-1"></span>
<div class="format">
<pre class="format"><code>postpone</code> ( <i>&quot;name&quot; &ndash;  </i>) core &ldquo;postpone&rdquo;
</pre></div>
<p><i>name</i> の コンパイル機能(compilation semantics)をコンパイルする。
</p>


<p><code>compile-+</code> のようなコンパイル・ワード(compiling
words)のコンパイルは通常即実行ワード(または即実行同様)であるため、 それらを実行するためにインタプリタ状態に切り替える必要はありません。
最後の例をそれに応じて変更すると、 以下のようになります:
</p>
<div class="example">
<pre class="example">: [compile-+] ( compilation: --; interpretation: -- )
  \ compiled code: ( n1 n2 -- n )
  POSTPONE + ; immediate

: foo ( n1 n2 -- n )
  [compile-+] ;
1 2 foo .
</pre></div>

<p>場合によっては、 複数のワードを POSTPONE する必要があることに気づくでしょう。 このような各ワードの前に POSTPONE
を置くのは面倒なので、 Gforth ではより便利な構文 <code>]] ... [[</code> を提供しています。  これにより、
<code>[compile-+]</code> を以下のように記述できるようになります:
</p>
<div class="example">
<pre class="example">: [compile-+] ( compilation: --; interpretation: -- )
  ]] + [[ ; immediate
</pre></div>

<span id="index-_005d_005d-_0028--_002d_002d--_0029-gforth_002d0_002e6"></span>
<span id="index-_005d_005d"></span>
<span id="index-_005d_005d-1"></span>
<div class="format">
<pre class="format"><code>]]</code> ( <i>&ndash;  </i>) gforth-0.6 &ldquo;right-bracket-bracket&rdquo;
</pre></div>
<p>postpone 状態に切り替え: すべてのワードと認識器(recognizers)は、 その前に <code>postpone</code>
があるかのように処理されます。  <code>[[</code> が認識されると、 postpone 状態は終了します。
</p>


<p>角括弧の珍しい方向はその機能を示しています。 <code>]</code> が即時実行(インタープリター状態)からコンパイルに切り替えるのと同じように、
<code>]]</code> はコンパイルから postpone 状態(つまり、 コンパイル機能のコンパイル)に切り替えます。  逆に、 <code>[[</code> は
postpone 状態からコンパイル状態に切り替えます。 これは、 コンパイル状態から即時実行(インタープリター状態)に切り替える <code>[</code>
に似ています。
</p>
<p><code>]] </code>...<code> [[</code> の本当の利点は、 POSTPONE するワードがたくさんある場合に明らかになります。  たとえば、
ワード <code>compile-map-array</code> (see <a href="Advanced-macros-Tutorial.html">Advanced macros</a>) は、
以下のようにさらに短く書くことができます:
</p>
<div class="example">
<pre class="example">: compile-map-array ( compilation: xt -- ; run-time: ... addr u -- ... )
\ at run-time, execute xt ( ... x -- ... ) for each element of the
\ array beginning at addr and containing u elements
  {: xt: xt :}
  ]] cells over + swap ?do
    i @ xt 1 cells +loop [[ ;

: sum-array ( addr u -- n )
  0 [ ' + compile-map-array ] ;
</pre></div>

<p><code>see sum-array</code> すると、 以下のコードが表示されます:
</p>
<div class="example">
<pre class="example">: sum-array
  #0 over + swap ?do
    i &nbsp;+ #8 +LOOP
;
</pre></div>

<p><code>]]</code>...<code>[[</code> に加えて、 この例では他の機能もいくつかお披露目しています:
</p>
<ul>
<li> (<code>xt:</code> を指定する) defer フレーバーのローカル変数 <code>xt</code> を使用しています。
<code>]]</code>...<code>[[</code> 内でローカル変数 xt に遭遇すると、 ローカル変数 xt を <code>compile,</code> します。

</li><li> <code>]]</code>...<code>[[</code> 内でリテラル <code>1</code> を使用します。  これにより、 <code>1</code> が postpone
(延期)されます。 つまり、 <code>compile-map-array</code> の実行時にコンパイルされます。

</li><li> <code>compile-map-array</code> が実行されると、 <code>1 cells</code> がコンパイルされ、 Gforth
の定数折りたたみによって <code>#8</code> に最適化(optimize)されます。

</li></ul>

<p>注意: <code>s\&quot;</code> などのワードのパースは postpone 指定時にはパースされないため、 <code>]]</code>...<code>[[</code>
内ではパースされないことに注意してください。 <code>s\&quot; mystring\n&quot;</code> の代わりに、 文字列認識器(string
recognizer)を使用して、 <code>]]</code>...<code>[[</code> 内で動作する <code>&quot;mystring\n&quot;</code>
で記述することができます。これは <code>]]</code>...<code>[[</code> 内で機能します。 同様に、 パース・ワード <code>[']</code>
についても、  <code>`</code> で始まる認識器(recognizer)表記で記述することができます。
</p>
<p>ただし、 あなたが <code>s\&quot;</code> を使用したい場合(または、 認識器(recognizer)置換がないパース・ワードがある場合)、
以下のようにコンパイル状態に切り替えることで実行できます:
</p>
<div class="example">
<pre class="example">]] ... [[ s\&quot; mystring\n&quot; ]] 2literal ... [[
</pre></div>

<p>標準 Forth での <code>]]</code> と、 その仲間の定義は、 <samp>compat/macros.fs</samp> で提供されます。
</p>
<p>即時コンパイル・ワード(immediate compiling words)は、 他の言語(特に Lisp)のマクロに似ています。
C言語などのマクロとの重要な違いは以下のとおりです:
</p>
<ul>
<li> マクロの定義と処理には、 別個の前処理用の言語や処理器ではなく、 同一の言語を使用します。

</li><li> したがって、 Forth の全機能をマクロ定義で利用できます。 たとえば、 任意の複雑な計算を実行したり、
条件付きまたはループで異なるコードを生成したりできます (例: see <a href="Advanced-macros-Tutorial.html">Advanced macros</a>)。  この能力は、
パーサ・ジェネレータや、 その他のコード生成ソフトウェアを作成するときに非常に役立ちます。

</li><li> <code>postpone</code> などを使用して定義されたマクロは、 文字列よりも高いレベルで言語を扱います。 名前との結び付け(name
binding)はマクロ定義時に行われるため、 C言語のマクロで発生する可能性のある名前の衝突の落とし穴を回避できます。 もちろん、 Forth
は自由主義の言語(liberal language)であり、 以下のようなテキスト解釈マクロ(text-interpreted
macros)を使用して自分自身を攻撃することもできます

<div class="example">
<pre class="example">: [compile-+] s&quot; +&quot; evaluate ; immediate
</pre></div>

<p>マクロ使用時に名前を結びつける(bind)だけでなく、 <code>evaluate</code> を使用すると、 あなたの定義は
<code>state</code>-smart (see <a href="Combined-words.html#state_002dsmartness">state-smartness</a>) になります。
</p></li></ul>

<p>マクロで数値をワードにコンパイルすることが必要な場合があります。  これを行うためのワードは <code>literal</code> ですが、
<code>postpone</code> する必要があるため、 <code>literal</code> のコンパイル機能(compilation
semantics)はマクロがコンパイルされる時ではなくマクロの実行時に効果を発揮します:
</p>
<div class="example">
<pre class="example">: [compile-5] ( -- ) \ compiled code: ( -- n )
  5 POSTPONE literal ; immediate

: foo [compile-5] ;
foo .
</pre></div>

<p>マクロにパラメータを渡して、 マクロを現在の定義にコンパイルする必要がある場合があります。  パラメータが数値の場合は、 <code>postpone
literal</code> を使用できます(他の値の場合も同様)。
</p>
<p>コンパイルされるワードを渡したい場合、 通常の方法は、実行トークンと <code>compile,</code> を渡すことです:
</p>
<div class="example">
<pre class="example">: twice1 ( xt -- ) \ compiled code: ... -- ...
  dup compile, compile, ;

: 2+ ( n1 -- n2 )
  [ ' 1+ twice1 ] ;
</pre></div>

<span id="index-compile_002c-_0028--xt-_002d_002d--_0029-core_002dext"></span>
<span id="index-compile_002c"></span>
<span id="index-compile_002c-1"></span>
<div class="format">
<pre class="format"><code>compile,</code> ( <i>xt &ndash;  </i>) core-ext &ldquo;compile-comma&rdquo;
</pre></div>
<p><i>xt</i> で表される機能(semantics)を現在の定義に追加します。 結果のコード断片が実行されると、 <i>xt</i> が
<code>execute</code> されたのと同一の振る舞いをします。
</p>


<p>Gforth で利用可能な代替方法では、 コンパイル機能をパラメータ(compilation semantics)として渡すことができる、
コンパイル・トークンを使用します(see <a href="Compilation-token.html">Compilation token</a>)。 以下は、 上記と同じ例にこの方法を使ったものです:
</p>
<div class="example">
<pre class="example">: twice ( ... ct -- ... ) \ compiled code: ... -- ...
  2dup 2&gt;r execute 2r&gt; execute ;

: 2+ ( n1 -- n2 )
  [ comp' 1+ twice ] ;
</pre></div>

<p>この例では、 <code>2&gt;r</code> と <code>2r&gt;</code> により、 実行(execute)されるコンパイル機能(compilation
semantics)がデータ・スタックに影響を与える場合でも、 <code>twice</code> が確実に機能するようにします(訳注: 2dup ( ct ct
) 2&gt;r ( ct r:ct ) execute ( ?? r:ct ) 2r&gt; ( ?? ct ) execute ( ??? ) 。 最初の
execute でデータ・スタックのTOSがどうなろうとも、 2つ目の execute のために ct を tos に与えるため。 ct は
2セル単位なので、 2dupで複製、 2&gt;r ... 2r&gt; で ct を1つ退避となる)
</p>
<p>これらのワードを使用して完全な定義を定義することもできます。 これは、 <code>does&gt;</code>
を使用する代わりの方法を提供します(see <a href="User_002ddefined-Defining-Words.html">User-defined Defining Words</a>)。  たとえば以下の代わりに
</p>
<div class="example">
<pre class="example">: curry+ ( n1 &quot;name&quot; -- )
    CREATE ,
DOES&gt; ( n2 -- n1+n2 )
    @ + ;
</pre></div>

<p>以下のように定義することができます
</p>
<div class="example">
<pre class="example">: curry+ ( n1 &quot;name&quot; -- )
  \ name execution: ( n2 -- n1+n2 )
  &gt;r : r&gt; POSTPONE literal POSTPONE + POSTPONE ; ;

-3 curry+ 3-
see 3-
</pre></div>

<p>n1 にアクセスするために <code>&gt;r : r&gt;</code> というシーケンスが必要です。 なぜなら、 <code>:</code> はデータ・スタックに
colon-sys をプッシュし、 それより下にある全てのモノにアクセスできなくなるためです。
</p>
<p>ワードを定義するこの方法は、 <code>does&gt;</code> を使用するよりも便利な場合もあれば、 そうでない場合もあります(see <a href="Advanced-does_003e-usage-example.html">Advanced does&gt; usage example</a>)。  この方式の利点の 1 つは、 コンパイラーは、  <code>literal</code>
でコンパイルされた値が固定されているのに対して、 <code>create</code> されたワードに関連付けられたデータは変更可能なことを認識しているため、
より適切に最適化できることです。
</p>
<span id="index-_005bcompile_005d-_0028--compilation-_0022name_0022-_002d_002d-_003b-run_002dtime-_003f-_002d_002d-_003f--_0029-core_002dext"></span>
<span id="index-_005bcompile_005d"></span>
<span id="index-_005bcompile_005d-1"></span>
<div class="format">
<pre class="format"><code>[compile]</code> ( <i>compilation &quot;name&quot; &ndash; ; run-time ? &ndash; ?  </i>) core-ext &ldquo;bracket-compile&rdquo;
</pre></div>
<p>古いワード(lLegacy word)です。  代わりに <code>postpone</code> を使用してください。  <i>name</i>
がデフォルト以外のコンパイル機能(compilation semantics)を持つ場合は、 <code>postpone</code> と同様に機能します。
<i>name</i> がデフォルトのコンパイル機能を持つ(つまり、 通常のワードである)場合、 <code>[compile] <i>name</i></code>
をコンパイルすることは、 <i>name</i> をコンパイルすることと同じです(つまり、 この場合 <code>[compile]</code> は冗長です)。
</p>


</div>
<div class="footnote">
<hr>
<h4 class="footnotes-heading">Footnotes</h4>

<h5><a id="FOOT23" href="#DOCF23">(23)</a></h5>
<p>最近の RFI の回答では、
ワードのコンパイルはコンパイル状態でのみ実行する必要があるとしているため、 この例はすべての標準システムで動作することは保証されませんが、
ちゃんとした(decent)システムであれば動作します</p>
</div>
<hr>
<div class="header">
<p>
Previous: <a href="Literals.html">Literals</a>, Up: <a href="Compiling-words.html">Compiling words</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Word-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
