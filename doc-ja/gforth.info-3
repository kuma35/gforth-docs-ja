This is gforth.info, produced by makeinfo version 6.8 from gforth.texi.

このマニュアルは、 標準 Forth 言語の高速で移植可能な実装である Gforth (バ
ージョン 0.7.9_20240418, April 18, 2024)用です。 これはリファレンス・マ
ニュアルとして機能しますが、 Forth の概要と Forth チュートリアルも含まれ
ています。

   Authors: Bernd Paysan, Anton Ertl, Gerald Wodni Copyright © 1995,
1996, 1997, 1998, 2000, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
2011, 2012, 2013, 2014,2015,2016,2017,2018,2019,2020,2021,2022,2023 Free
Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover texts
     being “A GNU Manual,” and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by the
     Free Software Foundation raise funds for GNU development.”
INFO-DIR-SECTION Software development
START-INFO-DIR-ENTRY
* Gforth: (gforth).          forth言語のための高速インタプリタ
END-INFO-DIR-ENTRY


File: gforth.info,  Node: Formatted numeric output,  Next: Floating-point output,  Prev: Simple numeric output,  Up: Other I/O

6.20.2 Formatted numeric output
-------------------------------

Forth は伝統的に、 整数の書式設定された出力に「表示数値出力」(“pictured
numeric Output”) と呼ばれる手法を使用しています。 この手法では、 数値か
ら数字桁(digits)が抽出され(‘base’ で定義された現在の出力基数を使用 *note
Number Conversion::)、 ASCII コードに変換され、 メモリのスクラッチパッド
領域(*note Implementation-defined options: core-idef.)に構築される文字列
の先頭に付加されます。 抽出プロセス中に、 文字列の先頭に任意の文字を追加
できます。 完成した文字列はアドレスと長さによって指定され、 プログラム制
御の下で操作(‘TYPE’ や、 コピーや、 変更)できます。

   前のセクションで説明したすべての整数出力ワード (*note Simple numeric
output::) は、 Gforth では表示数値出力(pictured numeric output)を使用し
て実装されています。

   表示数値出力(pictured numeric output)について覚えておくべき 3 つの重
要な点:

   • 常に2倍長整数を処理します。 1倍長整数を表示するには、 まず最初に2倍
     長に変換します (これを行う方法は *note Double precision::)。
   • 2倍長整数は常に符号無しであるかのように扱われます。 下記の例は、 符
     号付き数値を出力する方法を示しています。
   • 文字列は右から左に構築されます。 最下位桁が最初です。

   標準 Forth は、 ‘<#’ で空にして初期化し、 ‘#>’ で結果文字列を取得する
単一の出力バッファー(別名ホールド領域;hold area)をサポートします。

   Gforth はさらに、 このバッファーの入れ子になった使用をサポートしてお
り、 たとえば、 ホールド領域を処理するコード内でデバッグ・トレーサー
‘~~’ からの出力を入れ子にすることができます。 ‘<<#’ は新しい入れ子を開始
し、 ‘#>’ は結果文字列を生成し、 ‘#>>’ は入れ子を解除します。 入れ子のホ
ールド領域が再利用され、‘#>’ は次に外側の入れ子の文字列を生成します。
Gforth の高レベルの数値出力ワードはすべて ‘<<#’ ...  ‘#>’ ...  ‘#>>’ を
使用し、 ホールド領域の他のユーザー内に入れ子にできます。

‘<#’ ( –  ) core “less-number-sign”
   表示数値出力文字列を 初期化/クリア します(訳注: 表示数値出力用のポイ
ンタをホールド領域の末尾(初期値)に戻すだけ。 中身は消さない。)

‘<<#’ ( –  ) gforth-0.5 “less-less-number-sign”
   ‘#>>’ で終わるホールド領域を開始します。 相互に入れ子にすることも、
‘<#’ で入れ子にすることもできます。 注: ‘<<#’ と ‘#>>’ を一致させないと
、 最終的にホールド領域が不足します。 ‘<#’ を使用してホールド領域を空に
リセットできます。

‘#’ ( ud1 – ud2  ) core “number-sign”
   ‘<<#’ と ‘#>’ の間で使用されます。 UD1 の最下位桁(‘base’ による)を、
表示数値出力文字列の先頭に追加します。 UD2 は UD1/BASE、 つまり残りの桁
を表す数値です。

‘#s’ ( ud – 0 0  ) core “number-sign-s”
   ‘<<#’ と ‘#>’ の間で使用されます。 UD のすべての数字を表示数値出力文
字列の先頭に追加します。 ‘#s’ は少なくとも 1 つの数字を変換します。 した
がって、 UD が 0 の場合、 ‘#s’ は表示数値出力文字列の先頭に ‘0‘ を追加し
ます。

‘hold’ ( char –  ) core “hold”
   ‘<<#’ と ‘#>’ の間で使用されます。 表示数値出力文字列の前に文字 CHAR
を追加します。

‘holds’ ( addr u –  ) core-ext “holds”
   ‘<<#’ と ‘#>’ の間で使用されます。 表示数値出力文字列の前に文字列
‘addr u’ を追加します。

‘sign’ ( n –  ) core “sign”
   ‘<<#’ と ‘#>’ の間で使用されます。 N (1倍長整数) が負の場合、 表示数
値出力文字列の先頭に ‘-’ を追加します。

‘#>’ ( xd – addr u  ) core “number-sign-greater”
   変換対象(変換残りの)数値 XD を破棄し、 フォーマットされた文字列のアド
レスと長さを示す ADDR U を返すことで、 表示数値出力文字列を完成させます
。 標準のプログラムでは、 文字列内の文字を変更する場合があります。 ホー
ルド領域は解放されません。 ‘#>>’ を使用して ‘<<#’ で始まるホールド領域を
解放するか、 ‘<#’ を使用してすべてのホールド領域を解放します。

‘#>>’ ( –  ) gforth-0.5 “number-sign-greater-greater”
   ‘<<#’ で始まるホールド領域を解放します。

以下に、 表示数値出力の使用例をいくつか示します:

     : my-u. ( u -- )
       \ PNS(Pictured Number String)の最も単純な使用法。標準の u. のように振る舞います。
       0              \ 上記 u を 2倍長にする
       <<#            \ 変換開始
       #s             \ 全桁を変換
       #>             \ 変換終了
       TYPE SPACE     \ 表示、続けて空白1つ
       #>> ;          \ ホールド領域を開放

     : cents-only ( u -- )
       0              \ 上記 u を 2倍長整数に変換
       <<#            \ 変換開始
       # #            \ 最下位と最下位からの次の 2 桁のみ変換
       #>             \ 変換完了。他の桁は破棄
       TYPE SPACE     \ 表示、続けて空白1つ
       #>> ;          \ ホールド領域を開放

     : dollars-and-cents ( u -- )
       0              \ 上記 u を符号無し2倍長整数に変換
       <<#            \ 変換開始
       # #            \ 下位2桁を変換
       '.' hold       \ 小数点を打つ
       #s             \ 残りの桁を変換
       '$' hold       \ 通貨記号を打つ
       #>             \ 変換完了
       TYPE SPACE     \ 表示、続けて空白1つ
       #>> ;          \ ホールド領域を開放

     : my-. ( n -- )
       \ 負数も処理する標準の . のように振る舞う
       s>d            \ 符号付き2倍長整数に変換
       swap over dabs \ 符号バイトを別途保存して数値は符号無し2倍長に
       <<#            \ 変換開始
       #s             \ 全桁を変換
       rot sign       \ 符号チェック。必要なら "-" 付加
       #>             \ 変換完了
       TYPE SPACE     \ 表示、続けて空白1つ
       #>> ;          \ ホールド領域を開放

     : account. ( n -- )
       \ (会計風出力)会計士はマイナス記号が嫌いで、
       \ 負の数には括弧を使用します
       s>d            \ 符号付き2倍長整数に変換
       swap over dabs \ 符号バイトを別途保存して数値は符号無し2倍長に
       <<#            \ 変換開始
       2 pick         \ 符号バイトのコピーを得る
       0< IF ')' hold THEN \ これが(あれば)出力の右端の文字
       #s             \ 全桁を変換
       rot            \ 符号バイトを得る
       0< IF '(' hold THEN
       #>             \ 変換完了
       TYPE SPACE     \ 表示、続けて空白1つ
       #>> ;          \ ホールド領域を開放


   これらのワードの利用例をいくつか示します:

     1 my-u. 1  ok
     hex -1 my-u. decimal FFFFFFFFFFFFFFFF  ok
     1 cents-only 01  ok
     1234 cents-only 34  ok
     2 dollars-and-cents  $0.02  ok
     1234 dollars-and-cents  $12.34  ok
     123 my-. 123  ok
     -123 my-. -123  ok
     123 account. 123  ok
     -456 account. (456)  ok



File: gforth.info,  Node: Floating-point output,  Next: Miscellaneous output,  Prev: Formatted numeric output,  Up: Other I/O

6.20.3 Floating-point output
----------------------------

浮動小数点数出力は常に基数 10 を使用して表示されます。

‘f.’ ( r –  ) floating-ext “f-dot”
   (浮動小数点数) r を指数なしで表示し、 その後に空白1つ続けます。

‘fe.’ ( r –  ) floating-ext “f-e-dot”
   r を工学表記(3 で割り切れる指数) で表示し、 その後に空白1つ続けます。

‘fs.’ ( r –  ) floating-ext “f-s-dot”
   r を科学表記(指数付き)で表示し、 その後に空白1つ続けます。

‘fp.’ ( r –  ) floating-ext “f-p-dot”
   r を SI 接頭辞表記(3 で割れる指数を使用し、 可能な場合は SI 接頭辞に
変換)で表示し、 その後に空白1つ続けます。

   数値 1234.5678E23 をさまざまな浮動小数点数出力形式で出力する例を以下
に示します。

     1234.5678E23 f. 123456780000000000000000000.  ok
     1234.5678E23 fe. 123.456780000000E24  ok
     1234.5678E23 fs. 1.23456780000000E26  ok
     1234.5678E23 fp. 123.456780000000Y  ok

   出力桁幅は以下の影響を受けます:

‘precision’ ( – u  ) floating-ext “precision”
   u は、 ‘f.’ や ‘fe.’ や ‘fs.’ や ‘fp.’ で現在使用されている有効桁数で
す。

‘set-precision’ ( u –  ) floating-ext “set-precision”
   ‘f.’ や ‘fe.’ や ‘fs.’ や ‘fp.’ で現在使用されている有効桁数を u に設
定します。

   以下のコマンドを使用して、 出力をより詳細に制御できます:

‘f.rdp’ ( rf +nr +nd +np –  ) gforth-0.6 “f.rdp”
   浮動小数点数 rf を書式化して表示します。 出力の合計幅は nr です。 固
定小数点表記の場合、 小数点以下の桁数は +nd、 有効桁数の最小値は np です
。 ‘Set-precision’ は ‘f.rdp’ には影響しません。 固定小数点表記は、 有効
桁数が少なくとも np の場合で、 かつ、 小数点以下の桁数が収まる場合に、 使
用されます。 固定小数点表記が使用されない場合は指数表記が使用され、 それ
でも適合しない場合はアスタリスクが出力されます。 数値がまったく適合しな
いリスクを避けるために、 nr>=7 を使用することをお勧めします。 ‘f.rdp’ が
指数表記に切り替わるケースを避けるために、 nr>=np+5 をお勧めします。 ど
うしてかというと、 固定小数点表記でも有効桁数が少なすぎるのに、 指数表記
では有効桁数が更に少なくなるためです。 一部の数値を固定小数点表記しなけ
ればならない場合は、 nr>=nd+2 をお勧めします。 np の値が小さいほど、 よ
り多くの場合で固定小数点表記で表示されます (固定小数点表記に有効数字がほ
とんどまたはまったく残っていない場合)。 すべての数値を指数表記したい場合
は、np>nr をお勧めします。

   出力にどのような影響を与えるかをより直感的に理解できるように、 パラメ
ーターの組み合わせの例をいくつか示します。 各行内は同じ数値が出力されて
いて、 各列には同じパラメータの組み合わせが出力に使用されています:

         12 13 0    7 3 4   7 3 0   7 3 1   7 5 1   7 7 1   7 0 2  4 2 1
     |-1.234568E-6|-1.2E-6| -0.000|-1.2E-6|-1.2E-6|-1.2E-6|-1.2E-6|****|
     |-1.234568E-5|-1.2E-5| -0.000|-1.2E-5|-.00001|-1.2E-5|-1.2E-5|****|
     |-1.234568E-4|-1.2E-4| -0.000|-1.2E-4|-.00012|-1.2E-4|-1.2E-4|****|
     |-1.234568E-3|-1.2E-3| -0.001| -0.001|-.00123|-1.2E-3|-1.2E-3|****|
     |-1.234568E-2|-1.2E-2| -0.012| -0.012|-.01235|-1.2E-2|-1.2E-2|-.01|
     |-1.234568E-1|-1.2E-1| -0.123| -0.123|-.12346|-1.2E-1|-1.2E-1|-.12|
     |-1.2345679E0| -1.235| -1.235| -1.235|-1.23E0|-1.23E0|-1.23E0|-1E0|
     |-1.2345679E1|-12.346|-12.346|-12.346|-1.23E1|-1.23E1|   -12.|-1E1|
     |-1.2345679E2|-1.23E2|-1.23E2|-1.23E2|-1.23E2|-1.23E2|  -123.|-1E2|
     |-1.2345679E3|-1.23E3|-1.23E3|-1.23E3|-1.23E3|-1.23E3| -1235.|-1E3|
     |-1.2345679E4|-1.23E4|-1.23E4|-1.23E4|-1.23E4|-1.23E4|-12346.|-1E4|
     |-1.2345679E5|-1.23E5|-1.23E5|-1.23E5|-1.23E5|-1.23E5|-1.23E5|-1E5|

   以下を使用して、 数値を表示する代わりに文字列を生成できます:

‘f>str-rdp’ ( rf +nr +nd +np – c-addr nr  ) gforth-0.6 “f>str-rdp”
   rf を c-addr nr の文字列に変換します。 nr +nd np の変換規則と意味は
‘f.rdp’ と同じです。 結果は表示数値出力(pictured numeric output)バッファ
ーに格納され、 そのバッファを破壊するものによって破壊されます(訳注: この
バッファーは、 他の 表示数値出力(pictured numeric output) と共用であると
いうこと)。

‘f>buf-rdp’ ( rf c-addr +nr +nd +np –  ) gforth-0.6 “f>buf-rdp”
   rf を c-addr nr の文字列に変換します。 nr nd np の変換規則と意味は
‘f.rdp’ と同じです。

   以下のような、 高レベルの FP-to-string ワードを実装するために使用され
るプリミティブもあります:

‘represent’ ( r c-addr u – n f1 f2 ) floating “represent”
   r の 10 進仮数部(別名 mantissa)をバッファ c-addr u 内の文字列に変換し
ます。 n は指数で、r が負の場合は f1 が true、 r が有効(Gforth の有限数
)の場合は f2 が true です(訳注: 仮数部が u の桁数になるようそれ以下を四
捨五入するっぽい)。


File: gforth.info,  Node: Miscellaneous output,  Next: Displaying characters and strings,  Prev: Floating-point output,  Up: Other I/O

6.20.4 Miscellaneous output
---------------------------

‘cr’ ( –  ) core “c-r”
   (ホスト OS の好みの種類の)改行(newline)を出力します。 注意: Forth コ
マンド・ライン・インタプリタの改行(newline)挿入のクセのため、 ‘cr’ をテ
キストの先頭で使用することをお勧めします。 例: ‘cr ." hello, world"’.

‘space’ ( –  ) core “space”
   空白を1つ表示する。

‘spaces’ ( u –  ) core “spaces”
   U 個の空白を表示します。

‘out’ ( – addr  ) gforth-1.0 “out”
   ‘addr’ には、 ユーザー出力デバイス上の現在行内のカーソルの位置を指定
しようと試みる数値が含まれています。 ‘cr’ で 0 にリセットされ、 ‘type’ に
よって文字数ずつ増加、 ‘emit’ で増加、 ‘backspaces’ で減少します。 残念
ながら、 タブ文字や、マルチバイト文字や、 幅 0 と 幅2 のユニコード文字の
存在は考慮されていないため、 単純な場合にのみ機能します。

‘.\"’ ( compilation ’ccc"’ – ; run-time –  ) gforth-0.6 “dot-backslash-quote”
   ‘."’ と似ていますが、 C言語のようなバックスラッシュによるエスケープ・
シーケンス(\-escape-sequences)を認識します(詳しくは ‘S\"’ 参照)。

‘."’ ( compilation ’ccc"’ – ; run-time –  ) core “dot-quote”
   コンパイル時: ‘"‘ (二重引用符)で区切られた文字列 ccc をパースします。
実行時、 その文字列を表示します。 このワードのインタプリタ機能
(interpretation semantics)は、 標準 Forth では定義されていません。
Gforth でのインタプリタ機能(interpretation semantics)は、 その文字列を表
示することです。

‘.(’ ( compilation&interpretation "ccc<paren>" –  ) core-ext “dot-paren”
   コンパイル時(compilation semantics)とインタプリタ時(interpretation
semantics): ‘)’(右括弧)で区切られた文字列 ccc をパースします。 その文字
列を表示します。 これは、 コンパイル中に進行状況情報を表示するためによく
使用されます。 下記の例を参照してください。

   あなたが ‘.( hello)’ を使用するべきか ‘." hello"’ を使用するべきかを
気に掛けたくない場合は、 ‘"hello" type’ と書くことができます。 これによ
り、 通常必要なものが得られます(ただし、他の Forth システムへの移植性は
低くなります)。

例として、 ファイル ‘test.fs’ に保存されている以下のテキストについて考え
てみましょう:

     .( text-1)
     : my-word
       ." text-2" cr
       .( text-3)
       "text-4" type
     ;

     ." text-5"
     "text-6" type

   このコードを Gforth にロードすると、 以下の出力が生成されます:

     include test.fs <RET> text-1text-3text-5text-6 ok

   • ‘.(’ は即実行ワードであるため、 メッセージ ‘text-1’ と ‘text-3’ が
     表示されます。 コロン定義の内側でも外側でも、 全く同じに振る舞いま
     す。
   • ‘."’ に対する Gforth の追加インタプリタ機能(interpretation
     semantics)により、 メッセージ ‘text-5’ が表示されます。
   • ‘"text-6" type’ が通訳(interpret)され、 メッセージ ‘text-6’ が表示
     されます。
   • テキスト・インタプリタが ‘my-word’ の定義内で ‘."’ のコンパイル機能
     (compilation semantics)を実行するため、 メッセージ ‘text-2’ は「表
     示されません」。
   • ‘"text-4" type’ は ‘my-word’ 内にコンパイルされるため、 メッセージ
     ‘text-4’ は「表示されません」。


File: gforth.info,  Node: Displaying characters and strings,  Next: Terminal output,  Prev: Miscellaneous output,  Up: Other I/O

6.20.5 Displaying characters and strings
----------------------------------------

‘type’ ( c-addr u –  ) core “type”
   U>0 なら、 C-ADDR からに格納されている文字列から U 文字を表示します
(訳注: 日本語(UTF-8)の出力も対応)。

‘xemit’ ( xc –  ) xchar “x-emit”
   端末に xchar を出力します。

‘emit’ ( c –  ) core “emit”
   バイト値 c を現在の出力に送信します。 ASCII 文字の場合、 ‘emit’ は
‘xemit’ と同等です。

‘typewhite’ ( addr n –  ) gforth-0.2 “typewhite”
   type と似ていますが、 文字の代わりに空白が表示されます(訳注: 指定の文
字数 n だけ空白出すだけなので日本語(UTF-8)だと表示幅がズレる)。


File: gforth.info,  Node: Terminal output,  Next: Single-key input,  Prev: Displaying characters and strings,  Up: Other I/O

6.20.6 Terminal output
----------------------

端末に出力している場合、 カーソル位置を制御することができます:

‘at-xy’ ( x y –  ) facility “at-x-y”
   カーソルを位置 x y に置きます。 ディスプレイの左上角は 0 0 です。

‘at-deltaxy’ ( dx dy –  ) gforth-0.7 “at-deltaxy”
   現在の位置を x y として、 カーソルを x+dx y+dy に置きます。

   カーソルをどこに置くかを知るには、 以下のように、 画面(screen)のサイ
ズを知っておくと役立つことがよくあります:

‘form’ ( – nlines ncols  ) gforth-0.2 “form”
\ 訳注:画面のサイズを得る

   また、 以下のようなものを使用したい場合もあります:

‘page’ ( –  ) facility “page”
   画面(screen)をクリアする

   注意: ターミナル以外では、フォーム・フィード(form feed;FF)を取得する
には ‘page’ ではなく ‘12 Emit’ を使用する必要があることに注意してくださ
い。

6.20.6.1 Color output
.....................

以下のワード群は、 意味・理由ごとに色を変えるために使用されます。 更に細
かい設定は、 ワードによって指定された色とスタイルで生成されます。 実際の
色とスタイルはテーマによって異なります(下記を参照)。

‘default-color’ ( –  ) gforth-1.0 “default-color”
   システムのデフォルト用の色

‘error-color’ ( –  ) gforth-1.0 “error-color”
   エラー用の色: (通常は)赤

‘error-hl-inv’ ( –  ) gforth-1.0 “error-hl-inv”
   エラー用にハイライトとして反転表示するカラーモード

‘error-hl-ul’ ( –  ) gforth-1.0 “error-hl-ul”
   エラー用にアンダーラインでハイライトする色変更モード

‘warning-color’ ( –  ) gforth-1.0 “warning-color”
   警告(warning)の色: 背景が黒の端末では 青/黄

‘info-color’ ( –  ) gforth-1.0 “info-color”
   情報(info)用の色: 黒色の背景の端末では 緑/シアン

‘success-color’ ( –  ) gforth-1.0 “success-color”
   成功(success)の色: 緑

‘input-color’ ( –  ) gforth-1.0 “input-color”
   ユーザー入力の色: 黒/白 (両方ともボールド)

‘status-color’ ( –  ) gforth-1.0 “status-color”
   エラー用にハイライトとして反転表示するカラーモード

6.20.6.2 Color themes
.....................

あなたが、 明るい背景を好むか暗い背景を好むかに応じて、 前景の色テーマ
(foreground colors-theme)を以下のように変更できます:

‘light-mode’ ( –  ) gforth-1.0 “light-mode”
   白背景用の色テーマ

‘dark-mode’ ( –  ) gforth-1.0 “dark-mode”
   黒背景用の色テーマ

‘uncolored-mode’ ( –  ) gforth-1.0 “uncolored-mode”
   このモードでは色は設定されませんが、 デフォルトの色が使用されます。

‘magenta-input’ ( –  ) gforth-1.0 “magenta-input”
   入力色(input color)を認識しやすくします(プレゼンテーションに役立ちま
す)


File: gforth.info,  Node: Single-key input,  Next: Line input and conversion,  Prev: Terminal output,  Up: Other I/O

6.20.7 Single-key input
-----------------------

単一の印刷可能な文字を取得したい場合は、 ‘key’ を使用できます。 文字が
‘key’ に使用できるかどうかを確認するには、 ‘key?’ を使用できます。

‘key’ ( – char  ) core “key”
   1 文字 CHAR を受け取ります(ただし表示はされません)。

‘key-ior’ ( – char|ior  ) gforth-1.0 “key-ior”
   1 文字 CHAR を受け取ります (ただし表示はされません)。 エラーまたは割
り込みの場合は、 代わりに、 負数の IOR を返します。

‘key?’ ( – flag  ) facility “key-question”
   文字が ‘key’ で使用可能かどうかを判断します。 文字が使用可能な場合、
FLAG は true です。 次に ‘key’ を呼び出すと、 文字が生成されます。 一度
‘key?’ が true を返すと、 その後に ‘key’ または ‘ekey’ を呼び出す前に
‘key?’ を呼び出した場合も true が返されます。

‘xkey?’ ( – flag  ) xchar “x-key-query”
\ 訳注: UTF-8 な環境では key? は xkey? のエイリアスです。
\ xchar 文字が xkey で使用可能かどうかを判断します(たぶん)

   印刷可能な文字と印刷不可能な文字を組み合わせて処理したい場合は、
‘ekey’ とそのファミリーを使用して実行できます。 ‘ekey’ は、 ‘ekey>char’
で文字に変換するか、 ‘ekey>fkey’ でキー識別子に変換する必要があるキーボ
ード・イベントを生成します。

   ekey を使用するための一般的なコードは以下のようになります:

     ekey ekey>xchar if ( xc )
       ... \ do something with the character
     else ekey>fkey if ( key-id )
       case
         k-up                                  of ... endof
         k-f1                                  of ... endof
         k-left k-shift-mask or k-ctrl-mask or of ... endof
         ...
       endcase
     else ( keyboard-event )
       drop \ just ignore an unknown keyboard event type
     then then

‘ekey’ ( – u  ) facility-ext “e-key”
   キーボード・イベント U を受け取りす(実装定義のエンコーディングです) 。

‘ekey>xchar’ ( u – u false | xc true  ) xchar-ext “e-key-to-x-char”
   可能であれば、 キーボード・イベント U を xchar ‘xc’ に変換します。

‘ekey>char’ ( u – u false | c true  ) facility-ext “e-key-to-char”
   可能であれば、 キーボード・イベント U を文字 ‘c’ に変換します。 注意:
非 ASCII 文字は、 ‘ekey>char’ と ‘ekey>fkey’ の両方から ‘false’ が返るこ
とに注意してください。 利用可能な場合は、 ‘ekey>char’ の代わりに
‘ekey>xchar’ を使用します。

‘ekey>fkey’ ( u1 – u2 f  ) facility-ext “e-key-to-f-key”
   u1 が特殊キー(special key)セット内のキーボード・イベントの場合、 キー
ボード・イベント U1 をキー ID U2 に変換し、 true を返します。それ以外の
場合は、 U1 と false を返します。

‘ekey?’ ( – flag  ) facility-ext “e-key-question”
   キーボード・イベントが利用可能な場合は True。

   カーソル・キーのキー識別子は以下のとおりです:

‘k-left’ ( – u  ) facility-ext “k-left”

‘k-right’ ( – u  ) facility-ext “k-right”

‘k-up’ ( – u  ) facility-ext “k-up”

‘k-down’ ( – u  ) facility-ext “k-down”

‘k-home’ ( – u  ) facility-ext “k-home”
   別名 Pos1

‘k-end’ ( – u  ) facility-ext “k-end”

‘k-prior’ ( – u  ) facility-ext “k-prior”
   別名 PgUp

‘k-next’ ( – u  ) facility-ext “k-next”
   別名 PgDn

‘k-insert’ ( – u  ) facility-ext “k-insert”

‘k-delete’ ( – u  ) facility-ext “k-delete”
   著者の xterm 上では<DEL> キーで、 Backspace ではありません

   ファンクション・キー(別名キーパッド・キー)のキー識別子は以下のとおり
です:

‘k-f1’ ( – u  ) facility-ext “k-f-1”

‘k-f2’ ( – u  ) facility-ext “k-f-2”

‘k-f3’ ( – u  ) facility-ext “k-f-3”

‘k-f4’ ( – u  ) facility-ext “k-f-4”

‘k-f5’ ( – u  ) facility-ext “k-f-5”

‘k-f6’ ( – u  ) facility-ext “k-f-6”

‘k-f7’ ( – u  ) facility-ext “k-f-7”

‘k-f8’ ( – u  ) facility-ext “k-f-8”

‘k-f9’ ( – u  ) facility-ext “k-f-9”

‘k-f10’ ( – u  ) facility-ext “k-f-10”

‘k-f11’ ( – u  ) facility-ext “k-f-11”

‘k-f12’ ( – u  ) facility-ext “k-f-12”

   ‘k-f11’ と ‘k-f12’ はそれほど広くには利用可能ではないことに注意してく
ださい。

   これらのキー識別子をさまざまなシフト・キーのマスクと組み合わせること
ができます:

‘k-shift-mask’ ( – u  ) facility-ext “k-shift-mask”

‘k-ctrl-mask’ ( – u  ) facility-ext “k-ctrl-mask”

‘k-alt-mask’ ( – u  ) facility-ext “k-alt-mask”

   ASCII 値を持つキーが多数あるため、 特殊キーとして報告される可能性は低
いですが、 以下のキーとシフト・キーの組み合わせは特殊キーとして報告され
る可能性があります:

‘k-enter’ ( – u  ) gforth-1.0 “k-enter”

‘k-backspace’ ( – u  ) gforth-1.0 “k-backspace”

‘k-tab’ ( – u  ) gforth-1.0 “k-tab”

   さらに、 キーおよびその他のイベントには以下のキー・コードがあります:

‘k-winch’ ( – u  ) gforth-1.0 “k-winch”
   ユーザーがウィンドウ・サイズを変更したときに生成される可能性のあるキ
ー・コード。

‘k-pause’ ( – u  ) gforth-1.0 “k-pause”

‘k-mute’ ( – u  ) gforth-1.0 “k-mute”

‘k-volup’ ( – u  ) gforth-1.0 “k-volup”

‘k-voldown’ ( – u  ) gforth-1.0 “k-voldown”

‘k-sel’ ( – u  ) gforth-1.0 “k-sel”
   Androidでの選択(selections)のキー・コード

‘k-eof’ ( – u  ) gforth-1.0 “k-eof”

   注意: Forth システムに ‘ekey>fkey’ とキー識別子のワードがある場合でも
、 そのキーが必ずしも利用可能であるとは限らず、 すべてのキーとシフト・マ
スクとの可能なすべての組み合わせを報告できるとは限らないことに注意してく
ださい。 したがって、キーやキーの組み合わせが押せない場合や認識されない
場合でも、プログラムが使えるようにプログラムを作成してください。

   例: 古いキーボードには F11 キーと F12 キーがないことがよくあります。
xterm で Gforth を実行すると、xterm は多数の組み合わせ(例: <Shift-Up>)を
捕捉しますが、それを Gforth に渡すことはありません。 最後に、Gforth は現
在、 複数のシフト・キーの組み合わせを認識して報告しません(そのため、上記
の例の <shift-ctrl-left> のケースは決して入力されません)。

   Gforth は、ANSI 端末で利用可能なさまざまなキーを認識します(MS-DOS で
は、 その動作を実現するには ANSI.SYS ドライバーが必要です)。 これは、 そ
のようなキーが押されたときに ANSI 端末が送信するエスケープ・シーケンスを
認識することによって機能します。 他のエスケープ・シーケンスを送信する端
末を使用している場合、 Gforth では有益な結果は得られません。 他の Forth
システムは異なる方法で動作する可能性があります。

   Gforth には、 ファンクション・キーの名前を出力するためのいくつかのワ
ードも用意されています:

‘fkey.’ ( u –  ) gforth-1.0 “fkey-dot”
   ファンクション・キー u の文字列表現を出力します。 U はファンクション
・キー(おそらく修飾子マスク付き)でなければなりません。 そうでない場合は
例外が発生する可能性があります。

‘simple-fkey-string’ ( u1 – c-addr u  ) gforth-1.0 “simple-fkey-string”
   c-addr u は、ファンクション・キー u1 の文字列名です。 修飾子マスクの
ない単純なファンクション・キーに対してのみ機能します。 現在、 単純なファ
ンクション・キーでない u1 では例外を生成します。


File: gforth.info,  Node: Line input and conversion,  Next: Pipes,  Prev: Single-key input,  Up: Other I/O

6.20.8 Line input and conversion
--------------------------------

文字列をメモリに保存する方法については、 *note String representations::
を参照してください。

   キーボードから一行入力するためのワード群:

‘accept’ ( c-addr +n1 – +n2  ) core “accept”
   ユーザー入力デバイスから最大 N1 文字の文字列を取得し、 C-ADDR に保存
します。 N2 は受け取った文字列の長さです。 ユーザーは <RET> を押して終了
を指示します。 Gforth は、 ‘accept’ で、 Forth コマンド・ラインで利用で
きるすべての編集機能(履歴やワード補完を含む)をサポートしています。

‘edit-line’ ( c-addr n1 n2 – n3  ) gforth-0.6 “edit-line”
   ‘accept’ のように振る舞いますが、バッファ C-ADDR N1 の内容を先頭から
長さ n2 まで引用します( n2=0 の場合、 全く引用せず、 空の状態から入力編
集開始になります)。 受け取った文字列の長さを n3 に返します。

   変換ワード群:

‘s>number?’ ( addr u – d f  ) gforth-0.5 “s>number?”
   文字列 addr u を 符号付き2倍長整数 d に変換し、 フラグ f が true なら
ば成功、 false ならば変換失敗です( d の値は保証されません) (訳注: フラグ
が true の場合でも ‘-15.’ 基数プレフィックスを付けずに記述した場合、 警
告が出力されます。 警告が出ないようにするには基数プレフィックスを付けて
下さい ‘#-15.’)

‘s>unumber?’ ( c-addr u – ud flag  ) gforth-0.5 “s>unumber?”
   文字列 c-addr u を 符号なし2倍長整数 ud に変換します。 フラグ f が
true ならば成功、 false ならば変換失敗です( d の値は保証されません)。 (訳
注: フラグが true の場合でも ‘15.’ 基数プレフィックスを付けずに記述した
場合、 警告が出力されます。 警告が出ないようにするには基数プレフィックス
を付けて下さい ‘#15.’ 、 注意: 負数も受け付けます; "#-15."  s>unumber?
.s <3> -15 -1 -1 ok drop -15 -1 ud.
340282366920938463463374607431768211441 ok
"#340282366920938463463374607431768211441."  s>unumber?  .s <3> -15 -1
-1 ok 3 )

‘>number’ ( ud1 c-addr1 u1 – ud2 c-addr2 u2  ) core “to-number”
   文字列 C-ADDR1 U1 を現在の基数で符号なし2倍長整数に変換しようと試みま
す。 符号なし2倍長整数 UD1 に変換結果を積算して UD2 にします。 変換は、
文字列全体が変換されるか、 現在の基数で変換できない文字( ‘+‘ または ‘-‘
を含む)が検出されるまで、 左から右に続行されます。 変換可能な各文字ごと
に、 UD1 * ‘base’ してから、 次にその文字によって表される値を足しこみま
す( new ud1 = ud1 * base + digit )。 C-ADDR2 は、 最初の未変換文字の位置
です(文字列全体が変換された場合は文字列の末尾以降)。 U2 は、 文字列内の
未変換の文字の数です。 最後まで変換出来たときは 0 です。 オーバーフロー
は検出されません。

‘>float’ ( c-addr u – f:... flag ) floating “to-float”
   実際のスタック効果: ( c_addr u – r t | f )。 文字列 c-addr u を内部浮
動小数点表現に変換しようとします。 文字列が有効な浮動小数点数を表す場合
、 r が浮動小数点スタックに配置され、 flag が true になります。 それ以外
の場合、flag は false になります(訳注: この場合、 浮動小数点数スタックに
は何も積まれない)。 空白の文字列は特殊なケースであり、 浮動小数点数 0 を
表します。

‘>float1’ ( c-addr u c – f:... flag ) gforth-1.0 “to-float1”
   実際のスタック効果: ( c_addr u c – r t | f ) c を小数点として使用して
(訳注: ’.’ が小数点とは限らない。ロケールにより異なるため、指定できるよ
うになっている)、 文字列 c-addr u を内部浮動小数点表現に変換しようと試み
ます。 文字列が有効な浮動小数点数を表す場合、 r が浮動小数点スタックに配
置され、 flag が true になります。 それ以外の場合、flag は false になり
ます(この場合、浮動小数点数スタックには何も積まれません)。 空白の文字列
は特殊なケースであり、浮動小数点数 0 を表します。

   時代遅れ(OBSOLESCENT)の入力ワード群と変換ワード群:

‘convert’ ( ud1 c-addr1 – ud2 c-addr2  ) core-ext-obsolescent “convert”
   時代遅れ(OBSOLESCENT): ‘>number’ に置き換えられました。

‘expect’ ( c-addr +n –  ) core-ext-obsolescent “expect”
   最大 +n 文字の文字列を受け取り、c-addr から始まるメモリに保存します。
文字列は表示されます。 <return>キーを押すか、 +n 文字を受け取ると入力が
終了します。 通常の Gforth 行編集機能が利用可能です。 文字列の長さは
‘span’ に保存されますが、 <return> 文字は含まれません。 時代遅れ
(OBSOLESCENT): ‘accept’ に置き換えられました。

‘span’ ( – c-addr  ) core-ext-obsolescent “span”
   変数(variable) – c-addr は、 ‘expect’ によって最後に受け取った文字列
の長さを格納するセルのアドレスです。 時代遅れ(OBSOLESCENT)。


File: gforth.info,  Node: Pipes,  Next: Xchars and Unicode,  Prev: Line input and conversion,  Up: Other I/O

6.20.9 Pipes
------------

他のプロセスによって作成されたパイプライン(*note Gforth in pipes::)を
Gforth で使用することに加えて、 あなたは ‘open-pipe’ を使用してあなた独
自のパイプラインを作成し、 読み書きすることができます。

‘open-pipe’ ( c-addr u wfam – wfileid wior ) gforth-0.2 “open-pipe”

‘close-pipe’ ( wfileid – wretval wior ) gforth-0.2 “close-pipe”

   パイプラインに書き込む場合、 Gforth は ‘broken-pipe-error’ を throw す
る可能性があります。 あなたが、 この例外をキャッチしない場合、 Gforth は
例外をキャッチして通常は黙って(silently)に終了(exit)します(*note Gforth
in pipes::)。 しかし、 おそらくこれはあなたの望む事ではないので、
‘open-pipe’ から ‘close-pipe’ までのコードを ‘catch’ または ‘try’ ブロッ
クで囲むべきです。 そして、 あなた自身で問題を解決し、 通常の処理に戻し
ます。

‘broken-pipe-error’ ( – n  ) gforth-0.6 “broken-pipe-error”
   壊れたパイプラインのエラー番号


File: gforth.info,  Node: Xchars and Unicode,  Next: i18n and l10n,  Prev: Pipes,  Up: Other I/O

6.20.10 Xchars and Unicode
--------------------------

ASCII は英語(English language)にのみ適しています。 ただし、 ほとんどの西
洋言語(western languages)は、それぞれの少数の特殊文字をエンコードするに
は 1 バイトで十分であるため、 Forth の枠組みにある程度適合します(ただし
、常に同じエンコードを使用できるとは限りません。 ただし、 latin-1 が最も
広く使用されています)。 他の言語の場合は、 異なる文字セットを使用する必
要があり、その一部は可変幅です。 この問題に対処するために、 文字はスタッ
ク上ではユニコード・コードポイント(Unicode codepoints)として表され、 メ
モリ内では UTF-8 バイト文字列として表されることがよくあります。 ユニコー
ド・コードポイントは、 多くの場合、 1 つのアプリケーション・ レベル(one
application-level character)の文字を表しますが、 ユニコードは、基本文字
(base letter)と結合発音記号(combining diacritical mark)など、 複数のコー
ド・ポイントで構成される分解文字(combining diacritical mark)もサポートし
ます。

   ユニコード・コードポイントはメモリ内の複数バイトを消費する可能性があ
るため、 ここで我々の用語をすり合わせしておきましょう: char はメモリ内の
生のバイト、 またはスタック上の 0 ～ 255 の範囲の値です。 xchar
(extended char) は 1 つのコードポイントを表します。 これはメモリ内の 1 バ
イト以上で表され、 スタック上にはより大きな値が存在する可能性があります
。 ASCII 文字は char や xchar と同一です。 つまり、0 ～ 127 の範囲の値、
かつ、 メモリ内のその値を含む 1 バイトです。

   UTF-8 エンコードを使用する場合、 他のすべてのコードポイントは 1 文字
あたり 1 バイト以上必要になります。 ほとんどの場合、 このような文字はメ
モリ内の文字列として扱うだけでよく、 以下のワード群を使用する必要はあり
ませんが、 個々のコードポイントを処理したい場合は、 以下のワード群が役に
立ちます。 現時点では、 分解文字(decomposed characters)を扱うためのワー
ドはありません。

   xchar ワード群はいくつかのデータ型を追加します:

   • XC はスタック上の拡張文字(xchar)です。 これは 1 つのセルを占有し、
     符号なしセルのサブセットです。 16 ビット・システムでは、 ユニコード
     文字セットの BMP サブセット (つまり、 コードポイント<65536)のみがス
     タック上で表現できます。 アプリケーション文字(application
     characters)を常に文字列として表現すると、 この制限を回避できます。

   • XC-ADDR はメモリ内の xchar のアドレスです。 アライメント要件は
     C-ADDR と同じです。 xchar のメモリ表現はスタック表現とは異なり、 使
     用されるエンコーディングによって異なります。 xchar はメモリ内で可変
     数の char を使用できます。

   • XC-ADDR U はメモリ内の xchar のバッファで、XC-ADDR で始まり U char
     (つまり、 xchar ではなくバイト)の長さになります。

‘xc-size’ ( xc – u  ) xchar “x-c-size”
   xchar XC のメモリ・サイズを char で計算します。

‘x-size’ ( xc-addr u1 – u2  ) xchar “x-size”
   XC-ADDR に格納されている最初の xchar のメモリ・サイズを char で計算し
ます。

‘xc@’ ( xc-addr – xc  ) xchar-ext “xc-fetch”
   XC-ADDR1 から xchar XC を取得します。

‘xc@+’ ( xc-addr1 – xc-addr2 xc  ) xchar “x-c-fetch-plus”
   XC-ADDR1 から xchar XC を取得します。 XC-ADDR2 は、 XC の後ろの最初の
メモリ位置を指します。

‘xc@+?’ ( xc-addr1 u1 – xc-addr2 u2 xc  ) gforth-experimental “x-c-fetch-plus-query”
   文字列 XC-ADDR1 U1 の最初の xchar XC を取得します。 XC-ADDR2 U2 は XC
の後ろの残りの文字列です。

‘xc!+?’ ( xc xc-addr1 u1 – xc-addr2 u2 f  ) xchar “x-c-store-plus-query”
   xchar XC を、 アドレス XC-ADDR1 で始まり U1 文字分の大きさであるバッ
ファーに格納します。 XC-ADDR2 は XC の後の最初のメモリ位置を指し、 U2 は
バッファの残りのサイズです。 xchar XC がバッファーに収まった場合、 F は
true、 それ以外の場合は F は false で XC-ADDR2 U2 は XC-ADDR1 U1 と等し
くなります。 ‘XC!+?’ はバッファー・オーバーフローに対して安全であるため
、 ‘XC!+’ よりも推奨されます。

‘xc!+’ ( xc xc-addr1 – xc-addr2  ) xchar “x-c-store”
   xchar XC を XC-ADDR1 に保存します。 XC-ADDR2 は、 バッファ内の次の未
使用アドレスです。 これは最大 4 バイトを書き込むため、 アドレスをバッフ
ァの末尾と照合するだけの場合は、 有用なデータの上書きを避けるために、 バ
ッファの末尾の後に少なくとも 3 バイトの余裕(パディング)が必要であること
に注意してください。

‘xchar+’ ( xc-addr1 – xc-addr2  ) xchar “x-char-plus”
   XC-ADDR1 に格納されている xchar のサイズをこのアドレスに加算し、
XC-ADDR2 を与えます(訳注: つまり、 次の xchar 文字の位置を返す)

‘xchar-’ ( xc-addr1 – xc-addr2  ) xchar-ext “x-char-minus”
   XC-ADDR1 から xchar が見つかるまで逆方向に進み、 この xchar のサイズ
を XC-ADDR2 に加算すると XC-ADDR1 になります。

‘+x/string’ ( xc-addr1 u1 – xc-addr2 u2  ) xchar-ext “plus-x-slash-string”
   アドレス XC-ADDR1 サイズ U1 文字で定義されたバッファーで xchar 1つ分
だけ進めたアドレスを XC-ADDR2 に返します。 u2 は xchar 分だけ u1 より減
ります(残り文字列長さです)。 u2 が 0 になったら末尾まで到達しています。
注意: 0 になってもそこで止まりません更に進んでしまうので注意(長さが負数
になる)

‘x\string-’ ( xc-addr u1 – xc-addr u2  ) xchar-ext “x-backslash-string-minus”
   バッファの最後から開始して、 アドレス XC-ADDR とサイズ U1 (char単位)
で定義されたバッファー内で 1 xchar ずつ後方に進みます。 XC-ADDR は変わら
ず、 U2 は xchar 分ずつ短くなります。 注意: 0 になっても止まりません。そ
のまま長さが負数になっていきます。

‘-trailing-garbage’ ( xc-addr u1 – xc-addr u2  ) xchar-ext “minus-trailing-garbage”
   XC-ADDR U1 というバッファー内の最後の XCHAR を調べます — エンコードが
正しく、 完全な文字を表す場合 U2 は U1 と等しいです。 それ以外の場合は
U2 は、 最後の(文字化けした) xchar を除いた文字列を表します。

‘x-width’ ( xc-addr u – n  ) xchar-ext “x-width”
   アドレス XC-ADDR 長さ U (char単位)の文字列に対して、同じ幅の等幅
ASCII 文字での文字数を N に得ます。 等幅フォントを想定しています。 つま
り文字の幅はいずれも ASCII 文字の幅の整数倍であると仮定します(訳注: 含ま
れる xchar ごとにその表示幅を調べたのを積算して返します buf $@ type abcあ
def ok buf $@len .  9 ok buf $@ x-width .  8 ok)

‘xkey’ ( – xc  ) xchar “x-key”
   端末から xchar を 1 つ読み取ります。 これにより、xchar の読み取りが完
了するまでのすべての入力イベントが破棄されます(訳注: ヒストリ操作は効い
たので…全ての入力イベント…?)。

‘xc-width’ ( xc – n  ) xchar-ext “x-c-width”
   XC の幅は、通常の固定幅グリフ(fixed-width glyph)の幅の N 倍です。

‘xhold’ ( xc –  ) xchar-ext “x-hold”
   ‘<<#’ と ‘#>’ の間で使用されます。 表示数値出力文字列(pictured
numeric output string)の前に XC を追加します。 代替手段としては ‘holds’
を使用することができます。

‘xc,’ ( xchar –  ) xchar “x-c-comma”


File: gforth.info,  Node: i18n and l10n,  Next: Substitute,  Prev: Xchars and Unicode,  Up: Other I/O

6.20.11 国際化(I18n)とローカライズ
----------------------------------

エンド・ユーザー向けのプログラムは、 エンド・ユーザーの母国語に対応する
必要があります。 このような機能については古くから提案があり、 Xchars
(*note Xchars and Unicode::)や Substitute (*note Substitute::) などの国
際文字セットに関する他の提案から分割されました。 画面に表示されるメッセ
ージは、 開発者の母国語(native language)からユーザーの現地言語(local
languages)に翻訳する必要があります(訳注: gforth に最初から組み込まれてい
ないので都度 ‘require i18n.fs’ 等する必要ある。 本マニュアルに掲載が無い
が i18n な 日付用として ‘require i18n-date.fs’ するのもいいかもしれない
)。

   翻訳対象の文字列は ‘L" ’STRING‘"’ で宣言します。 これにより、 ロケー
ル文字列識別子(LSID)が返されます。 LSID は不明瞭なタイプ(opaque types)で
あり、 スタック上のセルとして扱われます。 LSID はロケールに変換できます
。 ロケールは、 言語およびその言語の国固有のバリエーションです。

‘L"’ ( "lsid<">" – lsid  ) gforth-experimental “l-quote”
   文字列が一意に新しい場合は、 文字列をパースし、 新しい lsid を定義し
ます。 同一文字列は同一の lsid となり、 同一文字列を使用して複数の場所か
ら同じ lsid を参照できます。

‘LU"’ ( "lsid<">" – lsid  ) gforth-experimental “l-unique-quote”
   文字列がユニークでない場合でも(重複してても)、 文字列をパースし、 常
に新しい lsid を定義します。

‘native@’ ( lsid – addr u  ) gforth-experimental “native-fetch”
   LSID からネイティブ文字列(native string)を取得します

‘locale@’ ( lsid – addr u  ) gforth-experimental “locale-fetch”
   現在の言語 かつ 現在の国(country)でローカライズされた文字列を取得しま
す

‘locale!’ ( addr u lsid –  ) gforth-experimental “locale-store”
   現在のロケール かつ 現在の国の、 ローカライズされた文字列 ADDR U を
LSID に保存します。

‘Language’ ( "name" –  ) gforth-experimental “Language”
   ロケールを定義します。 そのロケールを実行すると、 それが現在のロケー
ルになります。

‘Country’ ( <lang> "name" –  ) gforth-experimental “Country”
   現在のロケールのバリエーション(通常: 国;country)を定義します。 そのロ
ケールを実行すると、それが現在のロケールになります。 バリエーションのバ
リエーションを作成できます(国によってはバリエーションが存在する場合があ
ります。たとえば、 多くの言語で rolls/buns を表す単語が何語あるかを考え
てください)。

‘locale-file’ ( fid –  ) gforth-experimental “locale-file”
   FID から現在のロケールに行(lines)を読み取ります。

‘included-locale’ ( addr u –  ) gforth-experimental “included-locale”
   ファイル ADDR U から現在のロケールに行(lines)を読み取ります。

‘include-locale’ ( "name" –  ) gforth-experimental “include-locale”
   指定のファイル "NAME" から現在のロケールに行(lines)を読み取ります。

‘locale-csv’ ( "name" –  ) gforth-experimental “locale-csv”
   カンマ区切り値テーブルをロケールにインポートします。 最初の行にはロケ
ール名が含まれます。 “program” と “default” は特別なエントリです。
generic languages は特定の国(specific countries)向けの翻訳よりも優先しな
ければなりません。 “program” の下のエントリ(一番左にある必要があります)
は、 lsid の検索に使用されます。 空の場合、 行番号 1 は lsid インデック
スです。

‘.locale-csv’ ( –  ) gforth-experimental “dot-locale-csv”
   ロケール・データベースを CSV 形式で端末に出力します。

‘locale-csv-out’ ( "name" –  ) gforth-experimental “locale-csv”
   ファイル "NAME" を作成し、 ロケール・データベースを CSV 形式でファイ
ル "NAME" に書き込みます。


File: gforth.info,  Node: Substitute,  Next: CSV Reader,  Prev: i18n and l10n,  Up: Other I/O

6.20.12 Substitute
------------------

これは単純なテキスト・マクロ置換機能です。 ‘"text %macro% text"’ の形式
のテキストが処理され、‘'%'’ で囲まれたマクロ変数が関連する文字列に置き換
えられます。 2 つの連続する ‘%’ は 1 つの ‘%’ に置き換えられます。 マク
ロは特定のワードリストで定義され、実行時に文字列を返します。 標準では、
マクロを宣言する方法が 1 つだけ、 ‘replaces’ のみ定義されています。 これ
は文字列を返すだけのマクロを作成します。

‘macros-wordlist’ ( – wid  ) gforth-experimental “macros-wordlist”
   文字列置換マクロのワードリスト

‘replaces’ ( addr1 len1 addr2 len2 –  ) string-ext “replaces”
   名前が ADDR2 LEN2、 内容が ADDR1 LEN1 のマクロを作成します。 マクロが
既に存在する場合は、 内容を変更するだけです。

‘.substitute’ ( addr1 len1 – n / ior  ) gforth-experimental “dot-substitute”
   テキスト ADDR1 LEN1 内のすべてのマクロを置き換えて、 結果を出力します
。 N は置換した数。 または負数の場合は throw 可能な IOR です。

‘$substitute’ ( addr1 len1 – addr2 len2 n/ior  ) gforth-experimental “string-substitute”
   テキスト ADDR1 LEN1 内のすべてのマクロを置き換えます。 ADDR2 LEN2 が
置換結果で、 N は置換の数で、 負数場合は throw 可能な IOR です。

‘substitute’ ( addr1 len1 addr2 len2 – addr2 len3 n/ior  ) string-ext “substitute”
   テキスト ADDR1 LEN1 内のすべてのマクロを置き換え、 結果を ADDR2 LEN2
にコピーします。 ADDR2 LEN3 は置換結果で、 N は置換した数、または負数場
合は throw 可能な IOR です。

‘unescape’ ( addr1 u1 dest – dest u2  ) string-ext “unescape”
   ADDR1 U1 内のすべての区切り文字を2重にすることで、 置換後の結果が元の
テキストのままになります。 結果を格納するバッファー DEST には長さ指定の
必要が無いことに注意してください。 最悪の場合、 必要な文字数は U1 の 2倍
です。 DEST U2 は結果の文字列の長さです。

‘$unescape’ ( addr1 u1 – addr2 u2  ) gforth-experimental “string-unescape”
   ‘unescape’ と同じですが、 ‘$tmp’ を使用して一時的な結果文字列を作成し
ます。


File: gforth.info,  Node: CSV Reader,  Prev: Substitute,  Up: Other I/O

6.20.13 CSV Reader
------------------

CSV(Comma-separated values)は、 データをやり取りするための一般的なテキス
ト形式です。 Gforth は ‘csv.fs’ でCSVリーダーを提供します(注意: gforth に
最初から組み込まれてはいないので、 都度 ‘require csv.fs’ 等する必要があ
る)。

‘read-csv’ ( addr u xt –  ) gforth-experimental “read-csv”
   CVS ファイル ADDR U を読み取り、 見つかった項目ごとに XT を実行します
。 XT は ‘( addr ucol line -- )’、 つまり文字列と、 現在の列番号(0 で始
まる)と、 現在の行番号(1 で始まる)を受け取ります。


File: gforth.info,  Node: OS command line arguments,  Next: Locals,  Prev: Other I/O,  Up: Words

6.21 OS command line arguments
==============================

コマンドラインで Gforth プログラムに引数を渡す通常の方法は、 ‘-e’ オプシ
ョンを使用することです。 たとえば、

     gforth -e "123 456" foo.fs -e bye

   ただし、 コマンドライン引数を直接パースしたい場合もあります。 その場
合、 ‘next-arg’ を通じて(イメージ固有の)コマンドライン引数にアクセスでき
ます:

‘next-arg’ ( – addr u  ) gforth-0.7 “next-arg”
   OS コマンドラインから次の引数を取得し、 それを消費し addr u に返しま
す。 引数が残っていない場合は、 ‘0 0’ を返します。

   ‘next-arg’ のプログラム例 ‘echo.fs’ を以下に示します:

     : echo ( -- )
         begin
     	next-arg 2dup 0 0 d<> while
     	    type space
         repeat
         2drop ;

     echo cr bye

   これは以下のようにして起動します

     gforth echo.fs hello world

   そうすると以下のように出力されます

     hello world

   以下は、 OS コマンドラインを処理する下位レベルのワード群です:

‘arg’ ( u – addr count  ) gforth-0.2 “arg”
   u 番目のコマンドライン引数の文字列を返します。 u が最後の引数を超えて
いる場合は ‘0 0’ を返します。 ‘0 arg’ は、 Gforth を起動したプログラム名
です。 次の未処理の引数は常に ‘1 arg’ で、 その後の引数は ‘2 arg’ などで
す。 システムによってすでに処理された引数はすべて削除されます。 引数を処
理した後、 ‘shift-args’ を使用して引数を削除できます。

‘shift-args’ ( –  ) gforth-0.7 “shift-args”
   ‘1 arg’ が削除され、 後続のすべての OS コマンドライン・パラメータが 1
だけ左にシフトされ、‘argc @’ が減ります。 このワードは ‘argv @’ を変更で
きます。

   最後に、 Gforth は最下位レベルで以下のワード群を提供します:

‘argc’ ( – addr  ) gforth-0.2 “argc”
   変数(‘Variable’) – コマンドライン引数の数(コマンド名を含む)。
‘next-arg’ と ‘shift-args’ によって変更されます。

‘argv’ ( – addr  ) gforth-0.2 “argv”
   変数(‘Variable’) – コマンドライン引数 (コマンド名を含む) へのポインタ
ーのベクトル(vector)へのポインター。 各引数は、 C言語スタイルのゼロで終
わる文字列として表されます。 ‘next-arg’ と ‘shift-args’ によって変更され
ます。


File: gforth.info,  Node: Locals,  Next: Structures,  Prev: OS command line arguments,  Up: Words

6.22 Locals
===========

ローカル変数を使用すると、 Forth プログラミングがより楽しくなり、 Forth
プログラムが読みやすくなります。 残念ながら、 標準 Forth の ローカル変数
には制限がたくさんあります。 したがって、 標準 Forth のローカル変数ワー
ドセットだけでなく、 Gforth 独自のより強力なローカル変数ワードセットも提
供します(標準Forthのローカル変数ワードセットは、 Gforth のローカル変数ワ
ードセットで実装しました)。

   このセクションのアイデアは、 M. Anton Ertl, ‘Automatic Scoping of
Local Variables
(https://www.complang.tuwien.ac.at/papers/ertl94l.ps.gz)’, EuroForth ’94
でも公開されています。

* Menu:

* Gforth locals::
* Standard Forth locals::


File: gforth.info,  Node: Gforth locals,  Next: Standard Forth locals,  Prev: Locals,  Up: Locals

6.22.1 Gforth locals
--------------------

ローカル変数は以下のように定義できます

     {: local1 local2 ... -- comment :}
   or
     {: local1 local2 ... :}
   or
     {: local1 local2 ... | ulocal0 ulocal1 -- comment :}

   例えば、 以下のように使います
     : max {: n1 n2 -- n3 :}
      n1 n2 > if
        n1
      else
        n2
      endif ;

   ローカル変数定義とスタック・コメントは、 類似するよう意図しています。
ローカル変数定義は、 多くの場合、 ワードのスタック・コメントを置き換えま
す。 ローカル変数の順序はスタック・コメント内の順序に対応し、 ‘--’ 以降
はすべて実際はコメントです。

   この類似性には 1 つ欠点があります。 ローカル変数宣言とスタック・コメ
ントを混同しやすく、 バグが発生し、 見つけにくくなります。 ただし、 この
問題は適切なコーディング規約によって回避できます。 同じプログラム内で両
方の表記法を使用しないでください。 そうする場合は、 追加の手段を使用して
区別する必要があります。 例えば、 場所によって区別します。

   ローカルの名前の前に型指定子を付けることができます。 たとえば、浮動小
数点値の場合は ‘F:’ です:

     : CX* {: F: Ar F: Ai F: Br F: Bi -- Cr Ci :}
     \ 複素数の掛け算
      Ar Br f* Ai Bi f* f-
      Ar Bi f* Ai Br f* f+ ;

   Gforth は現在、 セル型指定子(‘W:’, ‘WA:’, ‘W^’)や、 2倍長整数型指定子
(‘D:’, ‘DA:’, ‘D^’)や、 浮動小数点数型指定子(‘F:’, ‘FA:’, ‘F^’)と、 さま
ざまなフレーバーの xt 型指定子(‘xt:’, ‘xta:’)、 をサポートしています:

“valueフレーバー(value-flavoured)”
     (*note Values::) valueフレーバーのローカル変数(‘W:’、 ‘D:’ などで定
     義)はその値を生成し、 ‘TO’ で変更できます。

“varueフレーバー(vaLue ではなくて vaRue)”
     (*note Varues::) varueフレーバーのローカル変数 foo (‘WA:’ などで定
     義) は、 ‘addr foo’ を使用してアドレスを取得できること(変数のスコー
     プを離れると無効になります)を除いて、 valueフレーバーのローカル変数
     とまったく同じように振る舞います。 現時点ではパフォーマンスに違いは
     ありませんが、 長期的には、 valueフレーバーのローカル変数はレジスタ
     に常駐できるため、 大幅に高速になるでしょう。

“variableフレーバー”
     (*note Variables::) variableフレーバーのローカル変数(‘W^’ などで定
     義)はそのアドレスを生成します(変数のスコープを離れると無効になりま
     す)。 たとえば、 標準のワード ‘emit’ は、 以下のように variableフレ
     ーバーのローカル変数(‘C^ char*’) と ‘type’ で定義できます:

          : emit {: C^ char* -- :}
              char* 1 type ;

“deferフレーバー(defer-flavoured)”
     (*note Deferred Words::) (‘XT:’ または ‘XTA:’ と指定した) defer フ
     レーバーのローカル変数 xt を ‘execute’ します。 ‘action-of’ を使用
     すると、 defer フレーバーのローカル変数から xt を取得できます。 ロ
     ーカル変数が ‘xta:’ で定義されている場合、 ‘addr’ を使用して、 xt が
     保存されているアドレス(ローカル変数のスコープの終わりまで有効)を取
     得できます。 たとえば、 標準のワード ‘execute’ は、 以下のように
     defer フレーバーのローカル変数で定義できます:

          : execute {: xt: x -- :}
            x ;

   型指定子のないローカル変数は ‘W:’ ローカル変数として扱われます。 以下
を使用して ‘addr’ の使用を許可または禁止できます:

‘default-wa:’ ( –  ) gforth-experimental “default-wa:”
   型指定子なしで定義されたローカル変数で ‘addr’ を許可します。 言い換え
れば、 型指定子無しでローカル変数定義したときは ‘wa:’ 型指定子を指定した
のと同じです

‘default-w:’ ( –  ) gforth-experimental “default-w:”
   型指定子なしで定義されたローカル変数では ‘addr’ を禁止します。 言い換
えれば、 型指定子なしで定義されたローカル変数は ‘w:’ 型指定子を指定して
ローカル変数を定義したのと同じです。

   ‘|’ の後ろで定義されたローカル変数を除いて、 ローカル変数の全てのフレ
ーバーは、 データ・スタックの値または、 (FP ローカル変数の場合) FP スタ
ックの値で初期化されます。 Gforth は ‘|’ の後ろで定義されたローカル変数
を 0 に初期化します。 一部の Forth システムでは初期化されないままになっ
ています。

   Gforth は、 ローカル・バッファーとデータデータ構造体のための角括弧
(square bracket)表記をサポートしています。 これらのローカル変数は
variableフレーバー のローカル変数に似ており、 サイズは定数式として指定し
ます。 宣言は ‘name[ size ]’ のようになります。 Forth の式 ‘size’ は宣言
中に評価され、 サイズをバイト単位で指定するスタック効果 ‘( -- +n )’ が必
要です。 角括弧 ‘[’ は定義された名前の一部です。

   ローカルのデータ構造体は、 データ・スタックに渡されたアドレスから
size バイトをコピーすることによって初期化されます。 (宣言内の ‘|’ の後の
、)初期化されていないローカルのデータ構造体は消去されず、 以前にローカル
・スタックにあったデータをすべて含むだけです。

   Example:

     begin-structure test-struct
       field: a1
       field: a2
     end-structure

     : test-local {: foo[ test-struct ] :}
         foo[ a1 !  foo[ a2 !
         foo[ test-struct dump ;

   Gforth では、コロン定義内のあらゆる場所でローカル変数を定義できます。
これにより、 以下のような疑問が生じます:

* Menu:

* Locals definition words::
* Where are locals visible by name?::
* How long do locals live?::
* Locals programming style::
* Locals implementation::
* Closures::


File: gforth.info,  Node: Locals definition words,  Next: Where are locals visible by name?,  Prev: Gforth locals,  Up: Gforth locals

6.22.1.1 Locals definitions words
.................................

このセクションでは、 ローカル変数を定義するために使用されるワード群を説
明します。 注意: ローカル変数を定義するワード(‘W:’ など)の実行時は、 右
端のローカル変数定義から左端のローカル変数定義の方向で実行され、 右端の
ローカル変数がスタックのTOSから得る事になることに注意してください。

‘{:’ ( – hmaddr u latest latestnt wid 0  ) local-ext “open-brace-colon”
   ローカル変数定義の開始。

‘--’ ( hmaddr u latest latestnt wid 0 ... –  ) gforth-0.2 “dash-dash”
   ローカル変数定義中の ‘--’ から ‘:}’ までのすべてが無視されます。 これ
は通常、 ローカル変数定義をスタック効果の説明としても使えるよう、 一人二
役の役割を持たせる場合に使います。

‘|’ ( –  ) gforth-1.0 “bar”
   ‘|’ の後ろで定義されたローカル変数はスタックから初期化されません。 し
たがって、 ‘W:’ のようなワードの実行時のスタック効果 ‘( -- )’ に変わりま
す。

‘:}’ ( hmaddr u latest latestnt wid 0 xt1 ... xtn –  ) gforth-1.0 “colon-close-brace”
   ローカル変数定義の終了。

‘{’ ( – hmaddr u latest latestnt wid 0  ) gforth-0.2 “open-brace”
   ローカル変数定義を開始します。 このワードの Forth-2012 標準名は ‘{:’
です。

‘}’ ( hmaddr u latest latestnt wid 0 xt1 ... xtn –  ) gforth-0.2 “close-brace”
   ローカル変数定義を終了します。 このワードの Forth-2012 標準名は ‘:}’
です。

‘W:’ ( compilation "name" – a-addr xt; run-time x –  ) gforth-0.2 “w-colon”
   valueフレーバーのセル・ローカル変数 name を定義します ‘( -- x1 )’

‘WA:’ ( compilation "name" – a-addr xt; run-time x –  ) gforth-1.0 “w-a-colon”
   varueフレーバーのセル・ローカル変数 name を定義します ‘( -- x1 )’

‘W^’ ( compilation "name" – a-addr xt; run-time x –  ) gforth-0.2 “w-caret”
   variableフレーバーのセル・ローカル変数 name を定義します ‘( -- a-addr
)’

‘D:’ ( compilation "name" – a-addr xt; run-time x1 x2 –  ) gforth-0.2 “d-colon”
   valueフレーバーの2倍長整数ローカル変数 name を定義します ‘( -- x3 x4
)’

‘DA:’ ( compilation "name" – a-addr xt; run-time x1 x2 –  ) gforth-1.0 “w-a-colon”
   varueフレーバーの2倍長整数ローカル変数 name を定義します ‘( -- x3 x4
)’

‘D^’ ( compilation "name" – a-addr xt; run-time x1 x2 –  ) gforth-0.2 “d-caret”
   variableフレーバーの2倍長整数ローカル変数 name を定義します ‘( --
a-addr )’

‘C:’ ( compilation "name" – a-addr xt; run-time c –  ) gforth-0.2 “c-colon”
   valueフレーバーの char ローカル変数 name を定義します ‘( -- c1 )’

‘CA:’ ( compilation "name" – a-addr xt; run-time c –  ) gforth-1.0 “c-a-colon”
   varueフレーバーの char ローカル変数 name を定義します ‘( -- c1 )’

‘C^’ ( compilation "name" – a-addr xt; run-time c –  ) gforth-0.2 “c-caret”
   variableフレーバーの char ローカル変数 name を定義します ‘( -- c-addr
)’

‘F:’ ( compilation "name" – a-addr xt; run-time r –  ) gforth-0.2 “f-colon”
   valueフレーバーの浮動小数点数ローカル変数 name を定義します ‘( -- r1
)’

‘FA:’ ( compilation "name" – a-addr xt; run-time f –  ) gforth-1.0 “f-a-colon”
   varueフレーバーの浮動小数点数ローカル変数 name を定義します ‘( -- r1
)’

‘F^’ ( compilation "name" – a-addr xt; run-time r –  ) gforth-0.2 “f-caret”
   variableフレーバーの浮動小数点数ローカル変数 name を定義します ‘( --
f-addr )’

‘XT:’ ( compilation "name" – a-addr xt; run-time xt1 –  ) gforth-1.0 “x-t-colon”
   deferフレーバーのセル・ローカル変数 name を定義します ‘( ... -- ...
)’

‘XTA:’ ( compilation "name" – a-addr xt; run-time ... – ...  ) gforth-1.0 “x-t-a-colon”
   ‘addr’ を使用できる defer フレーバーのローカル変数 name を定義します
。

   ‘|’ や ‘--’ や ‘:}’ や ‘}’ は通常、 検索順序スタック(the search
order)に含まれないことに注意してください(これらは ‘locals-types’ ボキャ
ブラリに含まれます)。 そしてこれらは必ずしも全ての Forth システムでワー
ドとして存在しているわけではありません。 したがって、 これらは Gforth の
ワードとして文書化されています。


File: gforth.info,  Node: Where are locals visible by name?,  Next: How long do locals live?,  Prev: Locals definition words,  Up: Gforth locals

6.22.1.2 Where are locals visible by name?
..........................................

ローカル変数をその名前によって可視できるのはどこまででしょうか？ – 基本
的に、 その答えは、 ローカル変数がブロック構造言語で期待される場所で、 場
合によってはもうちょっとだけ長くできます。 ローカル変数のスコープを制限
したい場合は、 その定義を ‘SCOPE’...‘ENDSCOPE’ で囲んで下さい。

‘scope’ ( compilation  – scope ; run-time  –  ) gforth-0.2 “scope”

‘endscope’ ( compilation scope – ; run-time  –  ) gforth-0.2 “endscope”

   これらのワードは制御構造のワードのように動作するため、 ‘CS-PICK’ およ
び ‘CS-ROLL’ とともに使用して、 任意の方法で範囲を制限できます。

   可視性の質問に対するより正確な答えが必要な場合のために、 ここで基本原
則を示します: ローカル変数は、 ローカル変数の定義を通じてのみ到達できる
すべての場所で可視です(1)。 つまり、 ローカル変数という定義を経由しない
と到達できる場所では不可視です。 たとえば、 ‘IF’...‘ENDIF’ の中で定義さ
れたローカル変数は ‘ENDIF’ まで可視で、 ‘BEGIN’...‘UNTIL’ 内で定義された
ローカル変数は ‘UNTIL’ の後(たとえば、後続の ‘ENDSCOPE’ まで)で可視です
。

   このソリューションの背景にある理由は次のとおりです: 私達は、 意味があ
る限り、 ローカル変数を可視させたいと考えています。 ユーザーは、 明示的
なスコープを使用することで、 いつでも可視性を短くすることができます。 ロ
ーカル変数の定義によってのみ到達できる場所では、 ローカル変数名の意味は
明らかです。 他の場所ではそうではありません。 ローカル変数定義が含まれて
いない制御フロー・パスでローカル変数はどのように初期化されるのでしょうか
？ 2 つの独立した制御フロー パスで同一ローカル変数名が 2 回定義されてい
る場合、 それはどちらのローカル変数を意味するのでしょうか？

   上記で、 ほぼすべてのユーザーにとって十分詳細であるため、 このセクシ
ョンの残りの部分はスキップしてかまいません。 本当にすべての血みどろの詳
細とオプションを知る必要がある場合は、 以下を読み続けてください。

   このルールを実装するには、 コンパイラはどの場所が到達不能
(unreachable)であるかを認識する必要があります。 ‘AHEAD’ や ‘AGAIN’ や
‘EXIT’ や ‘LEAVE’ の後で、 これが自動的に認識されます。 他の場合(例: ほ
とんどの ‘THROW’ の後)、 ‘UNREACHABLE’ というワードを使用して、 制御フロ
ーがその場所に到達しないことをコンパイラに伝えることができます。
‘UNREACHABLE’ が使用できる場所で使用されなかった場合、 唯一の結果は、 一
部のローカル変数の可視性が上記のルールに記載されているよりも制限されるこ
とです。 ‘UNREACHABLE’ を使用すべきではない場所で使用すると(つまり、 コ
ンパイラに嘘をついた場合)、 バグのあるコードが生成されます。

‘UNREACHABLE’ ( –  ) gforth-0.2 “UNREACHABLE”

   このルールのもう 1 つの問題は、 ‘BEGIN’ で、 どのローカル変数が
incoming back-edge で可視されるかをコンパイラが認識できないことです。 以
下で説明するすべての問題は、 コンパイラのこの無知が原因です(‘BEGIN’ ルー
プを例として使用してこの問題について説明します。 この説明は ‘?DO’ および
他のループにも当てはまります)。 おそらく最も陰険な例は以下のとおりです:
     AHEAD
     BEGIN
       x
     [ 1 CS-ROLL ] THEN
       {: x :}
       ...
     UNTIL

   これは、 可視性ルールに従って合法である必要があります。 ‘x’ の使用に
は、 定義を介してのみ到達できます。 ただし、 下記に明示した使用法でなけ
ればなりません。

   この例から、 可視性ルールを完全に実装するには大きな問題が伴うことが明
らかです。 私たちの実装は、 一般的なケースを宣伝どおりに扱い、 例外は安
全な方法で処理されます。 コンパイラは、 ‘BEGIN’ の後に可視できるローカル
変数について合理的な推測を行います。 悲観的すぎると、 ローカル変数が定義
されていないという偽のエラーがユーザーに表示されます。 コンパイラが楽観
的すぎる場合、 後でこれに気づき、 警告を発行します。 上記の場合、 コンパ
イラは ‘x’ が使用時に未定義であることについて文句を言います。 このセクシ
ョンのあいまいな例から、 コンパイラをトラブルに陥らせるには非常に特殊な
制御構造が必要であることがわかりますが、 それでもコンパイラは多くの場合
問題なく動作します。

   ‘BEGIN’ がそれより上から到達可能な場合、 最も楽観的な推測は、 ‘BEGIN’
の前に可視であるすべてのローカル変数も ‘BEGIN’ の後にも可視であることで
す。 この推測は、 ‘BEGIN’ 経由でのみ入るすべてのループ、 特に通常の
‘BEGIN’...‘WHILE’...‘REPEAT’ および ‘BEGIN’...‘UNTIL’ ループに対して有効
であり、 コンパイラに実装されています。 ‘BEGIN’ への分岐が ‘AGAIN’ また
は ‘UNTIL’ によって最終的に生成されると、 コンパイラは推測をチェックし、
それが楽観的すぎる場合はユーザーに警告します:
     IF
       {: x :}
     BEGIN
       \ x ?
     [ 1 cs-roll ] THEN
       ...
     UNTIL

   ここで、 ‘x’ は ‘BEGIN’ までのみ存続しますが、 コンパイラは ‘THEN’ ま
で存続すると楽観的に想定します。 ‘UNTIL’ をコンパイルするときにこの違い
に気づき、 警告を発行します。 ユーザーは警告を回避し、 明示的なスコープ
を使用して ‘x’ が間違った領域で使用されていないことを確認できます:
     IF
       SCOPE
       {: x :}
       ENDSCOPE
     BEGIN
     [ 1 cs-roll ] THEN
       ...
     UNTIL

   推測は楽観的であるため、 未定義のローカル変数に関する偽のエラー・メッ
セージは表示されません。

   ‘BEGIN’ がそれより上から到達可能でない場合(たとえば、 ‘AHEAD’ または
‘EXIT’ の後)、 ‘BEGIN’ の後で定義されたローカル変数の可視については、 コ
ンパイラは楽観的な推測を行うことさえできません。

   悲観的に、 制御構造の外側の最新の場所(つまり、 制御フロー・スタック上
に何もない場所)で可視であったすべてのローカル変数が可視であると仮定しま
す。 これは以下のことを意味します:

     : foo
       IF {: z :} THEN
       {: x :}
       AHEAD
         BEGIN
           ( * )
         [ 1 CS-ROLL ] THEN
         {: y :}
         ...
       UNTIL ;

   ここで、 ‘( * )’ でマークされた場所では、 ‘x’ は可視ですが、 ‘y’ は不
可視です(ただし、 到達可能性ルールによれば、 可視であるべきです)。 ‘z’ は
そこでは不可視で、 可視であるべきではありません。

   ただし、 ‘ASSUME-LIVE’ を使用すると、 最上位の制御フロー・スタック項
目が作成された時点と同じローカル変数が BEGIN で可視になるのだと、 コンパ
イラに想定させることができます。

‘ASSUME-LIVE’ ( orig – orig  ) gforth-0.2 “ASSUME-LIVE”

例えば、 以下のように使います
     IF
       {: x :}
       AHEAD
         ASSUME-LIVE
         BEGIN
           x
         [ 1 CS-ROLL ] THEN
         ...
       UNTIL
     THEN

   ここで、 ‘x’ のローカル変数定義は制御構造内にあるため、 ‘x’ を使用し
た時点では ‘x’ は可視ではありませんが、 ‘ASSUME-LIVE’ を使用することで、
プログラマはコンパイラに ‘AHEAD’ の時点で可視である、 そのローカル変数が
、 ‘BEGIN’ の時点でも可視であるべきであると伝えます。

   ‘BEGIN’ の前にローカル変数が定義されている他のケースは、
‘ASSUME-LIVE’ の前に適切な ‘CS-ROLL’ を挿入する(そして ‘ASSUME-LIVE’ の
背後にある制御フロー・スタック操作を変更する)ことで処理できます。

   ローカル変数が ‘BEGIN’ の後で定義されている場合(ただし、 ‘BEGIN’ の直
後で可視である必要があります)は、 ループを再配置することによってのみ処理
できます。 たとえば、上記の「最も陰険な」例は以下のように整理できます:
     BEGIN
       {: x :}
       ... 0=
     WHILE
       x
     REPEAT

   ---------- Footnotes ----------

   (1) コンパイラ構築用語では「すべての場所はローカル変数の定義によって
支配される」と言う


File: gforth.info,  Node: How long do locals live?,  Next: Locals programming style,  Prev: Where are locals visible by name?,  Up: Gforth locals

6.22.1.3 How long do locals live?
.................................

ローカル変数の生存期間はどのくらいなのか？ – 生存期間に関する質問に対す
る正しい答えは、次のとおりです: ローカル変数は、 少なくともアクセスでき
る限りは生存します。 valueフレーバーのローカル変数の場合、 これは、 その
可視性が終了するまでを意味します。 ただし、 variableフレーバーのローカル
変数は、可視性の範囲をはるかに超えてアドレスを通じてアクセスできる可能性
があります。 結局のところ、 これはそのようなローカル変数がガベージ・コレ
クションを受けなければならないことを意味します。 これには、Forth らしく
ない実装の複雑さが伴うため、 他の言語(C言語など)と同じ引っ込み思案な解決
策を採用しました。 つまり、 ローカル変数は、 それが可視である間のみ生存
します。その後、そのアドレスは無効になります(そして、 その後そのアドレス
にアクセスするプログラムはエラーになります)。


File: gforth.info,  Node: Locals programming style,  Next: Locals implementation,  Prev: How long do locals live?,  Up: Gforth locals

6.22.1.4 Locals programming style
.................................

どこでもローカル変数を定義できる自由は、 プログラミング・スタイルを劇的
に変える可能性を秘めています。 特に、 中間ストレージにリターン・スタック
を使用する必要がなくなります。 さらに、 すべてのスタック操作(実行時に決
定される引数を持つ ‘PICK’ や ‘ROLL’ を除く)を排除できます。 スタック項目
の順序が間違っている場合は、 すべてのスタック項目のローカル変数定義を記
述し、 その次に、 あなたが必要とする順序で項目を書き込むだけです。

   これは少し突飛なように思えますし、 スタック操作を排除することが意識的
なプログラミング目標になる可能性は低いです。 それでも、 ローカル変数を積
極的に使用すれば、 スタック操作の数は大幅に減少します(例: ‘max’ (*note
Gforth locals::) を ‘max’ の従来の実装と比較してみましょう)。

   これは、 ローカル変数の潜在的な利点の 1 つ、 つまり Forth プログラム
を読みやすくすることを示しています。 もちろん、 この利点は、 プログラマ
がワードを長ったらしく書くための自由度を追加する訳ではなく、 ファクタリ
ング(因数分解)の原則を尊重し続けた場合にのみ実現されます。

   ‘TO’ の使用は可能な限り避けるべきです。 ‘TO’ がない場合、 すべての
valueフレーバーのローカル変数には 1 つの代入しかなく、 関数型言語の多く
の利点が Forth に当てはまります。 つまり、 プログラムの分析・最適化・読
み取りが容易になります。 ローカル変数が何を表すかは定義から明らかであり
、 後で別のものに変わることはありません。

   たとえば、 ‘TO’ を使用したローカル変数定義は以下のようになります:
     : strcmp {: addr1 u1 addr2 u2 -- n :}
      u1 u2 min 0
      ?do
        addr1 c@ addr2 c@ -
        ?dup-if
          unloop exit
        then
        addr1 char+ TO addr1
        addr2 char+ TO addr2
      loop
      u1 u2 - ;
   ここで、 ‘TO’ は、 ループの反復ごとに ‘addr1’ と ‘addr2’ を更新するた
めに使用されます。 ‘strcmp’ は、‘TO’ の使用による可読性の問題の典型的な
例です。 ‘strcmp’ を読み始めると、 ‘addr1’ が文字列の先頭を指していると
考えるでしょう。 ループの終わり近くになって初めて、 それが何か別のもので
あることがわかります。

   これは、 現在の反復に適切な値で初期化される 2 つのローカル変数をルー
プの開始時に定義することで回避できます。
     : strcmp {: addr1 u1 addr2 u2 -- n :}
      addr1 addr2
      u1 u2 min 0
      ?do {: s1 s2 :}
        s1 c@ s2 c@ -
        ?dup-if
          unloop exit
        then
        s1 char+ s2 char+
      loop
      2drop
      u1 u2 - ;
   ここで、 ‘s1’ がループの反復ごとに異なる値を持つことは最初から明らか
です。


File: gforth.info,  Node: Locals implementation,  Next: Closures,  Prev: Locals programming style,  Up: Gforth locals

6.22.1.5 Locals implementation
..............................

Gforth は追加のローカル変数用スタック(ローカル・スタック)を使用します。
この最も説得力のある理由は、 リターン・スタックが浮動小数点数に整列され
ていないことです。 この追加のスタックを使用すると、 リターン・スタックを
ローカル変数用スタックとして使用する場合の問題や制限も解消されます。 他
のスタックと同様に、 ローカル・スタックは下位アドレスに向かって成長しま
す。 いくつかのプリミティブにより効率的な実装になっています。 あなたは、
これらを直接使用するべきではありませんが、 ‘see’ の出力には表示されるた
め、 以下に文書化しておきます:

‘@localn’ ( noffset – w ) gforth-internal “fetch-local-n”
\ 訳注: ローカル・スタックのTOSを0として noffset 番目のコピーをデータ・スタックに積む

‘f@localn’ ( noffset – r ) gforth-1.0 “f-fetch-local-n”

‘lp@’ ( – c-addr ) gforth-0.2 “lp-fetch”
   C_addr は、 ローカル・スタック・ポインタの現在の値です。

   doc-lp+!#(訳注: まだ説明書いて無いっぽい)
‘lp!’ ( c-addr – ) gforth-internal “lp-store”

‘>l’ ( w – ) gforth-0.2 “to-l”
\ 訳注: w をローカル・スタックにプッシュ

‘f>l’ ( r – ) gforth-0.2 “f-to-l”

   これらのプリミティブに加えて、 一般的に発生するインライン引数に対する
これらのプリミティブのいくつかの特殊化が、 効率上の理由から提供されてい
ます(例: ‘0 @localn’ の特殊化として ‘@local0’ )。 以下のコンパイル・ワー
ド(compiling words)は、 適切な特殊バージョン、 または一般バージョンを適
切にコンパイルします(訳注: ‘@local0’ シリーズは、 ‘@local0’ ローカル・ス
タックのTOS(のコピー)をスタックに積む、 ‘@local1’ ローカル・スタックの
2nd(のコピー)をスタックに積む、 〜 ‘@local4’ まである):

‘compile-lp+!’ ( n –  ) gforth-0.2 “compile-l-p-plus-store”

   ‘?branch-lp+!#’ のような、 条件分岐と ‘lp+!#’ の組み合わせ(ローカル・
スタック・ポインタは分岐が選択された場合にのみ変更されます)は、 ループの
効率と正確性のために提供されています。

   ディクショナリ空間内の特別な領域が、 ローカル変数名を保持するために予
約されています。 ‘{:’ はディクショナリ・ポインタをこの領域に切り替え、
‘:}’ はそれを元に戻し、 ローカル変数の初期化コードを生成します。 ‘W:’ な
どは通常の定義ワードです。 この特別な領域は、 すべてのコロン定義の先頭で
クリアされます。

   Gforth のディクショナリの特別な機能は、 型指定子なしでローカルの定義
を実装するために使用されます。 すべてのワードリスト(別名ボキャブラリ)に
は、 検索などのための独自のメソッド(methods)があります (*note Word
Lists::)。 型指定子なしでローカルの定義を実装するという目的のために、 私
達は特別な検索メソッドを使用してワードリストを定義しました。 ワードが検
索されると、 実際には ‘W:’ を使用してそのワードが作成されます。 ‘{:’ は
、 最初に ‘:}’ や ‘W:’ などを含むワードリストで検索し、 次に型指定子のな
いローカル変数を定義するためのワードリストで検索するよう検索順序スタック
(the search order)を変更します。

   ライフタイム・ルールは、 コロン定義内のスタック規律(stack
discipline)をサポートします。 ローカル変数のライフタイムは、 他のローカ
ル変数のライフタイムと入れ子になっているか、 他のローカル変数のライフタ
イムと重ならないか、 です。

   ‘BEGIN’ や ‘IF’ や ‘AHEAD’ では、 ローカル・スタック・ポインター操作
のコードは生成されません。 制御構造のワード間で、 ローカル変数定義はロー
カル変数をローカル・スタックにプッシュできます。 ‘AGAIN’ は、 他の 3 つ
の制御フローワードとの中で最も単純です。 分岐する前に、 対応する ‘BEGIN’
のローカル・スタックの深さを復元する必要があります。 そのコードは以下の
ようになります:
‘lp+!#’ current-locals-size − dest-locals-size
‘branch’ <begin>

   ‘UNTIL’ はもう少し複雑です。 分岐して戻る場合は、 ‘AGAIN’ と同じよう
にローカル・スタックを調整する必要があります。 ただし、 戻らずにその後ろ
へ流れる場合は、 ローカル・スタックを変更してはなりません。 コンパイラは
以下のコードを生成します:
‘?branch-lp+!#’ <begin> current-locals-size − dest-locals-size
   ローカル・スタック・ポインタは、 分岐が行われた場合にのみ調整されます
。

   ‘THEN’ は、 やや非効率なコードを生成する可能性があります:
‘lp+!#’ current-locals-size − orig-locals-size
<orig target>:
‘lp+!#’ orig-locals-size − new-locals-size

   2 番目の ‘lp+!#’ は、 ローカル・スタック・ポインタを orig 時点のレベ
ルから ‘THEN’ の後のレベルに調整します。 最初の ‘lp+!#’ は、 ローカル・
スタック・ポインタを現在のレベルから orig 時点のレベルに調整するため、 完
全な効果は、‘THEN’ の後の現在のレベルから正しいレベルに調整されることに
なります。

   従来の Forth の実装では、 dest 制御フロー・スタック・エントリはターゲ
ット・アドレスにすぎず、 orig エントリはパッチ当てされるアドレスにすぎま
せん。 ローカル変数の実装は、 すべての orig または dest 項目にワードリス
トを追加します。 これは、 エントリによって記述された時点で可視である(ま
たは可視である想定される)ローカル変数のリストです。 私たちの実装では、 エ
ントリの種類を識別するためのタグも追加します。 特に、 生きているのと死ん
でいるエントリ(到達可能なエントリと到達不可能なエントリ)を区別するためで
す。

   ローカル変数のワードリストに対して、 いくつかの珍しい操作を実行する必
要があります:

‘common-list’ ( list1 list2 – list3  ) gforth-internal “common-list”

‘sub-list?’ ( list1 list2 – f  ) gforth-internal “sub-list?”

‘list-size’ ( list – u  ) gforth-internal “list-size”

   ローカル変数のワードリスト実装のいくつかの機能により、 これらの操作の
実装が簡単になります。 ローカル変数のワードリストはリンクされたリストと
して編成されます。 リストに同一のローカル変数が含まれている場合、 これら
のリストの末尾は共有されます。 名前のアドレスは、 リスト内でその後ろにあ
る名前のアドレスよりも大きくなります。

   もう 1 つの重要な実装の詳細は、 変数 ‘dead-code’ です。これは、
‘BEGIN’ と ‘THEN’ によって直接到達できるか、 解決するブランチ経由でのみ
到達できるかを判断するために使用されます。 ‘dead-code’ は ‘UNREACHABLE’
や ‘AHEAD’ や ‘EXIT’ などによって設定され、 コロン定義の先頭 や ‘BEGIN’
や 通常は ‘THEN’ によってクリアされます。.

   カウンタ付きループはほとんどの点で他のループと似ていますが、 ‘LEAVE’
には特別な注意が必要です。 基本的に ‘AHEAD’ と同じサービスを実行しますが
、 制御フロー・スタック・エントリは作成されません。 したがって、 情報は
別の場所に保存する必要があります。 従来、 情報は ‘LEAVE’ によって作成さ
れたブランチのターゲット・フィールドに、 これらのフィールドをリンク・リ
ストに編成することによって格納されていました。 残念ながら、 この巧妙なト
リックでは、 拡張制御フロー情報を保存するための十分なスペースが提供され
ません。 したがって、 別のスタックである Leave スタックを導入します。 こ
れには、 すべての未解決の ‘LEAVE’ の制御フロー・スタック・エントリが含ま
れています。

   ローカル変数名は、 どの制御フロー経路にも表示されなくなった場合でも、
コロン定義の終わりまで保持されます。 場合によっては、 これによりローカル
変数の名前領域に必要な領域が増加する可能性がありますが、 通常はこの領域
を再利用するよりもコード量にかかるコストは少なくなります。


File: gforth.info,  Node: Closures,  Prev: Locals implementation,  Up: Gforth locals

6.22.1.6 Closures
.................

Gforth は基礎的なクロージャ(closure)も提供します。 クロージャは、 引用
(quotation)(*note Quotations::)とローカル変数の組み合わせです。 Gforth の
クロージャには、 クロージャの実行時に値が入力されるローカル変数があり、
トランポリン xt (trampoline xt)が生成されます。 そのトランポリン xt を
execute すると、 ローカル・スタック上のクロージャのローカル変数にアクセ
スして、 クロージャのコードが実行されます。 クロージャのローカル変数の変
更は永続的ではありません。 つまり、 クロージャが ‘EXIT’ されると、 変更
された値は失われます。

‘[{:’ ( – hmaddr u latest latestnt wid 0  ) gforth-experimental “start-closure”
   クロージャを開始します。 クロージャはまず、 クロージャのために使用す
るローカル変数フレームを宣言し、 次にそれらのローカル変数で実行されるコ
ードを宣言します。 クロージャは引用(quotations)のように ‘;]’ で終わりま
す。 ローカル宣言は、 クロージャ・ローカルが作成される場所に応じて終了し
ます。 実行時、 クロージャは トランポリン xt として作成され、 スタックか
らローカル変数・フレームの値を埋めます。 xt の実行時に、 ローカル変数・
フレームがローカル・スタックにコピーされ、 クロージャのコード内で使用さ
れます。 戻った後、 これらの値はローカル・スタックから削除され、 クロー
ジャ自体は更新されません。

‘:}l’ ( hmaddr u latest latestnt wid 0 a-addr1 u1 ... –  ) gforth-1.0 “close-brace-locals”
   クロージャ・ローカルの宣言を終了します。 クロージャはローカル・スタッ
クに割り当てられます。

‘:}d’ ( hmaddr u latest latestnt wid 0 a-addr1 u1 ... –  ) gforth-1.0 “colon-close-brace-d”
   クロージャ・ローカル宣言を終了します。 クロージャはディクショナリに割
り当てられます。

‘:}h’ ( hmaddr u latest latestnt wid 0 a-addr1 u1 ... –  ) gforth-1.0 “colon-close-brace-h”
   クロージャ・ローカル宣言を終了します。 クロージャーはヒープに割り当て
られます。

‘:}h1’ ( hmaddr u latest latestnt wid 0 a-addr1 u1 ... –  ) gforth-1.0 “colon-close-brace-h”
   クロージャ・ローカル宣言を終了します。 クロージャーはヒープに割り当て
られます。

‘:}xt’ ( hmaddr u latest latestnt wid 0 a-addr1 u1 ... –  ) gforth-1.0 “colon-close-brace-x-t”
   クロージャ・ローカル宣言を終了します。 クロージャは xt によってスタッ
ク上に割り当てられるため、 クロージャの実行時のスタック効果は ‘(
xt-alloc -- xt-closure )’ となります。

‘>addr’ ( xt – addr  ) gforth-experimental “to-addr”
   (‘free-closure’ から呼び出されます)ヒープ上のクロージャの xt を ADDR
に変換し、 ‘free’ に渡すことでクロージャを削除できます。

‘free-closure’ ( xt –  ) gforth-internal “free-closure”
   ヒープに割り当てられたクロージャを解放(free)します

     : foo [{: a f: b d: c xt: d :}d a . b f. c d. d ;] ;
     5 3.3e #1234. ' cr foo execute

   上記 ‘foo’ は、 単一セルと浮動小数点数と2倍長整数と xt を含むクロージ
ャをディクショナリ内に作成し、呼び出し時に最初の 3 つの値を出力後に xt を
実行します。

   これにより、 Algol コンパイラをテストするために 1964 年にドナルド・ク
ヌースが提案した “Man or boy test” を実装することができます(訳注: 手元で
はサッパリ動いてない(0.7.9_20240418, 2024.7))

     : A {: w^ k x1 x2 x3 xt: x4 xt: x5 | w^ B :} recursive
         k  0<= IF  x4 x5 f+  ELSE
             B k x1 x2 x3 action-of x4 [{: B k x1 x2 x3 x4 :}L
                 -1 k +!
                 k  B  x1 x2 x3 x4 A ;] dup B !
             execute  THEN ;
     : man-or-boy? ( n -- ) [: 1e ;] [: -1e ;] 2dup swap [: 0e ;] A f. ;

   場合によっては、 クロージャを変更するには永続的なストレージが必要です
。 複数のクロージャがその永続ストレージを共有する可能性さえあります。 上
の例では、 外部プロシージャのローカル変数がこれに使用されていますが、 場
合によっては、 クロージャが外部プロシージャよりも長く存続します。 特に、
ディクショナリまたはヒープ上に割り当てられたクロージャは、 親プロシージ
ャより長く存続するように設計されています。

   これらについては、 クロージャのように割り当てられるホーム・ロケーショ
ン(home locations)がありますが、 そのコードは作成時に直接実行され、 ホー
ム・ロケーションのアドレスを提供する必要があります。

     : bar ( a b c -- aaddr baddr caddr hl-addr )
         <{: w^ a w^ b w^ c :}h a b c ;> ;

   この例では、 ヒープ上に 3 つのセルを持つホーム・ロケーション(home
location)を作成し、 3 つのロケーションのアドレスとホーム・ロケーションの
アドレスを返します。 このアドレスは、 ホーム・ロケーションが不要になった
ときに ‘free’ するために使用できます。

‘<{:’ ( – hmaddr u latest latestnt wid 0  ) gforth-experimental “start-homelocation”
   ホーム・ロケーション(home location)の開始

‘;>’ ( –  ) gforth-experimental “end-homelocation”
   ホーム・ロケーションの終了


File: gforth.info,  Node: Standard Forth locals,  Prev: Gforth locals,  Up: Locals

6.22.2 Standard Forth locals
----------------------------

Forth-2012 標準では、 Gforth のローカル変数の制限付きバージョンであるロ
ーカル変数構文が定義されています:

   • ローカル変数はセル・サイズの値のみにすることができます(型指定子は許
     可されません)。
   • ローカル変数は制御構造の外側でのみ定義できます。
   • 定義ごとに許可されるローカル変数定義は 1 つだけです。
   • ローカル変数は、 リターン・スタックの明示的な使用を妨げる可能性があ
     ります。 正確な(そして長い)ルールについては、 標準を参照してくださ
     い。 ローカル変数を使用している定義でリターン・スタックにアクセスす
     るワードを使用しない場合は問題ありません。 このルールの目的は、 リ
     ターン・スタックを使ったローカル変数の実装を容易にすることです。
   • ローカル変数定義全体を 1 行に含める必要があります。

   標準 Forth ローカル変数ワードセット自体は ‘{:’ と 以下の 2 つのワード
で構成されます:

‘(local)’ ( addr u –  ) local “paren-local-paren”

   ANS Forth ローカル変数拡張ワードセット(ANS Forth locals extension
wordset)は ‘locals|’ を使用して構文を定義しますが、 これはとても酷い代物
なので、 使用しないことを強くお勧めします。 Gforth への移植を容易にする
ためにこの構文を実装しましたが、 ここでは文書化しません。 この構文の問題
は、 ローカル変数が標準のスタック・コメント表記とは逆の順序で定義されて
いるため、 プログラムが読みにくくなり、 読み間違いや書き間違いが起こりや
すくなることです。 この構文の唯一の利点は、 ANS Forth ローカル変数ワード
セットを使用して実装が簡単であることですが、 ‘{:’ 構文だって同じくらい実
装は簡単ですからね？


File: gforth.info,  Node: Structures,  Next: Object-oriented Forth,  Prev: Locals,  Up: Words

6.23 Structures
===============

このセクションでは、 Gforth に付属する構造体パッケージを紹介します。 標
準 Forth で実装されたパッケージのバージョンは、 ‘compat/struct.fs’ で入
手できます。 このパッケージは、 1989 年の comp.lang.forth への投稿に触発
されました(残念ながら、誰による投稿かは覚えていません。おそらく John
Hayes によるものでしょう)。 このセクションのバージョンは、 M. Anton
Ertl, Yet Another Forth Structures Package
(https://www.complang.tuwien.ac.at/forth/objects/structs.html), Forth
Dimensions 19(3), pages 13–16 です。 Marcel Hendrix は有益なコメントを提
供してくれました。

* Menu:

* Why explicit structure support?::
* Structure Usage::
* Structure Naming Convention::
* Structure Implementation::
* Structure Glossary::
* Forth200x Structures::


File: gforth.info,  Node: Why explicit structure support?,  Next: Structure Usage,  Prev: Structures,  Up: Structures

6.23.1 Why explicit structure support?
--------------------------------------

複数のフィールドを含む構造体を使用したい場合は、 その構造体用にメモリを
予約し、 アドレス算術演算を使用してフィールドにアクセスするだけです
(*note Address arithmetic::)。 例として、 以下のフィールドを持つ構造体を
考えてみましょう

‘a’
     これは浮動小数点数(float)です
‘b’
     これはセル(cell)です
‘c’
     これは浮動小数点数(float)です

   構造体の (float 整列された) ベース・アドレスが与えられると、

‘a’
     それ以上何もせずに a フィールドが得られます。
‘b’
     ‘float+’ すると b フィールドが得られます。
‘c’
     ‘float+ cell+ faligned’ すると c フィールドが得られます。

   これが非常に疲れる可能性があることは容易にわかります。

   さらに加えて、 ‘cell+’ を見ても、 どの構造体がアクセスされているか、
どのフィールドがアクセスされているかがわからないため、 あまり読みやすく
ありません。 何らかの方法で構造体の種類を推測し、 その構造体のどのフィー
ルドがそのオフセットに対応するかをドキュメントで調べる必要があります。

   最後に、 この種のアドレス計算はメンテナンスの問題も引き起こします。 構
造体の途中にフィールドを追加・削除した場合、 その後フィールドのすべての
アドレス計算を探し出して変更する必要があります。

   そこで、 ‘cell+’ とそのファミリーを直接使用する代わりに、 以下のよう
にオフセットを定数に保存してはどうでしょうか？:

     0 constant a-offset
     0 float+ constant b-offset
     0 float+ cell+ faligned c-offset

   これで、 ‘x-offset +’ を使用してフィールド ‘x’ のアドレスを取得できる
ようになりました。 これはあらゆる点ではるかに優れています。 もちろん、 フ
ィールドを追加する場合は、 その後のオフセット定義をすべて変更する必要が
あります。 これは、 以下の方法でオフセットを宣言することで改良できます:

     0 constant a-offset
     a-offset float+ constant b-offset
     b-offset cell+ faligned constant c-offset

   オフセット計算にはいつも ‘+’ を使うので、 定義されたワードのアクショ
ンに ‘+’ を含む定義ワード ‘cfield’ を使用できます:

     : cfield ( n "name" -- )
         create ,
     does> ( name execution: addr1 -- addr2 )
         @ + ;

     0 cfield a
     0 a float+ cfield b
     0 b cell+ faligned cfield c

   今や、 ‘x-offset +’ の代わりに、 単に ‘x’ と書くことができるようにな
りました。

   構造体フィールドのワード群が非常にうまく使用できるようになりました。
ただし、 その定義はまだ少し面倒です。 名前を繰り返す必要があり、 サイズ
と配置に関する情報はフィールド定義の前後に配置されます。 このセクション
で紹介する構造体パッケージは、 これらの問題に対処します。


File: gforth.info,  Node: Structure Usage,  Next: Structure Naming Convention,  Prev: Why explicit structure support?,  Up: Structures

6.23.2 Structure Usage
----------------------

以下のコマンドを使用して、 (データのない)リンク・リストの構造体を定義で
きます(訳注: これは構造体テンプレートを定義するだけです。 構造体変数とす
るには別途 ‘%alloc’ 等する必要があります):
     struct
         cell% field list-next
     end-struct list%

   スタック上のリスト・ノードのアドレスを使用して、 ‘list-next’ を使用し
て次のノードのアドレスを含むフィールドのアドレスを計算できます。 たとえ
ば、 以下のようにしてリストの長さを決定できます:

     : list-length ( list -- n )
     \ "list" is a pointer to the first element of a linked list
     \ "n" is the length of the list
         0 BEGIN ( list1 n1 )
             over
         WHILE ( list1 n1 )
             1+ swap list-next @ swap
         REPEAT
         nip ;

   ‘list% %allot’ を使用すると、 ディクショナリ内にリスト・ノード用のメ
モリを確保でき、 これにより、 リスト・ノードのアドレスがスタック上に残り
ます。ヒープ上で同様の割り当てを行うには、 ‘list% %alloc’ を使用できます
(または、‘allocate’ のようなスタック効果(つまり、ior を使用)が欲しい場合
は、 ‘list% %allocate’ を使用します)。 リスト・ノードのサイズは ‘list%
%size’ で取得でき、 そのセル・アライメントは ‘list% %alignment’ で取得で
きます。

   注意: 標準 Forth では、 ‘create’ されたワードの本体は ‘aligned’ され
ていますが、 必ずしも ‘faligned’ されている訳ではない事に注意してくださ
い。したがって、 以下のようにすると:

     create "name" foo% %allot drop

この場合、 ‘foo%’ に割り当てられたメモリは、 ‘foo%’ に文字フィールドやセ
ル・フィールドや2倍長整数フィールドのみが含まれている場合にのみ、
‘_name_’ の本体から開始されることが保証されます。 したがって、 浮動小数
点数が含まれる場合は、以下を使用することをお勧めします

     foo% %allot constant "name"

   以下のように、 構造体 ‘foo%’ を別の構造体のフィールドとして含めること
ができます:
     struct
     ...
         foo% field ...
     ...
     end-struct ...

   構造体をいちから構築する代わりに、 既存の構造体を拡張できます。 たと
えば、 上記例で定義したような、 データのない単純なリンク・リストはほとん
ど役に立ちません。 これを以下のように、 整数の値を持つリンク・リストに拡
張できます:(1)

     list%
         cell% field intlist-int
     end-struct intlist%

   ‘intlist%’ は、 ‘list-next’ と ‘intlist-int’ の 2 つのフィールドを持
つ構造体です。

   以下のように、 n 要素の ‘foo%’ 型を含む配列型を指定できます:

     foo% n *

   この配列型は、 通常の型を使用できる場所であればどこでも使用できます
(例: ‘field’ を定義する場所や ‘%allot’ を使用するとき)。

   最初のフィールドは構造体のベース・アドレスにあり、 この、 最初のフィ
ールドのワード(例: ‘list-next’)は実際にはスタック上のアドレスを変更しま
せん。 あなたは実行時間と領域の効率を考慮して、 最初のフィールドのワード
を取り除きたいとと思うかもしれません。 しかし、 構造体パッケージがこの場
合を最適化するため、 そのは必要ありません。 最初のフィールドのワードをコ
ンパイルする場合、 コードは生成されません。 したがって、 読みやすさと保
守性を考慮して、 最初のフィールドにアクセスするときにその最初のフィール
ドのワードは含めるべきです。

   ---------- Footnotes ----------

   (1) この機能は「拡張レコード」(extended records)とも呼ばれます。 これ
は、 オベロン・プログラミング言語が成した主な革新です。 言い換えれば、 こ
の機能を Modula-2 に追加することで、 Wirth は新しい言語を作成し、 新しい
コンパイラの記述等を行いました。 この機能を Forth に追加するには、 数行
のコードが必要なだけでした。


File: gforth.info,  Node: Structure Naming Convention,  Next: Structure Implementation,  Prev: Structure Usage,  Up: Structures

6.23.3 Structure Naming Convention
----------------------------------

(構造体の命名規則)(私が)思いつくフィールド名は非常に汎用的なものが多く、
使用すると頻繁に名前の衝突が発生します。 たとえば、 多くの構造体にはたい
てい ‘counter’ フィールドが含まれています。 (私の)頭に浮かぶ構造体名は、
多くの場合、 そのような構造体を作成するワードの名前の論理的な選択でもあ
ります。

   したがって、 私は以下の命名規則を採用しました:

   • フィールド名の形式は ‘_struct_-_field_’ です。 ‘struct’ は構造体の
     基本名、‘field’ はフィールドの基本名です。 フィールド・ワードは、 構
     造体(のアドレス)をフィールド(のアドレス)に変換するものと考えること
     ができます。

   • 構造体の名前は ‘struct%’ の形式で、 ‘struct’ は構造体の基本名です。

   この命名規則は、 拡張構造体のフィールドではあまり機能しません。 たと
えば、 上記例の整数リスト構造体にはフィールド ‘intlist-int’ がありますが
、 ‘intlist-next’ ではなく ‘list-next’ があります。


File: gforth.info,  Node: Structure Implementation,  Next: Structure Glossary,  Prev: Structure Naming Convention,  Up: Structures

6.23.4 Structure Implementation
-------------------------------

この実装の核となるアイデアは、 構築されている構造体に関するデータをグロ
ーバル変数ではなくスタックに渡すことです。 この設計上の決定が下されると
、 他のすべては自然に配置されます。

   スタック上の型の説明は align size の形式です。 サイズをスタックの
TOSに維持すると、 配列の処理が非常に簡単になります。

   ‘field’ は、 ‘Create’ と ‘DOES>’ を使用する定義ワードです。 フィール
ドの本体にはフィールドのオフセットが含まれており、 通常の ‘DOES>’ アクシ
ョンは以下のようになります:

     @ +

つまり、 アドレスにオフセットを加算して、 フィールドのスタック効果 addr1
– addr2 を与えます。

   この単純な構造は、 オフセット 0 のフィールドの最適化によって少し複雑
になります。 これには、 別の ‘DOES>’ 部分が必要です(そのようなフィールド
がコンパイル中に呼び出された場合、 スタック上に何かがあることに依存でき
ないため)。 したがって、 異なる ‘DOES>’ 部分を別々のワードに配置し、 オ
フセットに基づいてどれを呼び出すかを決定します。 ゼロ・オフセットの場合
、 フィールドは基本的に noop です。 これは即実行ワードであるため、 コン
パイル時にコードは生成されません。


File: gforth.info,  Node: Structure Glossary,  Next: Forth200x Structures,  Prev: Structure Implementation,  Up: Structures

6.23.5 Structure Glossary
-------------------------

‘%align’ ( align size –  ) gforth-0.4 “%align”
   データ空間ポインタをアラインメント ALIGN に整列(align)します。

‘%alignment’ ( align size – align  ) gforth-0.4 “%alignment”
   構造体のアライメント

‘%alloc’ ( align size – addr  ) gforth-0.4 “%alloc”
   サイズ SIZE のアドレス・ユニットをアラインメント ALIGN で整列
(align)して割り当て、 割り当てたデータ・ブロックのアドレスを ADDR に返し
ます。 成功しなかった場合は負数の ior を ‘throw’ します。

‘%allocate’ ( align size – addr ior  ) gforth-0.4 “%allocate”
   ‘allocate’ と同様に、 サイズ SIZE のアドレス単位をアライメント ALIGN
で整列(align)して割り当て、 割り当てたデータ・ブロックのアドレスを ADDR
に返します。 成功した場合、 ior=0, 成功しなかった場合は ior<0

‘%allot’ ( align size – addr  ) gforth-0.4 “%allot”
   データ空間にサイズ SIZE アドレス単位をアラインメント ALIGN で割り当て
ます。 結果のデータ・ブロックのアドレスを ADDR に返します。

‘cell%’ ( – align size  ) gforth-0.4 “cell%”
\訳注: セル1つ分のサイズ size と、 サイズをアライメントした align を返す

‘char%’ ( – align size  ) gforth-0.4 “char%”
\訳注: char 1つ分のサイズ size と、 そのサイズをアライメントした align を返します

‘dfloat%’ ( – align size  ) gforth-0.4 “dfloat%”

‘double%’ ( – align size  ) gforth-0.4 “double%”
\訳注: 2倍長整数1つ分のサイズ size と、サイズをアライメントした align を返します

‘end-struct’ ( align size "name" –  ) gforth-0.2 “end-struct”
   アライメント ALIGN とサイズ SIZE を使用して 構造体/型記述子 NAME を定
義します(SIZE は ALIGN の倍数になるように切り上げられます – size1)。
‘name’ 実行時: ( – ALIGN SIZE1)

‘field’ ( align1 offset1 align size "name" –  align2 offset2  ) gforth-0.2 “field”
   オフセット OFFSET1 と ALIGN SIZE で指定された型を持つフィールド NAME
を作成します。 OFFSET2 は次のフィールドのオフセットで、ALIGN2 は、 (そこ
までの)すべてのフィールドのアライメントです。 ‘name’ の実行時: ( ADDR1 –
ADDR2 ) ADDR2=ADDR1+OFFSET1

‘float%’ ( – align size  ) gforth-0.4 “float%”

‘sfloat%’ ( – align size  ) gforth-0.4 “sfloat%”

‘%size’ ( align size – size  ) gforth-0.4 “%size”
   構造体のサイズを返す

‘struct’ ( – align size  ) gforth-0.2 “struct”
   空の構造体。 構造体定義を開始するために使用されます。


File: gforth.info,  Node: Forth200x Structures,  Prev: Structure Glossary,  Up: Structures

6.23.6 Forth200x Structures
---------------------------

Forth 2012 標準では、 やや不便な形式の構造体が定義されています。 一般に
‘field+’ を使用する場合は、 自分でアライメントを行う必要がありますが、 ア
ライメント機能を含む便利なワード(例: ‘field:’)が多数あります。

   典型的な使用例は以下のとおりです:

     0
       field:                   s-a
       faligned 2 floats +field s-b
     constant s-struct

   この構造体を記述する別の方法は以下のとおりです:

     begin-structure s-struct
       field:                   s-a
       faligned 2 floats +field s-b
     end-structure

   以下のように、 同一のフィールドと追加のフィールドを持つ構造体を定義で
きます:

     s-struct
       cfield: t-c
       cfield: t-d
     constant t-struct

   あるいは、

     s-struct extend-structure t-struct
       cfield: t-c
       cfield: t-d
     end-structure

‘begin-structure’ ( "name" – struct-sys 0  ) facility-ext “begin-structure”

‘extend-structure’ ( n "name" – struct-sys n  ) gforth-1.0 “extend-structure”
   サイズ n の既存の構造体の拡張として、 新しい構造体 name を開始します
。

‘end-structure’ ( struct-sys +n –  ) facility-ext “end-structure”
   ‘begin-struction’ で開始された構造体を終了します

‘+field’ ( noffset1 nsize "name" – noffset2  ) facility-ext “plus-field”
   定義ワード。 name ‘( addr1 -- addr2 )’ を定義します。 ここで、 addr2
は addr1+noffset1 です。 noffset2 は noffset1+nsize です。

‘cfield:’ ( u1 "name" – u2  ) facility-ext “c-field-colon”
   文字サイズのフィールドを定義します

‘field:’ ( u1 "name" – u2  ) facility-ext “field-colon”
   アライメントされたセル・サイズのフィールドを定義します

‘2field:’ ( u1 "name" – u2  ) gforth-0.7 “two-field-colon”
   アライメントされた2倍長セル・サイズのフィールドを定義します

‘ffield:’ ( u1 "name" – u2  ) floating-ext “f-field-colon”
   アライメントされた浮動小数点サイズのフィールドを定義します

‘sffield:’ ( u1 "name" – u2  ) floating-ext “s-f-field-colon”
   sfaligned された sfloat サイズのフィールドを定義します

‘dffield:’ ( u1 "name" – u2  ) floating-ext “d-f-field-colon”
   dfaligned された dfloat サイズのフィールドを定義します

‘wfield:’ ( u1 "name" – u2  ) gforth-1.0 “w-field-colon”
   16 ビット値のアライメントされたフィールドを定義します。

‘lfield:’ ( u1 "name" – u2  ) gforth-1.0 “l-field-colon”
   32ビット値にアライメントされたフィールドを定義します。

‘xfield:’ ( u1 "name" – u2  ) gforth-1.0 “x-field-colon”
   64ビット値にアライメントされたフィールドを定義します。


File: gforth.info,  Node: Object-oriented Forth,  Next: Regular Expressions,  Prev: Structures,  Up: Words

6.24 Object-oriented Forth
==========================

Gforth には、オブジェクト指向プログラミング用の 3 つのパッケージ
(‘objects.fs’ と ‘oof.fs’ と ‘mini-oof.fs’) が付属しています。 どれも最
初から組み込まれていないため、 使用する前にインクルードする必要がありま
す。 これらのパッケージ(および、 その他のパッケージ)の最も重要な違いにつ
いては、 *note Comparison with other object models:: で説明します。 すべ
てのパッケージは 標準 Forth で書かれており、 他の 標準 Forth でも使用で
きます。

* Menu:

* Why object-oriented programming?::
* Object-Oriented Terminology::
* Objects::
* OOF::
* Mini-OOF::
* Mini-OOF2::
* Comparison with other object models::


File: gforth.info,  Node: Why object-oriented programming?,  Next: Object-Oriented Terminology,  Prev: Object-oriented Forth,  Up: Object-oriented Forth

6.24.1 Why object-oriented programming?
---------------------------------------

多くの場合、 いくつかのデータ構造「オブジェクト」(object)を扱わなければ
なりません。 それらは、 いつくかの側面では同様に扱う必要がありますが、 そ
れ以外の側面では異なる扱いをしなければなりません。 グラフィカル・オブジ
ェクトとは教科書的な例で言えば、 円や三角形や恐竜の絵やアイコン等ですが
、 プログラム開発中にさらに追加することもできます。 あなたが、 任意のグ
ラフィカル・オブジェクトにいくつかの操作を適用したいとしましょう。 たと
えば、 画面上に表示するための ‘draw’ 操作です。 しかしながら、 この
‘draw’ はオブジェクトの種類ごとに異なる処理を行う必要があります。

   ‘draw’ を、 描画されるオブジェクトの種類に依存して適切なコードを実行
する、 大きな ‘CASE’ 制御構造として実装することはできます。 これはあまり
洗練されたものではなく、 さらに、 新しい種類のグラフィック・オブジェクト
(例えば宇宙船など)を追加するたびに ‘draw’ を変更する必要があります。

   私たちがやりたいことは、 宇宙船を定義するときにシステムに次のように指
示することです: 「宇宙船を ‘draw’ する方法は私たちがこれこれこのとおり書
いたので、 それ以外の処理はシステム側でよしなしにしてください」

   これは、 (当然ながら、 )オブジェクト指向と呼ばれるすべてのシステムで
解決すべき問題です。 ここで紹介するオブジェクト指向パッケージは、 この問
題を解決します(それ以外の問題はあんまり解決できません…)。


File: gforth.info,  Node: Object-Oriented Terminology,  Next: Objects,  Prev: Why object-oriented programming?,  Up: Object-oriented Forth

6.24.2 Object-Oriented Terminology
----------------------------------

このセクションは主にリファレンスであるため、 すぐにすべてを理解する必要
はありません。 用語は主に Smalltalk からインスピレーションを得たものです
:

_クラス(class)_
     いくつかの追加機能を備えたデータ構造定義。

_オブジェクト(object)_
     クラス定義によって記述されたデータ構造の実体(インスタンス
     ;instance)。

_インスタンス変数(instance variables)_
     データ構造のフィールド。

_セレクター(selector)_
     (または「メソッド・セレクター」)さまざまなデータ構造(クラス)に対し
     て操作を実行するワード(例: ‘draw’)。 セレクターは、 「何の」
     (what)操作を行うかを記述します。 C++ 用語では (純粋)仮想関数 と言い
     ます

_メソッド(method)_
     特定のクラスのセレクターによって記述された操作を実行する具体的な定
     義。 メソッドは、 特定のクラスに対して「どのように」(how)操作が実行
     されるかを指定します。

_セレクター呼び出し(selector invocation)_
     セレクターの呼び出し。 呼び出しの 1 つの引数(TOS(スタックの頂上))は
     、 どのメソッドが使用されるかを決定するために使用されます。
     Smalltalk の用語では、 (セレクターとその他の引数で構成される、)メッ
     セージがオブジェクトに送信される と言います。

_受信オブジェクト(receiving object)_
     セレクターの呼び出しによって実行されるメソッドを決定するために使用
     されるオブジェクト。 ‘objects.fs’ モデルでは、 セレクターが呼び出さ
     れたときに TOS 上にあるオブジェクトです。 (「受信」という言葉は、
     Smalltalk の 「メッセージ」関連用語由来です。)

_子クラス(child class)_
     「親クラス」のすべてのプロパティ(インスタンス変数やセレクターやメソ
     ッド)を「継承」(inherit)したクラス。 Smalltalk の用語では、 サブク
     ラスはスーパークラスを継承します、 と言います。 C++ 用語では、 派生
     クラスは基底クラスから継承します(The derived class inherits from
     the base class.)、 と言います。


File: gforth.info,  Node: Objects,  Next: OOF,  Prev: Object-Oriented Terminology,  Up: Object-oriented Forth

6.24.3 The ‘objects.fs’ model
-----------------------------

このセクションでは、 ‘objects.fs’ パッケージについて説明します。 この資
料は、 M. Anton Ertl, ‘Yet Another Forth Objects Package
(https://www.complang.tuwien.ac.at/forth/objects/objects.html)’, Forth
Dimensions 19(2), pages 37–43 でも公開されています。

   このセクションは、 *note Structures:: を読了済であることを前提として
います。

   このモデルの基礎となっている技術は、 パーサ・ジェネレーター Gray の実
装に使用されており、 Gforth でもさまざまな種類のワードリスト(ハッシュの
有無や、大文字と小文字の区別の有無や、 ローカル変数用などの特殊用途のワ
ードリスト)を実装するために使用されています)。

* Menu:

* Properties of the Objects model::
* Basic Objects Usage::
* The Objects base class::
* Creating objects::
* Object-Oriented Programming Style::
* Class Binding::
* Method conveniences::
* Classes and Scoping::
* Dividing classes::
* Object Interfaces::
* Objects Implementation::
* Objects Glossary::

   Marcel Hendrix は、 このセクションに関して役立つコメントを提供しまし
た。


File: gforth.info,  Node: Properties of the Objects model,  Next: Basic Objects Usage,  Prev: Objects,  Up: Objects

6.24.3.1 Properties of the ‘objects.fs’ model
.............................................

   • オブジェクトをスタックに渡すのは簡単明瞭です。 スタック上でセレクタ
     ーを渡すのは多少めんどくさいですが、 可能です。

   • オブジェクトはメモリ内の単なるデータ構造であり、 そのアドレスによっ
     て参照されます。 ‘constant’ のような通常の定義ワードを使用してオブ
     ジェクトのワードを作成できます。 同様に、 オブジェクトを含むインス
     タンス変数と他のデータを含むインスタンス変数の間に違いはありません
     。

   • 遅延結び付け(Late binding)は効率的で使いやすいです。

   • 遅延結び付け(Late binding)によりパースが回避されるため、 状態スマー
     ト性(state-smartness)や拡張性の低下に関する問題が回避されます。 便
     宜上、 いくつかのパース・ワードがありますが、 それらには非パース・
     ワードもあります。 パースする定義ワードもいくつかあります。 すべて
     の標準の定義ワードは(‘:noname’ を除いて)パースするため、 これを避け
     るのは困難です。 ただし、 このようなワードは状態スマート
     (state-smart)ではないため、 他の多くのパース・ワードほど悪くはあり
     ません。

   • このモデルではすべてを取り入れようとしているわけではありません。 (著
     者の私見ですけども)このモデルでは、 いくつかのことをうまくやるとい
     った体です。 特に、 このモデルでは情報の隠蔽をサポートするように設
     計されていません(情報の隠蔽に役立つ可能性のある機能はありますが)。
     これを実現するには、また別のパッケージが使用可能です。

   • このモデルは階層構造((layered))になっています。 このモデルを使用す
     るために下位階層まですべての機能を学習して使用する必要はありません
     。 必要な機能はほんのわずかです((*note Basic Objects Usage::, *note
     The Objects base class::, *note Creating objects::)。 その他の機能
     はオプションであり、 互いに独立しています。

   • gforth 固有ではなく、 標準 Forth 用の実装が利用可能です。


File: gforth.info,  Node: Basic Objects Usage,  Next: The Objects base class,  Prev: Properties of the Objects model,  Up: Objects

6.24.3.2 Basic ‘objects.fs’ Usage
.................................

以下のようにして graphical オブジェクト(図形オブジェクト)のクラスを定義
できます:

     object class \ クラス名 "object" は親クラスです
       selector draw ( x y graphical -- )
     end-class graphical

   このコードは、 ‘draw’ 操作を持つクラス ‘graphical’ を定義します。 任
意の ‘graphical’ オブジェクトに対して ‘draw’ 操作を実行できます。例:

     100 100 t-rex draw

ここで、 ‘t-rex’ は、 graphical オブジェクトを生成するワード(定数
(constant)など)です。

   graphical オブジェクトを作成するにはどうすればよいでしょうか？ 現在の
定義では、 有用な graphical オブジェクトを作成できません。 クラス
‘graphical’ は graphical オブジェクト一般を記述しますが、 具体的な
graphical オブジェクト・タイプを記述しません(C++ ユーザーはこれを「抽象
クラス」(abstract class)と呼びます)。 たとえば、 クラス ‘graphical’ には
セレクター ‘draw’ のメソッドがありません。

   具体的な graphical オブジェクトのために、 クラス ‘graphical’ の子クラ
スを定義します。 例:

     graphical class \ 親クラスは graphical
       cell% field circle-radius

     :noname ( x y circle -- )
       circle-radius @ draw-circle ;
     overrides draw

     :noname ( n-radius circle -- )
       circle-radius ! ;
     overrides construct

     end-class circle

   ここでは、 フィールド ‘circle-radius’ を持つクラス ‘circle’ を
‘graphical’ の子として定義しています(フィールド ‘circle-radius’ は構造体
のフィールドと同じように動作します(*note Structures::)。 セレクター
‘draw’ と ‘construct’ 用の新しいメソッドを定義します(‘construct’ は
‘graphical’ の親クラスの ‘object’ クラスで定義されています))。

   以下のようにして、 ヒープ上(つまり、 ‘allocate’ されたメモリ)に
circle を作成できます:

     50 circle heap-new constant my-circle

‘heap-new’ は ‘construct’ を呼び出し、 フィールド ‘circle-radius’ を 50
で初期化します。 以下のようにして、 この新しい円を (100,100) の位置に描
画(draw)できます:

     100 100 my-circle draw

   注意: セレクターを呼び出すことができるのは、 TOS 上のオブジェクト(受
信オブジェクト) が、 セレクターが定義されたクラス、 またはその子孫の 1 つ
に属している場合のみです。 たとえば、 ‘draw’ は、 ‘graphical’ またはその
子孫(例: ‘circle’)に属するオブジェクトに対してのみ呼び出すことができます
。 ‘end-class’ の直前の検索順序スタック(the search order)は、 ‘class’ の
直後と同じである必要があります。


File: gforth.info,  Node: The Objects base class,  Next: Creating objects,  Prev: Basic Objects Usage,  Up: Objects

6.24.3.3 The ‘object.fs’ base class
...................................

あなたがクラスを定義するときは、 必ず親クラスを指定する必要があります。
では、 (最初の)クラス定義はどのようにすればよいのでしょうか？ そのために
最初から使用できるクラスが 1 つだけあります。 それは ‘object’ という名前
のクラスです。 これはすべてのクラスの祖先であるため、 親を持たない唯一の
クラスです。 そして、 ‘construct’ と ‘print’ という 2 つのセレクターを持
っています。


File: gforth.info,  Node: Creating objects,  Next: Object-Oriented Programming Style,  Prev: The Objects base class,  Up: Objects

6.24.3.4 Creating objects
.........................

‘heap-new’ ( ...  class – object ) を使用するとヒープ上にクラスのオブジ
ェクトを作成して初期化することができ、 ‘dict-new’ ( ...  class – object
) を使用するとディクショナリ内(‘allot’ による割り当て)にクラスのオブジェ
クトを作成して初期化することができます。 どちらのワードも当該クラス
class の ‘construct’ を呼び出し、 当該クラス class の ‘construct’ のスタ
ック効果(上記「...」の部分)で示されたスタック項目を消費します(訳注: 例え
ば 6.24.3.2 Basic ‘objects.fs’ Usage の例のように、 ‘circle’ の
‘construct’ のスタック効果 n-radius が必要で、 ‘50 circle heap-new
constant my-circle’ としなければならない)。

   オブジェクトに自分でメモリを割り当てたい場合は、 ‘class-inst-size 2@’
( class – align size ) を使用してクラスのアライメント(alignment)とサイズ
を取得できます。 オブジェクト用のメモリを確保したら、 ‘init-object’ (
...  class object – )でオブジェクトを初期化できます(訳注: class のための
データ構造を object からに構築し、 その後そのオブジェクトに対して
‘construct’ を実行します。 注意: 当該 class の ‘construct’ 用のスタック
項目の指定も必要な事に注意)。


File: gforth.info,  Node: Object-Oriented Programming Style,  Next: Class Binding,  Prev: Creating objects,  Up: Objects

6.24.3.5 Object-Oriented Programming Style
..........................................

このセクションはすべてを網羅したものではありません。

   一般に、 同一のセレクターのすべてのメソッドが同一スタック効果を持つよ
うにするのは良いアイデアです。 セレクターを呼び出すとき、 どのメソッドが
呼び出されるのかわからないことが多いため、 すべてのメソッドが同じスタッ
ク効果を持たない限り、 セレクター呼び出しのスタック効果を知ることはでき
ません。

   このルールには例外がひとつあります。 セレクター ‘construct’ のメソッ
ドです。 同一の場所に構築するクラスを指定しているため、 どのメソッドが呼
び出されるのかがわかります。 実際、 著者はユーザーに初期化を指定する便利
な方法を提供するためだけに ‘construct’ をセレクターとして定義しました。
使用方法としては、 セレクター呼び出しとは異なるメカニズムの方が自然です
(ただし、 おそらく説明するにはより多くのコードとスペースが必要になります
)。


File: gforth.info,  Node: Class Binding,  Next: Method conveniences,  Prev: Object-Oriented Programming Style,  Up: Objects

6.24.3.6 Class Binding
......................

通常のセレクター呼び出し(selector invocation)では、 受信オブジェクト
(receiving object)のクラスに応じて実行時(run-time)にメソッドが決定されま
す。 この実行時の選択(selection)は「遅延結び付け」(late binding)と呼ばれ
ます。

   場合によっては、 別のメソッドを呼び出すことが望ましい場合があります。
たとえば、 出力オブジェクト(‘print’ing ‘object’s)では、 受信用クラス
(receiver class)の冗長になりがちな ‘print’ メソッドの代わりに、 単純なメ
ソッドを使用したい事があります。 これを実現するには、 ‘print’ の呼び出し
を以下のように置き換えます(コンパイル時の場合):

     [bind] object print

または、 インタプリタ時は以下のようにします:

     bind object print

あるいは、 メソッドを名前(例: ‘print-object’)で定義し、 その名前を使用し
て呼び出すこともできます。 クラス結び付け(Class binding)は、 同じ効果を
達成する(多くの場合、 より便利な)方法にすぎません。 これにより、 名前の
乱雑さが回避され、 最初に名前を付けずにメソッドを直接呼び出すことができ
ます。

   クラス結び付け(class binding)のよくある使用法は次のとおりです: セレク
ターのメソッドを定義するとき、 親クラスでセレクターが行っていることと、
それ以上のことをメソッドに実行させたいことがよくあります。 この目的には
、 ‘[parent]’ という特別なワードがあります。 ‘[parent] "selector"’ は
‘[bind] "parent selector"’ と同等です。 ここで、‘parent’ は現在のクラス
の親クラスです。 たとえば、メソッド定義は以下のようになります:

     :noname
       dup [parent] foo \ 受信オブジェクトに対して親の foo を実行します
       ... \ (親の foo に加えて)更に何かする
     ; overrides foo

   ‘Object-oriented programming in ANS Forth’ (Forth Dimensions, March
1997) で Andrew McKewan は最適化手法としてクラス結び付け(class binding)を
紹介しています。 著者は緊急の場合を除き、 最適化手法の目的で使用しないこ
とをお勧めします。 とにかく、 このモデルでは遅延結び付け(Late binding)が
非常に高速であるため、 クラス結び付け(class binding)を使用するメリットは
小さいです。 適切でない場合にクラス結び付け(class binding)を使用すると、
保守性が低下します。

   プログラミング・スタイルの質問については次のとおりです。 セレクターは
受信オブジェクト(receiving object)の祖先クラス(ancestor classes)にのみ結
び付け(bind)すべきです。 たとえば、 受信オブジェクトがクラス ‘foo’ また
はその子孫であることがわかっているとします。 その場合は、 ‘foo’ とその祖
先にのみ結び付け(bind)するべきです。


File: gforth.info,  Node: Method conveniences,  Next: Classes and Scoping,  Prev: Class Binding,  Up: Objects

6.24.3.7 Method conveniences
............................

【メソッドをより便利に】通常、 メソッドでは受信オブジェクト(receiving
object)に頻繁にアクセスします。 メソッドをプレーンなコロン定義(‘:noname’
など)として定義する場合、 多くのスタック体操が必要になる場合があります。
これを回避するには、 ‘m: ... ;m’ を使用してメソッドを定義します。たとえ
ば、 以下を使用して ‘circle’ を ‘draw’ するメソッドを定義できます

     m: ( x y circle -- )
       ( x y ) this circle-radius @ draw-circle ;m

   このメソッドが実行されるときは、 受信オブジェクト(receiver object)(上
記例の circle)がスタックから取り除かれます。 その代わりに、 m: 〜 ;m の
間は ‘this’ を使用して受信オブジェクトにアクセスできます(ええ、 確かに、
この例では ‘m: ... ;m’ を使用する利点ないかもしれませんね)。 注意: しか
し、 スタック・コメントとしては ‘m:’ と ‘;m’ の間のコードだけでなく、 メ
ソッド全体(つまり、 受信オブジェクトを含むメソッド全体)のスタック効果を
指定していることに注意してください。 なお、 ‘m:...;m’ では ‘exit’ を使用
できません。 代わりに、 ‘exitm’ を使用してください(1)。

   あなたは ‘this "field"’ という形式のシーケンスを頻繁に使用するハメに
なると思います(上記例では: ‘this circle-radius’)。 そこで、 この方法での
みフィールドを使用する場合は、 ‘inst-var’ を使用してフィールドを定義し、
フィールド名の前の ‘this’ を削れます。 たとえば、 上記例の ‘circle’ クラ
スは以下のように定義することもできます:

     graphical class
       cell% inst-var radius

       m: ( x y circle -- )
         radius @ draw-circle ;m
       overrides draw

       m: ( n-radius circle -- )
         radius ! ;m
       overrides construct

     end-class circle

   ‘radius’ は、 ‘circle’ や、 その子孫クラスと、 それらの ‘m:...;m’ 内
でのみ使用できます。

   ‘inst-value’ を使用してフィールドを定義することもできます。 これは、
‘variable’ に対して ‘value’ があるのと同様に、 ‘inst-var’ に対して
‘inst-value’ があるのです。 このようなフィールドの値は ‘[to-inst]’ を使
用して変更できます。 たとえば、 クラス ‘circle’ を以下のように定義するこ
ともできます:

     graphical class
       inst-value radius

       m: ( x y circle -- )
         radius draw-circle ;m
       overrides draw

       m: ( n-radius circle -- )
         [to-inst] radius ;m
       overrides construct

     end-class circle

   ---------- Footnotes ----------

   (1) さらに、 ‘catch’ を呼び出すワードや、 ‘objects.fs’ をロードする前
に定義されているワードについては、 ‘catch’ を再定義したように、 これらも
再定義する必要があります: ‘: catch this >r catch r> to-this ;’


File: gforth.info,  Node: Classes and Scoping,  Next: Dividing classes,  Prev: Method conveniences,  Up: Objects

6.24.3.8 Classes and Scoping
............................

構造体の拡張とは異なり、 継承は頻繁に行われます。 これは、フィールド名命
名規則の問題をさらに悪化させます(*note Structure Naming Convention::): フ
ィールドが最初にどのクラスで定義されたかを常に覚えておく必要があります。
クラス構造の一部を変更すると、 影響を受けないコードの名前も変更する必要
があります。

   この問題を解決するために、 著者は(著者のオリジナルのモデルにはなかっ
た)スコープ・メカニズムを追加しました。 ‘inst-var’ (または
‘inst-value’)で定義されたフィールドは、 それが定義されているクラスと、 そ
のクラスの子孫のクラスでのみ可視です。 このようなフィールドの使用は、 い
ずれにしても、 これらのクラスの ‘m:’ で定義されたメソッドでのみ意味があ
ります。

   このスコープ・メカニズムにより、 名前が無関係なワードと衝突する可能性
が大幅に低くなるため、 着飾っていないフィールド名を使用できます。

   スコープ・メカニズムがあれば、 他のワードの可視性を制御するために使用
することもできます。 ‘protected’ の後に定義されたすべてのワードは、 現在
のクラスとその子孫でのみ表示されます。 ‘public’ は、 以前に有効だった
the current wordlist (新しく定義されたワードを入れるワードリスト)(つまり
ユーザー変数 ‘current’)を復元します。 ‘public’ または ‘set-current’ が介
在せずに複数の ‘protected’ がある場合、 ‘public’ はこれらの最初の
‘protected’ より前の有効な the current wordlist を復元します。


File: gforth.info,  Node: Dividing classes,  Next: Object Interfaces,  Prev: Classes and Scoping,  Up: Objects

6.24.3.9 Dividing classes
.........................

メソッドの定義を、 クラスや、そのセレクターや、 フィールドや、 インスタ
ンス変数、 の定義とは別に行う、 つまり、 実装を定義から分離することもで
きます。 これは以下の方法で行うことができます:

     graphical class
       inst-value radius
     end-class circle

     ... \ do some other stuff

     circle methods \ now we are ready

       m: ( x y circle -- )
         radius draw-circle ;m
       overrides draw

       m: ( n-radius circle -- )
         [to-inst] radius ;m
       overrides construct

     end-methods

   複数の ‘methods’...‘end-methods’ セクションを使用できます。 これらの
セクションでクラスに対して実行できることは、 メソッドの定義とクラスのセ
レクターのオーバーライドのみです。 新しいセレクターやフィールドを定義し
てはいけません。

   注意: 多くの場合、 セレクターを使用する前にオーバーライドする必要があ
ることに注意してください。 特に、 ‘heap-new’ とその他のメソッドを呼び出
す前に、 通常は ‘construct’ を新しいメソッドでオーバーライドする必要があ
ります。 たとえば、 上記例の ‘overrides construction’ シーケンスの前に
circle を作成してはなりません。


File: gforth.info,  Node: Object Interfaces,  Next: Objects Implementation,  Prev: Dividing classes,  Up: Objects

6.24.3.10 Object Interfaces
...........................

このモデルでは、 受信オブジェクト(receiving objects)のクラスまたはその祖
先の 1 つに定義されたセレクターのみを呼び出すことができます。 これらのク
ラスのいずれにも属さない受信オブジェクトを使用してセレクターを呼び出した
場合、 結果は未定義になります。 あなたの運が良ければ、 プログラムは即座
にクラッシュします。

   ここで、 2 つのクラスで 1 つまたは複数のセレクターを使用できるように
したい場合を考えてみましょう。 セレクターを共通の祖先クラスに追加する必
要があり、 最悪の場合は ‘object’ に追加する必要があります。 たとえば、 他
の誰かがこの祖先クラスに対して責任を負っているなどの理由で、 共通の祖先
クラスへのセレクターの追加を実行したくない場合もあります。

   この問題の解決策はインターフェイス(interface)です。 インターフェイス
はセレクターのコレクション(collection)です。 クラスがインターフェイスを
実装(implement)している場合、 そのインターフェイスのセレクターはそのクラ
スとその子孫のクラスで使用できるようになります。 クラスは無制限の数のイ
ンターフェイスを実装できます。 上で説明した問題については、 セレクター達
の為にインターフェイスを定義し、 両方のクラスでそのインターフェイスを実
装します。

   例として、 オブジェクトをディスクに書き込んで戻すための ‘storage’ と
いうインターフェイスと、 それを実装するクラス ‘foo’ について考えてみまし
ょう。 そのコードは以下のようになります:

     interface
       selector write ( file object -- )
       selector read1 ( file object -- )
     end-interface storage

     bar class
       storage implementation

       ... overrides write
       ... overrides read1
       ...

     end-class foo

(著者は、 ここから更に ‘read1’ を内部的に使用するワード ‘read’ ( file –
object ) を追加するのですが、 それはインターフェイスとは関係ないので、 こ
こでは説明を割愛します。 )

   注意: インターフェイスでは ‘protected’ を使用できないことに注意してく
ださい。 もちろん、 フィールドを定義することもできません。

   Neon モデルでは、 すべてのセレクターがすべてのクラスで使用できます。
したがってインターフェイスは必要ありません。 Neon モデルで支払う代償は、
遅延結び付け(late binding)が遅くなるため、 遅延結び付けを回避するために
複雑さが増すことです。


File: gforth.info,  Node: Objects Implementation,  Next: Objects Glossary,  Prev: Object Interfaces,  Up: Objects

6.24.3.11 ‘objects.fs’ Implementation
.....................................

オブジェクトは、 ‘struct...end-struct’ で記述されたデータ構造体の 1 つで
ある、 メモリの一片です。 これは、 そのオブジェクトのクラスのメソッド・
マップ(the method map) を指すフィールド ‘object-map’ を持っています。

   「メソッド・マップ」(method map)(1)は、 そのオブジェクトのクラスのメ
ソッドの実行トークン(xt)を含む配列です。 各セレクターには、 メソッド・マ
ップへのオフセットが含まれています。

   ‘selector’ は、‘CREATE’ と ‘DOES>’ を使用する定義ワードです。
selector の本体の内容はメソッド・マップのオフセット値です。 クラスのセレ
クターの ‘DOES>’ アクションは、 基本的には以下のとおりです(訳注: メソッ
ド・マップの実装上のフィールド名は "object-map"):

     ( object addr ) @ over object-map @ + @ execute

   なお、 ‘object-map’ はオブジェクトの最初のフィールドであるため、 コー
ドは生成されません。 ご覧のとおり、 セレクターの呼び出しには小さいけれど
も一定のコストがかかります。

   クラスは基本的に ‘struct’ とメソッド・マップを組み合わせたものです。
‘struct’ の場合と同様に、 クラス定義中に、 クラスのアライメントとサイズ
がスタックに渡されるため、 ‘field’ をクラスのフィールドの定義にも使用で
きます。 ただし、 スタックにさらに多くの項目を渡すと不便になるため、
‘class’ はメモリ内にデータ構造を構築し、 変数 ‘current-interface’ を通じ
てアクセスします。 定義が完了すると、 クラスはポインタ(たとえば、 子クラ
ス定義のパラメータとして利用したりする)としてスタックに置かれます。

   新しいクラスは、 その親のアライメントとサイズ、 およびその親のメソッ
ド・マップのコピーから始まります。 新しいフィールドを定義すると、 サイズ
とアライメントが拡張されます。 同様に、 新しいセレクターを定義すると、 メ
ソッド・マップが拡張されます。 ‘overrides’ は、 セレクターによって指定さ
れたオフセットでメソッド・マップに新しい xt を保存するだけです。

   クラス結び付け(class binding)は、 そのクラスのメソッド・マップからセ
レクターによって指定されたオフセットで xt を取得し、 それをコンパイル
(‘compile,’)するだけです(‘[bind]’ の場合)。

   著者は ‘this’ を ‘value’ として実装しました。 ‘m:...;m’ メソッドの開
始時に、 古い ‘this’ がリターン・スタックに保存され、 最後に復元されます
。 TOS 上のオブジェクトは ‘TO this’ で保存します。 この手法には欠点が 1
つあります。 ユーザーが ‘;m’ 経由ではなく ‘throw’ または ‘exit’ 経由でメ
ソッドを終了した場合、 ‘this’ は復元されません(そして ‘exit’ がクラッシ
ュする可能性があります)。 著者は ‘throw’ の問題に対処するために、 ‘this’
を保存および復元するために ‘catch’ を再定義しました(訳注: "objects.fs" を
インクルードした時に "redefined catch" と警告が出るが、 意図的に再定義し
てあるので無視してください、 ということ)。 例外をキャッチできるワードに
ついても全く同様に行うべきです。 ‘exit’ については、 単純に使用を禁止し
ます(代わりに ‘exitm’ を用意しました)。

   ‘inst-var’ は ‘field’ とまったく同じですが、 ‘DOES>’ アクションが異な
ります:
     @ this +
   ‘inst-value’ も同様です。

   各クラスは、 ‘inst-var’ と ‘inst-value’ で定義されたワードや、 それら
の protected されたワードを含む、 ワードリストを持っています。 また、 そ
の親へのポインタも持っています。 ‘class’ は、 クラスとそのすべての祖先の
ワードリストを検索順序スタック(the search order)にプッシュし、
‘end-class’ はそれらをスタックから drop します。

   インターフェイスは、 フィールドと親と protected されたワードのないク
ラスに似ています。 つまり、 メソッド・マップがあるだけです。 クラスがイ
ンターフェイスを実装する場合、 そのメソッド・マップにはインターフェイス
のメソッド・マップへのポインターが含まれます。 マップ内の正のオフセット
はクラス・メソッド用に予約されているため、 インターフェイス・マップ・ポ
インターは負のオフセットを持ちます。 クラス・セレクターとは異なり、 イン
ターフェイスにはシステム全体で一意のオフセットがあります。 クラス・セレ
クターのオフセットは、 セレクターが利用可能な(呼び出し可能な)クラスに対
してのみ一意です。

   この構造は、 インターフェイス・セレクターがメソッドを見つけるために、
クラス・セレクターよりも 1 つ多い間接参照を実行する必要があることを意味
します。 その本体には、 クラス・メソッド・マップ内のインターフェイス・マ
ップ・ポインター・オフセットと、 インターフェイス・メソッド・マップ内の
メソッド・オフセットが含まれています。 インターフェイス・セレクターの
‘does>’ アクションは、 基本的には以下のとおりです:

     ( object selector-body )
     2dup selector-interface @ ( object selector-body object interface-offset )
     swap object-map @ + @ ( object selector-body map )
     swap selector-offset @ + @ execute

   ここで、 ‘object-map’ と ‘selector-offset’ は最初のフィールドであり、
コードは生成されません。

   具体的な例として、 以下のコードについて考えてみましょう:

     interface
       selector if1sel1
       selector if1sel2
     end-interface if1

     object class
       if1 implementation
       selector cl1sel1
       cell% inst-var cl1iv1

       ' m1 overrides construct
       ' m2 overrides if1sel1
       ' m3 overrides if1sel2
       ' m4 overrides cl1sel2
     end-class cl1

     create obj1 object dict-new drop
     create obj2 cl1    dict-new drop

   このコードで作成されたデータ構造 (‘object’ のデータ構造を含む) は、セ
ル・サイズ 4 を想定して figure (objects-implementation.png) に図示されて
います。

   ---------- Footnotes ----------

   (1) 「メソッド・マップ」(method map)は著者自作用語です。 C++ 用語では
、 仮想関数テーブル と言います。


File: gforth.info,  Node: Objects Glossary,  Prev: Objects Implementation,  Up: Objects

6.24.3.12 ‘objects.fs’ Glossary
...............................

‘bind’ ( ... "class" "selector" – ...  ) objects “bind”
   指定のクラス CLASS の 指定セレクター SELECTOR のメソッドを execute し
ます。

‘<bind>’ ( class selector-xt – xt  ) objects “<bind>”
   XT は、 指定クラス CLASS のセレクター SELECTOR-XT のメソッドです。

‘bind'’ ( "class" "selector" – xt  ) objects “bind”’
   XT は 指定のクラス CLASS の 指定のセレクター SELECTOR のメソッドです
。

‘[bind]’ ( compile-time: "class" "selector" – ; run-time: ... object – ...  ) objects “[bind]”
   指定のクラス CLASS の 指定のセレクター SELECTOR のメソッドをコンパイ
ルします。

‘class’ ( parent-class – align offset  ) objects “class”
   PARENT-CLASS の子として新しいクラス定義を開始します。 スタックに積ま
れた ALIGN OFFSET は FIELD などで使用されます。

‘class->map’ ( class – map  ) objects “class->map”
   指定のクラス CLASS のメソッド・マップへのポインタを MAP に返します。

‘class-inst-size’ ( class – addr  ) objects “class-inst-size”
   指定のクラス CLASS のインスタンス(つまり、 オブジェクト)のサイズ仕様
を指します。 通常 ‘class-inst-size 2@ ( class -- align size )’ として使
用されます。

‘class-override!’ ( xt sel-xt class-map –  ) objects “class-override!”
   指定の XT は、 指定の CLASS-MAP のセレクター SEL-XT の新しいメソッド
です。

‘class-previous’ ( class –  ) objects “class-previous”
   指定の CLASS のワードリストを検索順序スタック(the search order)から
drop します。 CLASS のワードリストが実際に検索順序スタックに含まれている
かどうかのチェックは行われません。

‘class>order’ ( class –  ) objects “class>order”
   クラス CLASS のワードリストを検索順序スタック(the search-order)の先頭
に追加します。

‘construct’ ( ... object –  ) objects “construct”
   指定の OBJECT のデータ・フィールドを初期化します。 基底クラス OBJECT
の construct メソッドは何も行いません: ‘( object -- )’.

‘current'’ ( "selector" – xt  ) objects “current”’
   XT は、 現在のクラスの指定の SELECTOR のメソッドです。

‘[current]’ ( compile-time: "selector" – ; run-time: ... object – ...  ) objects “[current]”
   現在のクラスの SELECTOR のメソッドをコンパイルします。

‘current-interface’ ( – addr  ) objects “current-interface”
   変数(Variable): 現在定義中のクラスまたはインターフェイスが含まれます
。

‘dict-new’ ( ... class – object  ) objects “dict-new”
   指定のクラス CLASS オブジェクト用の領域を ‘allot’ を使用してディクシ
ョナリ内に確保し、 初期化(‘init-object’)したオブジェクトへのポインタを
OBJECT に返します(訳注: OBJECT は領域の先頭ではなくてメソッド・マップ
(object-map)フィールドを指している事に注意)

‘end-class’ ( align offset "name" –  ) objects “end-class”
   NAME という名前を付けてクラス定義を終了します。 NAME 実行時: ‘--
class’

‘end-class-noname’ ( align offset – class  ) objects “end-class-noname”
   クラス定義を終了します。 結果のクラスは CLASS です。

‘end-interface’ ( "name" –  ) objects “end-interface”
   ‘name’ という名前を付けてインターフェイス定義を終了します。 ‘name’ の
実行時: ‘--interface’

‘end-interface-noname’ ( – interface  ) objects “end-interface-noname”
   インターフェイス定義を終了します。 結果のインターフェイスは INTERFACE

‘end-methods’ ( –  ) objects “end-methods”
   クラスのメソッド定義から通常モードに切り替えます(現在、 これは古い検
索順序スタックを復元するだけです)。

‘exitm’ ( –  ) objects “exitm”
   メソッドから ‘exit’ します。 古い ‘this’ を復元します。

‘heap-new’ ( ... class – object  ) objects “heap-new”
   ‘allocate’ し、 クラス CLASS のオブジェクトを初期化します。

‘implementation’ ( interface –  ) objects “implementation”
   現在のクラスは指定のインターフェイス INTERFACE を実装します。 つまり
、 あなたは、 現在のクラス内とその子孫のクラス内で、 指定のインターフェ
イス INTERFACE の全てのセレクターを使用できます。

‘init-object’ ( ... class object –  ) objects “init-object”
   メモリのチャンク OBJECT (アドレス)をクラス CLASS のオブジェクトのため
に初期化します。 それから ‘construct’ を実行します(訳注: CLASS の
‘construct’ 用のスタック項目も必要な事に注意。 6.24.3.2 Basic
‘objects.fs’ Usage の例 circle で言えば n-radius が必要で(my-circle2 と
いうメモリ領域をクラス・オブジェクトにするとして、) ‘50 circle
my-circle-2 init-object’ としなければならない)

‘inst-value’ ( align1 offset1 "name" – align2 offset2  ) objects “inst-value”
   ALIGN2 OFFSET2 は W のサイズだけ足し込んだ値です。 NAME の実行時: ‘--
w’ W は、‘this’ オブジェクトの NAME フィールドの値です。

‘inst-var’ ( align1 offset1 align size "name" – align2 offset2  ) objects “inst-var”
   ADDR は、‘this’ オブジェクトのフィールド NAME のアドレスです。 NAME の
実行時: ‘-- addr’

‘interface’ ( –  ) objects “interface”
   インターフェイス定義を開始します。

‘m:’ ( – xt colon-sys; run-time: object –  ) objects “m:”
   メソッド定義を開始します。 定義中は指定の OBJECT が新しい ‘this’ にな
ります。

‘:m’ ( "name" – xt; run-time: object –  ) objects “:m”
   名前付きメソッド定義を開始します。 定義中は指定の OBJECT が新しい
‘this’ になります。 ‘;m’ で終わらせる必要があります。

‘;m’ ( colon-sys –; run-time: –  ) objects “;m”
   メソッド定義を終了します。 古い ‘this’ を復元します。

‘method’ ( xt "name" –  ) objects “method”
   セレクター NAME を作成し、XT を現在のクラスのメソッドにします。
‘name’ の実行時: ‘... object -- ...’

‘methods’ ( class –  ) objects “methods”
   CLASS を現在のクラスにします。 これは、 セレクターをオーバーライドす
るメソッドを定義するために使用することを目的としています。 新しいフィー
ルドやセレクターを定義することはできません。

‘object’ ( – class  ) objects “object”
   すべてのクラスの祖先。

‘overrides’ ( xt "selector" –  ) objects “overrides”
   現在のクラスの SELECTOR のデフォルト・メソッドを XT に置き換えます。
‘overrides’ はインターフェイス定義中に使用してはいけません。

‘[parent]’ ( compile-time: "selector" – ; run-time: ... object – ...  ) objects “[parent]”
   現在のクラスの親の SELECTOR のメソッドをコンパイルします。

‘print’ ( object –  ) objects “print”
   オブジェクトを出力します。 指定のクラス OBJECT のメソッドは、 オブジ
ェクトのアドレスとそのクラスのアドレスを出力します。

‘protected’ ( –  ) objects “protected”
   現在のクラスのワードリストをコンパイル・ワードリスト(the compilation
wordlist)にセットします

‘public’ ( –  ) objects “public”
   実際にコンパイル・ワードリスト(the compilation wordlist)を変更した最
後の ‘protected’ より前に有効だったコンパイル・ワードリストを復元します
。

‘selector’ ( "name" –  ) objects “selector”
   現在のクラスとその子孫のセレクター NAME を作成します。 ‘overrides’ を
使用して、 現在のクラスのセレクターのメソッドを設定できます。 NAME の実
行時: ‘... object -- ...’

‘this’ ( – object  ) objects “this”
   現在のメソッドの受信オブジェクト(receiving object)(別名アクティブ・オ
ブジェクト)。

‘<to-inst>’ ( w xt –  ) objects “<to-inst>”
   実行トークン XT を inst-value で作成したフィールドとみなしてフィール
ド・オフセットを取得し、 現在のオブジェクト(this)の当該フィールドに指定
の値 W を格納します。

‘[to-inst]’ ( compile-time: "name" – ; run-time: w –  ) objects “[to-inst]”
   W を ‘this’ オブジェクトの NAME フィールドに格納します。

‘to-this’ ( object –  ) objects “to-this”
   ‘this’ を設定します(内部的に使用されるものですが、 デバッグ時に役立ち
ます)。

‘xt-new’ ( ... class xt – object  ) objects “xt-new”
   ‘xt ( align size -- addr )’ を使用して何らかの形で領域を確保し、 そこ
に指定のクラス class の新しいオブジェクトを作成(‘init-object’)します。


File: gforth.info,  Node: OOF,  Next: Mini-OOF,  Prev: Objects,  Up: Object-oriented Forth

6.24.4 The ‘oof.fs’ model
-------------------------

このセクションでは、 ‘oof.fs’ パッケージについて説明します。

   このセクションで説明するパッケージは、 1991 年以来 bigFORTH で使用さ
れており、 新薬作成に使用されるクロマトグラフィー・システムと、グラフィ
ック・ユーザー・インターフェイス・ライブラリ (MINOS) という 2 つの大きな
アプリケーションに使用されています。

   ‘oof.fs’ の説明 (ドイツ語) は、‘Vierte Dimension’ 10(2), 1994 に掲載
された Bernd Paysan による ‘Object Oriented bigFORTH’ にあります。

* Menu:

* Properties of the OOF model::
* Basic OOF Usage::
* The OOF base class::
* Class Declaration::
* Class Implementation::


File: gforth.info,  Node: Properties of the OOF model,  Next: Basic OOF Usage,  Prev: OOF,  Up: OOF

6.24.4.1 Properties of the ‘oof.fs’ model
.........................................

   • このモデルは、 オブジェクト指向プログラミングと情報隠蔽を組み合わせ
     たものです。 クラス指向のスコープが提供されるため、 スコープが必要
     な大規模なアプリケーションを作成するのに役立ちます。

   • 名前付きオブジェクトや、 オブジェクト・ポインターや、 オブジェクト
     配列を作成できます。 セレクターの呼び出しには「オブジェクト・セレク
     ター」構文が使用されます。 スタック上のオブジェクトやセレクターに対
     するセレクターの呼び出しはあまり便利ではありませんが、 可能です。

   • セレクターの呼び出しと、 アクティブ・オブジェクトのインスタンス変数
     の使用は、 どちらもアクティブ・オブジェクトを使用するため、 簡単で
     す。

   • 遅延結び付け(Late binding)は効率的で使いやすいです。

   • ステートスマート・オブジェクトはセレクターをパースします。 ただし、
     (パース) セレクター ‘postpone’ とセレクター ‘'’ を使用して拡張性が
     提供されます。

   • gforth 固有ではなく、 標準 Forth 用の実装が利用可能です。


File: gforth.info,  Node: Basic OOF Usage,  Next: The OOF base class,  Prev: Properties of the OOF model,  Up: OOF

6.24.4.2 Basic ‘oof.fs’ Usage
.............................

このセクションでは、 ‘objects’ (*note Basic Objects Usage::) と同じ例を
使用します。

   以下のようにして graphical オブジェクト(図形オブジェクト)のクラスを定
義できます:

     object class graphical \ "object" is the parent class
       method draw ( x y -- )
     class;

   このコードは、 ‘draw’ 操作を持つクラス ‘graphical’ を定義します。 任
意の ‘graphical’ オブジェクトに対して ‘draw’ 操作を実行できます。例:

     100 100 t-rex draw

ここで、 ‘t-rex’ (訳注: 恐竜ティラノサウルス) はオブジェクトまたはオブジ
ェクト・ポインターであり、 たとえば次のように作成されます: ‘graphical :
t-rex’

   graphical オブジェクトを作成するにはどうすればよいでしょうか？ 現在の
定義では、 有用な graphical オブジェクトを作成できません。 クラス
‘graphical’ は graphical オブジェクト一般を記述しますが、 具体的な
graphical オブジェクト・タイプを記述しません(C++ ユーザーはこれを「抽象
クラス」(abstract class)と呼びます)。 たとえば、 クラス ‘graphical’ には
セレクター ‘draw’ のメソッドがありません。

   具体的な graphical オブジェクトのために、 クラス ‘graphical’ の子クラ
スを定義します。 例:

     graphical class circle \ "graphical" is the parent class
       cell var circle-radius
     how:
       : draw ( x y -- )
         circle-radius @ draw-circle ;

       : init ( n-radius -- )
         circle-radius ! ;
     class;

   ここでは、 クラス ‘circle’ を ‘graphical’ の子として、 フィールド
‘circle-radius’ とともに定義します。 セレクター ‘draw’ および ‘init’ の
新しいメソッドが定義されています(‘init’ は、 ‘graphical’ の親クラスであ
る ‘object’ で定義されています)。

   いまや、 以下のコマンドを使用してディクショナリ内に circle を作成でき
ます:

     50 circle : my-circle

‘:’ は ‘init’ を呼び出し、 フィールド ‘circle-radius’ を 50 で初期化しま
す。 以下のようにして、この新しい circle を (100,100) に描画できます:

     100 100 my-circle draw

   注意: セレクターを呼び出すことができるのは、 受信オブジェクトが、 セ
レクターが定義されたクラス、またはその子孫の 1 つに属している場合のみで
す。 たとえば、 ‘draw’ は、 ‘graphical’ またはその子孫(例: ‘circle’)に属
するオブジェクトに対してのみ呼び出すことができます。 このクラス階層で定
義されていないセレクターを呼び出そうとすると、 スコープ・メカニズムがチ
ェックするため、 コンパイル時にエラーが発生します。


File: gforth.info,  Node: The OOF base class,  Next: Class Declaration,  Prev: Basic OOF Usage,  Up: OOF

6.24.4.3 The ‘oof.fs’ base class
................................

クラスを定義するときは、 親クラスを指定する必要があります。 では、 クラ
スの定義はどのように始めればよいのでしょうか？ 最初から使用できるクラス
は 1 つあります。 それは ‘object’ です。 これをすべてのクラスの祖先とし
て使用する必要があります。 これは親が存在しない唯一のクラスです。 クラス
はインスタンス変数を持たない点を除けばオブジェクトでもあります。 クラス
の継承や定義の変更などのクラス操作は、 クラス ‘object’ のセレクターを通
じて処理されます。

   ‘object’ はいくつかのセレクターを提供します:

   • サブクラス化には ‘class’ を、 後で定義を追加するには ‘settings’ を
     、 型情報を取得するには ‘class?’ (現在のクラスはスタックに渡された
     クラスのサブクラスかどうか？ を調べる)。

     ‘object-class’ ( "name" –  ) oof “object-class”

     ‘object-definitions’ ( –  ) oof “object-definitions”

     ‘object-class?’ ( o – flag  ) oof “class-query”

   • ‘init’ と ‘dispose’ をオブジェクトのコンストラクターとデストラクタ
     ーとして使用します。 ‘init’ はオブジェクトのメモリが割り当て後に呼
     び出されますが、 ‘dispose’ は割り当て解除処理も行います。 したがっ
     て、 ‘dispose’ を再定義する場合は、 ‘super destroy’ を使用して親の
     destroy も呼び出す必要があります。

     ‘object-init’ ( ... –  ) oof “object-init”

     ‘object-dispose’ ( –  ) oof “object-dispose”

   • ‘new’ や ‘new[]’ や ‘:’ や ‘ptr’ や ‘asptr’ や ‘[]’ を使用して、 名
     前付きおよび名前なしで、 オブジェクトとオブジェクト配列またはオブジ
     ェクト・ポインタ を作成します。

     ‘object-new’ ( – o  ) oof “object-new”

     ‘object-new[]’ ( n – o  ) oof “new-array”

     ‘object-:’ ( "name" –  ) oof “define”

     ‘object-ptr’ ( "name" –  ) oof “object-ptr”

     ‘object-asptr’ ( o "name" –  ) oof “object-asptr”

     ‘object-[]’ ( n "name" –  ) oof “array”

   • ‘::’ と ‘super’ は明示的なスコープ設定に使用します。 明示的なスコー
     プ指定は、 スーパークラスまたは同じインスタンス変数セットを持つクラ
     スに対してのみ使用する必要があります。 明示的にスコープ指定されたセ
     レクターは早期結び付け(early binding)を使用します。

     ‘object-::’ ( "name" –  ) oof “scope”

     ‘object-super’ ( "name" –  ) oof “object-super”

   • ‘self’ でオブジェクト自身のアドレスを取得します

     ‘object-self’ ( – o  ) oof “object-self”

   • ‘bind’ や ‘bound’ や ‘link’ や ‘is’ を使用して、 オブジェクト・ポイ
     ンターと instance defers を割り当てます。

     ‘object-bind’ ( o "name" –  ) oof “object-bind”

     ‘object-bound’ ( class addr "name" –  ) oof “object-bound”

     ‘object-link’ ( "name" – class addr  ) oof “object-link”

     ‘object-is’ ( xt "name" –  ) oof “object-is”

   • ‘'’ はセレクター・トークンを取得し、 ‘send’ はスタックからセレクタ
     ーを呼び出し、 ‘postpone’ はセレクター呼び出しコードを生成します。

     ‘object-'’ ( "name" – xt  ) oof “tick”

     ‘object-postpone’ ( "name" –  ) oof “object-postpone”

   • ‘with’ と ‘endwith’ は、 スタックから得たオブジェクトをアクティブ・
     オブジェクトにし、 そのオブジェクトのスコープを有効にします。
     ‘with’ と ‘endwith’ を使用すると、 ステートスマート・オブジェクトに
     トラップされることなく、 セレクターを ‘postpone’ してコードを作成す
     ることもできます。

     ‘object-with’ ( o –  ) oof “object-with”

     ‘object-endwith’ ( –  ) oof “object-endwith”


File: gforth.info,  Node: Class Declaration,  Next: Class Implementation,  Prev: The OOF base class,  Up: OOF

6.24.4.4 Class Declaration
..........................

   • インスタンス変数

     ‘var’ ( size –  ) oof “var”
     インスタンス変数を作成する

   • オブジェクト・ポインタ

     ‘ptr’ ( –  ) oof “ptr”
     インスタンス・ポインターを作成します

     ‘asptr’ ( class –  ) oof “asptr”
     インスタンス・ポインターへのエイリアスを作成し、 別のクラスにキャス
     ト(cast)します。

   • Instance defers

     ‘defer’ ( –  ) oof “defer”
     instance defer を作成します

   • メソッド・セレクター

     ‘early’ ( –  ) oof “early”
     早期結び付け(early binding)用のメソッド・セレクターを作成します。

     ‘method’ ( –  ) oof “method”
     メソッド・セレクターを作成します。

   • クラス変数(class-wide variables)

     ‘static’ ( –  ) oof “static”
     クラス全体のセル・サイズの変数を作成します。

   • 宣言部分を終わらせる

     ‘how:’ ( –  ) oof “how-to”
     宣言を終わらせ、 実装部分を開始する

     ‘class;’ ( –  ) oof “end-class”
     クラス宣言または実装の終わり


File: gforth.info,  Node: Class Implementation,  Prev: Class Declaration,  Up: OOF

6.24.4.5 Class Implementation
.............................


File: gforth.info,  Node: Mini-OOF,  Next: Mini-OOF2,  Prev: OOF,  Up: Object-oriented Forth

6.24.5 The ‘mini-oof.fs’ model
------------------------------

Gforth の 3 番目のオブジェクト指向 Forth パッケージは 12行野郎
(12-liner)です。 ‘objects.fs’ 構文と ‘oof.fs’ 構文を組み合わせて使用​​し
、 機能を最小限に抑えています。 これは、Bernd Paysan の comp.lang.forth
への投稿に基づいています。

* Menu:

* Basic Mini-OOF Usage::
* Mini-OOF Example::
* Mini-OOF Implementation::


File: gforth.info,  Node: Basic Mini-OOF Usage,  Next: Mini-OOF Example,  Prev: Mini-OOF,  Up: Mini-OOF

6.24.5.1 Basic ‘mini-oof.fs’ Usage
..................................

基底クラス(base class)(‘class’、 オブジェクト・ポインターに 1 つのセルを
割り当てます) に加えて、 7つのワードがあります。 それは、 メソッドの定義
、 変数の定義、 クラスの定義開始、 クラスの定義終了、 結び付けの解決
(resolve binding)、 オブジェクトの割り当て、 クラス・メソッドのコンパイ
ル、 です。

‘object’ ( – a-addr  ) mini-oof “object”
   OBJECT はすべてのオブジェクトの基底クラス(base class)です。

‘method’ ( m v "name" – m’ v  ) mini-oof “method”
   セレクターを定義します。

‘var’ ( m v size "name" – m v’  ) mini-oof “var”
   SIZE バイトのサイズの変数を定義します。

‘class’ ( class – class selectors vars  ) mini-oof “class”
   クラスの定義を開始します。

‘end-class’ ( class selectors vars "name" –  ) mini-oof “end-class”
   クラスの定義を終了します。

‘defines’ ( xt class "name" –  ) mini-oof “defines”
   XT をクラス CLASS のセレクター NAME に結び付け(bind)します。

‘new’ ( class – o  ) mini-oof “new”
   クラス CLASS の新しい具体化(incarnation)を作成します。

‘::’ ( class "name" –  ) mini-oof “colon-colon”
   クラス CLASS のセレクター NAME のメソッドをコンパイルします (注意: 即
実行ではありません！)。


File: gforth.info,  Node: Mini-OOF Example,  Next: Mini-OOF Implementation,  Prev: Basic Mini-OOF Usage,  Up: Mini-OOF

6.24.5.2 Mini-OOF Example
.........................

短い例で、 このパッケージの使い方を示します。 他の例として button オブジ
ェクト の Mini-OOF バージョンが ‘moof-exm.fs’ にあります。

     object class
       method init
       method draw
     end-class graphical

   このコードは、 ‘draw’ 操作を持つクラス ‘graphical’ を定義します。 任
意の ‘graphical’ オブジェクトに対して ‘draw’ 操作を実行できます。例:

     100 100 t-rex draw

   ここで、 ‘t-rex’ はオブジェクトまたはオブジェクト・ポインターであり、
たとえば次のように作成されます: ‘graphical new Constant t-rex’

   具体的な graphical オブジェクトのために、 クラス ‘graphical’ の子クラ
スを定義します。 例:

     graphical class
       cell var circle-radius
     end-class circle \ "graphical" is the parent class

     :noname ( x y -- )
       circle-radius @ draw-circle ; circle defines draw
     :noname ( r -- )
       circle-radius ! ; circle defines init

   暗黙的な init メソッドはないため、 明示的に定義する必要があります。 オ
ブジェクトの作成コードは明示的に init を呼び出す必要があります。

     circle new Constant my-circle
     50 my-circle init

   すべてのオブジェクトの同じ場所に ‘init’ がある場合、 ‘init’ の自動呼
び出しで名前付きオブジェクトを作成する関数を追加することもできます:

     : new: ( .. o "name" -- )
         new dup Constant init ;
     80 circle new: large-circle

   以下のようにして、 この新しい circle を (100,100) に描画できます:

     100 100 my-circle draw


File: gforth.info,  Node: Mini-OOF Implementation,  Prev: Mini-OOF Example,  Up: Mini-OOF

6.24.5.3 ‘mini-oof.fs’ Implementation
.....................................

遅延結び付け(late binding)を備えたオブジェクト指向システムは通常、 「
vtable」アプローチを使用します。 つまり、 各オブジェクトの最初の変数はテ
ーブルへのポインタであり、 テーブルには関数ポインタとしてメソッドが含ま
れています。 vtable には他の情報も含まれる場合があります。

   まず、 セレクターを宣言しましょう:

     : method ( m v "name" -- m' v ) Create  over , swap cell+ swap
       DOES> ( ... o -- ... ) @ over @ + @ execute ;

   セレクターの宣言中、 セレクターの数とインスタンス変数は(アドレス単位
で)スタック上にあります。 ‘method’ はセレクターを 1 つ作成し、 セレクタ
ー番号をインクリメントします。 セレクターを実行するには、 オブジェクトを
取得し、 vtable ポインターを取得し、 オフセットを追加して、 そこに保存さ
れているメソッド xt を実行します。 実行時、 各セレクターは、 スタック・
パラメーターのTOSとして、 セレクターを呼び出すオブジェクトを受け取り、 パ
ラメーター(オブジェクトを含む)を変更せずに、 適切なメソッドに渡します。

   いまや、 インスタンス変数も宣言しなければなりません

     : var ( m v size "name" -- m v' ) Create  over , +
       DOES> ( o -- addr ) @ + ;

   同様に、 ワードには現在のオフセットを書き込んで作成されます。 インス
タンス変数はさまざまなサイズ(セル、 浮動小数点数、 2倍長整数、 char)にす
ることができるため、 そのサイズを取得してオフセットに追加します。 マシン
にアライメント制限がある場合は、 変数の前に適切な ‘aligned’ または
‘faligned’ を配置して、 変数のオフセットを調整します。 それが size がス
タックのTOSにある理由です。

   開始点(基底オブジェクト)と、 いくつかの糖衣構文も必要です:

     Create object  1 cells , 2 cells ,
     : class ( class -- class selectors vars ) dup 2@ ;

   継承の場合、 新しい派生クラスが宣言されるときに、 親オブジェクトの
vtable をコピーする必要があります。 これにより、 親クラスのすべてのメソ
ッドが提供されますが、 それらはオーバーライドすることもできます。

     : end-class  ( class selectors vars "name" -- )
       Create  here >r , dup , 2 cells ?DO ['] noop , 1 cells +LOOP
       cell+ dup cell+ r> rot @ 2 cells /string move ;

   最初の行は、 ‘noop’ で初期化された vtable を作成します。 2 行目は継承
メカニズムで、 親 vtable から xt 達をコピーします。

   新しいメソッドを定義する方法がまだありませんね。 ここで定義しましょう
:

     : defines ( xt class "name" -- ) ' >body @ + ! ;

   新しいオブジェクトを割り当てるためのワードも必要です:

     : new ( class -- o )  here over @ allot swap over ! ;

   派生クラスが親オブジェクトのメソッドにアクセスしたい場合があります。
Mini-OOF でこれを実現するには 2 つの方法があります: 1 つ目は名前付きのワ
ードを使用する方法で、 2 つ目は親オブジェクトの vtable を検索する方法で
す。

     : :: ( class "name" -- ) ' >body @ + @ compile, ;

   混乱しないためには良い例に勝るものはないので、 以下に例を示します。 ま
ず、 テキストとその位置を格納するテキスト・オブジェクト(‘button’ と呼ば
れます)を宣言しましょう:

     object class
       cell var text
       cell var len
       cell var x
       cell var y
       method init
       method draw
     end-class button

次に、 ‘draw’ と ‘init’ の 2 つのメソッドを実装します:

     :noname ( o -- )
      >r r@ x @ r@ y @ at-xy  r@ text @ r> len @ type ;
      button defines draw
     :noname ( addr u o -- )
      >r 0 r@ x ! 0 r@ y ! r@ len ! r> text ! ;
      button defines init

継承のデモンストレーションとして、 新しいデータや新しいセレクターを持た
ない、 クラス ‘bold-button’ を定義します:

     button class
     end-class bold-button

     : bold   27 emit ." [1m" ;
     : normal 27 emit ." [0m" ;

クラス ‘bold-button’ には ‘button’ とは異なる draw メソッドがありますが
、 新しいメソッドは ‘button’ の draw メソッドに関して定義されています:

     :noname bold [ button :: draw ] normal ; bold-button defines draw

最後に、 2 つのオブジェクトを作成し、セレクターを適用します:

     button new Constant foo
     s" thin foo" foo init
     page
     foo draw
     bold-button new Constant bar
     s" fat bar" bar init
     1 bar y !
     bar draw


File: gforth.info,  Node: Mini-OOF2,  Next: Comparison with other object models,  Prev: Mini-OOF,  Up: Object-oriented Forth

6.24.6 Mini-OOF2
----------------

Mini-OOF2 は多くの点で Mini-OOF とよく似ていますが、 いくつかの点で大き
く異なります。 特に、 Mini-OOF2 には現在のオブジェクト変数(current
object variable)を持ち、 プリミティブの ‘>o’ と ‘o>’ を使用してそのオブ
ジェクト・スタックを操作します。 すべてのメソッド呼び出しとインスタンス
変数へのアクセスは、 現在のオブジェクト(current object)を参照します。

‘>o’ ( c-addr – r:c-old ) new “to-o”
   現在のオブジェクト(current object)を C_ADDR に設定し、 以前の現在のオ
ブジェクトをリターン・スタックにプッシュします。

‘o>’ ( r:c-addr – ) new “o-restore”
   リターン・スタックから以前の現在のオブジェクト(current object)を復元
します

   メソッド呼び出しまたはインスタンス変数アクセスへのオブジェクト・ポイ
ンターの受け渡しを容易にするために、 追加の認識器(recognizer)
‘rec-moof2’ がアクティブ化されます。

‘rec-moof2’ ( addr u – xt translate-moof2 | notfound  ) mini-oof2 “rec-moof2”
   この認識器は非常に単純なドット・パーサ(dot-parser)で、 ‘.SELECTOR’ や
‘.IVAR’ を ‘>o SELECTOR o>’ や ‘>o IVAR o>’ に変換します。

   セレクターにメソッドを割り当てるには、 XT CLASS ‘is’ SELECTOR を使用
するため、 ‘defines’ は必要ありません。 メソッドの早期結び付け(early
binding)には、 ‘[’ CLASS ‘] defers’ SELECTOR が使用され、 ‘::’ は必要あ
りません。


File: gforth.info,  Node: Comparison with other object models,  Prev: Mini-OOF2,  Up: Object-oriented Forth

6.24.7 Comparison with other object models
------------------------------------------

【他のオブジェクト・モデルとの比較】オブジェクト指向の Forth 拡張機能が
数多く提案されています(‘A survey of object-oriented Forths’ (SIGPLAN
Notices, April 1996) by Bradford J. Rodriguez and W. F. S. Poehlman
lists 17)。 このセクションでは、 先程説明した、 よく知られた 2つのモデル
と、 (メソッド・マップの使用に関して)密接に関連した 2 つのモデルとの関係
について議論します。 このセクションでは Andras Zsoter が協力してくれまし
た。

   現在最も人気のあるモデルは Neon モデル(参照: ‘Object-oriented
programming in ANS Forth’ (Forth Dimensions, March 1997)であるようですで
すが、 このモデルには多くの制限があります(1):

   • ‘selector object’ 構文を使用しているため、 スタック上でオブジェクト
     を渡すのが不自然になります。

   • セレクターが入力ストリームを(コンパイル時に)パースする必要がありま
     す。 これにより、 拡張性が低下し、 バグが発見されにくくなります。

   • これにより、 すべてのオブジェクトですべてのセレクターを使用できるよ
     うになり、 インターフェイスが不要になりますが、 効率的な実装を作成
     することが難しくなります。

   もう 1 つのよく知られた出版物は、 ‘Object-Oriented Forth’ (Academic
Press, London, 1987) by Dick Pountain ですが、 遅延結び付け(late
binding)をほとんど扱っていないため、 真のオブジェクト指向プログラミング
に関するモノとは言えません。 代わりに、 Ada (83) のようなモジュラー言語
の特徴である情報隠蔽やオーバーロードなどの機能に焦点を当てています。

   Does late binding have to be slow?  (http://www.forth.org/oopf.html)
(Forth Dimensions 18(1) 1996, pages 31-35)(「遅延結び付けは遅くないとい
けないのか？」) で、 Andras Zsoter は(‘objects.fs’ の ‘this’ のような)ア
クティブ・オブジェクトを多用するモデルについて説明しています。 アクティ
ブ・オブジェクトは、 すべてのフィールドにアクセスするために使用されるだ
けでなく、 すべてのセレクター呼び出しの受信オブジェクトも指定します。 あ
なたは ‘{ ... }’ を使用してアクティブなオブジェクトを明示的に変更する必
要がありますが、 ‘objects.fs’ では ‘m: ... ;m’ で多かれ少なかれ暗黙的に
変更されます。 Zsoter のモデルでは、 受信オブジェクトがすでにアクティブ
なオブジェクトであるため、 メソッドのエントリ・ポイントでのこのような変
更は不要です。 一方、 Zsoter のモデルでは明示的な変更(機能)が絶対に必要
です。 そうしないと、 誰もアクティブ・オブジェクトを変更できなくなるから
です。 このモデルの標準 Forth での実装は、
<http://www.forth.org/oopf.html> から入手できます。

   ‘oof.fs’ モデルは、 (さまざまなワードリストに名前を保持することにより
、)情報の隠蔽とオーバーロードの解決(resolution)をオブジェクト指向プログ
ラミングと組み合わせます。 メソッドのエントリ時にアクティブ・オブジェク
トを暗黙的に設定しますが、 (‘>o...o>’ または ‘with...endwith’ を使用して
、)明示的に変更することもできます。 オーバーロードの解決と早期結び付け
(early binding)のために、 パースと、 ステートスマートなオブジェクトとク
ラスを使用します: オブジェクトまたはクラスはセレクターをパースし、 そこ
からメソッドを決定します。 セレクターがオブジェクトまたはクラスによって
パースされない場合、 Zsoter のモデルのように、 アクティブなオブジェクト
のセレクターへの呼び出し(遅延結び付け;late binding)が実行されます。 フィ
ールドには常にアクティブ・オブジェクトを通じてアクセスします。 このモデ
ルの大きな欠点は、 パースとステート・スマートです。 これにより拡張性が低
下し、微妙なバグが発生する可能性が高くなります。 基本的に、 オブジェクト
やクラスをティック(tick)したり ‘postpone’ したりしない場合にのみ安全です
(Bernd は反対しているが、 著者 (Anton) は納得していない)。

   ‘mini-oof.fs’ モデルは、 ‘objects.fs’ モデルの非常に簡素化されたバー
ジョンに非常に似ていますが、 構文的には ‘objects.fs’ と ‘oof.fs’ モデル
が混合されたものです。 。

   ---------- Footnotes ----------

   (1) この批評の長いバージョンは、Anton Ertl の ‘On Standardizing
Object-Oriented Forth Extensions’ (Forth Dimensions, May 1997) にありま
す。


File: gforth.info,  Node: Regular Expressions,  Next: Programming Tools,  Prev: Object-oriented Forth,  Up: Words

6.25 Regular Expressions
========================

正規表現(regular expression)は、 多くの現代的プログラミング言語で見られ
る、 文字列のパターン・マッチング・アルゴリズムです。 あなたは ‘require
regexp.fs’ を使用して正規表現機能を Gforth に追加できます。

   このパターン・マッチングの古典的な実装はバックトラッキング・アルゴリ
ズムです。 これは、 後方参照などの機能を使用する場合にも必要です。
Gforth は、 パターン・マッチングのためのバックトラッキング・プログラムを
定義する言語(language)を提供することで正規表現を実装します。 基本要素は
制御構造 ‘FORK’ ... ‘JOIN’ です。 これはワード内での前方呼び出しであるた
め、 軽量の試行錯誤制御構造(try and fail control structure)をコーディン
グできます。

‘FORK’ ( compilation – orig ; run-time f –  ) gforth-0.7 “FORK”
   AHEAD のような制御構造: JOIN の後にコードを呼び出します。

‘JOIN’ ( orig –  ) gforth-0.7 “JOIN”
   FORK のための、 THEN のような制御構造

   あなたは、 チェックが失敗した場合に、 フラグと ‘?LEAVE’ を計算するこ
とで、 任意の種類のチェックを自分でプログラムできます。 正規表現コードは
‘((’ と ‘))’ で囲まれています。

‘((’ ( addr u –  ) regexp-pattern “((”
   正規表現ブロックの開始

‘))’ ( – flag  ) regexp-pattern “))”
   正規表現ブロックの終了

   正規表現のパターン・マッチングには要素として文字セットがあるため、 多
くの機能を使用して文字クラス(‘charclass’ と呼ばれる)を作成・変更できます
。 ここでの文字はすべてバイトであるため、 ユニコード文字用には拡張されま
せん。

‘charclass’ ( –  ) regexp-cg “charclass”
   文字クラスを作成します

‘+char’ ( char –  ) regexp-cg “+char”
   現在の文字クラスに char を追加します

‘-char’ ( char –  ) regexp-cg “-char”
   現在の文字クラスから char を削除します

‘..char’ ( start end –  ) regexp-cg “..char”
   char の範囲(start 〜 end)を現在の文字クラスに追加します

‘+chars’ ( addr u –  ) regexp-cg “+chars”
   charの文字列(string)を現在の文字クラスに追加します

‘+class’ ( class –  ) regexp-cg “+class”
   文字クラス CLASS と現在の文字クラスの結合(union)

‘-class’ ( class –  ) regexp-cg “-class”
   現在の文字クラスから、 文字クラス CLASS を抜き取ります(subtract)。

   事前定義された文字クラス(charclasses)とそれらのテストと、 一般的なチ
ェックがあります。 チェックが失敗した場合は、 次に考えられる正規表現の代
替が試行されるか、 または、 ループが終了(leave)します(訳注: 基本的には、
チェックが成功した場合は ADDR を 1文字(char)分進めた ADDR’ を返し、 失敗
した場合はスタックに何も積まずに leave する)。

‘c?’ ( addr class – addr’ ) regexp-pattern “c?”
   文字クラス CLASS にマッチ(ADDR の位置の char が文字クラス CLASS に含
まれているなら ADDR の 1 char 次のアドレスを ADDR‘ に返し、 含まれていな
いなら ‘leave’ する)

‘-c?’ ( addr class – addr’ ) regexp-pattern “-c?”
   文字クラス CLASS 以外にマッチ(ADDR の位置の文字が文字クラス CLASS に
含まれていなければ ADDR の1文字後ろのアドレスを ADDR’ に返し、含まれてい
たら ‘leave’ する)

‘\d’ ( addr – addr’  ) regexp-pattern “\d”
   数字([0-9])にマッチ(指定の ADDR の char が digit かどうか([0-9])しら
べ、 そうなら ADDR の char 分次のアドレスを addr’ に返す。 そうでなけれ
ば ‘leave’ する)

‘\s’ ( addr – addr’  ) regexp-pattern “\s”
   非表示文字(\x00〜\x20)にマッチ(指定の ADDR の char が blanks かどうか
([\x00-\x20])しらべ、 そうなら ADDR の char 分次のアドレスを addr’ に返
す。 そうでなければ ‘leave’ する)

‘.?’ ( addr – addr’  ) regexp-pattern “.?”
   任意の1文字(char)にマッチ(任意の1文字(char)であれば次の文字のアドレス
を addr’ に返します。 そうでなければ leave します)

‘-\d’ ( addr – addr’  ) regexp-pattern “-\d”
   addr の文字が数字で無ければ([^0-9])次の文字のアドレスを addr’ に返し
ます。 そうでなければ leave します。

‘-\s’ ( addr – addr’  ) regexp-pattern “-\s”
   指定の ADDR の char が blanks で無いかどうか([^\x00-\x20])しらべ、 そ
うなら ADDR の char 分次のアドレスを addr’ に返す。 そうでなければ
‘leave’ する

‘`’ ( addr "char" – addr’ ) regexp-pattern “‘”
   指定の文字をチェックします。 ‘` c’ の形で使用し、 ADDR の文字が 文字
c ならば、 次の文字へのアドレスを ADDR’ に返し、そうでなければ leave し
ます。

‘`?’ ( addr "char" – addr | addr’ ) regexp-pattern “‘?”
\ 訳注: ‘`? c’  ADDR の文字が c ならば ADDR をそのまま返す。 c でなければ次の文字へのアドレスを ADDR’ に返す。

‘-`’ ( addr "char" – addr’ ) regexp-pattern “-‘”
\ 訳注: ‘-` c’ ADDR の文字が c でなければ次の文字へのアドレスを ADDR’ に返す。 そうでなければ leave する。
   指定の文字をチェックします。 ‘` c’ の形で使用し、 ADDR の文字が 文字
c ならば、 次の文字へのアドレスを ADDR’ に返し、そうでなければ leave し
ます。

   明示的に文字列の開始と終了、および文字列定数全体をチェックすることも
できます。

‘\^’ ( addr – addr  ) regexp-pattern “\^”
   文字列の開始にマッチ

‘\$’ ( addr – addr  ) regexp-pattern “\$”
   文字列の終了にマッチ

‘str=?’ ( addr1 addr u – addr2  ) regexp-pattern “str=?”
   指定の文字列 addr u にマッチ(等しい)するかどうかチェックします(マッチ
すれば文字列の次のアドレスを addr2 に返します。 マッチしない場合は leave
します)

   doc-=” (原文未記述)

   繰り返される文字セットをチェックするループは、 貪欲(greedy)または非貪
欲(non-greedy)にすることができます。

‘{**’ ( addr – addr addr  ) regexp-pattern “begin-greedy-star”
   貪欲な 0 個以上のパターンの開始

‘**}’ ( sys –  ) regexp-pattern “end-greedy-star”
   貪欲な 0 個以上のパターンの終わり

‘{++’ ( addr – addr addr  ) regexp-pattern “begin-greedy-plus”
   貪欲な 1 つ以上のパターンの開始

‘++}’ ( sys –  ) regexp-pattern “end-greedy-plus”
   貪欲な 1 つ以上のパターンの終わり

‘{*’ ( addr – addr addr  ) regexp-pattern “begin-non-greedy-star”
   非貪欲な 0 個以上のパターンの開始

‘*}’ ( addr addr’ – addr’  ) regexp-pattern “end-non-greedy-star”
   非貪欲な 0 個以上のパターンの終わり

‘{+’ ( addr – addr addr  ) regexp-pattern “begin-non-greedy-plus”
   非貪欲な 1 つ以上のパターンの開始

‘+}’ ( addr addr’ – addr’  ) regexp-pattern “end-non-greedy-plus”
   非貪欲な 1 つ以上のパターンの終わり

   例: 部分文字列の検索は、 実際にはその前にあるものとの非貪欲な一致です
。

‘//’ ( –  ) regexp-pattern “//”
   文字列内を検索(後続のパターンを文字列先頭ではなく文字列中でのマッチに
する)(訳注:
: ([0-9]) ( addr u – ) (( \( \d \) )) IF ."  [" \1 type ."  ]"  ELSE ."
fail" THEN ;
"0123" ([0-9]) [0] ok
"A123" ([0-9]) fail ok
: (//[0-9]) ( addr u – ) (( // \( \d \) )) IF ."  [" \1 type ."  ]"
ELSE ."  fail" THEN ;.
"0123" (//[0-9]) [0] ok
"A123" (//[0-9]) [1] ok
"ABC3" (//[0-9]) [3] ok)

   選択肢(alternative)は以下のように書きます。

‘{{’ ( addr – addr addr  ) regexp-pattern “begin-alternatives”
   選択肢(alternatives)の開始

‘||’ ( addr addr – addr addr  ) regexp-pattern “next-alternative”
   選択肢の区切り文字

‘}}’ ( addr addr – addr  ) regexp-pattern “end-alternatives”
   選択肢の終了

   ‘\1’ ～ ‘\9’ という名前の変数を最大 9 つ使用して、 一致した部分文字列
を参照できます

‘\(’ ( addr – addr  ) regexp-pattern “\(”
   マッチング変数の開始;変数は \\1〜9 として参照されます

‘\)’ ( addr – addr  ) regexp-pattern “\)”
   マッチング変数の終わり

‘\0’ ( – addr u  ) regexp-pattern “\0”
   文字列全体

   もちろん、 あなたは、 見つけたパターンを置換するコードを作成すること
もできます。

‘s>>’ ( addr – addr  ) regexp-replace “s>>”
   検索/置換 の置換パターン領域の開始

‘>>’ ( addr – addr  ) regexp-replace “>>”
   任意の置換コードを開始し、 コードはスタック上の文字列を評価し、 それ
を ‘<<’ に渡します。

‘<<’ ( run-addr addr u – run-addr  ) regexp-replace “<<”
   置換パターン領域の先頭からを、 指定の文字列 ADDR U に置換します

‘<<"’ ( "string<">" –  ) regexp-replace “<<"”
   置換パターン領域の先頭から文字列を STRING に置換します(訳注: 使い方:
‘<<" STRING’ )

‘s//’ ( addr u – ptr  ) regexp-replace “s//”
   検索/置換 ループの開始

‘//s’ ( ptr –  ) regexp-replace “//s”
   検索の終わり

‘//o’ ( ptr addr u – addr’ u’  ) regexp-replace “//o”
   検索/置換 の単一ループの終了

‘//g’ ( ptr addr u – addr’ u’  ) regexp-replace “//g”
   検索/置換 の全てのループの終了

   これらの使用例は ‘test/regexp-test.fs’ にあります。


File: gforth.info,  Node: Programming Tools,  Next: Multitasker,  Prev: Regular Expressions,  Up: Words

6.26 Programming Tools
======================

* Menu:

* Locating source code definitions::  and editing
* Locating uses of a word::  ‘where’.
* Locating exception source::  バックトレースの検証(examing)
* Examining compiled code::  ‘see’ and friends.
* Examining data::           スタック と メモリ
* Forgetting words::         通常、再ロード前に使われます
* Debugging::                トレーサー ‘~~’
                               を適宜挿入することによって
* Assertions::               あなたのプログラムを自己チェックさせます
* Singlestep Debugger::      あなたのプログラムをワート単位で実行します
* Code Coverage::            実行頻度を測定します


File: gforth.info,  Node: Locating source code definitions,  Next: Locating uses of a word,  Prev: Programming Tools,  Up: Programming Tools

6.26.1 Locating source code definitions
---------------------------------------

多くのプログラミング・システムは、 エディターがシステムのハブとなり、 プ
ログラムを構築して実行できる統合開発環境(IDE)として編成されています。 そ
れが必要な場合は、Gforth にもそれがあります(*note Emacs and Gforth::)。

   しかしながら、いくつかの Forth システムには異なる種類の IDE を持って
います: Forth コマンド・ラインが開発環境のハブです。 そこからさまざまな
方法でソースを表示し、 必要に応じてエディターを呼び出すことができます。

   gforth もそのような IDE を実装しています。 gforth は SwiftForth の慣
習をほぼ踏襲していますが、 それ以上の機能を実装しています。

   このアプローチの利点は、 お気に入りのエディターを使用できることです。
環境変数 ‘EDITOR’ をお気に入りのエディターに設定すると、 編集コマンドが
そのエディターを呼び出します。 Gforth はバックグラウンドでいくつかの GUI
エディターを呼び出し(そのため、 Forth セッションは続行するので、 編集を
終了する必要はありません)、 ターミナル上のエディターはフォアグラウンドで
呼び出します(Gforth に認識されないエディターのデフォルトはフォアグラウン
ドです)。 ‘EDITOR’ を設定していない場合、 デフォルトのエディターは ‘vi’
です。

‘locate’ ( "name" –  ) gforth-1.0 “locate”
   ワード name のソース・コードを表示し、 現在位置(current location)をそ
こに設定します。

   doc-xt-locate(原文 未記述)

   「現在位置」(current location)は、 ‘locate’ に加えて、 他の多くのワー
ドによって設定されます。 また、 ファイルのロード中にエラーが発生した場合
、 エラーの場所が現在位置になります。

   多くのワードが現在位置(current location)で機能します:

‘l’ ( –  ) gforth-1.0 “l”
   現在位置(current location)のソースコードの行達を表示します。

‘n’ ( –  ) gforth-1.0 “n”
   現在位置より後ろの行、 または最後の ‘n’ または ‘b’ 出力より後ろの行を
表示します。

‘b’ ( –  ) gforth-1.0 “b”
   現在位置より前の行、 または最後の ‘n’ または ‘b’ 出力より前の行を表示
します。

‘g’ ( –  ) gforth-0.7 “g”
   現在位置、 または最後の ‘n’ または ‘b’ 出力の先頭からエディターに入り
ます。

   以下の値を変更することで、 ‘l’ や ‘n’ や ‘b’ で表示する行数を制御でき
ます:

‘before-locate’ ( – u  ) gforth-1.0 “before-locate”
   現在位置の前に表示される行数(デフォルトは 3)。

‘after-locate’ ( – u  ) gforth-1.0 “after-locate”
   現在位置の後に表示される行数 (デフォルトは 12)。

   最後に、以下を使用すると、 エディターを開いて当該ワードのソース・コー
ドに直接移動できます。

‘edit’ ( "name" –  ) gforth-1.0 “edit”
   "name" の場所でエディターを起動します。

   以下を使用すると、 似た名前のワードの定義を確認できます

‘browse’ ( "subname" –  ) gforth-1.0 “browse”
   (‘mwords’ のように、) subname を名前の一部に含むワードが定義されてい
るすべての場所を表示します(*note Word Lists::)。 その後、 ‘ww’ または
‘nw’ または ‘bw’ (*note Locating uses of a word::) を使用して、 特定の場
所をより詳細に調査できます(訳注: 表示結果各行末尾の数(インデックス)を指
定して、 ‘ww’ で当該の場所の内容を閲覧する、 等)


File: gforth.info,  Node: Locating uses of a word,  Next: Locating exception source,  Prev: Locating source code definitions,  Up: Programming Tools

6.26.2 Locating uses of a word
------------------------------

‘where’ ( "name" –  ) gforth-1.0 “where”
   name が「使用されている」すべての場所を表示します(テキスト・インタプ
リタ時)。 その後、 ‘ww’ または ‘nw’ または ‘bw’ を使用して、 特定の場所
をより詳細に調べられます。 gforth の ‘where’ では name の定義は表示され
ません。 そのためには ‘locate’ を使用してください。

‘ww’ ( u –  ) gforth-1.0 “ww”
   その後の ‘l’ や ‘g’ で閲覧する場所をインデックス u で指定します。 こ
こで、 インデックスは ‘browse’ や ‘where’ で表示した際の行末尾の数字です
。

‘nw’ ( –  ) gforth-1.0 “nw”
   次の ‘l’ または ‘g’ では、 ‘browse’ または ‘where’ の次の行の場所を表
示します。 現在位置(current location)が ‘browse’ や ‘where’ の表示の最後
のモノである場合、 ‘nw’ の後には何も無いです。 現在位置(current
location)がまだ設定されていない時は、 ‘nw’ の後は、 ‘browse’ や ‘where’
の表示の最初のものが現在位置(current location)になります。

‘bw’ ( –  ) gforth-1.0 “bw”
   次の ‘l’ または ‘g’ では、 ‘browse’ または ‘where’ の前の行の場所を表
示します。 現在位置(current location)が ‘browse’ や ‘where’ の表示の最初
のモノである場合、 ‘bw’ の後には何も無いです。 現在位置(current
location)がまだ設定されていない時は、 ‘nw’ の後は、 ‘browse’ や ‘where’
の表示の最後のものが現在位置(current location)になります。

‘gg’ ( –  ) gforth-1.0 “gg”
   このワードの次の ‘ww’ や ‘nw’ や ‘bw’ や ‘bb’ や ‘nb’ や ‘lb’ (ただし
、 ‘locate’ や ‘edit’ や ‘l’ や ‘g’ は除く)は、 その結果を(‘g’ のように
)エディターに流し込みます。 これをこの場限り(one-shot)では無くく永続的に
するには、 ‘gg gg’ を使用します。

‘ll’ ( –  ) gforth-1.0 “ll”
   このワードの次の ‘ww’ や ‘nw’ や ‘bw’ や ‘bb’ や ‘nb’ や ‘lb’ (ただし
、 ‘locate’ や ‘edit’ や ‘l’ や ‘g’ は除く)は(‘l’ のように) Forth システ
ムに表示されます。 これを1回限りではなく永続的にするには、 ‘ll ll’ を使
用します。

‘whereg’ ( "name" –  ) gforth-1.0 “whereg”
   ‘where’ と似ていますが、 出力をエディターに流し込みます。 Emacs では
、コンパイル・モード・コマンド (*note (emacs)Compilation Mode::) を使用
して、 特定の箇所をより詳細に調査できます。

‘short-where’ ( –  ) gforth-1.0 “short-where”
   短いファイル形式を使用するように ‘where’ を設定します(デフォルト)。

‘expand-where’ ( –  ) gforth-1.0 “expand-where”
   完全に拡張されたファイル形式を使用するように ‘where’ を設定します(例
えば、 エディターなどに渡すためです)。

‘prepend-where’ ( –  ) gforth-1.0 “prepend-where”
   ‘where’ を設定してファイルを別の行に表示し、 その後にファイル名のない
‘where’ 行が続きます(SwiftForth 風)。

   ワードの使用状況に関するデータを利用すると、 どのワードが使用されてい
ないのかを表示することもできます:

‘unused-words’ ( –  ) gforth-1.0 “unused-words”
   使用されていないすべてのワードをリストします


File: gforth.info,  Node: Locating exception source,  Next: Examining compiled code,  Prev: Locating uses of a word,  Up: Programming Tools

6.26.3 Locating exception source
--------------------------------

‘tt’ ( u –  ) gforth-1.0 “tt”
\ 訳注: エラー表示時の Backtrace: で表示される番号を指定して、その場所を表示します。

‘nt’ (  –  ) gforth-1.0 “nt”
\ 訳注: ‘tt’ の次の backtrace 行の場所を表示します。

‘bt’ ( –  ) gforth-1.0 “bt”
\ 訳注: ‘tt’ で表示した1行前の backtrace 行の場所を表示します。


File: gforth.info,  Node: Examining compiled code,  Next: Examining data,  Prev: Locating exception source,  Up: Programming Tools

6.26.4 Examining compiled code
------------------------------

そして最後に、 ‘see’ とそのファミリーが、 コンパイル済のコードの表示を行
います。 ソース・コード内の一部の内容は、 コンパイルされたコードには存在
しません(書式設定やコメント等)。 しかし、 これは、 マクロや Gforth の最
適化機能によってどのようなスレッド化コード(threaded code)やネイティブ・
コード(native code)が生成されるかを確認するのに役立ちます。

‘see’ ( "<spaces>name" –  ) tools “see”
   現在の検索順序(search order)を使用して NAME を ‘locate’ します。
‘locate’ できたら、 その定義を表示します。 これは定義を逆コンパイルする
ことで実現されるため、 書式は機械化され、 一部のソース情報(コメントや定
義内のインタプリトされたシーケンスなど)は失われます。

‘xt-see’ ( xt –  ) gforth-0.2 “xt-see”
   xt で表される定義を逆コンパイルします。

‘simple-see’ ( "name" –  ) gforth-0.6 “simple-see”
   コロン定義 name を逆コンパイルして各セルごとに行表示し、 セルの意味を
推測してそれを表示します。

‘xt-simple-see’ ( xt –  ) gforth-1.0 “xt-simple-see”
   ‘simple-see’ のようにコロン定義 xt を逆コンパイルします。

‘simple-see-range’ ( addr1 addr2 –  ) gforth-0.6 “simple-see-range”
   [addr1,addr2) ( addr1 <= and < addr2 )の範囲のコードを ‘simple-see’ の
ように逆コンパイルします

‘see-code’ ( "name" –  ) gforth-0.7 “see-code”
   ‘simple-see’ と似ていますが、 インライン化されたプリミティブの動的ネ
イティブ・コード(dynamic native code)も表示されます。 静的命令融合
(superinstructions)の場合、 最初のプリミティブではなくプリミティブ・シー
ケンスが表示されます(命令融合(superinstructions)の他のプリミティブも表示
されます)。 ネイティブ・コードが生成されるプリミティブの場合、 最初と最
後のレジスタ内のスタック項目の数が表示されます(たとえば、 ‘1->1’ は、 最
初と最後のレジスタに 1 つのスタック項目があることを意味します)。 ネイテ
ィブ・コードを使用した各プリミティブまたは命令融合(superinstructions)に
ついては、 インライン引数とコンポーネント・プリミティブが最初に表示され
、 次にネイティブ・コードが表示されます。

‘xt-see-code’ ( xt –  ) gforth-1.0 “xt-see-code”
   コロン定義 xt を ‘see-code’ のように逆コンパイルします。

‘see-code-range’ ( addr1 addr2 –  ) gforth-0.7 “see-code-range”
   [addr1,addr2) ( addr1 <= and < addr2 )の範囲のコードを ‘see-code’ の
ように逆コンパイルします。

   例として、 以下について考えてみましょう:

     : foo x f@ fsin drop over ;

   この例は特に役に立つわけではありませんが、 さまざまなコード生成の違い
を示しています。 これを AMD64 の ‘gforth-fast’ でコンパイルし、
‘see-code foo’ を使用すると以下の出力が得られます(訳注: OSのコマンドライ
ンから、 ‘gforth’ ではなくて ‘gforth-fast’ で起動する):

     $7FD0CEE8C510 lit f@     1->1
     $7FD0CEE8C518 x
     $7FD0CEE8C520 f@
     7FD0CEB51697:   movsd   [r12],xmm15
     7FD0CEB5169D:   mov     rax,$00[r13]
     7FD0CEB516A1:   sub     r12,$08
     7FD0CEB516A5:   add     r13,$18
     7FD0CEB516A9:   movsd   xmm15,[rax]
     7FD0CEB516AE:   mov     rcx,-$08[r13]
     7FD0CEB516B2:   jmp     ecx
     $7FD0CEE8C528 fsin
     $7FD0CEE8C530 drop    1->0
     7FD0CEB516B4:   add     r13,$08
     $7FD0CEE8C538 over    0->1
     7FD0CEB516B8:   mov     r8,$10[r15]
     7FD0CEB516BC:   add     r13,$08
     $7FD0CEE8C540 ;s    1->1
     7FD0CEB516C0:   mov     r10,[rbx]
     7FD0CEB516C3:   add     rbx,$08
     7FD0CEB516C7:   lea     r13,$08[r10]
     7FD0CEB516CB:   mov     rcx,-$08[r13]
     7FD0CEB516CF:   jmp     ecx

   まず、 コンポーネント ‘lit’ と ‘f@’ を含む静的命令融合
(superinstruction)のスレッド化コード・セルが表示されます。 それは、 レジ
スタ内の 1 つのデータ・スタック項目 (‘1->1’) で始まり・終わります。 )。
これに、‘lit’ の引数 ‘x’ のセルと、 命令融合の ‘f@’ コンポーネントのセル
が続きます。 後者のセルは使用されませんが、 Gforth 内部の理由により存在
します。

   その次に、 命令融合 ‘lit f@’ に対して動的に生成されたネイティブ・コー
ドを表示します。 注意: アドレスを比較するとわかるように、 このネイティブ
・コードはメモリ内のスレッド化コードと混合されていない(not mixed)ことに
注意してください。

   ここに表示されているネイティブ・コードを理解するには、以下のレジスタ
について知っておくべきです:
スレッド化コードの命令ポインタは ‘r13’
データ・スタック・ポインタは ‘r15’
最初(TOS)のデータ・スタック・レジスタは ‘r8’ (データ・スタックのTOS、 つ
まり、 レジスタにデータ・スタック項目が 1 つある場合、 スタックのTOSがそ
こに存在します)
リターン・スタック ポインタは ‘rbx’
FP スタック・ポインタは ‘r12’
FP スタックの先頭(TOS)は ‘xmm15’
注意: レジスタの割り当てはエンジンによって異なるため、 コード表示におい
ては異なるレジスタの割り当てが表示される場合があることに注意してください
。

   ‘lit f@’ の動的ネイティブ・コードは、 ディスパッチ・ジャンプ(dispatch
jump;別名 NEXT)(訳注: 古典的には内部インタプリタへ制御を戻すためのジャン
プ)で終了します。 これは、 定義内の次のワード ‘fsin’ のネイティブ・コー
ドは動的に生成しないためです。

   次に、 ‘fsin’ のスレッド化コード・セルが表示されます。 このワードには
動的に生成されるネイティブ・コードはなく、 ‘see-code’ では静的ネイティブ
・コードは表示されません(‘fsin’ の静的ネイティブ・コードを確認したければ
‘see fsin’)。 ‘gforth-fast’ 内の静的ネイティブ・コードを含むすべてのワー
ドと同様、 データ・スタック表現への影響は ‘1->1’ (‘gforth’ エンジンでは
‘0->0’) です。 しかし、 これは表示されません。

   次に、 ‘drop’ のスレッド化コード・セルが表示されます。 ここで使用され
るネイティブ・コード版のバリエーションは、 レジスタ内の 1 つのデータ・ス
タック項目で始まり、 レジスタ内の 0 個のデータ スタック項目で終わります
(‘1->0’)。 この後に ‘drop’ のこのバリエーションのネイティブ・コードが続
きます。 ここのネイティブ・コードは次のワードのコードに続くため、 ここに
は NEXT はありません。

   次に、 ‘over’ のスレッド化コード・セルと、 その後に ‘0->1’ バリエーシ
ョンで動的に生成されたネイティブ・コードが表示されます。

   最後に、 ‘;s’ のスレッド化されたネイティブ・コード(‘foo’ 内の ‘;’ 用
にコンパイルされたプリミティブ)が表示されます。 ‘;s’ は制御フローを実行
する(制御フローからリターンする)ため、 NEXT で終了する必要があります。


File: gforth.info,  Node: Examining data,  Next: Forgetting words,  Prev: Examining compiled code,  Up: Programming Tools

6.26.5 Examining data and code
------------------------------

以下のワード群は、 スタックを非破壊的に調査します:

‘...’ ( x1 .. xn – x1 .. xn  ) gforth-1.0 “...”
   ‘.s’ のスマート・バージョン

‘.s’ ( –  ) tools “dot-s”
   データ・スタック上の項目の数を表示し、 その後に項目のリストを表示しま
す(ただし、 ‘maxdepth-.s’ で指定された値を超えないようにします)。 右端が
TOS になります。

‘f.s’ ( –  ) gforth-0.2 “f-dot-s”
   浮動小数点スタック上の項目の数を表示し、 その後に項目のリストを表示し
ます(ただし、 ‘maxdepth-.s’ で指定された値を超えないようにします)。 右端
が TOS になります。

‘f.s-precision’ ( – u  ) gforth-1.0 “f.s-precision”
   ‘value’ 型変数です。 u は f.s の出力のフィールド幅です。 他の精度の詳
細はこの値から導出されます。

‘maxdepth-.s’ ( – addr  ) gforth-0.2 “maxdepth-dot-s”
   変数(variable)。 デフォルトは 9 です。 ‘.s’ と ‘f.s’ は最大でその数の
スタック項目を表示します。

   ‘.r’ というワードがありますが、 リターン・戻りスタックは「表示されま
せん」。 これは、 フォーマットされた数値出力に使用されるワードです(*note
Simple numeric output::)。

   以下のワード群は、 スタックの深さを決定したり、スタックをクリアしたり
して、 スタック全体に作用します:

‘depth’ ( – +n  ) core “depth”
   +N は、 +N 自体がスタックに置かれる前にデータ・スタックに置かれていた
項目の数です。

‘fdepth’ ( – +n  ) floating “f-depth”
   データ・スタックに積まれた +n は、 浮動小数点スタック上にある(浮動小
数点)値の現在の数です。

‘clearstack’ ( ... –  ) gforth-0.2 “clear-stack”
   データ・スタックから全ての項目を削除して破棄します(訳注: データ・スタ
ックを空にします)。

‘fclearstack’ ( r0 .. rn –  ) gforth-1.0 “f-clearstack”
   浮動小数点スタックをクリアします

‘clearstacks’ ( ... –  ) gforth-0.7 “clear-stacks”
   データ・スタックと FP スタックを空にします

   以下のワード群はメモリを調べます。

‘?’ ( a-addr –  ) tools “question”
   アドレス A-ADDR の内容を現在の基数(base)で表示します。

‘dump’ ( addr u –  ) tools “dump”
   メモリのアドレス ADDR から始まる U バイトを表示します。 各行には 16 バ
イト分の内容が表示されます。 Gforth がオペレーティング・システム上で実行
されている場合、 任意の場所にアクセスしようとすると、 ‘Invalid memory
address’ エラーが発生する可能性があります。


File: gforth.info,  Node: Forgetting words,  Next: Debugging,  Prev: Examining data,  Up: Programming Tools

6.26.6 Forgetting words
-----------------------

forth は、 ワード達 (および、 その後ろでディクショナリ割り当てられたすべ
ての内容) を LIFO 方式で忘れさすことができます。

‘marker’ ( "<spaces> name" –  ) core-ext “marker”
   name という定義を作成します(マーク(mark)と呼ばれる)。 その実行機能
(execution semantics)は、 それ自体とその後に定義されたすべてのものを削除
します(訳注: 注意: 古典的な forth の ‘forget name’ と異なり、 任意のワー
ド以降を「忘れる」コマンドでは無い事に注意。 あらかじめ ‘marker’ でマー
クした位置でしか「忘れる」事はできない)。

   この機能の最も一般的な使用法は、 プログラム開発時です。 ソース・ファ
イルを変更するときは、 定義されているワードをすべて忘れて、 再度ロードし
ます(ソース・ファイルのロード後に定義されたワードもすべて忘れるので、 そ
れも再ロードする必要があります)。 変数への保存やシステム・ワードの破壊な
どの効果は、 ワードを忘れても元に戻されないことに注意してください。 著者
は、 gforth のようなシステムでは、 起動とコンパイルが十分に速いので、
gforth を終了して再起動する方が、 白紙の状態(clean state)で使えるので便
利だと思います。

   デバッグしているソース・ファイルの先頭で ‘marker’ を使用する例を以下
に示します。 これにより、 そのファイルの定義は二重定義されないようになり
ます。

     [IFDEF] my-code
         my-code
     [ENDIF]

     marker my-code
     init-included-files

     \ .. definitions start here
     \ .
     \ .
     \ end


File: gforth.info,  Node: Debugging,  Next: Assertions,  Prev: Forgetting words,  Up: Programming Tools

6.26.7 Debugging
----------------

編集/コンパイル/リンク/テスト の開発ループが遅い言語では、 デバッグを容
易にするために高度な トレース/ステッピング デバッガが必要になる傾向があ
ります。

   高速コンパイル言語でのより良い(より速い)方法は、 適切に選択した場所に
表示コード(printing code)を追加し、 プログラムを実行してその出力を見て、
問題が発生した箇所を確認し、 バグが見つかるまでさらに表示コード等を追加
することです(訳注: C言語で言うところの printf デバッグすると言っている
)。

   ‘debugs.fs’ で提供される単純なデバッグ支援機能は、 このスタイルのデバ
ッグをサポートすることを目的としています。

   ‘~~’ というワードは、 デバッグ情報(デフォルトではソースの場所とスタッ
クの内容)を出力します。 これは簡単にソース・コードに挿入できます。 Emacs
を使用している場合は、 削除も簡単です(Emacs Forth モードで ‘C-x ~’ を実
行すると、 ‘~~’ を ""(nothing) に query-replace します)。 defer ワード
‘printdebugdata’ と ‘.debugline’ は、 ‘~~’ の出力を制御します。 デフォル
トのソース位置出力形式は Emacs のコンパイル・モードで適切に動作するため
、 ‘C-x `’ を使用してソース・レベルでプログラムをステップ実行できます(ス
テップ実行デバッガーと比較した利点は、 任意の方向にステップ実行でき、 ク
ラッシュが発生した場所や奇妙なデータが発生した箇所を知る事ができるという
ことです)。

‘~~’ ( –  ) gforth-0.2 “tilde-tilde”
   ‘~~’ を記述したソース・コードの場所とスタックの内容を ‘.debugline’ を
使って出力します。

‘printdebugdata’ ( –  ) gforth-0.2 “print-debug-data”

‘.debugline’ ( nfile nline –  ) gforth-0.6 “print-debug-line”
   NFILE NLINE で示されるソース・コードの場所と追加のデバッグ情報を出力
します。 デフォルトの ‘.debugline’ は、 ‘printdebugdata’ を使用して追加
情報を出力します。

‘debug-fid’ ( – file-id  ) gforth-1.0 “File-id”
   デバッグ用の出力先。 デフォルトでは、 当該プロセスの ‘stderr’ です。

   ‘~~’ (およびアサート(assertions))は、 その出現後に同一ファイル内で
marker が実行されると、 通常、 間違ったファイル名を出力します。 ‘~~’ (お
よびアサート(assertions))は、 その出現前に同じファイル内で marker が実行
されると、 ファイル名として「どこか」(somewhere)を出力します。

‘once’ ( –  ) gforth-1.0 “once”
   ‘once’ から THEN までの操作を 1 回だけ だけ実行します(訳注: 1度実行さ
れるとその旨を body に書き込むので、 再度実行するには ‘once’ を含む定義
を「忘れ」(forget)て再度定義(読み込み)する必要がある)

‘~~bt’ ( –  ) gforth-1.0 “~~bt”
   スタック・ダンプとバックトレースを出力

‘~~1bt’ ( –  ) gforth-1.0 “~~1bt”
   スタックダンプとバックトレースを(‘once’と同様) 1 回だけ実行します

‘???’ ( –  ) gforth-0.2 “???”
   デバッグ・シェルを実行します

‘WTF??’ ( –  ) gforth-1.0 “WTF??”
   バックトレースとスタック・ダンプを使用してデバッグ・シェルを実行しま
す

‘!!FIXME!!’ ( –  ) gforth-1.0 “!!FIXME!!”
   決してこの場所に到達してはいけないワード(訳注: -2605 を throw する)

‘replace-word’ ( xt1 xt2 –  ) gforth-1.0 “replace-word”
   xt2 が xt1 を実行するようにします。 両方ともコロン定義である必要があ
ります。(訳注:
: foo ."  foo" ;
: bar ."  bar" ;
foo foo ok
bar bar ok
’ foo ’ bar replace-word ok
foo foo ok
bar foo ok

‘~~Variable’ ( "name" –  ) gforth-1.0 “~~Variable”
   アクセスごとにワッチされる(‘~~’ する)変数(variable を ~~variable に一
時的にリネームする)

‘~~Value’ ( n "name" –  ) gforth-1.0 “~~Value”
   アクセスごとにワッチされる(‘~~’ する) value ( value を 一時的に
~~value にリネームする)

‘+ltrace’ ( –  ) gforth-1.0 “+ltrace”
   行単位のトレースをONにする。

‘-ltrace’ ( –  ) gforth-1.0 “-ltrace”
   行単位のトレースをOFFにする

‘#loc’ ( nline nchar "file" –  ) gforth-1.0 “#loc”
   次のワードの場所を "FILE" の NLINE NCHAR と設定します


File: gforth.info,  Node: Assertions,  Next: Singlestep Debugger,  Prev: Debugging,  Up: Programming Tools

6.26.8 Assertions
-----------------

特にメンテナンス中に無効になる可能性があると仮定する場合(たとえば、 デー
タ構造の特定のフィールドは決してゼロにならない、 等)、 プログラムを自己
チェックするようにすることをお勧めします。 Gforth は、 こ​​の目的のため
に「アサート」(“assertions”)をサポートしています。 それらは以下のように
使用します:

     assert( flag )

   ‘assert(’ と ‘)’ の間のコードは flag を計算する必要があります。 すべ
てが正常な場合は true 、それ以外の場合は false になります。 スタック上の
他のものは何も変更しないでください。 アサートの全体的なスタック効果は ‘(
-- )’ です。 例:

     assert( 1 1 + 2 = ) \ what we learn in school
     assert( dup 0<> ) \ assert that the top of stack is not zero
     assert( false ) \ このコードには決して到達してはならない

   アサートの必要性は、 その時々によって異なります。 デバッグ中はより多
くのチェックが必要ですが、 運用環境では速度をより重視することがあります
。 したがって、アサートをオフにすることができます。 その場合、 つまり、
アサートはコメントになります。 アサートの重要性とそのチェックにかかる時
間に応じて、 一部のアサートをオフにし、 他のアサートをオンにしたほうがよ
い場合があります。 Gforth は、こ​​の目的のためにいくつかのレベルのアサー
トを提供します:

‘assert0(’ ( –  ) gforth-0.2 “assert-zero”
   常にオンにする必要がある重要なアサート。

‘assert1(’ ( –  ) gforth-0.2 “assert-one”
   通常のアサート: デフォルトではオンになっています。

‘assert2(’ ( –  ) gforth-0.2 “assert-two”
   デバッグ用のアサート。

‘assert3(’ ( –  ) gforth-0.2 “assert-three”
   通常のデバッグでは有効にしたくないであろう遅いアサート。 主に徹底的な
チェックを行うためにオンにします。

‘assert(’ ( –  ) gforth-0.2 “assert(”
   ‘assert1(’ と同等です

‘)’ ( –  ) gforth-0.2 “close-paren”
   アサートを終了します。 汎用の終端なので、 他の同様の目的でも使用され
ます

   変数 ‘assert-level’ は、オンにする最高のアサートを指定します。 つまり
、デフォルトの ‘assert-level’ の 1 では、 ‘assert0(’ および ‘assert1(’ は
チェックを実行しますが、 ‘assert2(’ および ‘assert3(’) はコメントとして
扱われます。

   ‘assert-level’ の値は、 実行時ではなくコンパイル時に評価されます。 し
たがって、 実行時にアサートをオンまたはオフにすることはできません。 あな
たはコードをコンパイルする前に ‘assert-level’ を適切に設定する必要があり
ます。 異なるコード部分を異なる ‘assert-level’ でコンパイルできます(例:
信頼に足るライブラリはレベル 1 で、 新しく作成されたコードはレベル 3 な
ど)。

‘assert-level’ ( – a-addr  ) gforth-0.2 “assert-level”
   変数(variable)。 指定のレベルを超えるすべてのアサートはオフになります
。

   アサートが失敗すると、 Emacs のコンパイル・モードと互換性のあるメッセ
ージが生成され、 実行が中止(abort)されます(現在は ‘ABORT"’ を使用します
。 あなたの興味があれば、 特別な throw コードを導入します。 ただし、 特
定の条件をキャッチ(‘catch’)したい場合は、 おそらくアサートよりも ‘throw’
を使用する方が適切です)。

   アサート (および ‘~~’) の出現後に同じファイル内で marker が実行される
と、 通常は間違ったファイル名が出力されます。 アサート (および ‘~~’) の
出現前に同じファイル内で marker が実行された場合、 ファイル名として「ど
れか」(somewhere)が出力されます。

   これらのアサート・ワードの標準 Forth での定義は、 ‘compat/assert.fs’
で提供されます。


File: gforth.info,  Node: Singlestep Debugger,  Next: Code Coverage,  Prev: Assertions,  Up: Programming Tools

6.26.9 Singlestep Debugger
--------------------------

シングルステップ・デバッガーは、 ‘gforth-itc’ エンジンでのみ動作します
(訳注: OSコマンドラインから gforth ではなくて gforth-itc で起動する)。

   新しいワードを作成するとき、 それが正しく動作するかどうかを確認する必
要があることがよくあります。 これを行うには、‘dbg badword’ と入力します
。 デバッグ・セッションは以下のようになります:

     : badword 0 DO i . LOOP ;  ok
     2 dbg badword
     : badword
     Scanning code...

     Nesting debugger ready!

     400D4738  8049BC4 0              -> [ 2 ] 00002 00000
     400D4740  8049F68 DO             -> [ 0 ]
     400D4744  804A0C8 i              -> [ 1 ] 00000
     400D4748 400C5E60 .              -> 0 [ 0 ]
     400D474C  8049D0C LOOP           -> [ 0 ]
     400D4744  804A0C8 i              -> [ 1 ] 00001
     400D4748 400C5E60 .              -> 1 [ 0 ]
     400D474C  8049D0C LOOP           -> [ 0 ]
     400D4758  804B384 ;              ->  ok

   各行が 1 ステップです。 次のワードを実行して表示するには、 常に
Return キーを押す必要があります。 次のワード全体を実行したくない場合は、
‘nest’ に対して ‘n’ と入力する必要があります。 利用可能なキーの概要は以
下のとおりです:

<RET>
     Next; 次のワードを実行する(execute)。

n
     Nest; 次のワードまで 1 ステップずつ辿る。

u
     Unnest; デバッグを停止し(stop)、残りのワードを実行します(execute)。
     ネスト(nest)機能でこのワードに到達した場合、 それを呼び出したワード
     でデバッグを続行します。

d
     Done; デバッグを停止し(stop)、 残りを実行します(execute)。

s
     Stop; 直ちに終了(abort)します。

   このメカニズムを使用して大規模なアプリケーションをデバッグすることは
、 あなたが関心のある部分が始まる前にプログラム内に非常に深くネストする
必要があるため、 非常に困難です。 これにはとても時間がかかります。

   これをより直接的に行うには、 ‘BREAK:’ コマンドをあなたのソース・コー
ドに追加します。 プログラムの実行が ‘BREAK:’ に達すると、 シングル・ステ
ップ・デバッガーが呼び出され、 上記すべての機能が利用できるようになりま
す。

   デバッグする部分が複数ある場合、 プログラムが現在どこで停止しているか
を把握できると便利です。 これを行うには、 ‘BREAK" string"’ コマンドを使
用します。 これは ‘BREAK:’ と同様に動作しますが、 「ブレークポイント」に
到達したときに文字列が出力される点が異なります。

‘dbg’ ( "name" –  ) gforth-0.2 “dbg”

‘break:’ ( –  ) gforth-0.4 “break:”

‘break"’ ( ’ccc"’ –  ) gforth-0.4 “break"”


File: gforth.info,  Node: Code Coverage,  Prev: Singlestep Debugger,  Up: Programming Tools

6.26.10 Code Coverage and Execution Frequency
---------------------------------------------

あなたのコードに対して広範なテスト(extensive tests)を実行する場合、 その
テストがコードのすべての部分を実行するかどうかを確認する必要が生じること
がよくあります。 これを(テスト)カバレッジと呼びます。 ファイル
‘coverage.fs’ には、 カバレッジと実行頻度を測定するためのツールが含まれ
ています(訳注: gforth に組み込まれて無いので使う時は ‘coverage.fs’ をロ
ードしてください)。

   コード・カバレッジは、 ‘coverage.fs’ の後にロードされるすべての基本ブ
ロック(逐次実行のコード・シーケンス)にカウント(計数)コードを挿入します。
コードが実行されるたびに、その基本ブロックのカウンター(計数器)がインクリ
メントされます。 後で、これらの基本ブロックに挿入されたカウント(計数)を
含むソース・ファイルを表示できます。

‘nocov[’ ( –  ) gforth-1.0 “nocov-bracket”
   (即実行ワード) 一時的にカバレッジをオフにすることを開始。

‘]nocov’ ( –  ) gforth-1.0 “bracket-nocov”
   (即実行ワード) 一時的にカバレッジをオフにすることを終了。

‘coverage?’ ( – f  ) gforth-internal “coverage?”
   Value: カバレッジ・チェックの オン/オフ

‘cov+’ ( –  ) gforth-experimental “cov+”
   (即実行ワード) ここ(here)にカバレッジ・カウンターを配置します。

‘?cov+’ ( flag – flag  ) gforth-experimental “?cov+”
   (即実行ワード) フラグ(flag)のカバレッジ・カウンター。 カバレッジの出
力では、 ‘?cov’ の後ろに 3 つの数字が表示されます。 1 つ目はスタックの最
上位が 0 以外だった実行の数です。 2 番目は、 ゼロだった場合の実行数です
。 3 番目は実行の合計数です。

‘.coverage’ ( –  ) gforth-experimental “.coverage”
   コードを実行頻度(execution frequencies)とともに表示します。

‘annotate-cov’ ( –  ) gforth-experimental “annotate-cov”
   カバレッジ情報を含むファイルごとに、 実行頻度(execution frequencies)が
挿入された ‘.cov’ ファイルを作成します。 最初に ‘bw-cover’ を使用するこ
とをお勧めします(デフォルトの ‘color-cover’ を使用すると、 ファイル内に
エスケープ シーケンスが含まれます)。

‘cov%’ ( –  ) gforth-experimental “cov-percent”
   ‘coverage.fs’ の後でロードされ、 少なくとも 1 回実行された基本ブロッ
クの割合を出力します。

‘.cover-raw’ ( –  ) gforth-experimental “.cover-raw”
   生の実行カウントを出力します。

   デフォルトでは、 カウント(計数)は(ANSI エスケープ・シーケンスを使用し
て、)カラーで表示されますが、 ‘bw-cover’ を使用すると、 エスケープ・シー
ケンスを使用せずに括弧で囲まれた形式でカウントを表示できます。

‘bw-cover’ ( –  ) gforth-1.0 “bw-cover”
   実行カウントを(カラー表示ではなく)括弧内に出力します(ソース・コード互
換)(訳注: つまり forth のコメントとして出力する。出力をそのまま forth の
ソース・コードとして利用可能)。

‘color-cover’ ( –  ) gforth-1.0 “color-cover”
   実行カウントをカラーで表示します(デフォルト)。

   カバレッジ・カウンター(計数器)をバイナリ形式で保存および再ロードして
、 複数のテスト実行にわたるカバレッジ・カウンターを集計できます。

‘save-cov’ ( –  ) gforth-experimental “save-cov”
   カバレッジ・カウンターを保存します。

‘load-cov’ ( –  ) gforth-experimental “load-cov”
   カバレッジ・カウンターをロードします。


File: gforth.info,  Node: Multitasker,  Next: C Interface,  Prev: Programming Tools,  Up: Words

6.27 Multitasker
================

* Menu:

* Pthreads::                 ネイティブ Unix 用マルチタスカー
* Cilk::                     Cilk風の spawn+sync 実装

Gforth は 2 つのマルチタスカーを提供します。 1 つは従来の協調的なラウン
ドロビン・マルチタスカー(cooperative round-robin multitasker)で、 もう 1
つはマルチコア・マシン上で複数のスレッドを同時に実行できる pthread ベー
スのマルチタスカーです。 将来、 Forth マルチタスカーの標準化により、 そ
の意味は変更せずにワードの名前が変更される可能性が高いため、 pthread ベ
ースのマルチタスカーは現在、 実験的な機能としてマークされています。


File: gforth.info,  Node: Pthreads,  Next: Cilk,  Prev: Multitasker,  Up: Multitasker

6.27.1 Pthreads
---------------

pthred 、 つまり posix スレッドは、 複数のコア上で並行実行することも、 1
つのコア上でプリエンプティブ・マルチタスクで実行することもできます。 た
だし、 以下のワード群の多くは、 従来の協調マルチタスク(traditional
cooperative multi-tasker)の場合と同一です。

   さらに、 一度に 1 つのタスクのみが何かを変更することを確認したり、 タ
スク間のコミュニケーションに使用したりするためのワード群もあります。
‘pause’ の呼び出し間でトランザクション(取引)を実行する協調マルチタスク
(cooperative-multitasking)はこの環境では機能しないため、 これらのワード
群はプリエンプティブ・マルチタスクおよびマルチコア・マルチタスクで必要な
ものです。

* Menu:

* Basic multi-tasking::
* Task-local data::
* Semaphores::
* Hardware operations for multi-tasking::
* Message queues::


File: gforth.info,  Node: Basic multi-tasking,  Next: Task-local data,  Prev: Pthreads,  Up: Pthreads

6.27.1.1 Basic multi-tasking
............................

タスクは ‘newtask’ または ‘newtask4’ を使用して、 指定された量のスタック
領域(すべて同じ、 または、 データ・スタックとリターン・スタックと FP ス
タックとローカル変数スタックそれぞれのサイズを指定)で作成できます。

‘newtask’ ( stacksize – task  ) gforth-experimental “newtask”
   タスク(taskを作成します。 データ・スタックとリターン・スタックと FP ス
タックとローカル変数スタックのサイズは全て同じにします(stacksize)(訳注:
スタックごとに個別サイズ指定したい時は ‘newtask4’ を使用してください)。

‘task’ ( ustacksize "name" –  ) gforth-experimental “task”
   タスク name を作成します。 各スタック(データ・スタック、 リターン・ス
タック、 FP スタック、 ローカル変数スタック) サイズは ustacksize です。
実行時: ( – task )

‘newtask4’ ( u-data u-return u-fp u-locals – task  ) gforth-experimental “newtask4”
   データ・スタック・サイズ u-data、 リターン・スタック・サイズ
u-return、 FP スタック・サイズ u-fp、 ローカル変数スタック・サイズ
u-locals で task を作成します。

   あなたが、 タスクにどのスタック・サイズを使用すればよいかわからない場
合は、 メイン・タスクのサイズを流用できます:

‘stacksize’ ( – u  ) gforth-experimental “stacksize”
   u はメイン・タスクのデータ・スタックサイズです。

‘stacksize4’ ( – u-data u-return u-fp u-locals  ) gforth-experimental “stacksize4”
   メイン・タスクのデータ・スタック・サイズと、 リターン・スタック・サイ
ズと、 FP スタック・サイズと、 ローカル変数スタックサイズを、 プッシュし
ます。

   タスクは非アクティブ状態(inactive state)で作成されます。 実行するには
、 以下のいずれかのワードを使用してアクティブ化(activate)する必要があり
ます:

‘initiate’ ( xt task –  ) gforth-experimental “initiate”
   task に xt を execute させます。 xt から戻ると、 タスクは自動的に終了
します(VFX 互換)。 ワンタイム実行可能クロージャ(one-time executable
closures)を使用して、 任意のパラメータをタスクに渡せます。

   以下の古い(legacy)ワード、 ‘activate’ と ‘pass’ は、 ‘initiate’ と同
じ機能を提供しますが、 インターフェイスが異なります: ‘does>’ と同様に、
含まれるコロン定義が 2 つの部分に分割されます: ‘activate’/‘pass’ より前
の部分はタスクをアクティブ化する部分で実行され、 タスクをアクティブ化し
た後に呼び出し元に戻ります。 ‘activate’/‘pass’ より後の部分は、 アクティ
ブ化されたターゲット・タスク内で実行されます。

‘activate’ ( run-time nest-sys1 task –  ) gforth-experimental “activate”
   指定のタスク(task)に ‘activate’ のより後ろにあるコードを実行させ、
‘activate’ を含むワードの呼び出し元に戻ります。 タスクが ‘activate’ の後
ろにあるコードから戻ると、 タスク自体が終了します。

‘pass’ ( x1 .. xn n task –  ) gforth-experimental “pass”
   現在のタスクのデータ・スタックから x1 ..  xn n を取り出し、 x1 ..  xn
を task のデータ・スタックにプッシュします。 task に ‘pass’ の後ろのコー
ドを実行させ、 ‘pass’ を含むワードの呼び出し元に戻ります。 タスクが
‘pass’ の後ろにあるコードから戻ると、 タスク自体が終了します。

   作成とアクティブ化(activation)をワン・ステップで行うこともできます:

‘execute-task’ ( xt – task  ) gforth-experimental “execute-task”
   メイン・タスクと同じスタック・サイズで新しいタスク TASK を作成します
。 task に xt を execute させます。 xt から戻ると、 タスクは自動的に終了
します。

   タスクは最後まで実行して終了する以外に、 ‘kill-task’ を使用してタスク
自身を終了することもできます。 他のタスクは ‘kill’ で終了できます。

‘kill-task’ ( –  ) gforth-experimental “kill-task”
   現在のタスクを終了(terminate)します。

‘kill’ ( task –  ) gforth-experimental “kill”
   指定のタスク(task)を終了(terminate)します。

   タスク自体を一時的に停止(temporarily stop)したり、 タスクを停止(be
stopped)したりすることもできます:

‘halt’ ( task –  ) gforth-experimental “halt”
   タスクを停止(stop)する

‘stop’ ( –  ) gforth-experimental “stop”
   現在のタスクを停止(stop)し、 イベントを待ちます(再起動(restart)される
可能性があります)

‘stop-ns’ ( timeout –  ) gforth-experimental “stop-ns”
   タイムアウト(ナノ秒単位)まで停止(stop)します。 ‘ms’ のより良い代替品
です

   タスクは、 タイムアウトが経過(timeout is over)するか、 別のタスクが以
下のワードでウェイクアップ(wake)すると再起動(restart)します:

‘restart’ ( task –  ) gforth-experimental “restart”
   タスクを起動(wake)する

   こちらもどうぞ:

‘pause’ ( –  ) gforth-experimental “pause”
   次の待機中のタスクに自発的に切り替えます(‘pause’ は従来の協調
(cooperative)タスク・スイッチャー(切替器)です。 pthread マルチタスクでは
、 協調するのに ‘pause’ は必要ありませんが、 それでも使用できます。 例え
ば、 何らかの理由でポーリングに頼らなければならないときです)。 これによ
り、 キュー内のイベントもチェックされます。


File: gforth.info,  Node: Task-local data,  Next: Semaphores,  Prev: Basic multi-tasking,  Up: Pthreads

6.27.1.2 Task-local data
........................

Forth では、 すべてのタスクには、 「ユーザー領域」(user area)と呼ばれる
、 基本的に同じタスク・ローカル・データがあります(初期の Forth システム
はマルチ・ユーザー・システムであり、 タスクごとに 1 人のユーザーが存在す
ることがよくありました)。 task の結果、 たとえば‘newtask’ は、そのユーザ
ー領域の開始アドレスです。 各タスクは、 システムによって定義されたユーザ
ー・データ(例: ‘base’)を取得します。 あなたは以下を使用して追加のユーザ
ー・データを定義できます:

‘User’ ( "name" –  ) gforth-0.2 “User”
   name という名前のユーザー変数(1 セル)を作成します。
name 実行時: ( – addr )
addr は現在のタスクのユーザー変数のアドレスです。

‘AUser’ ( "name" –  ) gforth-0.2 “AUser”
   name というユーザー変数を作成します( ‘User’ とはクロス・コンパイラー
でのみ違いが生じます)。

‘uallot’ ( n1 – n2  ) gforth-0.3 “uallot”
   n1 バイトのユーザー・データを確保します。 確保した領域の先頭をユーザ
ー領域内のオフセット値(n2)として返します。

‘UValue’ ( "name" –  ) gforth-1.0 “UValue”
   name はユーザー value です。
name 実行時: ( – x )

‘UDefer’ ( "name" –  ) gforth-1.0 “UDefer”
   name はタスク・ローカルの deferされたワードです。
Name 実行時: ( ...  – ...  )

   ユーザー・データを扱う場合には、 以下のようなワード群もあります。

‘up@’ ( – addr ) new “up-fetch”
   addr は現在のタスクのユーザー領域の先頭です(addr は現在のタスクの
task 識別子としても機能します)。

‘user'’ ( "name" – u  ) gforth-experimental “user”’
   各タスクのユーザー領域のユーザー変数 name の、 ユーザー領域先頭からの
オフセット値を U に返します。

‘'s’ ( addr1 task – addr2  ) gforth-experimental “’s”
   addr1 が現在のタスクのユーザー・データ内のアドレスである場合、 addr2
は 指定のタスク(task)のユーザー・データ内の対応するアドレスです。


File: gforth.info,  Node: Semaphores,  Next: Hardware operations for multi-tasking,  Prev: Task-local data,  Up: Pthreads

6.27.1.3 Semaphores
...................

協調的(cooperative)マルチタスカーは、 ‘pause’ の 2 つの呼び出しの間に相
互作用する他のタスクがないことを保証できます。 しかしながら、 pthread は
実際には(少なくともマルチコア CPU 上では)並列(concurrent)タスクであるた
め、 同じリソースにアクセスする際の競合を回避するためのいくつかのテクニ
ックが必要です。

   セマフォ(semaphore)を取得できるのは 1 つのスレッドのみであり、 他のす
べてのスレッドはセマフォが解放されるまで待機する必要があります。

‘semaphore’ ( "name" –  ) gforth-experimental “semaphore”
   名前付きセマフォ name を作成します
name 実行時: ( – semaphore )

‘lock’ ( semaphore –  ) gforth-experimental “lock”
   セマフォをロック(lock)

‘unlock’ ( semaphore –  ) gforth-experimental “unlock”
   セマフォのロックを解除します(unlock)

   同時アクセスを防ぐもう 1 つのアプローチが、 クリティカル・セクション
です。 ここではクリティカル・セクションをセマフォで実装しているため、 ク
リティカル・セクションに使用するセマフォを指定する必要があります。 同一
のセマフォを使用するクリティカル・セクション達のみが相互に排他的です。

‘critical-section’ ( xt semaphore –  ) gforth-experimental “critical-section”
   semaphoreをロックした状態で xt を execute します。 xt を離れた後は、
それが例外の throw によるものであっても semaphore のロックが解除されます
。


File: gforth.info,  Node: Hardware operations for multi-tasking,  Next: Message queues,  Prev: Semaphores,  Up: Pthreads

6.27.1.4 Hardware operations for multi-tasking
..............................................

アトミックなハードウェア操作は、 他のタスクが中間状態を参照することなく
、 操作全体を実行します。 これらの操作は、 遅い OS プリミティブを使用せ
ずにタスクを同期するために使用できますが、 非アトミックな操作シーケンス
と比較すると遅くなる傾向があります。 アトミックな操作は、 アライメントを
必要としないハードウェアであっても、 アライメントされたアドレスでのみ正
しく機能します。

‘!@’ ( u1 a-addr – u2 ) gforth-experimental “store-fetch”
   A_ADDR から 値を U2 に取得し、 そして、 A_ADDR に 値 U1 を格納する操
作を、 アトミック操作として行います。

‘+!@’ ( u1 a-addr – u2 ) gforth-experimental “add-store-fetch”
   A_ADDR から 値 U2 を取得し、 A_ADDR の値に U1 を足し込む操作を、 アト
ミック操作として行います。

‘?!@’ ( unew uold a-addr – uprev ) gforth-experimental “question-store-fetch”
   A_ADDR から値 UPREV を取得し、それを UOLD と比較し、 等しい場合は
UNEW を A_ADDR に格納する操作を、 アトミック操作として行います。

   もう 1 つのハードウェア操作はメモリ・バリアです(memory barrier)。 残
念ながら、 最新のハードウェアでは、 メモリ操作を他のメモリ操作と比較して
(別のコアから見た場合に)並べ替えることができることが多く、 メモリ・バリ
アにより、 タスク実行のある時点でこの並べ替えを抑制します。

‘barrier’ ( – ) gforth-experimental “barrier”
   バリア前のすべてのメモリ操作は、 バリア後のメモリ操作より前に実行され
ます。


File: gforth.info,  Node: Message queues,  Prev: Hardware operations for multi-tasking,  Up: Pthreads

6.27.1.5 Message queues
.......................

Gforth のメッセージ・キューはアクター・モデルのバリエーションです。

   イベントは xt です。 送信タスクは受信タスクにイベントを実行するように
お願いし、 受信タスクは準備ができたらそのメッセージ・キューからイベント
を 1 つ実行します。 単一実行クロージャ(Execute-once closures)は、 パラメ
ータを渡すイベントに使用できます。

‘send-event’ ( xt task –  ) gforth-experimental “send-event”
   タスク IPC: XT を TASK に送信します。 TASK で xt が execute されます
。 使い捨てクロージャ(one-shot closure)を使用して、 xt でパラメータを渡
します。

   複数のタスクが 1 つのタスクにイベントを送信する場合、 イベントは任意
の順序で到着する可能性があります。 イベントを受信するには、 受信タスクに
以下のいずれかのワードを使います:

‘?events’ ( –  ) gforth-experimental “question-events”
   現在のタスクのメッセージ・キュー内のすべてのイベント・シーケンスを一
度に 1 つずつ実行します。

‘event-loop’ ( –  ) gforth-experimental “event-loop”
   イベント・シーケンスを待ち、 イベント・シーケンスが到着したら実行しま
す。 キューにイベント・シーケンスがない場合は待機に戻ります。 このワード
は二度と制御を戻しません(This word never returns.)。

   ‘event-loop’ の代わりに、 タスクが ‘stop’ 状態になると、 イベントを受
信する準備も整い、 そして、 イベントを受信するとタスクが起動(wake)されま
す。


File: gforth.info,  Node: Cilk,  Prev: Pthreads,  Up: Multitasker

6.27.2 Cilk
-----------

gforth の Cilk は、 同じ名前のプログラミング言語からインスピレーションを
得た、 複数のコアで実行される複数のタスク間で作業を分割するためのフレー
ムワークです。 Cilk を使用する場合は、 ‘require cilk.fs’ としてください
。

   考え方としては、 並行して解決できる部分問題(subproblems)を特定し、 フ
レームワークがワーカー・タスクをこれらの部分問題に割り当てるというもので
す。 特に、 各サブ・タスクに対して ‘spawn’ ワードの 1 つを使用します。 最
終的には、 部分問題が解決されるまで ‘cilk-sync’ で待つ必要があります。

   現在、 すべての生成は 1 つのタスクから発生する必要があり、
‘cilk-sync’ はすべての部分問題(subproblems)が完了するまで待機するため、
再帰アルゴリズムに現在の gforth Cilk を使用するのは簡単ではありません。

   オーバーヘッドを避けるために、 部分問題を細かく分割しすぎないでくださ
い。 どのくらい細かいかは、 部分問題の実行時間がどの程度均一であるかによ
って決まりますが、 かなりの実行時間の問題の場合は、 5*‘cores’ 個の部分問
題(subproblems)にするのが、 おそらく良い出発点となります。

‘cores’ ( – u  ) cilk “cores”
   使用するワーカー・タスクの数を含む値。 デフォルトでは、 これはハード
ウェア・スレッドの数(SMT/HT の場合)です。 (決定できれば、)それ以外の場合
は 1 になります。 別の数を使用したい場合は、 ‘cilk-init’ を呼び出す前に
‘cores’ を変更します。

‘cilk-init’ ( –  ) cilk “cilk-init”
   ワーカー・タスクがまだ実行されていない場合は開始します。

‘spawn’ ( xt –  ) cilk “spawn”
   ワーカー・タスクで xt ( – ) を execute します。 使い捨て実行可能クロ
ージャ(one-time executable closures)を使用して、 ヒープに割り当てられた
クロージャを渡し、 ‘spawn’ 呼び出し側から、 ワーカーで実行されているコー
ドに任意のデータを渡すことができます。
例: ‘( n r ) [{: n f: r :}h1 code ;] spawn’

‘spawn1’ ( x xt –  ) cilk “spawn1”
   Execute xt ( x – ) in a worker task.

‘spawn2’ ( x1 x2 xt –  ) cilk “spawn2”
   Execute xt ( x1 x2 – ) in a worker task.

‘cilk-sync’ ( –  ) cilk “cilk-sync”
   すべての部分問題が完了(complete)するまで待ちます(wait)。

‘cilk-bye’ ( –  ) cilk “cilk-bye”
   すべてのワーカーを終了(terminate)します。


File: gforth.info,  Node: C Interface,  Next: Assembler and Code Words,  Prev: Multitasker,  Up: Words

6.28 C Interface
================

Gforth の C言語インターフェイスは、 Forth スタックからパラメータを取得し
てC言語の関数を呼び出す、 C言語の関数を含むラッパー・ライブラリをコンパ
イルすることによって機能します。 このラッパー・ライブラリはC言語のコンパ
イラによってコンパイルされます。 コンパイル結果はキャッシュされるため、
ラッパー・ライブラリを変更する必要がある場合、 Gforth は C言語のコンパイ
ルを再実行するだけで済みます。 このビルド処理は自動(automatic)で、 イン
ターフェイス宣言の最後に行われます。 Gforth は、 この処理に libtool と
GCC を使用します。

   C言語のインターフェイスはほぼ完成した状態で、 コールバックも既に追加
されていますが、 構造体については、 独立したスコープを持たない Forth2012
構造体を使用します。 これらの構造体のオフセットは、 SWIG プラグインを使
用してヘッダー・ファイルから抽出されます。

* Menu:

* Calling C Functions::
* Declaring C Functions::
* Calling C function pointers::
* Defining library interfaces::
* Declaring OS-level libraries::
* Callbacks::
* C interface internals::
* Low-Level C Interface Words::
* Automated interface generation using SWIG::
* Migrating the C interface from earlier Gforth::


File: gforth.info,  Node: Calling C Functions,  Next: Declaring C Functions,  Prev: C Interface,  Up: C Interface

6.28.1 Calling C functions
--------------------------

C言語の関数関数が宣言されたら(*note Declaring C Functions:: 参照)、 次の
ように呼び出すことができます: あなたは引数達をスタックにプッシュしてから
、 C言語関数のワードを呼び出します。 引数は、 C言語のドキュメントに記載
されているのと同じ順序でプッシュする必要があります(つまり、 最初の引数が
スタックの最も深いところにあります)。 整数およびポインタ引数はデータ・ス
タックにプッシュする必要があり、 浮動小数点引数は FP スタックにプッシュ
する必要があります。 これらの引数は、 呼び出されたC言語の関数によって消
費されます。

   C言語の関数から戻るとき、 戻り値がある場合、 その戻り値は適切なスタッ
クに置きます。 整数の戻り値はデータ・スタックにプッシュされ、 FP の戻り
値は FP スタックにプッシュされ、 void 戻り値の場合は何もプッシュされませ
ん。 C言語ではあまり使用されない場合でも、 ほとんどのC言語の関数には戻り
値があることに注意してください。 Forth では、 この戻り値を使用しない場合
は、 明示的に捨てる(‘drop’)必要があります。

   C言語インターフェイスは、 必要に応じて、 ベストエフォートで C言語の型
と Forth の型の間で自動的に変換します(場合によっては、 ある程度の損失が
発生する可能性があります)。

   例として、 POSIX 関数 ‘lseek()’ について考察してみましょう:

     off_t lseek(int fd, off_t offset, int whence);

   この関数は 3 つの整数引数を受け取り、 整数引数 1 つ返すため、 現在の
ファイルのオフセットをファイルの先頭に設定するための Forth 呼び出しは以
下のようになります:

     fd @ 0 SEEK_SET lseek -1 = if
       ... \ error handling
     then

   あなたは、 ‘off_t’ がセルに収まらないため、 lseek に大きなオフセット
を渡すことができず、 戻り値の一部しか取得できないのではないかと心配する
かもしれません。 その場合、 関数の宣言(*note Declaring C Functions::)で
、off_t 引数と戻り値に 2倍長セルを使用するように宣言し、 結果の Forth ワ
ードに ‘dlseek’ などの別の名前を付ける必要があります。 その結果は以下の
ように呼び出すことができます:

     fd @ #0. SEEK_SET dlseek #-1. d= if
       ... \ error handling
     then

   構造体または共用体の受け渡しは現在、 このインターフェイスではサポート
されていません(1)

   可変数の引数を持つ関数の呼び出し(「variadic関数」例: ‘printf()’)は、
引数パターンごとに 1 つの関数呼び出しワードを宣言し、 目的のパターンに適
切なワードを呼び出すことによってのみサポートされます。

   ---------- Footnotes ----------

   (1) あなたが C 言語コンパイラの呼び出し規則を知っていれば、 通常は何
らかの方法でそのような関数を呼び出すことはできますが、 その方法は通常、
プラットフォーム間で移植可能ではなく、 場合によっては C 言語コンパイラ間
でさえ移植可能ではありません。


File: gforth.info,  Node: Declaring C Functions,  Next: Calling C function pointers,  Prev: Calling C Functions,  Up: C Interface

6.28.2 Declaring C Functions
----------------------------

Before you can call ‘lseek’ or ‘dlseek’, you have to declare it.  The
declaration consists of two parts:

The C part
     is the C declaration of the function, or more typically and
     portably, a C-style ‘#include’ of a file that contains the
     declaration of the C function.

The Forth part
     declares the Forth types of the parameters and the Forth word name
     corresponding to the C function.

   For the words ‘lseek’ and ‘dlseek’ mentioned earlier, the
declarations are:

     \c #define _FILE_OFFSET_BITS 64
     \c #include <sys/types.h>
     \c #include <unistd.h>
     c-function lseek lseek n n n -- n
     c-function dlseek lseek n d n -- d

   The C part of the declarations is prefixed by ‘\c’, and the rest of
the line is ordinary C code.  You can use as many lines of C
declarations as you like, and they are visible for all further function
declarations.

   The Forth part declares each interface word with ‘c-function’,
followed by the Forth name of the word, the C name of the called
function, and the stack effect of the word.  The stack effect contains
an arbitrary number of types of parameters, then ‘--’, and then exactly
one type for the return value.  The possible types are:

‘n’
     single-cell integer

‘a’
     address (single-cell)

‘d’
     double-cell integer

‘r’
     floating-point value

‘func’
     C function pointer

‘void’
     no value (used as return type for void functions)

   To deal with variadic C functions, you can declare one Forth word for
every pattern you want to use, e.g.:

     \c #include <stdio.h>
     c-function printf-nr printf a n r -- n
     c-function printf-rn printf a r n -- n

   Note that with C functions declared as variadic (or if you don’t
provide a prototype), the C interface has no C type to convert to, so no
automatic conversion happens, which may lead to portability problems in
some cases.  You can add the C type cast in curly braces after the Forth
type.  This also allows to pass e.g.  structs to C functions, which in
Forth cannot live on the stack.

     c-function printfll printf a n{(long long)} -- n
     c-function pass-struct pass_struct a{*(struct foo *)} -- n

   This typecasting is not available to return values, as C does not
allow typecasts for lvalues.

‘\c’ ( "rest-of-line" –  ) gforth-0.7 “backslash-c”
   One line of C declarations for the C interface

‘c-function’ ( "forth-name" "c-name" "{type}" "—" "type" –  ) gforth-0.7 “c-function”
   Define a Forth word forth-name.  Forth-name has the specified stack
effect and calls the C function ‘c-name’.

‘c-value’ ( "forth-name" "c-name" "—" "type" –  ) gforth-1.0 “c-value”
   Define a Forth word forth-name.  Forth-name has the specified stack
effect and gives the C value of ‘c-name’.

‘c-variable’ ( "forth-name" "c-name" –  ) gforth-1.0 “c-variable”
   Define a Forth word forth-name.  Forth-name returns the address of
‘c-name’.

   In order to work, this C interface invokes GCC at run-time and uses
dynamic linking.  If these features are not available, there are other,
less convenient and less portable C interfaces in ‘lib.fs’ and
‘oldlib.fs’.  These interfaces are mostly undocumented and mostly
incompatible with each other and with the documented C interface; you
can find some examples for the ‘lib.fs’ interface in ‘lib.fs’.


File: gforth.info,  Node: Calling C function pointers,  Next: Defining library interfaces,  Prev: Declaring C Functions,  Up: C Interface

6.28.3 Calling C function pointers from Forth
---------------------------------------------

If you come across a C function pointer (e.g., in some C-constructed
structure) and want to call it from your Forth program, you could use
the structures as described above by defining a macro.  Or you use
‘c-funptr’.

‘c-funptr’ ( "forth-name" <{>"c-typecast"<}> "{type}" "—" "type" –  ) gforth-1.0 “c-funptr”
   Define a Forth word forth-name.  Forth-name has the specified stack
effect plus the called pointer on top of stack, i.e.  ‘( {type} ptr --
type )’ and calls the C function pointer ‘ptr’ using the typecast or
struct access ‘c-typecast’.

   Let us assume that there is a C function pointer type ‘func1’ defined
in some header file ‘func1.h’, and you know that these functions take
one integer argument and return an integer result; and you want to call
functions through such pointers.  Just define

     \c #include <func1.h>
     c-funptr call-func1 {((func1)ptr)} n -- n

   and then you can call a function pointed to by, say ‘func1a’ as
follows:

     -5 func1a call-func1 .

   The Forth word ‘call-func1’ is similar to ‘execute’, except that it
takes a C ‘func1’ pointer instead of a Forth execution token, and it is
specific to ‘func1’ pointers.  For each type of function pointer you
want to call from Forth, you have to define a separate calling word.


File: gforth.info,  Node: Defining library interfaces,  Next: Declaring OS-level libraries,  Prev: Calling C function pointers,  Up: C Interface

6.28.4 Defining library interfaces
----------------------------------

You can give a name to a bunch of C function declarations (a library
interface), as follows:

     c-library lseek-lib
     \c #define _FILE_OFFSET_BITS 64
     ...
     end-c-library

   The effect of giving such a name to the interface is that the names
of the generated files will contain that name, and when you use the
interface a second time, it will use the existing files instead of
generating and compiling them again, saving you time.  The generated
file contains a 128 bit hash (not cryptographically safe, but good
enough for that purpose) of the source code, so changing the
declarations will cause a new compilation.  Normally these files are
cached in ‘$HOME/.gforth/’ARCHITECTURE‘/libcc-named’, so if you
experience problems or have other reasons to force a recompilation, you
can delete the files there.

   Note that you should use ‘c-library’ before everything else having
anything to do with that library, as it resets some setup stuff.  The
idea is that the typical use is to put each
‘c-library’...‘end-c-library’ unit in its own file, and to be able to
include these files in any order.  All other words dealing with the C
interface are hidden in the vocabulary ‘c-lib’, which is put on top o
the search stack by ‘c-library’ and removed by ‘end-c-library’.

   Note that the library name is not allocated in the dictionary and
therefore does not shadow dictionary names.  It is used in the file
system, so you have to use naming conventions appropriate for file
systems.  The name is also used as part of the C symbols, but characters
outside the legal C symbol names are replaced with underscores.  Also,
you shall not call a function you declare after ‘c-library’ before you
perform ‘end-c-library’.

   A major benefit of these named library interfaces is that, once they
are generated, the tools used to generated them (in particular, the C
compiler and libtool) are no longer needed, so the interface can be used
even on machines that do not have the tools installed.  The build system
of Gforth can even cross-compile these libraries, so that the libraries
are available for plattforms on which build tools aren’t installed.

‘c-library-name’ ( c-addr u –  ) gforth-0.7 “c-library-name”
   Start a C library interface with name c-addr u.

‘c-library’ ( "name" –  ) gforth-0.7 “c-library”
   Parsing version of ‘c-library-name’

‘end-c-library’ ( –  ) gforth-0.7 “end-c-library”
   Finish and (if necessary) build the latest C library interface.


File: gforth.info,  Node: Declaring OS-level libraries,  Next: Callbacks,  Prev: Defining library interfaces,  Up: C Interface

6.28.5 Declaring OS-level libraries
-----------------------------------

For calling some C functions, you need to link with a specific OS-level
library that contains that function.  E.g., the ‘sin’ function requires
linking a special library by using the command line switch ‘-lm’.  In
our C iterface you do the equivalent thing by calling ‘add-lib’ as
follows:

     clear-libs
     s" m" add-lib
     \c #include <math.h>
     c-function sin sin r -- r

   First, you clear any libraries that may have been declared earlier
(you don’t need them for ‘sin’); then you add the ‘m’ library (actually
‘libm.so’ or somesuch) to the currently declared libraries; you can add
as many as you need.  Finally you declare the function as shown above.
Typically you will use the same set of library declarations for many
function declarations; you need to write only one set for that, right at
the beginning.

   Note that you must not call ‘clear-libs’ inside
‘c-library...end-c-library’; however, ‘c-library’ performs the function
of ‘clear-libs’, so ‘clear-libs’ is not necessary, and you usually want
to put ‘add-lib’ calls inside ‘c-library...end-c-library’.

‘clear-libs’ ( –  ) gforth-0.7 “clear-libs”
   Clear the list of libs

‘add-lib’ ( c-addr u –  ) gforth-0.7 “add-lib”
   Add library libstring to the list of libraries, where string is
represented by c-addr u.

‘add-libpath’ ( c-addr u –  ) gforth-0.7 “add-libpath”
   Add path string to the list of library search pathes, where string is
represented by c-addr u.

‘add-framework’ ( c-addr u –  ) gforth-1.0 “add-framework”
   Add framework libstring to the list of frameworks, where string is
represented by c-addr u.

‘add-incdir’ ( c-addr u –  ) gforth-1.0 “add-incdir”
   Add path c-addr u to the list of include search pathes

‘add-cflags’ ( c-addr u –  ) gforth-1.0 “add-cflags”
   add any kind of cflags to compilation

‘add-ldflags’ ( c-addr u –  ) gforth-1.0 “add-ldflags”
   add flag to linker


File: gforth.info,  Node: Callbacks,  Next: C interface internals,  Prev: Declaring OS-level libraries,  Up: C Interface

6.28.6 Callbacks
----------------

In some cases you have to pass a function pointer to a C function, i.e.,
the library wants to call back to your application (and the pointed-to
function is called a callback function).  You can pass the address of an
existing C function (that you get with ‘lib-sym’, *note Low-Level C
Interface Words::), but if there is no appropriate C function, you
probably want to define the function as a Forth word.  Then you need to
generate a callback as described below:

   You can generate C callbacks from Forth code with ‘c-callback’.

‘c-callback’ ( "forth-name" "{type}" "—" "type" –  ) gforth-1.0 “c-callback”
   Define a callback instantiator with the given signature.  The
callback instantiator forth-name ‘( xt -- addr )’ takes an XT, and
returns the ADDRess of the C function handling that callback.

‘c-callback-thread’ ( "forth-name" "{type}" "—" "type" –  ) gforth-1.0 “c-callback-thread”
   Define a callback instantiator with the given signature.  The
callback instantiator forth-name ‘( xt -- addr )’ takes an XT, and
returns the ADDRess of the C function handling that callback.  This
callback is safe when called from another thread

   This precompiles a number of callback functions (up to the value
‘callback#’).  The prototype of the C function is deduced from its Forth
signature.  If this is not sufficient, you can add types in curly braces
after the Forth type.

     c-callback vector4double: f f f f -- void
     c-callback vector4single: f{float} f{float} f{float} f{float} -- void


File: gforth.info,  Node: C interface internals,  Next: Low-Level C Interface Words,  Prev: Callbacks,  Up: C Interface

6.28.7 How the C interface works
--------------------------------

The documented C interface works by generating a C code out of the
declarations.

   In particular, for every Forth word declared with ‘c-function’, it
generates a wrapper function in C that takes the Forth data from the
Forth stacks, and calls the target C function with these data as
arguments.  The C compiler then performs an implicit conversion between
the Forth type from the stack, and the C type for the parameter, which
is given by the C function prototype.  After the C function returns, the
return value is likewise implicitly converted to a Forth type and
written back on the stack.

   The ‘\c’ lines are literally included in the C code (but without the
‘\c’), and provide the necessary declarations so that the C compiler
knows the C types and has enough information to perform the conversion.

   These wrapper functions are eventually compiled and dynamically
linked into Gforth, and then they can be called.

   The libraries added with ‘add-lib’ are used in the compile command
line to specify dependent libraries with ‘-lLIB’, causing these
libraries to be dynamically linked when the wrapper function is linked.


File: gforth.info,  Node: Low-Level C Interface Words,  Next: Automated interface generation using SWIG,  Prev: C interface internals,  Up: C Interface

6.28.8 Low-Level C Interface Words
----------------------------------

‘open-lib’ ( c-addr1 u1 – u2 ) gforth-0.4 “open-lib”

‘lib-sym’ ( c-addr1 u1 u2 – u3 ) gforth-0.4 “lib-sym”

‘lib-error’ ( – c-addr u ) gforth-0.7 “lib-error”
   Error message for last failed ‘open-lib’ or ‘lib-sym’.

‘call-c’ ( ... w – ... ) gforth-0.2 “call-c”
   Call the C function pointed to by w.  The C function has to access
the stack itself.  The stack pointers are exported into a ptrpair
structure passed to the C function, and returned in that form.


File: gforth.info,  Node: Automated interface generation using SWIG,  Next: Migrating the C interface from earlier Gforth,  Prev: Low-Level C Interface Words,  Up: C Interface

6.28.9 Automated interface generation using SWIG
------------------------------------------------

SWIG, the Simple Wrapper Interface Generator, is used to create C
interfaces for a lot of programming languages.  The SWIG version
extended with a Forth module can be found on github
(https://github.com/GeraldWodni/swig).

6.28.9.1 Basic operation
........................

C-headers are parsed and converted to Forth-Sourcecode which uses the
previously describe C interface functions.

6.28.9.2 Detailed operation:
............................

  1. Select a target, in this example we are using ‘example.h’
  2. Create an interface file for the header.  This can be used to pass
     options, switches and define variables.  In the simplest case it
     just instructs to translate all of ‘example.h’:
          %module example
          %insert("include")
          {
              #include "example.h"
          }
          %include "example.h"
  3. Use SWIG to create a ‘.fsi-c’ file.
     ‘swig -forth -stackcomments -use-structs -enumcomments -o
     example-fsi.c example.i’.
     FSI stands “Forth Source Independent” meaning it can be transferred
     to any host having a C-compiler.  SWIG is not required past this
     point.
  4. On the target machine compile the ‘.fsi-c’ file to a ‘.fsx’ (x
     stands for executable)
     ‘gcc -o example.fsx example-fsi.c’
     The compilation will resolve all constants to the values on the
     target.
  5. The last step is to run the executable and capture its output to a
     ‘.fs’ “Forth Source” file.
     ‘./example.fsx -gforth > example.fs’
     This code can now be used on the target platform.

6.28.9.3 Examples
.................

You can find some examples in SWIG’s Forth Example section
(https://github.com/GeraldWodni/swig/tree/master/Examples/forth).

   A lot of interface files can be found in Forth Posix C-Interface
(https://github.com/GeraldWodni/posix) and Forth C-Interface Modules
(https://github.com/GeraldWodni/forth-c-interfaces).

   Contribution to the Forth C-Interface Module repository
(https://github.com/GeraldWodni/forth-c-interfaces) is always welcome.


File: gforth.info,  Node: Migrating the C interface from earlier Gforth,  Prev: Automated interface generation using SWIG,  Up: C Interface

6.28.10 Migrating from Gforth 0.7
---------------------------------

In this version, you can use ‘\c’, ‘c-function’ and ‘add-lib’ only
inside ‘c-library’...‘end-c-library’.  ‘add-lib’ now always starts from
a clean slate inside a ‘c-library’, so you don’t need to use
‘clear-libs’ in most cases.

   If you have a program that uses these words outside
‘c-library’...‘end-c-library’, just wrap them in
‘c-library’...‘end-c-library’.  You may have to add some instances of
‘add-lib’, however.


File: gforth.info,  Node: Assembler and Code Words,  Next: Carnal words,  Prev: C Interface,  Up: Words

6.29 Assembler and Code Words
=============================

* Menu:

* Assembler Definitions::    Definitions in assembly language
* Common Assembler::         アセンブラ文法
* Common Disassembler::
* 386 Assembler::            逸脱(deviations)と特殊ケース
* AMD64 Assembler::
* Alpha Assembler::          逸脱(deviations)と特殊ケース
* MIPS assembler::           逸脱(deviations)と特殊ケース
* PowerPC assembler::        逸脱(deviations)と特殊ケース
* ARM Assembler::            逸脱(deviations)と特殊ケース
* Other assemblers::         アセンブラ自体の書き方


File: gforth.info,  Node: Assembler Definitions,  Next: Common Assembler,  Prev: Assembler and Code Words,  Up: Assembler and Code Words

6.29.1 Definitions in assembly language
---------------------------------------

Gforth は、 アセンブリ言語でワードを実装する方法(‘abi-code’ … ‘end-code’
を使用)と、 任意の実行時の振る舞いを持つ定義ワードを定義する方法(‘does>’
のようなの)を提供し、 ここで、 この実行時の振る舞いを(‘does>’ とは異なり
、) Forth ではなくアセンブリ言語で定義します。

   ただし、 Gforth のマシン非依存の性質により、 いくつかの問題が生じます
。 まず、 Gforth は複数のアーキテクチャ上で実行されるため、 標準のアセン
ブラを提供できません。 ただし、 実行されるいくつかのアーキテクチャ用のア
センブラは提供されています。 さらに言えば、 Gforth ではシステムに依存し
ないアセンブラを使用したり、 ‘,’ や ‘c,’ を使用してマシン・コードを直接
コンパイルしたりできます。

   もう 1 つの問題は、Gforth の仮想マシンのレジスタ(スタック・ポインタと
仮想マシン命令ポインタ)がインストールとエンジンに依存することです。 また
、 どのレジスタを自由に使用できるかは、 インストールとエンジンによって異
なります。 したがって、 Gforth 仮想マシンのコンテキストで実行するように
記述されたコードは、 基本的に、 そのコードが開発されたインストールとエン
ジンに限定されます(たまたま、 他の場所でも動く可能性はありますが、 それ
に頼ることはできません)。

   幸いなことに、 同じ呼び出し規約(ABI)を持つプラットフォーム上で実行さ
れている Gforth に移植可能(portable)な ‘abi-code’ ワードを Gforth で定義
できます。 通常、 これは同じアーキテクチャと OS の組み合わせへの移植性を
意味し、 しばしば OS の境を越えることができます。

‘assembler’ ( –  ) tools-ext “assembler”
   ボキャブラリ: 検索順序スタック(the search order)のTOSのワードリストを
assembler ワードリストに置き換えます。

‘init-asm’ ( –  ) gforth-0.2 “init-asm”
   assembler ワードリストを検索順序スタック(the search order)にプッシュ
します(訳注:つまり assembler ワードリストが検索順序スタックのTOSになる
)。

‘abi-code’ ( "name" – colon-sys  ) gforth-1.0 “abi-code”
   C言語プロトタイプ(C-prototype)に対応するプラットフォームの ABI 規則を
使用して呼び出されるネイティブ・コード定義を開始します:
     Cell *function(Cell *sp, Float **fpp);
   ここで、 FP スタック・ポインタは、 FP スタック・ポインタを含むメモリ
位置への参照を提供することによって渡され、 (必要な場合)変更された FP ス
タック・ポインタをそこに格納することによって渡されます。

‘;abi-code’ ( –  ) gforth-1.0 “semicolon-abi-code”
   コロン定義を終了しますが、 実行時に最後に定義されたワード X (‘create’
で作られたワードである必要があります)の変更もして、 C言語プロトタイプに
対応するプラットフォームの ABI 規約を使用してネイティブ・コードを呼び出
します:
      Cell *function(Cell *sp, Float **fpp, Address body);
   The FP stack pointer is passed in by providing a reference to a
memory location containing the FP stack pointer and is passed out by
storing the changed FP stack pointer there (if necessary).  The
parameter body is the body of X.

‘end-code’ ( colon-sys –  ) gforth-0.2 “end-code”
   End a code definition.  Note that you have to assemble the return
from the ABI call (for ‘abi-code’) or the dispatch to the next VM
instruction (for ‘code’ and ‘;code’) yourself.

‘code’ ( "name" – colon-sys  ) tools-ext “code”
   Start a native code definition that runs in the context of the Gforth
virtual machine (engine).  Such a definition is not portable between
Gforth installations, so we recommend using ‘abi-code’ instead of
‘code’.  You have to end a ‘code’ definition with a dispatch to the next
virtual machine instruction.

‘;code’ ( compilation. colon-sys1 – colon-sys2  ) tools-ext “semicolon-code”
   The code after ‘;code’ becomes the behaviour of the last defined word
(which must be a ‘create’d word).  The same caveats apply as for ‘code’,
so we recommend using ‘;abi-code’ instead.

‘flush-icache’ ( c-addr u – ) gforth-0.2 “flush-icache”
   Make sure that the instruction cache of the processor (if there is
one) does not contain stale data at c-addr and u bytes afterwards.
‘END-CODE’ performs a ‘flush-icache’ automatically.  Caveat:
‘flush-icache’ might not work on your installation; this is usually the
case if direct threading is not supported on your machine (take a look
at your ‘machine.h’) and your machine has a separate instruction cache.
In such cases, ‘flush-icache’ does nothing instead of flushing the
instruction cache.

   If ‘flush-icache’ does not work correctly, ‘abi-code’ words etc.
will not work (reliably), either.

   The typical usage of these words can be shown most easily by analogy
to the equivalent high-level defining words:

     : foo                              abi-code foo
        <high-level Forth words>              <assembler>
     ;                                  end-code

     : bar                              : bar
        <high-level Forth words>           <high-level Forth words>
        CREATE                             CREATE
           <high-level Forth words>           <high-level Forth words>
        DOES>                              ;code
           <high-level Forth words>           <assembler>
     ;                                  end-code

   For using ‘abi-code’, take a look at the ABI documentation of your
platform to see how the parameters are passed (so you know where you get
the stack pointers) and how the return value is passed (so you know
where the data stack pointer is returned).  The ABI documentation also
tells you which registers are saved by the caller (caller-saved), so you
are free to destroy them in your code, and which registers have to be
preserved by the called word (callee-saved), so you have to save them
before using them, and restore them afterwards.  For some architectures
and OSs we give short summaries of the parts of the calling convention
in the appropriate sections.  More reverse-engineering oriented people
can also find out about the passing and returning of the stack pointers
through ‘see abi-call’.

   Most ABIs pass the parameters through registers, but some (in
particular the most common 386 (aka IA-32) calling conventions) pass
them on the architectural stack.  The common ABIs all pass the return
value in a register.

   Other things you need to know for using ‘abi-code’ is that both the
data and the FP stack grow downwards (towards lower addresses) in
Gforth, with ‘1 cells’ size per cell, and ‘1 floats’ size per FP value.

   Here’s an example of using ‘abi-code’ on the 386 architecture:

     abi-code my+ ( n1 n2 -- n )
     4 sp d) ax mov \ sp into return reg
     ax )    cx mov \ tos
     4 #     ax add \ update sp (pop)
     cx    ax ) add \ sec = sec+tos
     ret            \ return from my+
     end-code

   An AMD64 variant of this example can be found in *note AMD64
Assembler::.

   Here’s a 386 example that deals with FP values:

     abi-code my-f+ ( r1 r2 -- r )
     8 sp d) cx mov  \ load address of fp
     cx )    dx mov  \ load fp
     .fl dx )   fld  \ r2
     8 #     dx add  \ update fp
     .fl dx )   fadd \ r1+r2
     .fl dx )   fstp \ store r
     dx    cx ) mov  \ store new fp
     4 sp d) ax mov  \ sp into return reg
     ret             \ return from my-f+
     end-code

