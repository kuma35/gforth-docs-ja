# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
msgid ""
msgstr ""
"Project-Id-Version: gforth-docs-ja 0.0\n"
"POT-Creation-Date: 2024-10-09 08:06+0900\n"
"PO-Revision-Date: 2024-10-09 07:53+0900\n"
"Last-Translator: kuma35\n"
"Language-Team: Japanese\n"
"Language: ja_JP\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: include
#: ../doc/vmgen.texi:4
#, no-wrap
msgid "version.texi"
msgstr "version.texi"

#. type: settitle
#: ../doc/vmgen.texi:5
#, no-wrap
msgid "Vmgen (Gforth @value{VERSION})"
msgstr "Vmgen (Gforth @value{VERSION})"

#. type: copying
#: ../doc/vmgen.texi:12
msgid ""
"This manual is for Vmgen (version @value{VERSION}, @value{UPDATED}), the "
"virtual machine interpreter generator"
msgstr ""
"このマニュアルは、 仮想マシン・インタープリタ・ジェネレーターである Vmgen "
"(バージョン @value{VERSION}、@value{UPDATED}) 用です"

#. type: copying
#: ../doc/vmgen.texi:15
msgid ""
"Author: Anton Ertl Copyright @copyright{} 2002,2003,2005,2007,2008,2019 Free "
"Software Foundation, Inc."
msgstr ""
"Author: Anton Ertl Copyright @copyright{} 2002,2003,2005,2007,2008,2019 Free "
"Software Foundation, Inc."

#. type: quotation
#: ../doc/vmgen.texi:24
msgid ""
"Permission is granted to copy, distribute and/or modify this document under "
"the terms of the GNU Free Documentation License, Version 1.2 or any later "
"version published by the Free Software Foundation; with no Invariant "
"Sections, with the Front-Cover texts being ``A GNU Manual,'' and with the "
"Back-Cover Texts as in (a) below.  A copy of the license is included in the "
"section entitled ``GNU Free Documentation License.''"
msgstr ""
"Permission is granted to copy, distribute and/or modify this document under "
"the terms of the GNU Free Documentation License, Version 1.2 or any later "
"version published by the Free Software Foundation; with no Invariant "
"Sections, with the Front-Cover texts being ``A GNU Manual,'' and with the "
"Back-Cover Texts as in (a) below.  A copy of the license is included in the "
"section entitled ``GNU Free Documentation License.''"

#. type: quotation
#: ../doc/vmgen.texi:28
msgid ""
"(a) The FSF's Back-Cover Text is: ``You have freedom to copy and modify this "
"GNU Manual, like GNU software.  Copies published by the Free Software "
"Foundation raise funds for GNU development.''"
msgstr ""
"(a) The FSF's Back-Cover Text is: ``You have freedom to copy and modify this "
"GNU Manual, like GNU software.  Copies published by the Free Software "
"Foundation raise funds for GNU development.''"

#. type: dircategory
#: ../doc/vmgen.texi:31
#, no-wrap
msgid "Software development"
msgstr "Software development"

#. type: menuentry
#: ../doc/vmgen.texi:34
msgid "Vmgen: (vmgen)"
msgstr "Vmgen: (vmgen)"

#. type: menuentry
#: ../doc/vmgen.texi:34
msgid "Virtual machine interpreter generator"
msgstr "Virtual machine interpreter generator"

#. type: top
#: ../doc/vmgen.texi:37 ../doc/vmgen.texi:49
#, no-wrap
msgid "Vmgen"
msgstr "Vmgen"

#. type: subtitle
#: ../doc/vmgen.texi:38
#, no-wrap
msgid "for Gforth version @value{VERSION}, @value{UPDATED}"
msgstr "for Gforth version @value{VERSION}, @value{UPDATED}"

#. type: author
#: ../doc/vmgen.texi:39
#, no-wrap
msgid "M. Anton Ertl (@email{anton@@mips.complang.tuwien.ac.at})"
msgstr "M. Anton Ertl (@email{anton@@mips.complang.tuwien.ac.at})"

#. type: node
#: ../doc/vmgen.texi:48 ../doc/vmgen.texi:127 ../doc/vmgen.texi:237
#: ../doc/vmgen.texi:271 ../doc/vmgen.texi:413 ../doc/vmgen.texi:453
#: ../doc/vmgen.texi:600 ../doc/vmgen.texi:1263 ../doc/vmgen.texi:1322
#: ../doc/vmgen.texi:1867 ../doc/vmgen.texi:1910 ../doc/vmgen.texi:1933
#: ../doc/vmgen.texi:1985 ../doc/vmgen.texi:1999 ../doc/vmgen.texi:2011
#, no-wrap
msgid "Top"
msgstr "Top"

#. type: node
#: ../doc/vmgen.texi:48 ../doc/vmgen.texi:69 ../doc/vmgen.texi:127
#: ../doc/vmgen.texi:128 ../doc/vmgen.texi:237
#, no-wrap
msgid "Introduction"
msgstr "Introduction"

#. type: node
#: ../doc/vmgen.texi:48
#, no-wrap
msgid "(dir)"
msgstr "(dir)"

#. type: menuentry
#: ../doc/vmgen.texi:69
msgid "What can Vmgen do for you?"
msgstr "What can Vmgen do for you?"

#. type: node
#: ../doc/vmgen.texi:69 ../doc/vmgen.texi:127 ../doc/vmgen.texi:237
#: ../doc/vmgen.texi:238 ../doc/vmgen.texi:271
#, no-wrap
msgid "Why interpreters?"
msgstr "Why interpreters?"

#. type: menuentry
#: ../doc/vmgen.texi:69
msgid "Advantages and disadvantages"
msgstr "Advantages and disadvantages"

#. type: node
#: ../doc/vmgen.texi:69 ../doc/vmgen.texi:74 ../doc/vmgen.texi:237
#: ../doc/vmgen.texi:271 ../doc/vmgen.texi:272 ../doc/vmgen.texi:281
#: ../doc/vmgen.texi:327 ../doc/vmgen.texi:371 ../doc/vmgen.texi:413
#, no-wrap
msgid "Concepts"
msgstr "Concepts"

#. type: menuentry
#: ../doc/vmgen.texi:69
msgid "VM interpreter background"
msgstr "VM interpreter background"

#. type: node
#: ../doc/vmgen.texi:69 ../doc/vmgen.texi:271 ../doc/vmgen.texi:413
#: ../doc/vmgen.texi:414 ../doc/vmgen.texi:415 ../doc/vmgen.texi:453
#, no-wrap
msgid "Invoking Vmgen"
msgstr "Invoking Vmgen"

#. type: node
#: ../doc/vmgen.texi:69 ../doc/vmgen.texi:80 ../doc/vmgen.texi:413
#: ../doc/vmgen.texi:453 ../doc/vmgen.texi:454 ../doc/vmgen.texi:463
#: ../doc/vmgen.texi:545 ../doc/vmgen.texi:600
#, no-wrap
msgid "Example"
msgstr "Example"

#. type: node
#: ../doc/vmgen.texi:69 ../doc/vmgen.texi:85 ../doc/vmgen.texi:453
#: ../doc/vmgen.texi:600 ../doc/vmgen.texi:601 ../doc/vmgen.texi:619
#: ../doc/vmgen.texi:758 ../doc/vmgen.texi:1081 ../doc/vmgen.texi:1144
#: ../doc/vmgen.texi:1208 ../doc/vmgen.texi:1263
#, no-wrap
msgid "Input File Format"
msgstr "Input File Format"

#. type: node
#: ../doc/vmgen.texi:69 ../doc/vmgen.texi:600 ../doc/vmgen.texi:1263
#: ../doc/vmgen.texi:1264 ../doc/vmgen.texi:1322
#, no-wrap
msgid "Error messages"
msgstr "Error messages"

#. type: menuentry
#: ../doc/vmgen.texi:69
msgid "reported by Vmgen"
msgstr "reported by Vmgen"

#. type: node
#: ../doc/vmgen.texi:69 ../doc/vmgen.texi:104 ../doc/vmgen.texi:1263
#: ../doc/vmgen.texi:1322 ../doc/vmgen.texi:1323 ../doc/vmgen.texi:1344
#: ../doc/vmgen.texi:1574 ../doc/vmgen.texi:1623 ../doc/vmgen.texi:1700
#: ../doc/vmgen.texi:1735 ../doc/vmgen.texi:1776 ../doc/vmgen.texi:1867
#, no-wrap
msgid "Using the generated code"
msgstr "Using the generated code"

#. type: node
#: ../doc/vmgen.texi:69 ../doc/vmgen.texi:113 ../doc/vmgen.texi:1322
#: ../doc/vmgen.texi:1867 ../doc/vmgen.texi:1868 ../doc/vmgen.texi:1876
#: ../doc/vmgen.texi:1910
#, no-wrap
msgid "Hints"
msgstr "Hints"

#. type: menuentry
#: ../doc/vmgen.texi:69
msgid "VM archictecture, efficiency"
msgstr "VM archictecture, efficiency"

#. type: node
#: ../doc/vmgen.texi:69 ../doc/vmgen.texi:1867 ../doc/vmgen.texi:1910
#: ../doc/vmgen.texi:1911 ../doc/vmgen.texi:1933
#, no-wrap
msgid "The future"
msgstr "The future"

#. type: node
#: ../doc/vmgen.texi:69 ../doc/vmgen.texi:1910 ../doc/vmgen.texi:1933
#: ../doc/vmgen.texi:1934 ../doc/vmgen.texi:1985
#, no-wrap
msgid "Changes"
msgstr "Changes"

#. type: menuentry
#: ../doc/vmgen.texi:69
msgid "from earlier versions"
msgstr "from earlier versions"

#. type: node
#: ../doc/vmgen.texi:69 ../doc/vmgen.texi:1933 ../doc/vmgen.texi:1985
#: ../doc/vmgen.texi:1986 ../doc/vmgen.texi:1999
#, no-wrap
msgid "Contact"
msgstr "Contact"

#. type: menuentry
#: ../doc/vmgen.texi:69
msgid "Bug reporting etc."
msgstr "Bug reporting etc."

#. type: node
#: ../doc/vmgen.texi:69 ../doc/vmgen.texi:117 ../doc/vmgen.texi:1985
#: ../doc/vmgen.texi:1999 ../doc/vmgen.texi:2000 ../doc/vmgen.texi:2006
#: ../doc/vmgen.texi:2011
#, no-wrap
msgid "Copying This Manual"
msgstr "Copying This Manual"

#. type: menuentry
#: ../doc/vmgen.texi:69
msgid "Manual License"
msgstr "Manual License"

#. type: unnumbered
#: ../doc/vmgen.texi:69 ../doc/vmgen.texi:1999 ../doc/vmgen.texi:2011
#: ../doc/vmgen.texi:2012
#, no-wrap
msgid "Index"
msgstr "Index"

#. type: menuentry
#: ../doc/vmgen.texi:72
msgid "--- The Detailed Node Listing ---"
msgstr "--- The Detailed Node Listing ---"

#. type: node
#: ../doc/vmgen.texi:78 ../doc/vmgen.texi:278 ../doc/vmgen.texi:281
#: ../doc/vmgen.texi:282 ../doc/vmgen.texi:327
#, no-wrap
msgid "Front end and VM interpreter"
msgstr "Front end and VM interpreter"

#. type: menuentry
#: ../doc/vmgen.texi:78 ../doc/vmgen.texi:278
msgid "Modularizing an interpretive system"
msgstr "Modularizing an interpretive system"

#. type: node
#: ../doc/vmgen.texi:78 ../doc/vmgen.texi:278 ../doc/vmgen.texi:281
#: ../doc/vmgen.texi:327 ../doc/vmgen.texi:328 ../doc/vmgen.texi:371
#, no-wrap
msgid "Data handling"
msgstr "Data handling"

#. type: menuentry
#: ../doc/vmgen.texi:78 ../doc/vmgen.texi:278
msgid "Stacks, registers, immediate arguments"
msgstr "Stacks, registers, immediate arguments"

#. type: section
#: ../doc/vmgen.texi:78 ../doc/vmgen.texi:278 ../doc/vmgen.texi:327
#: ../doc/vmgen.texi:371 ../doc/vmgen.texi:372
#, no-wrap
msgid "Dispatch"
msgstr "Dispatch"

#. type: menuentry
#: ../doc/vmgen.texi:78 ../doc/vmgen.texi:278
msgid "From one VM instruction to the next"
msgstr "From one VM instruction to the next"

#. type: node
#: ../doc/vmgen.texi:83 ../doc/vmgen.texi:460 ../doc/vmgen.texi:463
#: ../doc/vmgen.texi:464 ../doc/vmgen.texi:545
#, no-wrap
msgid "Example overview"
msgstr "Example overview"

#. type: section
#: ../doc/vmgen.texi:83 ../doc/vmgen.texi:460 ../doc/vmgen.texi:463
#: ../doc/vmgen.texi:545 ../doc/vmgen.texi:546
#, no-wrap
msgid "Using profiling to create superinstructions"
msgstr "Using profiling to create superinstructions"

#. type: node
#: ../doc/vmgen.texi:91 ../doc/vmgen.texi:93 ../doc/vmgen.texi:616
#: ../doc/vmgen.texi:619 ../doc/vmgen.texi:620 ../doc/vmgen.texi:701
#: ../doc/vmgen.texi:758
#, no-wrap
msgid "Input File Grammar"
msgstr "Input File Grammar"

#. type: node
#: ../doc/vmgen.texi:91 ../doc/vmgen.texi:97 ../doc/vmgen.texi:616
#: ../doc/vmgen.texi:619 ../doc/vmgen.texi:758 ../doc/vmgen.texi:759
#: ../doc/vmgen.texi:860 ../doc/vmgen.texi:917 ../doc/vmgen.texi:992
#: ../doc/vmgen.texi:1053 ../doc/vmgen.texi:1081
#, no-wrap
msgid "Simple instructions"
msgstr "Simple instructions"

#. type: node
#: ../doc/vmgen.texi:91 ../doc/vmgen.texi:616 ../doc/vmgen.texi:758
#: ../doc/vmgen.texi:1081 ../doc/vmgen.texi:1082 ../doc/vmgen.texi:1144
#, no-wrap
msgid "Superinstructions"
msgstr "Superinstructions"

#. type: node
#: ../doc/vmgen.texi:91 ../doc/vmgen.texi:616 ../doc/vmgen.texi:1081
#: ../doc/vmgen.texi:1144 ../doc/vmgen.texi:1145 ../doc/vmgen.texi:1208
#, no-wrap
msgid "Store Optimization"
msgstr "Store Optimization"

#. type: section
#: ../doc/vmgen.texi:91 ../doc/vmgen.texi:616 ../doc/vmgen.texi:1144
#: ../doc/vmgen.texi:1208 ../doc/vmgen.texi:1209
#, no-wrap
msgid "Register Machines"
msgstr "Register Machines"

#. type: menuentry
#: ../doc/vmgen.texi:91 ../doc/vmgen.texi:616
msgid "How to define register VM instructions"
msgstr "How to define register VM instructions"

#. type: subsection
#: ../doc/vmgen.texi:95 ../doc/vmgen.texi:699 ../doc/vmgen.texi:701
#: ../doc/vmgen.texi:702
#, no-wrap
msgid "Eval escapes"
msgstr "Eval escapes"

#. type: menuentry
#: ../doc/vmgen.texi:95 ../doc/vmgen.texi:699
msgid "what follows \\E"
msgstr "what follows \\E"

#. type: node
#: ../doc/vmgen.texi:102 ../doc/vmgen.texi:857 ../doc/vmgen.texi:860
#: ../doc/vmgen.texi:861 ../doc/vmgen.texi:917
#, no-wrap
msgid "Explicit stack access"
msgstr "Explicit stack access"

#. type: menuentry
#: ../doc/vmgen.texi:102 ../doc/vmgen.texi:857
msgid "If the C code accesses a stack pointer"
msgstr "C言語コードからスタック・ポインターへアクセス"

#. type: node
#: ../doc/vmgen.texi:102 ../doc/vmgen.texi:857 ../doc/vmgen.texi:860
#: ../doc/vmgen.texi:917 ../doc/vmgen.texi:918 ../doc/vmgen.texi:992
#, no-wrap
msgid "C Code Macros"
msgstr "C Code Macros"

#. type: menuentry
#: ../doc/vmgen.texi:102 ../doc/vmgen.texi:857
msgid "Macros recognized by Vmgen"
msgstr "Vmgen が認識するマクロ"

#. type: node
#: ../doc/vmgen.texi:102 ../doc/vmgen.texi:857 ../doc/vmgen.texi:917
#: ../doc/vmgen.texi:992 ../doc/vmgen.texi:993 ../doc/vmgen.texi:1053
#, no-wrap
msgid "C Code restrictions"
msgstr "C Code restrictions"

#. type: menuentry
#: ../doc/vmgen.texi:102 ../doc/vmgen.texi:857
msgid "Vmgen makes assumptions about C code"
msgstr "Vmgen が仮定するC言語コード"

#. type: subsection
#: ../doc/vmgen.texi:102 ../doc/vmgen.texi:857 ../doc/vmgen.texi:992
#: ../doc/vmgen.texi:1053 ../doc/vmgen.texi:1054
#, no-wrap
msgid "Stack growth direction"
msgstr "Stack growth direction"

#. type: menuentry
#: ../doc/vmgen.texi:102 ../doc/vmgen.texi:857
msgid "is configurable per stack"
msgstr "is configurable per stack"

#. type: node
#: ../doc/vmgen.texi:111 ../doc/vmgen.texi:1341 ../doc/vmgen.texi:1344
#: ../doc/vmgen.texi:1345 ../doc/vmgen.texi:1574
#, no-wrap
msgid "VM engine"
msgstr "VM engine"

#. type: menuentry
#: ../doc/vmgen.texi:111 ../doc/vmgen.texi:1341
msgid "Executing VM code"
msgstr "Executing VM code"

#. type: node
#: ../doc/vmgen.texi:111 ../doc/vmgen.texi:1341 ../doc/vmgen.texi:1344
#: ../doc/vmgen.texi:1574 ../doc/vmgen.texi:1575 ../doc/vmgen.texi:1623
#, no-wrap
msgid "VM instruction table"
msgstr "VM instruction table"

#. type: node
#: ../doc/vmgen.texi:111 ../doc/vmgen.texi:175 ../doc/vmgen.texi:1341
#: ../doc/vmgen.texi:1574 ../doc/vmgen.texi:1623 ../doc/vmgen.texi:1624
#: ../doc/vmgen.texi:1625 ../doc/vmgen.texi:1700
#, no-wrap
msgid "VM code generation"
msgstr "VM code generation"

#. type: menuentry
#: ../doc/vmgen.texi:111 ../doc/vmgen.texi:1341
msgid "Creating VM code (in the front-end)"
msgstr "Creating VM code (in the front-end)"

#. type: node
#: ../doc/vmgen.texi:111 ../doc/vmgen.texi:1341 ../doc/vmgen.texi:1623
#: ../doc/vmgen.texi:1700 ../doc/vmgen.texi:1701 ../doc/vmgen.texi:1735
#, no-wrap
msgid "Peephole optimization"
msgstr "Peephole optimization"

#. type: menuentry
#: ../doc/vmgen.texi:111 ../doc/vmgen.texi:1341
msgid "Creating VM superinstructions"
msgstr "Creating VM superinstructions"

#. type: node
#: ../doc/vmgen.texi:111 ../doc/vmgen.texi:1341 ../doc/vmgen.texi:1700
#: ../doc/vmgen.texi:1735 ../doc/vmgen.texi:1736 ../doc/vmgen.texi:1737
#: ../doc/vmgen.texi:1776
#, no-wrap
msgid "VM disassembler"
msgstr "VM disassembler"

#. type: menuentry
#: ../doc/vmgen.texi:111 ../doc/vmgen.texi:1341
msgid "for debugging the front end"
msgstr "for debugging the front end"

#. type: cindex
#: ../doc/vmgen.texi:111 ../doc/vmgen.texi:1341 ../doc/vmgen.texi:1735
#: ../doc/vmgen.texi:1776 ../doc/vmgen.texi:1777 ../doc/vmgen.texi:1778
#, no-wrap
msgid "VM profiler"
msgstr "VM profiler"

#. type: menuentry
#: ../doc/vmgen.texi:111 ../doc/vmgen.texi:1341
msgid "for finding worthwhile superinstructions"
msgstr "for finding worthwhile superinstructions"

#. type: section
#: ../doc/vmgen.texi:115 ../doc/vmgen.texi:1873 ../doc/vmgen.texi:1876
#: ../doc/vmgen.texi:1877
#, no-wrap
msgid "Floating point"
msgstr "Floating point"

#. type: menuentry
#: ../doc/vmgen.texi:115 ../doc/vmgen.texi:1873
msgid "and stacks"
msgstr "and stacks"

#. type: appendixsec
#: ../doc/vmgen.texi:119 ../doc/vmgen.texi:2004 ../doc/vmgen.texi:2006
#: ../doc/vmgen.texi:2007
#, no-wrap
msgid "GNU Free Documentation License"
msgstr "GNU Free Documentation License"

#. type: menuentry
#: ../doc/vmgen.texi:119 ../doc/vmgen.texi:2004
msgid "License for copying this manual."
msgstr "License for copying this manual."

#. type: Plain text
#: ../doc/vmgen.texi:136
msgid ""
"Vmgen is a tool for writing efficient interpreters.  It takes a simple "
"virtual machine description and generates efficient C code for dealing with "
"the virtual machine code in various ways (in particular, executing it).  The "
"run-time efficiency of the resulting interpreters is usually within a factor "
"of 10 of machine code produced by an optimizing compiler."
msgstr ""
"Vmgen は、 効率的なインタープリターを作成するためのツールです。  これは、 単"
"純な仮想マシンの記述を受け取り、 さまざまな方法で仮想マシン・コードを処理する"
"(特に、 それを実行する)ための効率的な C 言語のコードを生成します。 その結果得"
"られるインタープリターの実行効率は、 最適化コンパイラーによって生成されるマシ"
"ンコードの10分の1以内に収まるのが普通です。"

#. type: Plain text
#: ../doc/vmgen.texi:139
msgid ""
"The interpreter design strategy supported by Vmgen is to divide the "
"interpreter into two parts:"
msgstr ""
"Vmgen がサポートするインタープリター設計戦略は、 インタープリターを以下の 2 "
"つの部分に分割することです:"

#. type: itemize
#: ../doc/vmgen.texi:148
msgid ""
"The @emph{front end} takes the source code of the language to be "
"implemented, and translates it into virtual machine code.  This is similar "
"to an ordinary compiler front end; typically an interpreter front-end "
"performs no optimization, so it is relatively simple to implement and runs "
"fast."
msgstr ""
"「フロント・エンド」は、 実装する言語のソース・コードを取得し、 それを仮想マ"
"シン・コードに変換します。  これは通常のコンパイラー・フロント・エンドに似て"
"います。 通常、 インタープリターのフロント・エンドは最適化を実行しないため、 "
"実装が比較的簡単で、 高速に実行されます。"

#. type: itemize
#: ../doc/vmgen.texi:152
msgid ""
"The @emph{virtual machine interpreter} executes the virtual machine code."
msgstr "「仮想マシン・インタープリター」は仮想マシン・コードを実行します。"

#. type: Plain text
#: ../doc/vmgen.texi:160
msgid ""
"Such a division is usually used in interpreters, for modularity as well as "
"for efficiency.  The virtual machine code is typically passed between front "
"end and virtual machine interpreter in memory, like in a load-and-go "
"compiler; this avoids the complexity and time cost of writing the code to a "
"file and reading it again."
msgstr ""
"このような分割は通常、 モジュール性と効率性のためにインタープリターで使用され"
"ます。  仮想マシン・コードは通常、 load-and-go コンパイラーのように、 フロン"
"ト・エンドとメモリ内の仮想マシン・インタープリターの間で受け渡されます。 これ"
"により、 コードをファイルに書き込んで再度読み取るという複雑さと時間のコストが"
"回避されます。"

#. type: Plain text
#: ../doc/vmgen.texi:165
msgid ""
"A @emph{virtual machine} (VM) represents the program as a sequence of "
"@emph{VM instructions}, following each other in memory, similar to real "
"machine code.  Control flow occurs through VM branch instructions, like in a "
"real machine."
msgstr ""
"「仮想マシン」(VM) は、 実際のマシン・コードと同様に、 メモリ内で相互に続く"
"「VM 命令」のシーケンスとしてプログラムを表します。  制御フローは、 実際のマ"
"シンと同様に、 VM 分岐命令を通じて発生します。"

#. type: cindex
#: ../doc/vmgen.texi:166
#, no-wrap
msgid "functionality features overview"
msgstr "functionality features overview"

#. type: Plain text
#: ../doc/vmgen.texi:170
msgid ""
"In this setup, Vmgen can generate most of the code dealing with virtual "
"machine instructions from a simple description of the virtual machine "
"instructions (@pxref{Input File Format}), in particular:"
msgstr ""
"このセットアップでは、 Vmgen は、 仮想マシン命令の簡単な記述(@pxref{Input "
"File Format})から仮想マシン命令を処理するほとんどのコードを生成できます。 特"
"に以下のようなものです:"

#. type: cindex
#: ../doc/vmgen.texi:173 ../doc/vmgen.texi:1346
#, no-wrap
msgid "VM instruction execution"
msgstr "VM instruction execution"

#. type: table
#: ../doc/vmgen.texi:177
msgid "Useful in the front end."
msgstr "フロント・エンドで役立ちます。"

#. type: item
#: ../doc/vmgen.texi:178
#, no-wrap
msgid "VM code decompiler"
msgstr "VM code decompiler"

#. type: table
#: ../doc/vmgen.texi:180
msgid "Useful for debugging the front end."
msgstr "フロント・エンドのデバッグに役立ちます。"

#. type: item
#: ../doc/vmgen.texi:181
#, no-wrap
msgid "VM code tracing"
msgstr "VM code tracing"

#. type: table
#: ../doc/vmgen.texi:185
msgid ""
"Useful for debugging the front end and the VM interpreter.  You will "
"typically provide other means for debugging the user's programs at the "
"source level."
msgstr ""
"フロント・エンドと VM インタープリターのデバッグに役立ちます。  あなたは、 通"
"常は、 ユーザーのプログラムをソース・レベルでデバッグするための他の手段を提供"
"するでしょう。"

#. type: item
#: ../doc/vmgen.texi:186
#, no-wrap
msgid "VM code profiling"
msgstr "VM code profiling"

#. type: table
#: ../doc/vmgen.texi:189
msgid ""
"Useful for optimizing the VM interpreter with superinstructions (@pxref{VM "
"profiler})."
msgstr ""
"スーパー命令(superinstructions)を使用して VM インタープリターを最適化するのに"
"役立ちます(@pxref{VM profiler})。"

#. type: Plain text
#: ../doc/vmgen.texi:195
msgid ""
"To create parts of the interpretive system that do not deal with VM "
"instructions, you have to use other tools (e.g., @command{bison}) and/or "
"hand-code them."
msgstr ""
"VM 命令を処理しないインタープリター・システムのパーツを作成するには、 他の"
"ツール(例: @command{bison})を使用するか、 手動でコーディングする必要がありま"
"す。"

#. type: cindex
#: ../doc/vmgen.texi:196
#, no-wrap
msgid "efficiency features overview"
msgstr "efficiency features overview"

#. type: Plain text
#: ../doc/vmgen.texi:200
msgid ""
"Vmgen supports efficient interpreters though various optimizations, in "
"particular"
msgstr ""
"Vmgen は、さまざまな最適化を通じて効率的なインタープリターをサポートします。 "
"特に"

#. type: item
#: ../doc/vmgen.texi:203
#, no-wrap
msgid "Threaded code"
msgstr "コードのスレッド化"

#. type: item
#: ../doc/vmgen.texi:205
#, no-wrap
msgid "Caching the top-of-stack in a register"
msgstr "TOSをレジスターにキャッシュ"

#. type: item
#: ../doc/vmgen.texi:207
#, no-wrap
msgid "Combining VM instructions into superinstructions"
msgstr "VM 命令をスーパー命令(superinstructions)に結合"

#. type: itemize
#: ../doc/vmgen.texi:212
msgid ""
"Replicating VM (super)instructions for better BTB prediction accuracy (not "
"yet in vmgen-ex, but already in Gforth)."
msgstr ""
"BTB 予測精度を向上させるために VM (スーパー) 命令を複製(vmgen-ex にはまだ含ま"
"れていませんが、 Gforth にはすでに含まれています)。"

#. type: cindex
#: ../doc/vmgen.texi:215
#, no-wrap
msgid "speed for JVM"
msgstr "speed for JVM"

#. type: Plain text
#: ../doc/vmgen.texi:224
msgid ""
"As a result, Vmgen-based interpreters are only about an order of magnitude "
"slower than native code from an optimizing C compiler on small benchmarks; "
"on large benchmarks, which spend more time in the run-time system, the "
"slowdown is often less (e.g., the slowdown of a Vmgen-generated JVM "
"interpreter over the best JVM JIT compiler we measured is only a factor of "
"2-3 for large benchmarks; some other JITs and all other interpreters we "
"looked at were slower than our interpreter)."
msgstr ""
"その結果、Vmgen ベースのインタープリターは、 小規模なベンチマークでは、 最適"
"化された C 言語コンパイラーからのネイティブ・コードよりも 1 桁ほど遅いだけで"
"す。 ランタイム・システムでより多くの時間を費やす大規模なベンチマークでは、 "
"多くの場合、 速度低下は少なくなります(たとえば、 Vmgen で生成された JVM イン"
"タープリターの速度の低下は、 大規模なベンチマークの場合、 測定した最高​​の JVM "
"JIT コンパイラーと比べてわずか 2 から 3 分の 1 です。 他のいくつかの JIT "
"と、 私たちが調べた他のすべてのインタープリターは、 私たちのインタープリター"
"よりも遅かったです)。"

#. type: Plain text
#: ../doc/vmgen.texi:230
msgid ""
"VMs are usually designed as stack machines (passing data between VM "
"instructions on a stack), and Vmgen supports such designs especially well; "
"however, you can also use Vmgen for implementing a register VM "
"(@pxref{Register Machines}) and still benefit from most of the advantages "
"offered by Vmgen."
msgstr ""
"VM は通常、 スタック・シン(VM 命令間のデータを受け渡しをスタック上で行う)とし"
"て設計されており、 Vmgen はそのような設計を特に適切にサポートします。 ただ"
"し、 Vmgen を使用して レジスター型 VM (@pxref{Register Machines}) を実装する"
"こともでき、 それでも Vmgen が提供する利点のほとんどを活用できます。"

#. type: Plain text
#: ../doc/vmgen.texi:235
msgid ""
"There are many potential uses of the instruction descriptions that are not "
"implemented at the moment, but we are open for feature requests, and we will "
"consider new features if someone asks for them; so the feature list above is "
"not exhaustive."
msgstr ""
"今現在では実装されていない命令記述(instruction descriptions)には多くの潜在的"
"な用途がありうるものと思います。 私達は機能のリクエストは受け付けており、 誰"
"かがリクエストした場合は新しい機能を検討します。 そのため、 上記の機能リスト"
"はすべてを網羅したものではありません。"

#. type: cindex
#: ../doc/vmgen.texi:239
#, no-wrap
msgid "interpreters, advantages"
msgstr "interpreters, advantages"

#. type: cindex
#: ../doc/vmgen.texi:240
#, no-wrap
msgid "advantages of interpreters"
msgstr "advantages of interpreters"

#. type: cindex
#: ../doc/vmgen.texi:241
#, no-wrap
msgid "advantages of vmgen"
msgstr "advantages of vmgen"

#. type: Plain text
#: ../doc/vmgen.texi:245
msgid ""
"Interpreters are a popular language implementation technique because they "
"combine all three of the following advantages:"
msgstr ""
"インタープリターは、 以下の 3 つの利点をすべて兼ね備えた、 人気のある言語実装"
"手法です:"

#. type: item
#: ../doc/vmgen.texi:248
#, no-wrap
msgid "Ease of implementation"
msgstr "実装の容易さ"

#. type: item
#: ../doc/vmgen.texi:250
#, no-wrap
msgid "Portability"
msgstr "移植性が高い"

#. type: item
#: ../doc/vmgen.texi:252
#, no-wrap
msgid "Fast edit-compile-run cycle"
msgstr "編集、コンパイル、実行のサイクルが速い"

#. type: Plain text
#: ../doc/vmgen.texi:257
msgid "Vmgen makes it even easier to implement interpreters."
msgstr "Vmgen を使用すると、 インタープリターの実装がさらに簡単になります。"

#. type: cindex
#: ../doc/vmgen.texi:258
#, no-wrap
msgid "speed of interpreters"
msgstr "speed of interpreters"

#. type: Plain text
#: ../doc/vmgen.texi:267
msgid ""
"The main disadvantage of interpreters is their run-time speed.  However, "
"there are huge differences between different interpreters in this area: the "
"slowdown over optimized C code on programs consisting of simple operations "
"is typically a factor of 10 for the more efficient interpreters, and a "
"factor of 1000 for the less efficient ones (the slowdown for programs "
"executing complex operations is less, because the time spent in libraries "
"for executing complex operations is the same in all implementation "
"strategies)."
msgstr ""
"インタープリターの主な欠点は、 実行速度です。 ただし、 実行速度の分野では、 "
"インタープリターごとに大きな違いがあります。 単純な操作で構成されるプログラム"
"上の最適化された C 言語コードの速度の低下は、 通常、 より効率的なインタープリ"
"ターでは 10 倍、 効率の低いインタープリタでは 1000 倍になります(複雑な操作を"
"実行するためのライブラリで費やされる時間はすべての実装戦略で同一であるため、 "
"複雑な操作を実行するプログラムの速度低下は少なくなります)。"

#. type: Plain text
#: ../doc/vmgen.texi:269
msgid "Vmgen supports techniques for building efficient interpreters."
msgstr ""
"Vmgen は、 効率的なインタープリターを構築するための手法をサポートしています。"

#. type: cindex
#: ../doc/vmgen.texi:283
#, no-wrap
msgid "modularization of interpreters"
msgstr "modularization of interpreters"

#. type: cindex
#: ../doc/vmgen.texi:285
#, no-wrap
msgid "front-end"
msgstr "front-end"

#. type: Plain text
#: ../doc/vmgen.texi:290
msgid ""
"Interpretive systems are typically divided into a @emph{front end} that "
"parses the input language and produces an intermediate representation for "
"the program, and an interpreter that executes the intermediate "
"representation of the program."
msgstr ""
"インタープリター・ステムは通常、 入力言語をパースしてプログラムの中間表現を生"
"成する「フロント・エンド」と、 プログラムの中間表現を実行するインタープリター"
"に分かれます。"

#. type: cindex
#: ../doc/vmgen.texi:291
#, no-wrap
msgid "virtual machine"
msgstr "virtual machine"

#. type: cindex
#: ../doc/vmgen.texi:292
#, no-wrap
msgid "VM"
msgstr "VM"

#. type: cindex
#: ../doc/vmgen.texi:293
#, no-wrap
msgid "VM instruction"
msgstr "VM instruction"

#. type: cindex
#: ../doc/vmgen.texi:294
#, no-wrap
msgid "instruction, VM"
msgstr "instruction, VM"

#. type: cindex
#: ../doc/vmgen.texi:295
#, no-wrap
msgid "VM branch instruction"
msgstr "VM branch instruction"

#. type: cindex
#: ../doc/vmgen.texi:296
#, no-wrap
msgid "branch instruction, VM"
msgstr "branch instruction, VM"

#. type: cindex
#: ../doc/vmgen.texi:297
#, no-wrap
msgid "VM register"
msgstr "VM register"

#. type: cindex
#: ../doc/vmgen.texi:298
#, no-wrap
msgid "register, VM"
msgstr "register, VM"

#. type: cindex
#: ../doc/vmgen.texi:299
#, no-wrap
msgid "opcode, VM instruction"
msgstr "opcode, VM instruction"

#. type: cindex
#: ../doc/vmgen.texi:300
#, no-wrap
msgid "immediate argument, VM instruction"
msgstr "immediate argument, VM instruction"

#. type: Plain text
#: ../doc/vmgen.texi:312
msgid ""
"For efficient interpreters the intermediate representation of choice is "
"virtual machine code (rather than, e.g., an abstract syntax tree).  "
"@emph{Virtual machine} (VM) code consists of VM instructions arranged "
"sequentially in memory; they are executed in sequence by the VM interpreter, "
"but VM branch instructions can change the control flow and are used for "
"implementing control structures.  The conceptual similarity to real machine "
"code results in the name @emph{virtual machine}.  Various terms similar to "
"terms for real machines are used; e.g., there are @emph{VM registers} (like "
"the instruction pointer and stack pointer(s)), and the VM instruction "
"consists of an @emph{opcode} and @emph{immediate arguments}."
msgstr ""
"効率的なインタープリターの場合、 選択される中間表現は(抽象構文ツリーなどでは"
"なく、 )仮想マシン・コードです。 「仮想仮想マシン」(VM) コードは、 メモリー内"
"に順番に配置された VM 命令で構成されます。 これらは VM インタープリターによっ"
"て順番に実行されますが、 VM 分岐命令は制御フローを変更することができ、 制御構"
"造の実装に使用されます。  実際のマシン・コードと概念的に類似しているため、 "
"「仮想マシン」という名前が付けられます。  実機の用語に類似したさまざまな用語"
"が使用されています。 たとえば、 「VM レジスター」(命令ポインターやスタック・"
"ポインターなど)があり、 VM 命令は 「オペコード」と 「直接引数」(immediate "
"arguments)で構成されます。"

#. type: Plain text
#: ../doc/vmgen.texi:318
msgid ""
"In this framework, Vmgen supports building the VM interpreter and any other "
"component dealing with VM instructions.  It does not have any support for "
"the front end, apart from VM code generation support.  The front end can be "
"implemented with classical compiler front-end techniques, supported by tools "
"like @command{flex} and @command{bison}."
msgstr ""
"このフレームワークでは、 Vmgen は VM インタープリターと、 VM 命令を処理するそ"
"の他のコンポーネントの構築をサポートします。  VM コード生成のサポートを除い"
"て、 フロント・エンドのサポートはありません。  フロント・エンドは、 "
"@command{flex} や @command{bison} などのツールでサポートされる、 従来のコンパ"
"イラー・フロント・エンド手法を使用して実装できます。"

#. type: Plain text
#: ../doc/vmgen.texi:325
msgid ""
"The intermediate representation is usually just internal to the interpreter, "
"but some systems also support saving it to a file, either as an image file, "
"or in a full-blown linkable file format (e.g., JVM).  Vmgen currently has no "
"special support for such features, but the information in the instruction "
"descriptions can be helpful, and we are open to feature requests and "
"suggestions."
msgstr ""
"中間表現は通常、 インタープリターの内部にのみ存在しますが、 一部のシステムで"
"は、 イメージ・ファイルとして、 または完全なリンク可能なファイル形式(JVM な"
"ど)でのファイルへの保存もサポートしています。  現在、 Vmgen ではそのような機"
"能に対する特別なサポートはありませんが、 命令記述に記載されている情報が役に立"
"つ可能性があります。 また、 私達は機能のリクエストや提案をお待ちしています。"

#. type: cindex
#: ../doc/vmgen.texi:330
#, no-wrap
msgid "stack machine"
msgstr "stack machine"

#. type: cindex
#: ../doc/vmgen.texi:331
#, no-wrap
msgid "register machine"
msgstr "register machine"

#. type: Plain text
#: ../doc/vmgen.texi:336
msgid ""
"Most VMs use one or more stacks for passing temporary data between VM "
"instructions.  Another option is to use a register machine architecture for "
"the virtual machine; we believe that using a stack architecture is usually "
"both simpler and faster."
msgstr ""
"ほとんどの VM は、 VM 命令間で一時データを渡すために 1 つ以上のスタックを使用"
"します。  私達は、 通常、 スタック・アーキテクチャを使用する方が簡単かつ高速"
"であると考えていますが、 もう一つのオプションとして、 仮想マシンにレジス"
"ター・マシン・アーキテクチャを使用することが考えられます。"

#. type: Plain text
#: ../doc/vmgen.texi:339
msgid ""
"However, this option is slower or significantly more complex to implement "
"than a stack machine architecture."
msgstr ""
"ただし、 このオプションはスタック・マシン・アーキテクチャよりも実装に時間がか"
"かるか、 非常に複雑です。"

#. type: Plain text
#: ../doc/vmgen.texi:342
msgid ""
"Vmgen has special support and optimizations for stack VMs, making their "
"implementation easy and efficient."
msgstr ""
"Vmgen にはスタック VM に対する特別なサポートと最適化があり、 スタック VM の実"
"装が簡単かつ効率的に行えます。"

#. type: Plain text
#: ../doc/vmgen.texi:345
msgid ""
"You can also implement a register VM with Vmgen (@pxref{Register Machines}), "
"and you will still profit from most Vmgen features."
msgstr ""
"また、 Vmgen (@pxref{Register Machines}) を使用して レジスター VM を実装する"
"こともできます。 その場合でも、 あなたは Vmgen のほとんどの機能を活用できま"
"す。"

#. type: cindex
#: ../doc/vmgen.texi:346
#, no-wrap
msgid "stack item size"
msgstr "stack item size"

#. type: cindex
#: ../doc/vmgen.texi:347
#, no-wrap
msgid "size, stack items"
msgstr "size, stack items"

#. type: Plain text
#: ../doc/vmgen.texi:353
msgid ""
"Stack items all have the same size, so they typically will be as wide as an "
"integer, pointer, or floating-point value.  Vmgen supports treating two "
"consecutive stack items as a single value, but anything larger is best kept "
"in some other memory area (e.g., the heap), with pointers to the data on the "
"stack."
msgstr ""
"スタック項目はすべて同一サイズなので、 通常は整数やポインターや浮動小数点数値"
"は同じサイズ幅になります。  Vmgen は、 2 つの連続したスタック項目を単一の値と"
"して扱うことをサポートしていますが、 それより大きいものは、 スタックに置い"
"た、 データへのポインターを使用して、 他のメモリ領域(ヒープなど)に保持するの"
"が最適です。"

#. type: cindex
#: ../doc/vmgen.texi:354 ../doc/vmgen.texi:844
#, no-wrap
msgid "instruction stream"
msgstr "instruction stream"

#. type: cindex
#: ../doc/vmgen.texi:355
#, no-wrap
msgid "immediate arguments"
msgstr "immediate arguments"

#. type: Plain text
#: ../doc/vmgen.texi:359
msgid ""
"Another source of data is immediate arguments VM instructions (in the VM "
"instruction stream).  The VM instruction stream is handled similar to a "
"stack in Vmgen."
msgstr ""
"もう 1 つのデータ源は、 (VM 命令ストリーム内の) 即時引数 VM 命令達(immediate "
"arguments VM instructions)です。 VM 命令ストリームは、 Vmgen のスタックと同様"
"に処理されます。"

#. type: cindex
#: ../doc/vmgen.texi:360
#, no-wrap
msgid "garbage collection"
msgstr "garbage collection"

#. type: cindex
#: ../doc/vmgen.texi:361
#, no-wrap
msgid "reference counting"
msgstr "reference counting"

#. type: Plain text
#: ../doc/vmgen.texi:369
msgid ""
"Vmgen has no built-in support for, nor restrictions against @emph{garbage "
"collection}.  If you need garbage collection, you need to provide it in your "
"run-time libraries.  Using @emph{reference counting} is probably harder, but "
"might be possible (contact us if you are interested)."
msgstr ""
"Vmgen には、 「ガーベジ・コレクション」に対するサポートも制限も組み込まれてい"
"ません。  ガベージ・コレクションが必要な場合は、 ランタイム・ライブラリでそれ"
"を提供する必要があります。  「参照カウント」(reference counting)を使用するの"
"はおそらく困難、 可能な場合もあります(興味がある場合は私達にお問い合わせくだ"
"さい)。"

#. type: cindex
#: ../doc/vmgen.texi:373
#, no-wrap
msgid "Dispatch of VM instructions"
msgstr "Dispatch of VM instructions"

#. type: cindex
#: ../doc/vmgen.texi:374
#, no-wrap
msgid "main interpreter loop"
msgstr "main interpreter loop"

#. type: Plain text
#: ../doc/vmgen.texi:378
msgid ""
"Understanding this section is probably not necessary for using Vmgen, but it "
"may help.  You may want to skip it now, and read it if you find statements "
"about dispatch methods confusing."
msgstr ""
"Vmgen を使用する場合、 このセクションを理解する必要はおそらくありませんが、 "
"役立つ場合もあります。 ここでスキップして、 あとでディスパッチ方法に関する記"
"述がわかりにくい場合にこのセクションを読むといいでしょう。"

#. type: Plain text
#: ../doc/vmgen.texi:382
msgid ""
"After executing one VM instruction, the VM interpreter has to dispatch the "
"next VM instruction (Vmgen calls the dispatch routine @samp{NEXT}).  Vmgen "
"supports two methods of dispatch:"
msgstr ""
"1 つの VM 命令を実行した後、 VM インタープリターは次の VM 命令にディスパッチ"
"(dispatch;切り替え作業)する必要があります(Vmgen はディスパッチ・ルーチン"
"「NEXT」を呼び出します)。  Vmgen は 2 つのディスパッチ方法をサポートしていま"
"す:"

#. type: cindex
#: ../doc/vmgen.texi:385 ../doc/vmgen.texi:386
#, no-wrap
msgid "switch dispatch"
msgstr "switch dispatch"

#. type: table
#: ../doc/vmgen.texi:394
msgid ""
"In this method the VM interpreter contains a giant @code{switch} statement, "
"with one @code{case} for each VM instruction.  The VM instruction opcodes "
"are represented by integers (e.g., produced by an @code{enum}) in the VM "
"code, and dispatch occurs by loading the next opcode, @code{switch}ing on "
"it, and continuing at the appropriate @code{case}; after executing the VM "
"instruction, the VM interpreter jumps back to the dispatch code."
msgstr ""
"この方法では、 VM インタープリターに巨大な @code{switch} ステートメントが含ま"
"れており、 VM 命令ごとに 1 つの @code{case} があります。  VM 命令のオペコード"
"は、 VM コード内の整数(@code{enum} によって生成されるなどする)によって表さ"
"れ、 ディスパッチは、 次のオペコードをロードし、 @code{switch} して、 適切な "
"@code{case} で続行することによって行います。 VM 命令の実行後、 VM インタープ"
"リタはディスパッチ・コードに戻ります。"

#. type: cindex
#: ../doc/vmgen.texi:395 ../doc/vmgen.texi:396
#, no-wrap
msgid "threaded code"
msgstr "threaded code"

#. type: table
#: ../doc/vmgen.texi:405
msgid ""
"This method represents a VM instruction opcode by the address of the start "
"of the machine code fragment for executing the VM instruction.  Dispatch "
"consists of loading this address, jumping to it, and incrementing the VM "
"instruction pointer.  Typically the threaded-code dispatch code is appended "
"directly to the code for executing the VM instruction.  Threaded code cannot "
"be implemented in ANSI C, but it can be implemented using GNU C's labels-as-"
"values extension (@pxref{Labels as Values, , Labels as Values, gcc.info, GNU "
"C Manual})."
msgstr ""
"このメソッドは、 VM 命令を実行するためのマシン・コード断片の開始アドレスに"
"よって VM 命令オペコードを表します。 ディスパッチ(切り替え作業)は、 このアド"
"レスのロードと、 そこへのジャンプと VM 命令ポインターのインクリメントで構成さ"
"れます。  通常、 スレッド化コードのディスパッチ・コードは、 VM 命令を実行する"
"コードに直接追加されます。  スレッド化コードは ANSI C では実装できませんが、 "
"GNU C の label-as-values 拡張機能を使用して実装できます(@pxref{Labels as "
"Values, , Labels as Values, gcc.info, GNU C Manual})。"

#. type: Plain text
#: ../doc/vmgen.texi:411
msgid ""
"Threaded code can be twice as fast as switch dispatch, depending on the "
"interpreter, the benchmark, and the machine."
msgstr ""
"インタープリターやベンチマークやマシンによっては、 スレッド化コードはスイッ"
"チ・ディスパッチより 2 倍早くなることがあります。"

#. type: Plain text
#: ../doc/vmgen.texi:418
msgid "The usual way to invoke Vmgen is as follows:"
msgstr "Vmgen を呼び出す通常の方法は以下のとおりです:"

#. type: example
#: ../doc/vmgen.texi:421
#, no-wrap
msgid "vmgen @var{inputfile}\n"
msgstr "vmgen @var{inputfile}\n"

#. type: Plain text
#: ../doc/vmgen.texi:432
msgid ""
"Here @var{inputfile} is the VM instruction description file, which usually "
"ends in @file{.vmg}.  The output filenames are made by taking the basename "
"of @file{inputfile} (i.e., the output files will be created in the current "
"working directory) and replacing @file{.vmg} with @file{-vm.i}, @file{-"
"disasm.i}, @file{-gen.i}, @file{-labels.i}, @file{-profile.i}, and @file{-"
"peephole.i}.  E.g., @command{vmgen hack/foo.vmg} will create @file{foo-vm."
"i}, @file{foo-disasm.i}, @file{foo-gen.i}, @file{foo-labels.i}, @file{foo-"
"profile.i} and @file{foo-peephole.i}."
msgstr ""
"ここで @var{inputfile} は VM 命令記述ファイルで、 通常は @file{.vmg} で終わり"
"ます。  それぞれの出力ファイル名は、 @file{inputfile} のベース名を取得し(つま"
"り、 出力ファイルは現在の作業ディレクトリに作成されます)、 @file{.vmg} の部分"
"を、 @file{-vm.i} と @file{-disasm.i} と @file{-gen.i} と  @file{-labels.i} "
"と @file{-profile.i} と @file{-peephole.i} とにに置き換えることによって作成さ"
"れます。 たとえば、@command{vmgen hack/foo.vmg} なら、 @file{foo-vm.i} と "
"@file{foo-disasm.i} と @file{foo-gen.i} と @file{foo-labels.i} と @file{foo-"
"profile.i} と @file{foo-peephole.i} を作成します。"

#. type: Plain text
#: ../doc/vmgen.texi:434
msgid "The command-line options supported by Vmgen are"
msgstr "Vmgen でサポートされるコマンドライン・オプションは以下のとおりです"

#. type: cindex
#: ../doc/vmgen.texi:437
#, no-wrap
msgid "-h, command-line option"
msgstr "-h, command-line option"

#. type: cindex
#: ../doc/vmgen.texi:438
#, no-wrap
msgid "--help, command-line option"
msgstr "--help, command-line option"

#. type: item
#: ../doc/vmgen.texi:439
#, no-wrap
msgid "--help"
msgstr "--help"

#. type: itemx
#: ../doc/vmgen.texi:440
#, no-wrap
msgid "-h"
msgstr "-h"

#. type: table
#: ../doc/vmgen.texi:442
msgid "Print a message about the command-line options"
msgstr "コマンドライン・オプションに関するメッセージを出力します"

#. type: cindex
#: ../doc/vmgen.texi:443
#, no-wrap
msgid "-v, command-line option"
msgstr "-v, command-line option"

#. type: cindex
#: ../doc/vmgen.texi:444
#, no-wrap
msgid "--version, command-line option"
msgstr "--version, command-line option"

#. type: item
#: ../doc/vmgen.texi:445
#, no-wrap
msgid "--version"
msgstr "--version"

#. type: itemx
#: ../doc/vmgen.texi:446
#, no-wrap
msgid "-v"
msgstr "-v"

#. type: table
#: ../doc/vmgen.texi:448
msgid "Print version and exit"
msgstr "バージョンを出力して終了(exit)"

#. type: cindex
#: ../doc/vmgen.texi:455
#, no-wrap
msgid "example of a Vmgen-based interpreter"
msgstr "example of a Vmgen-based interpreter"

#. type: cindex
#: ../doc/vmgen.texi:465
#, no-wrap
msgid "example overview"
msgstr "example overview"

#. type: file{#1}
#: ../doc/vmgen.texi:466
#, no-wrap
msgid "vmgen-ex"
msgstr "vmgen-ex"

#. type: file{#1}
#: ../doc/vmgen.texi:467
#, no-wrap
msgid "vmgen-ex2"
msgstr "vmgen-ex2"

#. type: Plain text
#: ../doc/vmgen.texi:474
msgid ""
"There are two versions of the same example for using Vmgen: @file{vmgen-ex} "
"and @file{vmgen-ex2} (you can also see Gforth as example, but it uses "
"additional (undocumented) features, and also differs in some other "
"respects).  The example implements @emph{mini}, a tiny Modula-2-like "
"language with a small JavaVM-like virtual machine."
msgstr ""
"Vmgen を使用する同一の例として、 @file{vmgen-ex} と @file{vmgen-ex2} の 2 つ"
"のバージョンがあります(例として Gforth もありますが、 追加の(文書化されていな"
"い)機能が使用されており、 他のいくつかの点でも異なります)。  この例では、 "
"JavaVM のような小さな仮想マシンを備えた小さな Modula-2 のような言語である"
"「mini」言語を実装しています。"

#. type: Plain text
#: ../doc/vmgen.texi:480
msgid ""
"The difference between the examples is that @file{vmgen-ex} uses many casts, "
"and @file{vmgen-ex2} tries to avoids most casts and uses unions instead.  In "
"the rest of this manual we usually mention just files in @file{vmgen-ex}; if "
"you want to use unions, use the equivalent file in @file{vmgen-ex2}."
msgstr ""
"2つの例の違いは、 @file{vmgen-ex} は多くのキャスト(cast)を使用するのに対し、 "
"@file{vmgen-ex2} はほとんどのキャストを回避し、 代わりに共用体(unions)を使用"
"することです。  このマニュアルの残りの部分では、 通常、 @file{vmgen-ex} 内の"
"ファイルについてのみ言及します。 共用体(union)を使用したい場合は、 "
"@file{vmgen-ex2} 内の同等のファイルを使用してください。"

#. type: cindex
#: ../doc/vmgen.texi:480
#, no-wrap
msgid "unions example"
msgstr "unions example"

#. type: cindex
#: ../doc/vmgen.texi:481
#, no-wrap
msgid "casts example"
msgstr "casts example"

#. type: Plain text
#: ../doc/vmgen.texi:484
msgid "The files provided with each example are:"
msgstr "各例で提供されるファイルは以下のとおりです:"

#. type: cindex
#: ../doc/vmgen.texi:484
#, no-wrap
msgid "example files"
msgstr "example files"

#. type: example
#: ../doc/vmgen.texi:506
#, no-wrap
msgid ""
"Makefile\n"
"README\n"
"disasm.c           wrapper file\n"
"engine.c           wrapper file\n"
"peephole.c         wrapper file\n"
"profile.c          wrapper file\n"
"mini-inst.vmg      simple VM instructions\n"
"mini-super.vmg     superinstructions (empty at first)\n"
"mini.h             common declarations\n"
"mini.l             scanner\n"
"mini.y             front end (parser, VM code generator)\n"
"support.c          main() and other support functions\n"
"fib.mini           example mini program\n"
"simple.mini        example mini program\n"
"test.mini          example mini program (tests everything)\n"
"test.out           test.mini output\n"
"stat.awk           script for aggregating profile information\n"
"peephole-blacklist list of instructions not allowed in superinstructions\n"
"seq2rule.awk       script for creating superinstructions\n"
msgstr ""
"Makefile\n"
"README\n"
"disasm.c           wrapper file\n"
"engine.c           wrapper file\n"
"peephole.c         wrapper file\n"
"profile.c          wrapper file\n"
"mini-inst.vmg      simple VM instructions\n"
"mini-super.vmg     superinstructions (empty at first)\n"
"mini.h             common declarations\n"
"mini.l             scanner\n"
"mini.y             front end (parser, VM code generator)\n"
"support.c          main() and other support functions\n"
"fib.mini           example mini program\n"
"simple.mini        example mini program\n"
"test.mini          example mini program (tests everything)\n"
"test.out           test.mini output\n"
"stat.awk           プロファイル情報を集約するためのスクリプト\n"
"peephole-blacklist スーパー命令で許可されない命令のリスト\n"
"seq2rule.awk       スーパー命令を生成するためのスクリプト\n"

#. type: Plain text
#: ../doc/vmgen.texi:510
msgid ""
"For your own interpreter, you would typically copy the following files and "
"change little, if anything:"
msgstr ""
"あなた独自のインタープリターを作る場合、 通常、 以下のファイル群はコピーして"
"使い、 変更することはほとんどないでしょう:"

#. type: cindex
#: ../doc/vmgen.texi:510
#, no-wrap
msgid "wrapper files"
msgstr "wrapper files"

#. type: example
#: ../doc/vmgen.texi:519
#, no-wrap
msgid ""
"disasm.c           wrapper file\n"
"engine.c           wrapper file\n"
"peephole.c         wrapper file\n"
"profile.c          wrapper file\n"
"stat.awk           script for aggregating profile information\n"
"seq2rule.awk       script for creating superinstructions\n"
msgstr ""
"disasm.c           wrapper file\n"
"engine.c           wrapper file\n"
"peephole.c         wrapper file\n"
"profile.c          wrapper file\n"
"stat.awk           プロファイル情報を集約するためのスクリプト\n"
"seq2rule.awk       スーパー命令を生成するためのスクリプト\n"

#. type: Plain text
#: ../doc/vmgen.texi:523
msgid "You would typically change much in or replace the following files:"
msgstr ""
"そして、 通常、 あなたは、 以下のファイル群を大幅に変更するか、 置き換える事"
"になります:"

#. type: example
#: ../doc/vmgen.texi:532
#, no-wrap
msgid ""
"Makefile\n"
"mini-inst.vmg      simple VM instructions\n"
"mini.h             common declarations\n"
"mini.l             scanner\n"
"mini.y             front end (parser, VM code generator)\n"
"support.c          main() and other support functions\n"
"peephole-blacklist list of instructions not allowed in superinstructions\n"
msgstr ""
"Makefile\n"
"mini-inst.vmg      simple VM instructions\n"
"mini.h             common declarations\n"
"mini.l             scanner\n"
"mini.y             front end (parser, VM code generator)\n"
"support.c          main() and other support functions\n"
"peephole-blacklist スーパー命令で許可されない命令のリスト\n"

# ~/work/gforth-docs-ja/vmgen-ex
# $ sudo apt install flex
# $ sudo apt install bison (手元ではインストール済だった)
# $ make
#
# $ ./mini -h
# Usage: ./mini [options] file
# Options:
# -h      Print this message and exit
# -d      disassemble VM program before execution
# -p      profile VM code sequences (output on stderr)
# -t      trace VM code execution (output on stderr)
#
# $ ./mini simple.mini
# result = 1
#   
# $ make check
# ./mini test.mini | tr -d '\015' | diff - test.out
#
# $ ./mini fib.mini
# result = 5702887
#. type: Plain text
#: ../doc/vmgen.texi:537
msgid ""
"You can build the example by @code{cd}ing into the example's directory, and "
"then typing @code{make}; you can check that it works with @code{make "
"check}.  You can run run mini programs like this:"
msgstr ""
"example のディレクトリに @code{cd} してから @code{make} と入力すると、 "
"example をビルドできます。  @code{make check} で動作することを確認できま"
"す。  以下のようにして mini 言語のプログラムを実行できます:"

#. type: example
#: ../doc/vmgen.texi:540
#, no-wrap
msgid "./mini fib.mini\n"
msgstr "./mini fib.mini\n"

#. type: Plain text
#: ../doc/vmgen.texi:543
msgid "To learn about the options, type @code{./mini -h}."
msgstr "オプションについて詳しくは、 @code{./mini -h} と入力してください。"

#. type: cindex
#: ../doc/vmgen.texi:547
#, no-wrap
msgid "profiling example"
msgstr "profiling example"

#. type: cindex
#: ../doc/vmgen.texi:548
#, no-wrap
msgid "superinstructions example"
msgstr "superinstructions example"

#. type: Plain text
#: ../doc/vmgen.texi:554
msgid ""
"I have not added rules for this in the @file{Makefile} (there are many "
"options for selecting superinstructions, and I did not want to hardcode one "
"into the @file{Makefile}), but there are some supporting scripts, and here's "
"an example:"
msgstr ""
"作者は @file{Makefile} には、 プロファイリングを使用してスーパー命令を作成す"
"るためのルールを追加していません(スーパー命令選択の選択肢はたくさんあります"
"が、 それらの選択肢を @file{Makefile} にハードコードしたくありませんでした)"
"が、 サポートするスクリプトがいくつかあります。 例:"

#. type: Plain text
#: ../doc/vmgen.texi:557
msgid ""
"Suppose you want to use @file{fib.mini} and @file{test.mini} as training "
"programs, you get the profiles like this:"
msgstr ""
"@file{fib.mini} と @file{test.mini} をトレーニング・プログラムとして使用する"
"と、 以下のようなプロファイルが得られます:"

#. type: example
#: ../doc/vmgen.texi:560
#, no-wrap
msgid "make fib.prof test.prof #takes a few seconds\n"
msgstr "make fib.prof test.prof #数秒かかります\n"

#. type: Plain text
#: ../doc/vmgen.texi:563
msgid "You can aggregate these profiles with @file{stat.awk}:"
msgstr "これらのプロファイルは @file{stat.awk} で集約できます:"

#. type: example
#: ../doc/vmgen.texi:566
#, no-wrap
msgid "awk -f stat.awk fib.prof test.prof\n"
msgstr "awk -f stat.awk fib.prof test.prof\n"

#. type: Plain text
#: ../doc/vmgen.texi:569
msgid "The result contains lines like:"
msgstr "結果には以下のような行が含まれます:"

#. type: example
#: ../doc/vmgen.texi:572
#, no-wrap
msgid "      2      16        36910041 loadlocal lit\n"
msgstr "      2      16        36910041 loadlocal lit\n"

#. type: Plain text
#: ../doc/vmgen.texi:577
msgid ""
"This means that the sequence @code{loadlocal lit} statically occurs a total "
"of 16 times in 2 profiles, with a dynamic execution count of 36910041."
msgstr ""
"これは、 シーケンス @code{loadlocal lit} が 2 つのプロファイルで合計 16 回静"
"的に発生し、 動的実行数が 36910041 であることを意味します。"

#. type: Plain text
#: ../doc/vmgen.texi:581
msgid ""
"The numbers can be used in various ways to select superinstructions.  E.g., "
"if you just want to select all sequences with a dynamic execution count "
"exceeding 10000, you would use the following pipeline:"
msgstr ""
"数値はスーパー命令を選択するためにさまざまな方法で使用できます。  たとえば、 "
"動的実行数が 10000 を超えるシーケンスをすべて選択したい場合は、 以下のパイプ"
"ラインを使用します:"

#. type: example
#: ../doc/vmgen.texi:588
#, no-wrap
msgid ""
"awk -f stat.awk fib.prof test.prof|\n"
"awk '$3>=10000'|                #select sequences\n"
"fgrep -v -f peephole-blacklist| #eliminate wrong instructions\n"
"awk -f seq2rule.awk|  #transform sequences into superinstruction rules\n"
"sort -k 3 >mini-super.vmg       #sort sequences\n"
msgstr ""
"awk -f stat.awk fib.prof test.prof|\n"
"awk '$3>=10000'|                #シーケンスを選択\n"
"fgrep -v -f peephole-blacklist| #良くない命令を排除\n"
"awk -f seq2rule.awk|  #シーケンスをスーパー命令ルールに変換\n"
"sort -k 3 >mini-super.vmg       #シーケンスを並べ替え\n"

#. type: Plain text
#: ../doc/vmgen.texi:594
msgid ""
"The file @file{peephole-blacklist} contains all instructions that directly "
"access a stack or stack pointer (for mini: @code{call}, @code{return}); the "
"sort step is necessary to ensure that prefixes precede larger "
"superinstructions."
msgstr ""
"ファイル @file{peephole-blacklist} には、スタックまたはスタック・ポインター"
"(mini 言語の場合: @code{call} 、@code{return})に直接アクセスするすべての命令"
"が含まれています。 並べ替え手順は、 プレフィックスが、 大きなスーパー命令より"
"も前に配置されるようにするために必要です。"

#. type: Plain text
#: ../doc/vmgen.texi:597
msgid ""
"Now you can create a version of mini with superinstructions by just saying "
"@samp{make}"
msgstr ""
"いまや、 あなたは @samp{make} と言うだけでスーパー命令を備えたバージョンの "
"mini 言語を作成できるようになりました。"

#. type: cindex
#: ../doc/vmgen.texi:602
#, no-wrap
msgid "input file format"
msgstr "input file format"

#. type: cindex
#: ../doc/vmgen.texi:603
#, no-wrap
msgid "format, input file"
msgstr "format, input file"

#. type: Plain text
#: ../doc/vmgen.texi:607
msgid ""
"Vmgen takes as input a file containing specifications of virtual machine "
"instructions.  This file usually has a name ending in @file{.vmg}."
msgstr ""
"Vmgen は、 仮想マシン命令の仕様を含むファイルを入力として受け取ります。  通"
"常、 このファイルの名前は @file{.vmg} で終わります。"

#. type: Plain text
#: ../doc/vmgen.texi:609
msgid "Most examples are taken from the example in @file{vmgen-ex}."
msgstr "ほとんどの例は @file{vmgen-ex} のを使っています。"

#. type: cindex
#: ../doc/vmgen.texi:621
#, no-wrap
msgid "grammar, input file"
msgstr "grammar, input file"

#. type: cindex
#: ../doc/vmgen.texi:622
#, no-wrap
msgid "input file grammar"
msgstr "input file grammar"

#. type: Plain text
#: ../doc/vmgen.texi:627
msgid ""
"The grammar is in EBNF format, with @code{@var{a}|@var{b}} meaning ``@var{a} "
"or @var{b}'', @code{@{@var{c}@}} meaning 0 or more repetitions of @var{c} "
"and @code{[@var{d}]} meaning 0 or 1 repetitions of @var{d}."
msgstr ""
"文法は EBNF 形式で、 @code{@var{a}|@var{b}} は「@var{a} または @var{b}」、 "
"@code{@{@var{c}@}} は @var{c} の 0 回以上の繰り返しを意味し、 "
"@code{[@var{d}]} は @var{d} の 0 回または 1 回の繰り返しを意味します。"

#. type: cindex
#: ../doc/vmgen.texi:628
#, no-wrap
msgid "free-format, not"
msgstr "free-format, not"

#. type: cindex
#: ../doc/vmgen.texi:629
#, no-wrap
msgid "newlines, significance in syntax"
msgstr "newlines, significance in syntax"

#. type: Plain text
#: ../doc/vmgen.texi:632
msgid ""
"Vmgen input is not free-format, so you have to take care where you put "
"newlines (and, in a few cases, white space)."
msgstr ""
"Vmgen の入力は自由書式ではないため、 改行(および場合によっては空白)をどこに入"
"れるかに注意する必要があります。"

#. type: example
#: ../doc/vmgen.texi:635
#, no-wrap
msgid ""
"description: @{instruction|comment|eval-escape|c-escape@}\n"
"\n"
msgstr ""
"description: @{instruction|comment|eval-escape|c-escape@}\n"
"\n"

#. type: example
#: ../doc/vmgen.texi:637
#, no-wrap
msgid ""
"instruction: simple-inst|superinst\n"
"\n"
msgstr ""
"instruction: simple-inst|superinst\n"
"\n"

#. type: example
#: ../doc/vmgen.texi:639
#, no-wrap
msgid ""
"simple-inst: ident '(' stack-effect ')' newline c-code newline newline\n"
"\n"
msgstr ""
"simple-inst: ident '(' stack-effect ')' newline c-code newline newline\n"
"\n"

#. type: example
#: ../doc/vmgen.texi:641
#, no-wrap
msgid ""
"stack-effect: @{ident@} '--' @{ident@}\n"
"\n"
msgstr ""
"stack-effect: @{ident@} '--' @{ident@}\n"
"\n"

#. type: example
#: ../doc/vmgen.texi:643
#, no-wrap
msgid ""
"super-inst: ident '=' ident @{ident@}  \n"
"\n"
msgstr ""
"super-inst: ident '=' ident @{ident@}  \n"
"\n"

#. type: example
#: ../doc/vmgen.texi:645
#, no-wrap
msgid ""
"comment:      '\\ '  text newline\n"
"\n"
msgstr ""
"comment:      '\\ '  text newline\n"
"\n"

#. type: example
#: ../doc/vmgen.texi:647
#, no-wrap
msgid ""
"eval-escape:  '\\E ' text newline\n"
"\n"
msgstr ""
"eval-escape:  '\\E ' text newline\n"
"\n"

#. type: example
#: ../doc/vmgen.texi:649
#, no-wrap
msgid "c-escape:     '\\C ' text newline\n"
msgstr "c-escape:     '\\C ' text newline\n"

#. type: Plain text
#: ../doc/vmgen.texi:654
msgid ""
"Note that the @code{\\}s in this grammar are meant literally, not as C-style "
"encodings for non-printable characters."
msgstr ""
"注意: この文法の @code{\\} は、 印刷不可能な文字の C 言語スタイルのエンコー"
"ディングではなく、 文字通りの意味であることに注意してください。"

#. type: Plain text
#: ../doc/vmgen.texi:656
msgid "There are two ways to delimit the C code in @code{simple-inst}:"
msgstr ""
"@code{simple-inst} で C 言語コードを区切る(delimit)方法は 2 つあります:"

#. type: itemize
#: ../doc/vmgen.texi:665
msgid ""
"If you start it with a @samp{@{} at the start of a line (i.e., not even "
"white space before it), you have to end it with a @samp{@}} at the start of "
"a line (followed by a newline).  In this case you may have empty lines "
"within the C code (typically used between variable definitions and "
"statements)."
msgstr ""
"行頭が @samp{@{} で始まる場合(つまり、 その前に空白も無い場合)、 (改行に続い"
"て)行頭の @samp{@}} で終了する必要があります。  この場合、 C 言語コード内に空"
"行が含まれる可能性があります(通常、 変数定義とステートメントの間で使用されま"
"す)。"

#. type: itemize
#: ../doc/vmgen.texi:669
msgid ""
"You do not start it with @samp{@{}.  Then the C code ends at the first empty "
"line, so you cannot have empty lines within this code."
msgstr ""
"@samp{@{} で始めない場合。 この場合、 C 言語コードは最初の空行で終了するた"
"め、 このコード内に空行を含めることはできません。"

#. type: Plain text
#: ../doc/vmgen.texi:677
msgid ""
"The text in @code{comment}, @code{eval-escape} and @code{c-escape} must not "
"contain a newline.  @code{Ident} must conform to the usual conventions of C "
"identifiers (otherwise the C compiler would choke on the Vmgen output), "
"except that idents in @code{stack-effect} may have a stack prefix (for stack "
"prefix syntax, @pxref{Eval escapes})."
msgstr ""
"@code{comment} と @code{eval-escape} と @code{c-escape} 内の text には改行を"
"含めることはできません。  @code{Ide​​nt} は、 C 言語識別子の通常の規則に準拠す"
"る必要があります(そうしないと、 Vmgen 出力で C 言語のコンパイラーが詰まり"
"(choke)ます)。 @code{Ide​​nt} は、 @code{stack-effect} の ident にスタック・プ"
"レフィックス(スタック・プレフィックス構文については @pxref{Eval escapes} 参"
"照)が付いている場合がある点を除き、 C 言語識別子の通常の規則に準拠する必要が"
"あります。"

#. type: cindex
#: ../doc/vmgen.texi:678
#, no-wrap
msgid "C escape"
msgstr "C escape"

#. type: code{#1}
#: ../doc/vmgen.texi:679
#, no-wrap
msgid "\\C"
msgstr "\\C"

#. type: cindex
#: ../doc/vmgen.texi:680
#, no-wrap
msgid "conditional compilation of Vmgen output"
msgstr "conditional compilation of Vmgen output"

#. type: Plain text
#: ../doc/vmgen.texi:684
msgid ""
"The @code{c-escape} passes the text through to each output file (without the "
"@samp{\\C}).  This is useful mainly for conditional compilation (i.e., you "
"write @samp{\\C #if ...} etc.)."
msgstr ""
"@code{c-escape} は text を各出力ファイルに渡します(@samp{\\C} 無しで)。  これ"
"は主に条件付きコンパイルに役立ちます(つまり、 @samp{\\C #if ...} などを記述し"
"ます)。"

#. type: cindex
#: ../doc/vmgen.texi:685
#, no-wrap
msgid "sync lines"
msgstr "sync lines"

#. type: code{#1}
#: ../doc/vmgen.texi:686
#, no-wrap
msgid "#line"
msgstr "#line"

#. type: Plain text
#: ../doc/vmgen.texi:692
msgid ""
"In addition to the syntax given in the grammer, Vmgen also processes sync "
"lines (lines starting with @samp{#line}), as produced by @samp{m4 -s} "
"(@pxref{Invoking m4, , Invoking m4, m4.info, GNU m4}) and similar tools.  "
"This allows associating C compiler error messages with the original source "
"of the C code."
msgstr ""
"文法で指定された構文に加えて、 Vmgen は @samp{m4 -s} (@pxref{Invoking m4, , "
"Invoking m4, m4.info, GNU m4})や、 同様のツールによって生成された同期行(sync "
"lines)(@samp{#line} で始まる行)も処理します。 これにより、 C 言語コンパイラー"
"のエラー・メッセージを C 言語コードの元のソースに関連付けることができます。"

#. type: Plain text
#: ../doc/vmgen.texi:696
msgid ""
"Vmgen understands a few extensions beyond the grammar given here, but these "
"extensions are only useful for building Gforth.  You can find a description "
"of the format used for Gforth in @file{prim}."
msgstr ""
"Vmgen は、 ここで説明した文法を超えたいくつかの拡張機能を理解しますが、 これ"
"らの拡張機能は Gforth を構築する場合にのみ役立ちます。  Gforth に使用される書"
"式の説明は @file{prim} にあります。"

#. type: cindex
#: ../doc/vmgen.texi:703
#, no-wrap
msgid "escape to Forth"
msgstr "escape to Forth"

#. type: cindex
#: ../doc/vmgen.texi:704
#, no-wrap
msgid "eval escape"
msgstr "eval escape"

#. type: code{#1}
#: ../doc/vmgen.texi:705
#, no-wrap
msgid "\\E"
msgstr "\\E"

#. type: Plain text
#: ../doc/vmgen.texi:711
msgid ""
"The text in @code{eval-escape} is Forth code that is evaluated when Vmgen "
"reads the line.  You will normally use this feature to define stacks and "
"types."
msgstr ""
"@code{eval-escape} 内の text は、 Vmgen が行を読み取るときに評価(eval)される "
"Forth コードです。  通常、 この機能を使用してスタックと型を定義します。"

#. type: Plain text
#: ../doc/vmgen.texi:715
msgid ""
"If you do not know (and do not want to learn) Forth, you can build the text "
"according to the following grammar; these rules are normally all Forth you "
"need for using Vmgen:"
msgstr ""
"あなたが Forth を知らない (そして学びたくない) 場合は、 以下の文法に従って "
"text を作成できます。 これらのルールは通常、 Vmgen を使用するために必要な "
"Forth の全てです:"

#. type: example
#: ../doc/vmgen.texi:718
#, no-wrap
msgid ""
"text: stack-decl|type-prefix-decl|stack-prefix-decl|set-flag\n"
"\n"
msgstr ""
"text: stack-decl|type-prefix-decl|stack-prefix-decl|set-flag\n"
"\n"

#. type: example
#: ../doc/vmgen.texi:724
#, no-wrap
msgid ""
"stack-decl: 'stack ' ident ident ident\n"
"type-prefix-decl: \n"
"    's\" ' string '\" ' ('single'|'double') ident 'type-prefix' ident\n"
"stack-prefix-decl:  ident 'stack-prefix' string\n"
"set-flag: ('store-optimization'|'include-skipped-insts') ('on'|'off')\n"
msgstr ""
"stack-decl: 'stack ' ident ident ident\n"
"type-prefix-decl: \n"
"    's\" ' string '\" ' ('single'|'double') ident 'type-prefix' ident\n"
"stack-prefix-decl:  ident 'stack-prefix' string\n"
"set-flag: ('store-optimization'|'include-skipped-insts') ('on'|'off')\n"

#. type: Plain text
#: ../doc/vmgen.texi:729
msgid ""
"Note that the syntax of this code is not checked thoroughly (there are many "
"other Forth program fragments that could be written in an eval-escape)."
msgstr ""
"このコードの構文は完全にはチェックされていないことに注意してください(eval-"
"escape で記述できる Forth プログラムの断片は他にも多数あります)。"

#. type: Plain text
#: ../doc/vmgen.texi:735
msgid ""
"A stack prefix can contain letters, digits, or @samp{:}, and may start with "
"an @samp{#}; e.g., in Gforth the return stack has the stack prefix "
"@samp{R:}.  This restriction is not checked during the stack prefix "
"definition, but it is enforced by the parsing rules for stack items later."
msgstr ""
"スタック・プレフィックスには文字または数字または @samp{:} を含めることがで"
"き、@samp{#} で始まる場合もあります。 たとえば、Gforth では、 リターン・ス"
"タックにはスタック・プレフィックス @samp{R:} が付きます。  この制限は、 ス"
"タック・プレフィックスの定義ではチェックされませんが、 後でスタック項目のパー"
"ス・ルールによって強制されます。"

#. type: Plain text
#: ../doc/vmgen.texi:738
msgid ""
"If you know Forth, the stack effects of the non-standard words involved are:"
msgstr ""
"あなたが既に Forth をご存知の場合、 関連する非標準ワードのスタック効果は以下"
"のとおりです:"

#. type: findex
#: ../doc/vmgen.texi:738
#, no-wrap
msgid "stack"
msgstr "stack"

#. type: findex
#: ../doc/vmgen.texi:739
#, no-wrap
msgid "type-prefix"
msgstr "type-prefix"

#. type: findex
#: ../doc/vmgen.texi:740
#, no-wrap
msgid "single"
msgstr "single"

#. type: findex
#: ../doc/vmgen.texi:741
#, no-wrap
msgid "double"
msgstr "double"

#. type: findex
#: ../doc/vmgen.texi:742
#, no-wrap
msgid "stack-prefix"
msgstr "stack-prefix"

#. type: findex
#: ../doc/vmgen.texi:743
#, no-wrap
msgid "store-optimization"
msgstr "store-optimization"

#. type: example
#: ../doc/vmgen.texi:753
#, no-wrap
msgid ""
"stack                 ( \"name\" \"pointer\" \"type\" -- )\n"
"                      ( name execution: -- stack )\n"
"type-prefix           ( addr u item-size stack \"prefix\" -- )\n"
"single                ( -- item-size )\n"
"double                ( -- item-size )\n"
"stack-prefix          ( stack \"prefix\" -- )\n"
"store-optimization    ( -- addr )\n"
"include-skipped-insts ( -- addr )\n"
msgstr ""
"stack                 ( \"name\" \"pointer\" \"type\" -- )\n"
"                      ( name execution: -- stack )\n"
"type-prefix           ( addr u item-size stack \"prefix\" -- )\n"
"single                ( -- item-size )\n"
"double                ( -- item-size )\n"
"stack-prefix          ( stack \"prefix\" -- )\n"
"store-optimization    ( -- addr )\n"
"include-skipped-insts ( -- addr )\n"

#. type: Plain text
#: ../doc/vmgen.texi:756
msgid "An @var{item-size} takes three cells on the stack."
msgstr "@var{item-size} はスタック上で 3 つのセルを占有します。"

#. type: cindex
#: ../doc/vmgen.texi:760
#, no-wrap
msgid "simple VM instruction"
msgstr "simple VM instruction"

#. type: cindex
#: ../doc/vmgen.texi:761
#, no-wrap
msgid "instruction, simple VM"
msgstr "instruction, simple VM"

#. type: Plain text
#: ../doc/vmgen.texi:764
msgid "We will use the following simple VM instruction description as example:"
msgstr "例として、 以下の簡単な VM 命令の記述を使用します:"

#. type: example
#: ../doc/vmgen.texi:768
#, no-wrap
msgid ""
"sub ( i1 i2 -- i )\n"
"i = i1-i2;\n"
msgstr ""
"sub ( i1 i2 -- i )\n"
"i = i1-i2;\n"

#. type: Plain text
#: ../doc/vmgen.texi:773
msgid ""
"The first line specifies the name of the VM instruction (@code{sub}) and its "
"stack effect (@code{i1 i2 -- i}).  The rest of the description is just plain "
"C code."
msgstr ""
"最初の行には、 VM 命令の名前 (@code{sub}) とそのスタック効果 (@code{i1 i2 -- "
"i}) を指定します。  最初の行以外の記述の残りの部分は単なる C 言語コードです。"

#. type: cindex
#: ../doc/vmgen.texi:774
#, no-wrap
msgid "stack effect"
msgstr "stack effect"

#. type: cindex
#: ../doc/vmgen.texi:775
#, no-wrap
msgid "effect, stack"
msgstr "effect, stack"

#. type: Plain text
#: ../doc/vmgen.texi:783
msgid ""
"The stack effect specifies that @code{sub} pulls two integers from the data "
"stack and puts them in the C variables @code{i1} and @code{i2} (with the "
"rightmost item (@code{i2}) taken from the top of stack; intuition: if you "
"push @code{i1}, then @code{i2} on the stack, the resulting stack picture is "
"@code{i1 i2}) and later pushes one integer (@code{i}) on the data stack (the "
"rightmost item is on the top afterwards)."
msgstr ""
"スタック効果では、 @code{sub} がデータ・スタックから 2 つの整数を取得し、 そ"
"れらを C 言語の変数 @code{i1} と @code{i2} に格納することを指定します(右端の"
"項目 (@code{i2}) が、 スタックのトップです: @code{i1} をスタックにプッシュ"
"し、 次に @code{i2} をスタックにプッシュすると、 結果のスタック状態は "
"@code{i1 i2} になります)。 そしてその後、 その後 1 つの整数 (@code{i}) をス"
"タックにプッシュします(右端の項目がスタックの一番上になります)。"

#. type: cindex
#: ../doc/vmgen.texi:784
#, no-wrap
msgid "prefix, type"
msgstr "prefix, type"

#. type: cindex
#: ../doc/vmgen.texi:785
#, no-wrap
msgid "type prefix"
msgstr "type prefix"

#. type: cindex
#: ../doc/vmgen.texi:786
#, no-wrap
msgid "default stack of a type prefix"
msgstr "default stack of a type prefix"

#. type: Plain text
#: ../doc/vmgen.texi:790
msgid ""
"How do we know the type and stack of the stack items? Vmgen uses prefixes, "
"similar to Fortran; in contrast to Fortran, you have to define the prefix "
"first:"
msgstr ""
"スタック項目の型とスタックを知るにはどうすればよいでしょうか?  Vmgen は、 "
"Fortran と同様にプレフィックスを使用します。 Fortran とは対照的に、 あなたは"
"最初にプレフィックスを定義する必要があります:"

#. type: example
#: ../doc/vmgen.texi:793
#, no-wrap
msgid "\\E s\" Cell\"   single data-stack type-prefix i\n"
msgstr "\\E s\" Cell\"   single data-stack type-prefix i\n"

#. type: Plain text
#: ../doc/vmgen.texi:799
msgid ""
"This defines the prefix @code{i} to refer to the type @code{Cell} (defined "
"as @code{long} in @file{mini.h}) and, by default, to the @code{data-stack}.  "
"It also specifies that this type takes one stack item (@code{single}).  The "
"type prefix is part of the variable name."
msgstr ""
"これは、 型 @code{Cell} (@file{mini.h} では @code{long} として定義)を参照する"
"プレフィックス @code{i} を定義し、 デフォルトでは @code{data-stack} を参照し"
"ます。 また、 この型が 1 つのスタック項目(@code{single})を占めることも指定し"
"ます。  型プレフィックスは変数名の一部です。"

#. type: cindex
#: ../doc/vmgen.texi:800
#, no-wrap
msgid "stack definition"
msgstr "stack definition"

#. type: cindex
#: ../doc/vmgen.texi:801
#, no-wrap
msgid "defining a stack"
msgstr "defining a stack"

#. type: Plain text
#: ../doc/vmgen.texi:803
msgid "Before we can use @code{data-stack} in this way, we have to define it:"
msgstr ""
"@code{data-stack} を使用する前に、 この方法で @code{data-stack} を定義する必"
"要があります:"

#. type: example
#: ../doc/vmgen.texi:806
#, no-wrap
msgid "\\E stack data-stack sp Cell\n"
msgstr "\\E stack data-stack sp Cell\n"

#. type: cindex
#: ../doc/vmgen.texi:809
#, no-wrap
msgid "stack basic type"
msgstr "stack basic type"

#. type: cindex
#: ../doc/vmgen.texi:810
#, no-wrap
msgid "basic type of a stack"
msgstr "basic type of a stack"

#. type: cindex
#: ../doc/vmgen.texi:811
#, no-wrap
msgid "type of a stack, basic"
msgstr "type of a stack, basic"

#. type: Plain text
#: ../doc/vmgen.texi:819
msgid ""
"This line defines the stack @code{data-stack}, which uses the stack pointer "
"@code{sp}, and each item has the basic type @code{Cell}; other types have to "
"fit into one or two @code{Cell}s (depending on whether the type is "
"@code{single} or @code{double} wide), and are cast from and to Cells on "
"accessing the @code{data-stack} with type cast macros (@pxref{VM engine}).  "
"By default, stacks grow towards lower addresses in Vmgen-erated interpreters "
"(@pxref{Stack growth direction})."
msgstr ""
"この行は、 スタック・ポインター @code{sp} を使用するスタック @code{data-"
"stack} を定義し、 各項目の基本タイプは @code{Cell} です。 他の型は 1 つまた"
"は 2 つの @code{Cell} に収まる必要があり(型の幅が @code{single} か "
"@code{double} かによって異なります)、 型キャスト・マクロ(@pxref{VM engine})を"
"使用して @code{data-stack} にアクセスするときに Cell との間でキャストされま"
"す。 Vmgen 製インタープリターではスタックは、 デフォルトでは、 より低いアドレ"
"スに向かって伸長します(@pxref{Stack growth direction})。"

#. type: cindex
#: ../doc/vmgen.texi:820
#, no-wrap
msgid "stack prefix"
msgstr "stack prefix"

#. type: cindex
#: ../doc/vmgen.texi:821
#, no-wrap
msgid "prefix, stack"
msgstr "prefix, stack"

#. type: Plain text
#: ../doc/vmgen.texi:824
msgid ""
"We can override the default stack of a stack item by using a stack prefix.  "
"E.g., consider the following instruction:"
msgstr ""
"スタック・プレフィックスを使用して、 スタック項目のデフォルト・スタックをオー"
"バーライドできます。 たとえば、 以下の命令について考えてみましょう:"

#. type: example
#: ../doc/vmgen.texi:827
#, no-wrap
msgid "lit ( #i -- i )\n"
msgstr "lit ( #i -- i )\n"

#. type: Plain text
#: ../doc/vmgen.texi:833
msgid ""
"The VM instruction @code{lit} takes the item @code{i} from the instruction "
"stream (indicated by the prefix @code{#}), and pushes it on the (default) "
"data stack.  The stack prefix is not part of the variable name.  Stack "
"prefixes are defined like this:"
msgstr ""
"VM 命令 @code{lit} は、 命令ストリームから(プレフィックス @code{#} で示され"
"る) 項目 @code{i} を取得し、 それを(デフォルトの)データ・スタックにプッシュし"
"ます。  スタック・プレフィックスは変数名の一部ではありません。  スタック・プ"
"レフィックスは以下のように定義されます:"

#. type: example
#: ../doc/vmgen.texi:837
#, no-wrap
msgid ""
"\\E inst-stream stack-prefix #\n"
"\\E data-stack  stack-prefix S:\n"
msgstr ""
"\\E inst-stream stack-prefix #\n"
"\\E data-stack  stack-prefix S:\n"

#. type: Plain text
#: ../doc/vmgen.texi:843
msgid ""
"This definition defines that the stack prefix @code{#} specifies the "
"``stack'' @code{inst-stream}.  Since the instruction stream behaves a little "
"differently than an ordinary stack, it is predefined, and you do not need to "
"define it."
msgstr ""
"この定義は、 スタック・プレフィックス @code{#} が「スタック」 @code{inst-"
"stream} を指定することを定義します。  命令ストリームは通常のスタックとは振る"
"舞いが少し異なるため、 事前に定義されており、 あなたが定義する必要はありませ"
"ん。"

#. type: Plain text
#: ../doc/vmgen.texi:851
msgid ""
"The instruction stream contains instructions and their immediate arguments, "
"so specifying that an argument comes from the instruction stream indicates "
"an immediate argument.  Of course, instruction stream arguments can only "
"appear to the left of @code{--} in the stack effect.  If there are multiple "
"instruction stream arguments, the leftmost is the first one (just as the "
"intuition suggests)."
msgstr ""
"命令ストリームには命令とその直接引数(immediate arguments)が含まれるため、 引"
"数が命令ストリームからのものであることを指定することは、 直接引数であることを"
"示しています。  もちろん、 命令ストリーム引数は、 スタック効果の @code{--} の"
"左側にのみ出現できます。  複数の命令ストリーム引数がある場合、 (あなたの直観"
"どおり)左端が最初の引数になります。"

#. type: cindex
#: ../doc/vmgen.texi:862
#, no-wrap
msgid "stack access, explicit"
msgstr "stack access, explicit"

#. type: cindex
#: ../doc/vmgen.texi:863
#, no-wrap
msgid "Stack pointer access"
msgstr "Stack pointer access"

#. type: cindex
#: ../doc/vmgen.texi:864
#, no-wrap
msgid "explicit stack access"
msgstr "explicit stack access"

#. type: Plain text
#: ../doc/vmgen.texi:868
msgid ""
"This feature is not needed and not supported in the 0.6.2 version of vmgen "
"that is documented here (and that is invoked by default)."
msgstr ""
"この機能は、 ここで説明されている(デフォルトで呼び出される) vmgen の 0.6.2 "
"バージョンでは必要なく、 サポートされていません。"

#. type: Plain text
#: ../doc/vmgen.texi:875
msgid ""
"Not all stack effects can be specified using the stack effect specifications "
"above.  For VM instructions that have other stack effects, you can specify "
"them explicitly by accessing the stack pointer in the C code; however, you "
"have to notify Vmgen of such explicit stack accesses, otherwise Vmgens "
"optimizations could conflict with your explicit stack accesses."
msgstr ""
"上記のスタック効果の仕様を使用して、 すべてのスタック効果を指定できるわけでは"
"ありません。  他のスタック効果がある VM 命令の場合は、 C 言語コードでスタッ"
"ク・ポインターにアクセスすることで明示的に指定できます。 ただし、 そのような"
"明示的なスタック・アクセスを Vmgen に通知する必要があります。 そうしないと、 "
"Vmgen の最適化が、 この明示的なスタック・アクセスと競合する可能性があります。"

#. type: Plain text
#: ../doc/vmgen.texi:883
msgid ""
"You notify Vmgen by putting @code{...} with the appropriate stack prefix "
"into the stack comment.  Then the VM instruction will first take the other "
"stack items specified in the stack effect into C variables, then make sure "
"that all other stack items for that stack are in memory, and that the stack "
"pointer for the stack points to the top-of-stack (by default, unless you "
"change the stack access transformation: @pxref{Stack growth direction})."
msgstr ""
"Vmgen に通知するには、 @code{...} と適切なスタック・プレフィックスをスタッ"
"ク・コメントに入れます。  次に、 VM 命令はまずスタック効果で指定された他のス"
"タック項目を C 言語の変数に取り込み、 次にそのスタックの他のすべてのスタック"
"項目がメモリ内にあり、 スタックのスタック・ポインターが先頭を指していることを"
"確認します(デフォルトでは。 あなたがスタック・アクセス変換(the stack access "
"transformation)を変更しない限り: @pxref{Stack growth direction})。"

#. type: Plain text
#: ../doc/vmgen.texi:887
msgid ""
"The general rule is: If you mention a stack pointer in the C code of a VM "
"instruction, you should put a @code{...} for that stack in the stack effect."
msgstr ""
"一般的なルールは次のとおりです: VM 命令の C 言語コードでスタック・ポインター"
"に言及する場合は、 スタック効果にそのスタックの @code{...} を含める必要があり"
"ます。"

#. type: Plain text
#: ../doc/vmgen.texi:889
msgid "Consider this example:"
msgstr "以下の例について考えてみましょう:"

#. type: example
#: ../doc/vmgen.texi:896
#, no-wrap
msgid ""
"return ( #iadjust S:... target afp i1 -- i2 )\n"
"SET_IP(target);\n"
"sp = (Cell *)(((char *)sp)+iadjust);\n"
"fp = afp;\n"
"i2=i1;\n"
msgstr ""
"return ( #iadjust S:... target afp i1 -- i2 )\n"
"SET_IP(target);\n"
"sp = (Cell *)(((char *)sp)+iadjust);\n"
"fp = afp;\n"
"i2=i1;\n"

#. type: Plain text
#: ../doc/vmgen.texi:902
msgid ""
"First the variables @code{target afp i1} are popped off the stack, then the "
"stack pointer @code{sp} is set correctly for the new stack depth, then the C "
"code changes the stack depth and does other things, and finally @code{i2} is "
"pushed on the stack with the new depth."
msgstr ""
"最初に変数 @code{target afp i1} がスタックからポップされ、 次にスタック・ポイ"
"ンター @code{sp} が新しいスタックの深さに正しく設定され、 次に C 言語のコード"
"がスタックの深さを変更して他の処理を行い、 最後に @code{i2} は新しい深さでス"
"タックにプッシュされます。"

#. type: Plain text
#: ../doc/vmgen.texi:908
msgid ""
"The position of the @code{...} within the stack effect does not matter.  You "
"can use several @code{...}s, for different stacks, and also several for the "
"same stack (that has no additional effect).  If you use @code{...} without a "
"stack prefix, this specifies all the stacks except the instruction stream."
msgstr ""
"スタック効果内の @code{...} の位置は関係ありません。  異なるスタックに複数の "
"@code{...} を使用することも、 同一のスタックに複数の @code{...} を使用するこ"
"ともできます(追加の効果はありません)。  スタック・プレフィックスなしで "
"@code{...} を使用すると、 命令ストリームを除くすべてのスタックが指定されま"
"す。"

#. type: Plain text
#: ../doc/vmgen.texi:914
msgid ""
"You cannot use @code{...} for the instruction stream, but that is not "
"necessary: At the start of the C code, @code{IP} points to the start of the "
"next VM instruction (i.e., right beyond the end of the current VM "
"instruction), and you can change the instruction pointer with @code{SET_IP} "
"(@pxref{VM engine})."
msgstr ""
"命令ストリームに @code{...} を使用することはできませんが、 その必要はありませ"
"ん。 C 言語のコードの先頭で、 @code{IP} は次の VM 命令の先頭(つまり、 現在の "
"VM 命令の末尾のすぐ次)を指し、 @code{SET_IP} を使用して命令ポインターを変更で"
"きます(@pxref{VM engine})。"

#. type: cindex
#: ../doc/vmgen.texi:919
#, no-wrap
msgid "macros recognized by Vmgen"
msgstr "macros recognized by Vmgen"

#. type: cindex
#: ../doc/vmgen.texi:920
#, no-wrap
msgid "basic block, VM level"
msgstr "basic block, VM level"

#. type: Plain text
#: ../doc/vmgen.texi:924
msgid ""
"Vmgen recognizes the following strings in the C code part of simple "
"instructions:"
msgstr ""
"Vmgen は、 単純な命令の C 言語コード部分にある以下の文字列を認識します:"

#. type: findex
#: ../doc/vmgen.texi:927 ../doc/vmgen.texi:928 ../doc/vmgen.texi:1448
#, no-wrap
msgid "SET_IP"
msgstr "SET_IP"

#. type: table
#: ../doc/vmgen.texi:932
msgid ""
"As far as Vmgen is concerned, a VM instruction containing this ends a VM "
"basic block (used in profiling to delimit profiled sequences).  On the C "
"level, this also sets the instruction pointer."
msgstr ""
"Vmgen に関する限り、 これを含む VM 命令は、 (プロファイルされたシーケンスを区"
"切るためにプロファイリングで使用される、) VM 基本ブロックを終了します。 C 言"
"語のレベルでは、 これにより命令ポインターも設定されます。"

#. type: item
#: ../doc/vmgen.texi:933 ../doc/vmgen.texi:934 ../doc/vmgen.texi:1526
#: ../doc/vmgen.texi:1527
#, no-wrap
msgid "SUPER_END"
msgstr "SUPER_END"

#. type: table
#: ../doc/vmgen.texi:937
msgid ""
"This ends a basic block (for profiling), even if the instruction contains no "
"@code{SET_IP}."
msgstr ""
"これにより、 命令に @code{SET_IP} が含まれていない場合でも、 (プロファイリン"
"グ用の)基本ブロックが終了します。"

#. type: findex
#: ../doc/vmgen.texi:938 ../doc/vmgen.texi:939
#, no-wrap
msgid "INST_TAIL;"
msgstr "INST_TAIL;"

#. type: table
#: ../doc/vmgen.texi:945
msgid ""
"Vmgen replaces @samp{INST_TAIL;} with code for ending a VM instruction and "
"dispatching the next VM instruction.  Even without a @samp{INST_TAIL;} this "
"happens automatically when control reaches the end of the C code.  If you "
"want to have this in the middle of the C code, you need to use "
"@samp{INST_TAIL;}.  A typical example is a conditional VM branch:"
msgstr ""
"Vmgen は、 @samp{INST_TAIL;} を、 VM 命令を終了して次の VM 命令をディスパッチ"
"するためのコードに置き換えます。  @samp{INST_TAIL;} がなくても、 制御が C g言"
"語コードの最後に到達すると、 これは自動的に行われます。 これを C 言語コードの"
"途中に置きたい場合に @samp{INST_TAIL;} を使用する必要があります。  典型的な例"
"は、 以下のような条件付き VM 分岐です:"

#. type: example
#: ../doc/vmgen.texi:951
#, no-wrap
msgid ""
"if (branch_condition) @{\n"
"  SET_IP(target); INST_TAIL;\n"
"@}\n"
"/* implicit tail follows here */\n"
msgstr ""
"if (branch_condition) @{\n"
"  SET_IP(target); INST_TAIL;\n"
"@}\n"
"/* implicit tail follows here */\n"

#. type: table
#: ../doc/vmgen.texi:956
msgid ""
"In this example, @samp{INST_TAIL;} is not strictly necessary, because there "
"is another one implicitly after the if-statement, but using it improves "
"branch prediction accuracy slightly and allows other optimizations."
msgstr ""
"この例では、 if ステートメントの後に @samp{INST_TAIL;} が暗黙的に存在するた"
"め、 厳密には @samp{INST_TAIL;} は必要ありませんが、 これを使用すると分岐予測"
"の精度がわずかに向上し、 他の最適化が可能になります。"

#. type: item
#: ../doc/vmgen.texi:957 ../doc/vmgen.texi:958 ../doc/vmgen.texi:1532
#: ../doc/vmgen.texi:1533
#, no-wrap
msgid "SUPER_CONTINUE"
msgstr "SUPER_CONTINUE"

#. type: table
#: ../doc/vmgen.texi:964
msgid ""
"This indicates that the implicit tail at the end of the VM instruction "
"dispatches the sequentially next VM instruction even if there is a "
"@code{SET_IP} in the VM instruction.  This enables an optimization that is "
"not yet implemented in the vmgen-ex code (but in Gforth).  The typical "
"application is in conditional VM branches:"
msgstr ""
"これは、 VM 命令に @code{SET_IP} が含まれている場合でも、 VM 命令の終わりの暗"
"黙の末尾に連続して次の VM 命令をディスパッチすることを示します。 これによ"
"り、 vmgen-ex コードにはまだ実装されていない(しかし Gforthには実装されている)"
"最適化が可能になります。  典型的なアプリケーションは以下のような条件付き VM "
"分岐内にあります:"

#. type: example
#: ../doc/vmgen.texi:970
#, no-wrap
msgid ""
"if (branch_condition) @{\n"
"  SET_IP(target); INST_TAIL; /* now this INST_TAIL is necessary */\n"
"@}\n"
"SUPER_CONTINUE;\n"
msgstr ""
"if (branch_condition) @{\n"
"  SET_IP(target); INST_TAIL; /* now this INST_TAIL is necessary */\n"
"@}\n"
"SUPER_CONTINUE;\n"

#. type: Plain text
#: ../doc/vmgen.texi:989
msgid ""
"Note that Vmgen is not smart about C-level tokenization, comments, strings, "
"or conditional compilation, so it will interpret even a commented-out "
"SUPER_END as ending a basic block (or, e.g., @samp{RESET_IP;} as "
"@samp{SET_IP;}).  Conversely, Vmgen requires the literal presence of these "
"strings; Vmgen will not see them if they are hiding in a C preprocessor "
"macro."
msgstr ""
"注意: Vmgen は C 言語レベルのトークン化またはコメントまたは文字列または条件付"
"きコンパイルについては賢明ではないため、 コメント・アウトされた SUPER_END で"
"あっても基本ブロックの終了として(または、 例えば、 @samp{RESET_IP;} を "
"@samp{SET_IP;} として)解釈されることに注意してください。 逆に、 Vmgen ではこ"
"れらの文字列が文字通り存在する必要があります。 C 言語のプリプロセッサ・マクロ"
"内に隠れている場合、 Vmgen はそれらを認識できません。"

#. type: cindex
#: ../doc/vmgen.texi:994
#, no-wrap
msgid "C code restrictions"
msgstr "C code restrictions"

#. type: cindex
#: ../doc/vmgen.texi:995
#, no-wrap
msgid "restrictions on C code"
msgstr "restrictions on C code"

#. type: cindex
#: ../doc/vmgen.texi:996
#, no-wrap
msgid "assumptions about C code"
msgstr "assumptions about C code"

#. type: cindex
#: ../doc/vmgen.texi:998
#, no-wrap
msgid "accessing stack (pointer)"
msgstr "accessing stack (pointer)"

#. type: cindex
#: ../doc/vmgen.texi:999
#, no-wrap
msgid "stack pointer, access"
msgstr "stack pointer, access"

#. type: cindex
#: ../doc/vmgen.texi:1000
#, no-wrap
msgid "instruction pointer, access"
msgstr "instruction pointer, access"

#. type: Plain text
#: ../doc/vmgen.texi:1007
msgid ""
"Vmgen generates code and performs some optimizations under the assumption "
"that the user-supplied C code does not access the stack pointers or stack "
"items, and that accesses to the instruction pointer only occur through "
"special macros.  In general you should heed these restrictions.  However, if "
"you need to break these restrictions, read the following."
msgstr ""
"Vmgen は、ユーザー指定の C 言語コードがスタック・ポインターやスタック項目にア"
"クセスせず、 命令ポインターへのアクセスは特殊なマクロを介してのみ発生するとい"
"う想定に基づいて、 コードを生成し、 いくつかの最適化を実行します。  一般に、 "
"あなたはこれらの制限に注意する必要があります。  ただし、 あなたがこれらの制限"
"を破る必要がある場合は、 以下をお読みください。"

#. type: Plain text
#: ../doc/vmgen.texi:1010
msgid ""
"Accessing a stack or stack pointer directly can be a problem for several "
"reasons:"
msgstr ""
"スタックまたはスタック・ポインターに直接アクセスすると、 いくつかの理由で問題"
"が発生する可能性があります:"

#. type: cindex
#: ../doc/vmgen.texi:1010
#, no-wrap
msgid "stack caching, restriction on C code"
msgstr "stack caching, restriction on C code"

#. type: cindex
#: ../doc/vmgen.texi:1011
#, no-wrap
msgid "superinstructions, restrictions on components"
msgstr "superinstructions, restrictions on components"

#. type: itemize
#: ../doc/vmgen.texi:1027
msgid ""
"Vmgen optionally supports caching the top-of-stack item in a local variable "
"(that is allocated to a register).  This is the most frequent source of "
"trouble.  You can deal with it either by not using top-of-stack caching "
"(slowdown factor 1-1.4, depending on machine), or by inserting flushing code "
"(e.g., @samp{IF_spTOS(sp[...] = spTOS);}) at the start and reloading code (e."
"g., @samp{IF_spTOS(spTOS = sp[0])}) at the end of problematic C code.  Vmgen "
"inserts a stack pointer update before the start of the user-supplied C code, "
"so the flushing code has to use an index that corrects for that.  In the "
"future, this flushing may be done automatically by mentioning a special "
"string in the C code."
msgstr ""
"Vmgen はオプションで、 スタック・トップの項目をローカル変数(レジスターに割り"
"当てられる)にキャッシュすることをサポートします。  これは最も頻繁に起こるトラ"
"ブルの原因です。  これに対処するには、 スタック・トップ・キャッシュを使用しな"
"い(マシンによって異なるが、 減速係数 1 ～ 1.4)か、 あるいは、 問題のある C 言"
"語コードの先頭にフラッシュ・コード(たとえば @samp{IF_spTOS(sp[...] = "
"spTOS);})を挿入し、 最後にコードをリロードする(たとえば @samp{IF_spTOS(spTOS "
"= sp[0])})かのいずれかで対処できます。  Vmgen は、 ユーザー指定の C 言語コー"
"ドの開始前にスタック・ポインターの更新を挿入するため、 フラッシュ・コードでは"
"それを修正するインデックスを使用する必要があります。  将来的には、 C 言語コー"
"ドで特別な文字列を指定することによって、 このフラッシュが自動的に行われるよう"
"になる可能性があります。"

#. type: itemize
#: ../doc/vmgen.texi:1037
msgid ""
"The Vmgen-erated code loads the stack items from stack-pointer-indexed "
"memory into variables before the user-supplied C code, and stores them from "
"variables to stack-pointer-indexed memory afterwards.  If you do any writes "
"to the stack through its stack pointer in your C code, it will not affect "
"the variables, and your write may be overwritten by the stores after the C "
"code.  Similarly, a read from a stack using a stack pointer will not reflect "
"computations of stack items in the same VM instruction."
msgstr ""
"Vmgen で生成されたコードは、 ユーザーが指定した C 言語コードの前にスタック項"
"目をスタック・ポインターでインデックス付けされたメモリーから変数にロードし、 "
"その後、 変数からスタック・ポインターでインデックス付けされたメモリーに格納し"
"ます。  C 言語コードでスタック・ポインターを介してスタックに書き込みを行った"
"場合、 変数には影響せず、 その書き込みは C 言語コードの格納によって上書きされ"
"る可能性があります。  同様に、 スタック・ポインターを使用したスタックからの読"
"み取りは、 同じ VM 命令内のスタック項目の計算を反映しません。"

#. type: itemize
#: ../doc/vmgen.texi:1043
msgid ""
"Superinstructions keep stack items in variables across the whole "
"superinstruction.  So you should not include VM instructions, that access a "
"stack or stack pointer, as components of superinstructions (@pxref{VM "
"profiler})."
msgstr ""
"スーパー命令(superinstructions)は、 スーパー命令全体にわたってスタック項目を"
"変数に保持します。  したがって、 スタックまたはスタック・ポインターにアクセス"
"する VM 命令をスーパー命令のコンポーネントとして含めるべきではありません"
"(@pxref{VM profiler})。"

#. type: Plain text
#: ../doc/vmgen.texi:1051
msgid ""
"You should access the instruction pointer only through its special macros "
"(@samp{IP}, @samp{SET_IP}, @samp{IPTOS}); this ensure that these macros can "
"be implemented in several ways for best performance.  @samp{IP} points to "
"the next instruction, and @samp{IPTOS} is its contents."
msgstr ""
"命令ポインターには、 そのための特別なマクロ(@samp{IP}, @samp{SET_IP}, "
"@samp{IPTOS})を介してのみアクセスする必要があります。 これにより、 これらのマ"
"クロをいくつかの方法で実装して最高のパフォーマンスを実現できるようになりま"
"す。  @samp{IP} は次の命令を指していて、 @samp{IPTOS} はその内容です。"

#. type: cindex
#: ../doc/vmgen.texi:1055
#, no-wrap
msgid "stack growth direction"
msgstr "stack growth direction"

#. type: code{#1}
#: ../doc/vmgen.texi:1057
#, no-wrap
msgid "stack-access-transform"
msgstr "stack-access-transform"

#. type: Plain text
#: ../doc/vmgen.texi:1062
msgid ""
"By default, the stacks grow towards lower addresses.  You can change this "
"for a stack by setting the @code{stack-access-transform} field of the stack "
"to an xt @code{( itemnum -- index )} that performs the appropriate index "
"transformation."
msgstr ""
"デフォルトでは、 スタックは下位アドレスに向かって伸長します。 これを変更する"
"には、 スタックの @code{stack-access-transform} フィールドを、 適切なインデッ"
"クス変換を実行する xt @code{( itemnum -- index )} に設定します。"

#. type: Plain text
#: ../doc/vmgen.texi:1066
msgid ""
"E.g., if you want to let @code{data-stack} grow towards higher addresses, "
"with the stack pointer always pointing just beyond the top-of-stack, use "
"this right after defining @code{data-stack}:"
msgstr ""
"たとえば、 @code{data-stack} をより高いアドレスに向かって伸長させ、 スタッ"
"ク・ポインターが常にスタックの最上位のすぐ先を指すようにする場合は、 "
"@code{data-stack} を定義した直後に以下を使用します:"

#. type: example
#: ../doc/vmgen.texi:1070
#, no-wrap
msgid ""
"\\E : sp-access-transform ( itemnum -- index ) negate 1- ;\n"
"\\E ' sp-access-transform ' data-stack >body stack-access-transform !\n"
msgstr ""
"\\E : sp-access-transform ( itemnum -- index ) negate 1- ;\n"
"\\E ' sp-access-transform ' data-stack >body stack-access-transform !\n"

#. type: Plain text
#: ../doc/vmgen.texi:1079
msgid ""
"This means that @code{sp-access-transform} will be used to generate indexes "
"for accessing @code{data-stack}.  The definition of @code{sp-access-"
"transform} above transforms n into -n-1, e.g, 1 into -2.  This will access "
"the 0th data-stack element (top-of-stack) at sp[-1], the 1st at sp[-2], "
"etc., which is the typical way upward-growing stacks are used.  If you need "
"a different transform and do not know enough Forth to program it, let me "
"know."
msgstr ""
"これは、 @code{sp-access-transform} を使用して @code{data-stack} にアクセスす"
"るためのインデックスを生成することを意味します。  上記の @code{sp-access-"
"transform} の定義は、 n を -n-1 に変換します(例: 1 を -2 にする)。  これは、 "
"sp[-1] の 0 番目のデータ・スタック要素(スタックの先頭)、 sp[-2] の 1 番目の"
"データースタック要素などにアクセスします。 これは、 上向きに成長するスタック"
"が使用される一般的な方法です。  あなたが別のインデックス変換が必要で、 それを"
"プログラムするのに十分な Forth の知識がない場合は、 我々にお尋ね下さい。"

#. type: cindex
#: ../doc/vmgen.texi:1083
#, no-wrap
msgid "superinstructions, defining"
msgstr "superinstructions, defining"

#. type: cindex
#: ../doc/vmgen.texi:1084
#, no-wrap
msgid "defining superinstructions"
msgstr "defining superinstructions"

#. type: Plain text
#: ../doc/vmgen.texi:1092
msgid ""
"Note: don't invest too much work in (static) superinstructions; a future "
"version of Vmgen will support dynamic superinstructions (see Ian Piumarta "
"and Fabio Riccardi, @cite{Optimizing Direct Threaded Code by Selective "
"Inlining}, PLDI'98), and static superinstructions have much less benefit in "
"that context (preliminary results indicate only a factor 1.1 speedup)."
msgstr ""
"注意: (静的な)スーパー命令(superinstructions)にあまり多くの作業を費やさないで"
"ください。 Vmgen の将来のバージョンでは、 動的スーパー命令がサポートされる予"
"定で(Ian Piumarta and Fabio Riccardi, @cite{Optimizing Direct Threaded Code "
"by Selective Inlining}, PLDI'98 参照)、 静的スーパー命令の利点ははるかに少な"
"くなっています(暫定的な結果は、 係数 1.1 の高速化)。"

#. type: Plain text
#: ../doc/vmgen.texi:1094
msgid "Here is an example of a superinstruction definition:"
msgstr "以下にスーパー命令(superinstruction)定義の例を示します:"

#. type: example
#: ../doc/vmgen.texi:1097
#, no-wrap
msgid "lit_sub = lit sub\n"
msgstr "lit_sub = lit sub\n"

#. type: Plain text
#: ../doc/vmgen.texi:1106
msgid ""
"@code{lit_sub} is the name of the superinstruction, and @code{lit} and "
"@code{sub} are its components.  This superinstruction performs the same "
"action as the sequence @code{lit} and @code{sub}.  It is generated "
"automatically by the VM code generation functions whenever that sequence "
"occurs, so if you want to use this superinstruction, you just need to add "
"this definition (and even that can be partially automatized, @pxref{VM "
"profiler})."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1107
#, no-wrap
msgid "prefixes of superinstructions"
msgstr "prefixes of superinstructions"

#. type: Plain text
#: ../doc/vmgen.texi:1113
msgid ""
"Vmgen requires that the component instructions are simple instructions "
"defined before superinstructions using the components.  Currently, Vmgen "
"also requires that all the subsequences at the start of a superinstruction "
"(prefixes) must be defined as superinstruction before the superinstruction.  "
"I.e., if you want to define a superinstruction"
msgstr ""

#. type: example
#: ../doc/vmgen.texi:1116
#, no-wrap
msgid "foo4 = load add sub mul\n"
msgstr "foo4 = load add sub mul\n"

#. type: Plain text
#: ../doc/vmgen.texi:1120
msgid ""
"you first have to define @code{load}, @code{add}, @code{sub} and @code{mul}, "
"plus"
msgstr ""

#. type: example
#: ../doc/vmgen.texi:1124
#, no-wrap
msgid ""
"foo2 = load add\n"
"foo3 = load add sub\n"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1128
msgid ""
"Here, @code{sumof4} is the longest prefix of @code{sumof5}, and "
"@code{sumof3} is the longest prefix of @code{sumof4}."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1137
msgid ""
"Note that Vmgen assumes that only the code it generates accesses stack "
"pointers, the instruction pointer, and various stack items, and it performs "
"optimizations based on this assumption.  Therefore, VM instructions where "
"your C code changes the instruction pointer should only be used as last "
"component; a VM instruction where your C code accesses a stack pointer "
"should not be used as component at all.  Vmgen does not check these "
"restrictions, they just result in bugs in your interpreter."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1138
#, no-wrap
msgid "include-skipped-insts"
msgstr "include-skipped-insts"

#. type: Plain text
#: ../doc/vmgen.texi:1142
msgid ""
"The Vmgen flag @code{include-skipped-insts} influences superinstruction code "
"generation.  Currently there is no support in the peephole optimizer for "
"both variations, so leave this flag alone for now."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1146
#, no-wrap
msgid "store optimization"
msgstr "store optimization"

#. type: cindex
#: ../doc/vmgen.texi:1147
#, no-wrap
msgid "optimization, stack stores"
msgstr "optimization, stack stores"

#. type: cindex
#: ../doc/vmgen.texi:1148
#, no-wrap
msgid "stack stores, optimization"
msgstr "stack stores, optimization"

#. type: cindex
#: ../doc/vmgen.texi:1149
#, no-wrap
msgid "eliminating stack stores"
msgstr "eliminating stack stores"

#. type: Plain text
#: ../doc/vmgen.texi:1154
msgid ""
"This minor optimization (0.6%--0.8% reduction in executed instructions for "
"Gforth) puts additional requirements on the instruction descriptions and is "
"therefore disabled by default."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1156
msgid "What does it do? Consider an instruction like"
msgstr ""

#. type: example
#: ../doc/vmgen.texi:1159
#, no-wrap
msgid "dup ( n -- n n )\n"
msgstr "dup ( n -- n n )\n"

#. type: Plain text
#: ../doc/vmgen.texi:1167
msgid ""
"For simplicity, also assume that we are not caching the top-of-stack in a "
"register.  Now, the C code for dup first loads @code{n} from the stack, and "
"then stores it twice to the stack, one time to the address where it came "
"from; that time is unnecessary, but gcc does not optimize it away, so vmgen "
"can do it instead (if you turn on the store optimization)."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1174
msgid ""
"Vmgen uses the stack item's name to determine if the stack item contains the "
"same value as it did at the start.  Therefore, if you use the store "
"optimization, you have to ensure that stack items that have the same name on "
"input and output also have the same value, and are not changed in the C code "
"you supply.  I.e., the following code could fail if you turn on the store "
"optimization:"
msgstr ""

#. type: example
#: ../doc/vmgen.texi:1178
#, no-wrap
msgid ""
"add1 ( n -- n )\n"
"n++;\n"
msgstr ""
"add1 ( n -- n )\n"
"n++;\n"

#. type: Plain text
#: ../doc/vmgen.texi:1181
msgid "Instead, you have to use different names, i.e.:"
msgstr ""

#. type: example
#: ../doc/vmgen.texi:1185
#, no-wrap
msgid ""
"add1 ( n1 -- n2 )\n"
"n2=n1+1;\n"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1192
msgid ""
"Similarly, the store optimization assumes that the stack pointer is only "
"changed by Vmgen-erated code.  If your C code changes the stack pointer, use "
"different names in input and output stack items to avoid a (probably wrong) "
"store optimization, or turn the store optimization off for this VM "
"instruction."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1194
msgid "To turn on the store optimization, write"
msgstr ""

#. type: example
#: ../doc/vmgen.texi:1197
#, no-wrap
msgid "\\E store-optimization on\n"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1202
msgid ""
"at the start of the file.  You can turn this optimization on or off between "
"any two VM instruction descriptions.  For turning it off again, you can use"
msgstr ""

#. type: example
#: ../doc/vmgen.texi:1205
#, no-wrap
msgid "\\E store-optimization off\n"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1210
#, no-wrap
msgid "Register VM"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1211
#, no-wrap
msgid "Superinstructions for register VMs"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1212
#, no-wrap
msgid "tracing of register VMs"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1217
msgid ""
"If you want to implement a register VM rather than a stack VM with Vmgen, "
"there are two ways to do it: Directly and through superinstructions."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1220
msgid ""
"If you use the direct way, you define instructions that take the register "
"numbers as immediate arguments, like this:"
msgstr ""

#. type: example
#: ../doc/vmgen.texi:1224
#, no-wrap
msgid ""
"add3 ( #src1 #src2 #dest -- )\n"
"reg[dest] = reg[src1]+reg[src2];\n"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1231
msgid ""
"A disadvantage of this method is that during tracing you only see the "
"register numbers, but not the register contents.  Actually, with an "
"appropriate definition of @code{printarg_src} (@pxref{VM engine}), you can "
"print the values of the source registers on entry, but you cannot print the "
"value of the destination register on exit."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1235
msgid ""
"If you use superinstructions to define a register VM, you define simple "
"instructions that use a stack, and then define superinstructions that have "
"no overall stack effect, like this:"
msgstr ""

#. type: example
#: ../doc/vmgen.texi:1239
#, no-wrap
msgid ""
"loadreg ( #src -- n )\n"
"n = reg[src];\n"
"\n"
msgstr ""

#. type: example
#: ../doc/vmgen.texi:1242
#, no-wrap
msgid ""
"storereg ( n #dest -- )\n"
"reg[dest] = n;\n"
"\n"
msgstr ""

#. type: example
#: ../doc/vmgen.texi:1245
#, no-wrap
msgid ""
"adds ( n1 n2 -- n )\n"
"n = n1+n2;\n"
"\n"
msgstr ""

#. type: example
#: ../doc/vmgen.texi:1247
#, no-wrap
msgid "add3 = loadreg loadreg adds storereg\n"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1254
msgid ""
"An advantage of this method is that you see the values and not just the "
"register numbers in tracing.  A disadvantage of this method is that "
"currently you cannot generate superinstructions directly, but only through "
"generating a sequence of simple instructions (we might change this in the "
"future if there is demand)."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1261
msgid ""
"Could the register VM support be improved, apart from the issues mentioned "
"above? It is hard to see how to do it in a general way, because there are a "
"number of different designs that different people mean when they use the "
"term @emph{register machine} in connection with VM interpreters.  However, "
"if you have ideas or requests in that direction, please let me know "
"(@pxref{Contact})."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1265
#, no-wrap
msgid "error messages"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1268
msgid "These error messages are created by Vmgen:"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1271
#, no-wrap
msgid "@code{# can only be on the input side} error"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1272
#, no-wrap
msgid "# can only be on the input side"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1276
msgid ""
"You have used an instruction-stream prefix (usually @samp{#}) after the "
"@samp{--} (the output side); you can only use it before (the input side)."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1277
#, no-wrap
msgid "@code{prefix for this combination must be defined earlier} error"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1278
#, no-wrap
msgid "the prefix for this superinstruction must be defined earlier"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1282
msgid ""
"You have defined a superinstruction (e.g. @code{abc = a b c}) without "
"defining its direct prefix (e.g., @code{ab = a b}), @xref{Superinstructions}."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1283
#, no-wrap
msgid "@code{sync line syntax} error"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1284
#, no-wrap
msgid "sync line syntax"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1290
msgid ""
"If you are using a preprocessor (e.g., @command{m4}) to generate Vmgen input "
"code, you may want to create @code{#line} directives (aka sync lines).  This "
"error indicates that such a line is not in th syntax expected by Vmgen (this "
"should not happen; please report the offending line in a bug report)."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1291
#, no-wrap
msgid "@code{syntax error, wrong char} error"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1292
#, no-wrap
msgid "syntax error, wrong char"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1299
msgid ""
"A syntax error.  If you do not see right away where the error is, it may be "
"helpful to check the following: Did you put an empty line in a VM "
"instruction where the C code is not delimited by braces (then the empty line "
"ends the VM instruction)? If you used brace-delimited C code, did you put "
"the delimiting braces (and only those) at the start of the line, without "
"preceding white space? Did you forget a delimiting brace?"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1300
#, no-wrap
msgid "@code{too many stacks} error"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1301
#, no-wrap
msgid "too many stacks"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1304
msgid ""
"Vmgen currently supports 3 stacks (plus the instruction stream); if you need "
"more, let us know."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1305
#, no-wrap
msgid "@code{unknown prefix} error"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1306
#, no-wrap
msgid "unknown prefix"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1310
msgid ""
"The stack item does not match any defined type prefix (after stripping away "
"any stack prefix).  You should either declare the type prefix you want for "
"that stack item, or use a different type prefix"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1311
#, no-wrap
msgid "@code{unknown primitive} error"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1312
#, no-wrap
msgid "unknown primitive"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1315
msgid ""
"You have used the name of a simple VM instruction in a superinstruction "
"definition without defining the simple VM instruction first."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1320
msgid ""
"In addition, the C compiler can produce errors due to code produced by "
"Vmgen; e.g., you need to define type cast functions."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1324
#, no-wrap
msgid "generated code, usage"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1325
#, no-wrap
msgid "Using vmgen-erated code"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1333
msgid ""
"The easiest way to create a working VM interpreter with Vmgen is probably to "
"start with @file{vmgen-ex}, and modify it for your purposes.  This chapter "
"explains what the various wrapper and generated files do.  It also contains "
"reference-manual style descriptions of the macros, variables etc. used by "
"the generated code, and you can skip that on first reading."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1347
#, no-wrap
msgid "engine"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1348
#, no-wrap
msgid "executing VM code"
msgstr ""

#. type: file{#1}
#: ../doc/vmgen.texi:1349
#, no-wrap
msgid "engine.c"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1350
#, no-wrap
msgid "@file{-vm.i} output file"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1354
msgid ""
"The VM engine is the VM interpreter that executes the VM code.  It is "
"essential for an interpretive system."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1360
msgid ""
"Vmgen supports two methods of VM instruction dispatch: @emph{threaded code} "
"(fast, but gcc-specific), and @emph{switch dispatch} (slow, but portable "
"across C compilers); you can use conditional compilation "
"(@samp{defined(__GNUC__)}) to choose between these methods, and our example "
"does so."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1367
msgid ""
"For both methods, the VM engine is contained in a C-level function.  Vmgen "
"generates most of the contents of the function for you (@file{@var{name}-vm."
"i}), but you have to define this function, and macros and variables used in "
"the engine, and initialize the variables.  In our example the engine "
"function also includes @file{@var{name}-labels.i} (@pxref{VM instruction "
"table})."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1368
#, no-wrap
msgid "tracing VM code"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1369
#, no-wrap
msgid "superinstructions and tracing"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1376
msgid ""
"In addition to executing the code, the VM engine can optionally also print "
"out a trace of the executed instructions, their arguments and results.  For "
"superinstructions it prints the trace as if only component instructions were "
"executed; this allows to introduce new superinstructions while keeping the "
"traces comparable to old ones (important for regression tests)."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1382
msgid ""
"It costs significant performance to check in each instruction whether to "
"print tracing code, so we recommend producing two copies of the engine: one "
"for fast execution, and one for tracing.  See the rules for @file{engine.o} "
"and @file{engine-debug.o} in @file{vmgen-ex/Makefile} for an example."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1384
msgid "The following macros and variables are used in @file{@var{name}-vm.i}:"
msgstr ""

#. type: findex
#: ../doc/vmgen.texi:1387
#, no-wrap
msgid "LABEL"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1388
#, no-wrap
msgid "LABEL(@var{inst_name})"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1395
msgid ""
"This is used just before each VM instruction to provide a jump or "
"@code{switch} label (the @samp{:} is provided by Vmgen).  For switch "
"dispatch this should expand to @samp{case @var{label}:}; for threaded-code "
"dispatch this should just expand to @samp{@var{label}:}.  In either case "
"@var{label} is usually the @var{inst_name} with some prefix or suffix to "
"avoid naming conflicts."
msgstr ""

#. type: findex
#: ../doc/vmgen.texi:1396
#, no-wrap
msgid "LABEL2"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1397
#, no-wrap
msgid "LABEL2(@var{inst_name})"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1400
msgid ""
"This will be used for dynamic superinstructions; at the moment, this should "
"expand to nothing."
msgstr ""

#. type: findex
#: ../doc/vmgen.texi:1401
#, no-wrap
msgid "NAME"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1402
#, no-wrap
msgid "NAME(@var{inst_name_string})"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1407
msgid ""
"Called on entering a VM instruction with a string containing the name of the "
"VM instruction as parameter.  In normal execution this should be expand to "
"nothing, but for tracing this usually prints the name, and possibly other "
"information (several VM registers in our example)."
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1408 ../doc/vmgen.texi:1409
#, no-wrap
msgid "DEF_CA"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1414
msgid ""
"Usually empty.  Called just inside a new scope at the start of a VM "
"instruction.  Can be used to define variables that should be visible during "
"every VM instruction.  If you define this macro as non-empty, you have to "
"provide the finishing @samp{;} in the macro."
msgstr ""

#. type: findex
#: ../doc/vmgen.texi:1415
#, no-wrap
msgid "NEXT_P0"
msgstr ""

#. type: findex
#: ../doc/vmgen.texi:1416
#, no-wrap
msgid "NEXT_P1"
msgstr ""

#. type: findex
#: ../doc/vmgen.texi:1417
#, no-wrap
msgid "NEXT_P2"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1418
#, no-wrap
msgid "NEXT_P0 NEXT_P1 NEXT_P2"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1427
msgid ""
"The three parts of instruction dispatch.  They can be defined in different "
"ways for best performance on various processors (see @file{engine.c} in the "
"example or @file{engine/threaded.h} in Gforth).  @samp{NEXT_P0} is invoked "
"right at the start of the VM instruction (but after @samp{DEF_CA}), "
"@samp{NEXT_P1} right after the user-supplied C code, and @samp{NEXT_P2} at "
"the end.  The actual jump has to be performed by @samp{NEXT_P2} (if you "
"would do it earlier, important parts of the VM instruction would not be "
"executed)."
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1435
msgid ""
"The simplest variant is if @samp{NEXT_P2} does everything and the other "
"macros do nothing.  Then also related macros like @samp{IP}, @samp{SET_IP}, "
"@samp{IP}, @samp{INC_IP} and @samp{IPTOS} are very straightforward to "
"define.  For switch dispatch this code consists just of a jump to the "
"dispatch code (@samp{goto next_inst;} in our example); for direct threaded "
"code it consists of something like @samp{(@{cfa=*ip++; goto *cfa;@})}."
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1443
msgid ""
"Pulling code (usually the @samp{cfa=*ip++;}) up into @samp{NEXT_P1} usually "
"does not cause problems, but pulling things up into @samp{NEXT_P0} usually "
"requires changing the other macros (and, at least for Gforth on Alpha, it "
"does not buy much, because the compiler often manages to schedule the "
"relevant stuff up by itself).  An even more extreme variant is to pull code "
"up even further, into, e.g., NEXT_P1 of the previous VM instruction "
"(prefetching, useful on PowerPCs)."
msgstr ""

#. type: findex
#: ../doc/vmgen.texi:1444
#, no-wrap
msgid "INC_IP"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1445
#, no-wrap
msgid "INC_IP(@var{n})"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1447
msgid "This increments @code{IP} by @var{n}."
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1449
#, no-wrap
msgid "SET_IP(@var{target})"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1451
msgid "This sets @code{IP} to @var{target}."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1452
#, no-wrap
msgid "type cast macro"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1453 ../doc/vmgen.texi:1971
#, no-wrap
msgid "vm_@var{A}2@var{B}"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1454
#, no-wrap
msgid "vm_@var{A}2@var{B}(a,b)"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1464
msgid ""
"Type casting macro that assigns @samp{a} (of type @var{A}) to @samp{b} (of "
"type @var{B}).  This is mainly used for getting stack items into variables "
"and back.  So you need to define macros for every combination of stack basic "
"type (@code{Cell} in our example) and type-prefix types used with that stack "
"(in both directions).  For the type-prefix type, you use the type-prefix "
"(not the C type string) as type name (e.g., @samp{vm_Cell2i}, not "
"@samp{vm_Cell2Cell}).  In addition, you have to define a vm_@var{X}2@var{X} "
"macro for the stack's basic type @var{X} (used in superinstructions)."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1465
#, no-wrap
msgid "instruction stream, basic type"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1470
msgid ""
"The stack basic type for the predefined @samp{inst-stream} is @samp{Cell}.  "
"If you want a stack with the same item size, making its basic type "
"@samp{Cell} usually reduces the number of macros you have to define."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1471
#, no-wrap
msgid "unions in type cast macros"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1472
#, no-wrap
msgid "casts in type cast macros"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1473
#, no-wrap
msgid "type casting between floats and integers"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1481
msgid ""
"Here our examples differ a lot: @file{vmgen-ex} uses casts in these macros, "
"whereas @file{vmgen-ex2} uses union-field selection (or assignment to union "
"fields).  Note that casting floats into integers and vice versa changes the "
"bit pattern (and you do not want that).  In this case your options are to "
"use a (temporary) union, or to take the address of the value, cast the "
"pointer, and dereference that (not always possible, and sometimes expensive)."
msgstr ""

#. type: findex
#: ../doc/vmgen.texi:1482
#, no-wrap
msgid "vm_two@var{A}2@var{B}"
msgstr ""

#. type: findex
#: ../doc/vmgen.texi:1483
#, no-wrap
msgid "vm_@var{B}2two@var{A}"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1484
#, no-wrap
msgid "vm_two@var{A}2@var{B}(a1,a2,b)"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1485
#, no-wrap
msgid "vm_@var{B}2two@var{A}(b,a1,a2)"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1490
msgid ""
"Type casting between two stack items (@code{a1}, @code{a2}) and a variable "
"@code{b} of a type that takes two stack items.  This does not occur in our "
"small examples, but you can look at Gforth for examples (see "
"@code{vm_twoCell2d} in @file{engine/forth.h})."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1491
#, no-wrap
msgid "stack pointer definition"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1492
#, no-wrap
msgid "instruction pointer definition"
msgstr ""

#. type: var{#1}
#: ../doc/vmgen.texi:1493
#, no-wrap
msgid "stackpointer"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1500
msgid ""
"For each stack used, the stackpointer name given in the stack declaration is "
"used.  For a regular stack this must be an l-expression; typically it is a "
"variable declared as a pointer to the stack's basic type.  For @samp{inst-"
"stream}, the name is @samp{IP}, and it can be a plain r-value; typically it "
"is a macro that abstracts away the differences between the various "
"implementations of @code{NEXT_P*}."
msgstr ""

#. type: findex
#: ../doc/vmgen.texi:1501 ../doc/vmgen.texi:1502
#, no-wrap
msgid "IMM_ARG"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1503
#, no-wrap
msgid "IMM_ARG(access,value)"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1506
msgid ""
"Define this to expland to ``(access)''.  This is just a placeholder for "
"future extensions."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1507
#, no-wrap
msgid "top of stack caching"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1508
#, no-wrap
msgid "stack caching"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1509
#, no-wrap
msgid "TOS"
msgstr ""

#. type: findex
#: ../doc/vmgen.texi:1510
#, no-wrap
msgid "IPTOS"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1511
#, no-wrap
msgid "@var{stackpointer}TOS"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1518
msgid ""
"The top-of-stack for the stack pointed to by @var{stackpointer}.  If you are "
"using top-of-stack caching for that stack, this should be defined as "
"variable; if you are not using top-of-stack caching for that stack, this "
"should be a macro expanding to @samp{@var{stackpointer}[0]}.  The stack "
"pointer for the predefined @samp{inst-stream} is called @samp{IP}, so the "
"top-of-stack is called @samp{IPTOS}."
msgstr ""

#. type: findex
#: ../doc/vmgen.texi:1519
#, no-wrap
msgid "IF_@var{stackpointer}TOS"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1520
#, no-wrap
msgid "IF_@var{stackpointer}TOS(@var{expr})"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1525
msgid ""
"Macro for executing @var{expr}, if top-of-stack caching is used for the "
"@var{stackpointer} stack.  I.e., this should do @var{expr} if there is top-"
"of-stack caching for @var{stackpointer}; otherwise it should do nothing."
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1531
msgid ""
"This is used by the VM profiler (@pxref{VM profiler}); it should not do "
"anything in normal operation, and call @code{vm_count_block(IP)} for "
"profiling."
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1535
msgid "This is just a hint to Vmgen and does nothing at the C level."
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1536 ../doc/vmgen.texi:1537
#, no-wrap
msgid "MAYBE_UNUSED"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1542
msgid ""
"This should be defined as @code{__attribute__((unused))} for gcc-2.7 and "
"higher.  It suppresses the warnings about unused variables in the code for "
"superinstructions.  You need to define this only if you are using "
"superinstructions."
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1543 ../doc/vmgen.texi:1544
#, no-wrap
msgid "VM_DEBUG"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1549
msgid ""
"If this is defined, the tracing code will be compiled in (slower "
"interpretation, but better debugging).  Our example compiles two versions of "
"the engine, a fast-running one that cannot trace, and one with potential "
"tracing and profiling."
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1550 ../doc/vmgen.texi:1551
#, no-wrap
msgid "vm_debug"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1555
msgid ""
"Needed only if @samp{VM_DEBUG} is defined.  If this variable contains true, "
"the VM instructions produce trace output.  It can be turned on or off at any "
"time."
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1556 ../doc/vmgen.texi:1557
#, no-wrap
msgid "vm_out"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1560
msgid ""
"Needed only if @samp{VM_DEBUG} is defined.  Specifies the file on which to "
"print the trace output (type @samp{FILE *})."
msgstr ""

#. type: findex
#: ../doc/vmgen.texi:1561
#, no-wrap
msgid "printarg_@var{type}"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1562
#, no-wrap
msgid "printarg_@var{type}(@var{value})"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1569
msgid ""
"Needed only if @samp{VM_DEBUG} is defined.  Macro or function for printing "
"@var{value} in a way appropriate for the @var{type}.  This is used for "
"printing the values of stack items during tracing.  @var{Type} is normally "
"the type prefix specified in a @code{type-prefix} definition (e.g., "
"@samp{printarg_i}); in superinstructions it is currently the basic type of "
"the stack."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1576
#, no-wrap
msgid "instruction table"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1577
#, no-wrap
msgid "opcode definition"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1578
#, no-wrap
msgid "labels for threaded code"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1579
#, no-wrap
msgid "@code{vm_prim}, definition"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1580
#, no-wrap
msgid "@file{-labels.i} output file"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1588
msgid ""
"For threaded code we also need to produce a table containing the labels of "
"all VM instructions.  This is needed for VM code generation (@pxref{VM code "
"generation}), and it has to be done in the engine function, because the "
"labels are not visible outside.  It then has to be passed outside the "
"function (and assigned to @samp{vm_prim}), to be used by the VM code "
"generation functions."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1597
msgid ""
"This means that the engine function has to be called first to produce the VM "
"instruction table, and later, after generating VM code, it has to be called "
"again to execute the generated VM code (yes, this is ugly).  In our example "
"program, these two modes of calling the engine function are differentiated "
"by the value of the parameter ip0 (if it equals 0, then the table is passed "
"out, otherwise the VM code is executed); in our example, we pass the table "
"out by assigning it to @samp{vm_prim} and returning from @samp{engine}."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1600
msgid ""
"In our example (@file{vmgen-ex/engine.c}), we also build such a table for "
"switch dispatch; this is mainly done for uniformity."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1603
msgid ""
"For switch dispatch, we also need to define the VM instruction opcodes used "
"as case labels in an @code{enum}."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1607
msgid ""
"For both purposes (VM instruction table, and enum), the file "
"@file{@var{name}-labels.i} is generated by Vmgen.  You have to define the "
"following macro used in this file:"
msgstr ""

#. type: findex
#: ../doc/vmgen.texi:1610
#, no-wrap
msgid "INST_ADDR"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1611
#, no-wrap
msgid "INST_ADDR(@var{inst_name})"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1618
msgid ""
"For switch dispatch, this is just the name of the switch label (the same "
"name as used in @samp{LABEL(@var{inst_name})}), for both uses of "
"@file{@var{name}-labels.i}.  For threaded-code dispatch, this is the address "
"of the label defined in @samp{LABEL(@var{inst_name})}); the address is taken "
"with @samp{&&} (@pxref{Labels as Values, , Labels as Values, gcc.info, GNU C "
"Manual})."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1626
#, no-wrap
msgid "code generation, VM"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1627
#, no-wrap
msgid "@file{-gen.i} output file"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1632
msgid ""
"Vmgen generates VM code generation functions in @file{@var{name}-gen.i} that "
"the front end can call to generate VM code.  This is essential for an "
"interpretive system."
msgstr ""

#. type: findex
#: ../doc/vmgen.texi:1633
#, no-wrap
msgid "gen_@var{inst}"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1636
msgid ""
"For a VM instruction @samp{x ( #a b #c -- d )}, Vmgen generates a function "
"with the prototype"
msgstr ""

#. type: example
#: ../doc/vmgen.texi:1639
#, no-wrap
msgid "void gen_x(Inst **ctp, a_type a, c_type c)\n"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1647
msgid ""
"The @code{ctp} argument points to a pointer to the next instruction.  "
"@code{*ctp} is increased by the generation functions; i.e., you should "
"allocate memory for the code to be generated beforehand, and start with *ctp "
"set at the start of this memory area.  Before running out of memory, "
"allocate a new area, and generate a VM-level jump to the new area (this "
"overflow handling is not implemented in our examples)."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1648
#, no-wrap
msgid "immediate arguments, VM code generation"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1652
msgid ""
"The other arguments correspond to the immediate arguments of the VM "
"instruction (with their appropriate types as defined in the "
"@code{type_prefix} declaration."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1655
msgid ""
"The following types, variables, and functions are used in @file{@var{name}-"
"gen.i}:"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1658 ../doc/vmgen.texi:1659
#, no-wrap
msgid "Inst"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1662
msgid ""
"The type of the VM instruction; if you use threaded code, this is @code{void "
"*}; for switch dispatch this is an integer type."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1663
#, no-wrap
msgid "@code{vm_prim}, use"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1664
#, no-wrap
msgid "vm_prim"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1666
msgid ""
"The VM instruction table (type: @code{Inst *}, @pxref{VM instruction table})."
msgstr ""

#. type: findex
#: ../doc/vmgen.texi:1667
#, no-wrap
msgid "gen_inst"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1668
#, no-wrap
msgid "gen_inst(Inst **ctp, Inst i)"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1674
msgid ""
"This function compiles the instruction @code{i}.  Take a look at it in "
"@file{vmgen-ex/peephole.c}.  It is trivial when you don't want to use "
"superinstructions (just the last two lines of the example function), and "
"slightly more complicated in the example due to its ability to use "
"superinstructions (@pxref{Peephole optimization})."
msgstr ""

#. type: findex
#: ../doc/vmgen.texi:1675
#, no-wrap
msgid "genarg_@var{type_prefix}"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1676
#, no-wrap
msgid "genarg_@var{type_prefix}(Inst **ctp, @var{type} @var{type_prefix})"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1681
msgid ""
"This compiles an immediate argument of @var{type} (as defined in a "
"@code{type-prefix} definition).  These functions are trivial to define (see "
"@file{vmgen-ex/support.c}).  You need one of these functions for every type "
"that you use as immediate argument."
msgstr ""

#. type: findex
#: ../doc/vmgen.texi:1684
#, no-wrap
msgid "BB_BOUNDARY"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1691
msgid ""
"In addition to using these functions to generate code, you should call "
"@code{BB_BOUNDARY} at every basic block entry point if you ever want to use "
"superinstructions (or if you want to use the profiling supported by Vmgen; "
"but this support is also useful mainly for selecting superinstructions).  If "
"you use @code{BB_BOUNDARY}, you should also define it (take a look at its "
"definition in @file{vmgen-ex/mini.y})."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1697
msgid ""
"You do not need to call @code{BB_BOUNDARY} after branches, because you will "
"not define superinstructions that contain branches in the middle (and if you "
"did, and it would work, there would be no reason to end the superinstruction "
"at the branch), and because the branches announce themselves to the profiler."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1702
#, no-wrap
msgid "peephole optimization"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1703
#, no-wrap
msgid "superinstructions, generating"
msgstr ""

#. type: file{#1}
#: ../doc/vmgen.texi:1704
#, no-wrap
msgid "peephole.c"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1705
#, no-wrap
msgid "@file{-peephole.i} output file"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1710
msgid ""
"You need peephole optimization only if you want to use superinstructions.  "
"But having the code for it does not hurt much if you do not use "
"superinstructions."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1717
msgid ""
"A simple greedy peephole optimization algorithm is used for superinstruction "
"selection: every time @code{gen_inst} compiles a VM instruction, it checks "
"if it can combine it with the last VM instruction (which may also be a "
"superinstruction resulting from a previous peephole optimization); if so, it "
"changes the last instruction to the combined instruction instead of laying "
"down @code{i} at the current @samp{*ctp}."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1722
msgid ""
"The code for peephole optimization is in @file{vmgen-ex/peephole.c}.  You "
"can use this file almost verbatim.  Vmgen generates @file{@var{file}-"
"peephole.i} which contains data for the peephole optimizer."
msgstr ""

#. type: findex
#: ../doc/vmgen.texi:1723
#, no-wrap
msgid "init_peeptable"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1732
msgid ""
"You have to call @samp{init_peeptable()} after initializing @samp{vm_prim}, "
"and before compiling any VM code to initialize data structures for peephole "
"optimization.  After that, compiling with the VM code generation functions "
"will automatically combine VM instructions into superinstructions.  Since "
"you do not want to combine instructions across VM branch targets (otherwise "
"there will not be a proper VM instruction to branch to), you have to call "
"@code{BB_BOUNDARY} (@pxref{VM code generation}) at branch targets."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1738
#, no-wrap
msgid "disassembler, VM code"
msgstr ""

#. type: file{#1}
#: ../doc/vmgen.texi:1739
#, no-wrap
msgid "disasm.c"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1740
#, no-wrap
msgid "@file{-disasm.i} output file"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1746
msgid ""
"A VM code disassembler is optional for an interpretive system, but highly "
"recommended during its development and maintenance, because it is very "
"useful for detecting bugs in the front end (and for distinguishing them from "
"VM interpreter bugs)."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1754
msgid ""
"Vmgen supports VM code disassembling by generating @file{@var{file}-disasm."
"i}.  This code has to be wrapped into a function, as is done in @file{vmgen-"
"ex/disasm.c}.  You can use this file almost verbatim.  In addition to "
"@samp{vm_@var{A}2@var{B}(a,b)}, @samp{vm_out}, @samp{printarg_@var{type}"
"(@var{value})}, which are explained above, the following macros and "
"variables are used in @file{@var{file}-disasm.i} (and you have to define "
"them):"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1757
#, no-wrap
msgid "ip"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1759
msgid "This variable points to the opcode of the current VM instruction."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1760
#, no-wrap
msgid "@code{IP}, @code{IPTOS} in disassmbler"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1761
#, no-wrap
msgid "IP IPTOS"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1766
msgid ""
"@samp{IPTOS} is the first argument of the current VM instruction, and "
"@samp{IP} points to it; this is just as in the engine, but here @samp{ip} "
"points to the opcode of the VM instruction (in contrast to the engine, where "
"@samp{ip} points to the next cell, or even one further)."
msgstr ""

#. type: findex
#: ../doc/vmgen.texi:1767
#, no-wrap
msgid "VM_IS_INST"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1768
#, no-wrap
msgid "VM_IS_INST(Inst i, int n)"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1771
msgid ""
"Tests if the opcode @samp{i} is the same as the @samp{n}th entry in the VM "
"instruction table."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1779
#, no-wrap
msgid "profiling for selecting superinstructions"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1780
#, no-wrap
msgid "superinstructions and profiling"
msgstr ""

#. type: file{#1}
#: ../doc/vmgen.texi:1781
#, no-wrap
msgid "profile.c"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1782
#, no-wrap
msgid "@file{-profile.i} output file"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1790
msgid ""
"The VM profiler is designed for getting execution and occurence counts for "
"VM instruction sequences, and these counts can then be used for selecting "
"sequences as superinstructions.  The VM profiler is probably not useful as "
"profiling tool for the interpretive system.  I.e., the VM profiler is useful "
"for the developers, but not the users of the interpretive system."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1794
msgid ""
"The output of the profiler is: for each basic block (executed at least "
"once), it produces the dynamic execution count of that basic block and all "
"its subsequences; e.g.,"
msgstr ""

#. type: example
#: ../doc/vmgen.texi:1799
#, no-wrap
msgid ""
"       9227465  lit storelocal \n"
"       9227465  storelocal branch \n"
"       9227465  lit storelocal branch \n"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1803
msgid ""
"I.e., a basic block consisting of @samp{lit storelocal branch} is executed "
"9227465 times."
msgstr ""

#. type: file{#1}
#: ../doc/vmgen.texi:1804
#, no-wrap
msgid "stat.awk"
msgstr ""

#. type: file{#1}
#: ../doc/vmgen.texi:1805
#, no-wrap
msgid "seq2rule.awk"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1809
msgid ""
"This output can be combined in various ways.  E.g., @file{vmgen-ex/stat.awk} "
"adds up the occurences of a given sequence wrt dynamic execution, static "
"occurence, and per-program occurence.  E.g.,"
msgstr ""

#. type: example
#: ../doc/vmgen.texi:1812
#, no-wrap
msgid "      2      16        36910041 loadlocal lit \n"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1824
msgid ""
"indicates that the sequence @samp{loadlocal lit} occurs in 2 programs, in 16 "
"places, and has been executed 36910041 times.  Now you can select "
"superinstructions in any way you like (note that compile time and space "
"typically limit the number of superinstructions to 100--1000).  After you "
"have done that, @file{vmgen/seq2rule.awk} turns lines of the form above into "
"rules for inclusion in a Vmgen input file.  Note that this script does not "
"ensure that all prefixes are defined, so you have to do that in other ways.  "
"So, an overall script for turning profiles into superinstructions can look "
"like this:"
msgstr ""

#. type: example
#: ../doc/vmgen.texi:1831
#, no-wrap
msgid ""
"awk -f stat.awk fib.prof test.prof|\n"
"awk '$3>=10000'|                #select sequences\n"
"fgrep -v -f peephole-blacklist| #eliminate wrong instructions\n"
"awk -f seq2rule.awk|            #turn into superinstructions\n"
"sort -k 3 >mini-super.vmg       #sort sequences\n"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1841
msgid ""
"Here the dynamic count is used for selecting sequences (preliminary results "
"indicate that the static count gives better results, though); the third line "
"eliminates sequences containing instructions that must not occur in a "
"superinstruction, because they access a stack directly.  The dynamic count "
"selection ensures that all subsequences (including prefixes) of longer "
"sequences occur (because subsequences have at least the same count as the "
"longer sequences); the sort in the last line ensures that longer "
"superinstructions occur after their prefixes."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1845
msgid ""
"But before using this, you have to have the profiler.  Vmgen supports its "
"creation by generating @file{@var{file}-profile.i}; you also need the "
"wrapper file @file{vmgen-ex/profile.c} that you can use almost verbatim."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1846
#, no-wrap
msgid "@code{SUPER_END} in profiling"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1847
#, no-wrap
msgid "@code{BB_BOUNDARY} in profiling"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1859
msgid ""
"The profiler works by recording the targets of all VM control flow changes "
"(through @code{SUPER_END} during execution, and through @code{BB_BOUNDARY} "
"in the front end), and counting (through @code{SUPER_END}) how often they "
"were targeted.  After the program run, the numbers are corrected such that "
"each VM basic block has the correct count (entering a block without "
"executing a branch does not increase the count, and the correction fixes "
"that), then the subsequences of all basic blocks are printed.  To get all "
"this, you just have to define @code{SUPER_END} (and @code{BB_BOUNDARY}) "
"appropriately, and call @code{vm_print_profile(FILE *file)} when you want to "
"output the profile on @code{file}."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1860
#, no-wrap
msgid "@code{VM_IS_INST} in profiling"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1865
msgid ""
"The @file{@var{file}-profile.i} is similar to the disassembler file, and it "
"uses variables and functions defined in @file{vmgen-ex/profile.c}, plus "
"@code{VM_IS_INST} already defined for the VM disassembler (@pxref{VM "
"disassembler})."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1869
#, no-wrap
msgid "hints"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1882
msgid ""
"How should you deal with floating point values? Should you use the same "
"stack as for integers/pointers, or a different one? This section discusses "
"this issue with a view on execution speed."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1892
msgid ""
"The simpler approach is to use a separate floating-point stack.  This allows "
"you to choose FP value size without considering the size of the integers/"
"pointers, and you avoid a number of performance problems.  The main downside "
"is that this needs an FP stack pointer (and that may not fit in the register "
"file on the 386 arhitecture, costing some performance, but comparatively "
"little if you take the other option into account).  If you use a separate FP "
"stack (with stack pointer @code{fp}), using an fpTOS is helpful on most "
"machines, but some spill the fpTOS register into memory, and fpTOS should "
"not be used there."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1902
msgid ""
"The other approach is to share one stack (pointed to by, say, @code{sp})  "
"between integer/pointer and floating-point values.  This is ok if you do not "
"use @code{spTOS}.  If you do use @code{spTOS}, the compiler has to decide "
"whether to put that variable into an integer or a floating point register, "
"and the other type of operation becomes quite expensive on most machines "
"(because moving values between integer and FP registers is quite "
"expensive).  If a value of one type has to be synthesized out of two values "
"of the other type (@code{double} types), things are even more interesting."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1908
msgid ""
"One way around this problem would be to not use the @code{spTOS} supported "
"by Vmgen, but to use explicit top-of-stack variables (one for integers, one "
"for FP values), and having a kind of accumulator+stack architecture (e.g., "
"Ocaml bytecode uses this approach); however, this is a major change, and its "
"ramifications are not completely clear."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1912
#, no-wrap
msgid "future ideas"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1918
msgid ""
"We have a number of ideas for future versions of Vmgen.  However, there are "
"so many possible things to do that we would like some feedback from you.  "
"What are you doing with Vmgen, what features are you missing, and why?"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1931
msgid ""
"One idea we are thinking about is to generate just one @file{.c} file "
"instead of letting you copy and adapt all the wrapper files (you would still "
"have to define stuff like the type-specific macros, and stack pointers etc. "
"somewhere).  The advantage would be that, if we change the wrapper files "
"between versions, you would not need to integrate your changes and our "
"changes to them; Vmgen would also be easier to use for beginners.  The main "
"disadvantage of that is that it would reduce the flexibility of Vmgen a "
"little (well, those who like flexibility could still patch the resulting "
"@file{.c} file, like they are now doing for the wrapper files).  In any "
"case, if you are doing things to the wrapper files that would cause problems "
"in a generated-@file{.c}-file approach, please let us know."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1935
#, no-wrap
msgid "Changes from old versions"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1938
msgid "User-visible changes between 0.5.9-20020822 and 0.5.9-20020901:"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1942
msgid ""
"The store optimization is now disabled by default, but can be enabled by the "
"user (@pxref{Store Optimization}).  Documentation for this optimization is "
"also new."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1944
msgid "User-visible changes between 0.5.9-20010501 and 0.5.9-20020822:"
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1946
msgid ""
"There is now a manual (in info, HTML, Postscript, or plain text format)."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1949
msgid ""
"There is the vmgen-ex2 variant of the vmgen-ex example; the new variant uses "
"a union type instead of lots of casting."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1953
msgid ""
"Both variants of the example can now be compiled with an ANSI C compiler "
"(using switch dispatch and losing quite a bit of performance); tested with "
"@command{lcc}."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1960
msgid ""
"Users of the gforth-0.5.9-20010501 version of Vmgen need to change several "
"things in their source code to use the current version.  I recommend keeping "
"the gforth-0.5.9-20010501 version until you have completed the change (note "
"that you can have several versions of Gforth installed at the same time).  I "
"hope to avoid such incompatible changes in the future."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1962
msgid "The required changes are:"
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1965
#, no-wrap
msgid "@code{TAIL;}, changes"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1966
#, no-wrap
msgid "TAIL;"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1969
msgid ""
"has been renamed into @code{INST_TAIL;} (less chance of an accidental match)."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1970
#, no-wrap
msgid "@code{vm_@var{A}2@var{B}}, changes"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1973
msgid "now takes two arguments."
msgstr ""

#. type: cindex
#: ../doc/vmgen.texi:1974
#, no-wrap
msgid "@code{vm_two@var{A}2@var{B}}, changes"
msgstr ""

#. type: item
#: ../doc/vmgen.texi:1975
#, no-wrap
msgid "vm_two@var{A}2@var{B}(b,a1,a2);"
msgstr ""

#. type: table
#: ../doc/vmgen.texi:1977
msgid ""
"changed to vm_two@var{A}2@var{B}(a1,a2,b) (note the absence of the @samp{;})."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1983
msgid ""
"Also some new macros have to be defined, e.g., @code{INST_ADDR}, and "
"@code{LABEL}; some macros have to be defined in new contexts, e.g., "
"@code{VM_IS_INST} is now also needed in the disassembler."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1990
msgid ""
"To report a bug, use @url{https://savannah.gnu.org/bugs/?"
"func=addbug&group_id=2672}."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1994
msgid ""
"For discussion on Vmgen (e.g., how to use it), use the mailing list "
"@email{bug-vmgen@@mail.freesoftware.fsf.org} (use @url{http://mail.gnu.org/"
"mailman/listinfo/help-vmgen} to subscribe)."
msgstr ""

#. type: Plain text
#: ../doc/vmgen.texi:1997
msgid ""
"You can find vmgen information at @url{http://www.complang.tuwien.ac.at/"
"anton/vmgen/}."
msgstr ""

#. type: include
#: ../doc/vmgen.texi:2008
#, no-wrap
msgid "fdl.texi"
msgstr ""
