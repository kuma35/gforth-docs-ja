<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- このマニュアルは、 標準 Forth 言語の高速で移植可能な実装である Gforth (バージョン 0.7.9_20240418,
April 18, 2024)用です。 これはリファレンス・マニュアルとして機能しますが、 Forth の概要と Forth
チュートリアルも含まれています。

Authors: Bernd Paysan, Anton Ertl, Gerald Wodni Copyright (C) 1995,
1996, 1997, 1998, 2000, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
2011, 2012, 2013, 2014,2015,2016,2017,2018,2019,2020,2021,2022,2023 Free
Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant
Sections, with the Front-Cover texts being "A GNU Manual," and with the
Back-Cover Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have freedom to copy and modify this
GNU Manual, like GNU software.  Copies published by the Free Software
Foundation raise funds for GNU development." -->
<title>How does that work? (Gforth マニュアル)</title>

<meta name="description" content="How does that work? (Gforth マニュアル)">
<meta name="keywords" content="How does that work? (Gforth マニュアル)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Word-Index.html" rel="index" title="Word Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Introduction.html" rel="up" title="Introduction">
<link href="Forth-is-written-in-Forth.html" rel="next" title="Forth is written in Forth">
<link href="Your-first-definition.html" rel="prev" title="Your first definition">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="gforth.css">


</head>

<body lang="en">
<div class="section" id="How-does-that-work_003f">
<div class="header">
<p>
Next: <a href="Forth-is-written-in-Forth.html" accesskey="n" rel="next">Forth is written in Forth</a>, Previous: <a href="Your-first-definition.html" accesskey="p" rel="prev">Your first Forth definition</a>, Up: <a href="Introduction.html" accesskey="u" rel="up">An Introduction to Standard Forth</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Word-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="How-does-that-work_003f-1"></span><h3 class="section">4.4 How does that work?</h3>
<span id="index-parsing-words"></span>








<p>ここで、 前のセクションの <code>add-two</code> の定義をもう一度見てみましょう。 テキスト・インタプリタの動作方法に関する知識から、
<code>add-two</code> を定義しようとしたとき、 私達は以下の結果を予期したかもしれません:
</p>
<div class="example">
<pre class="example"><kbd>: add-two 2 + . ;<span class="key">RET</span></kbd>
*the terminal*:4: Undefined word
: &gt;&gt;&gt;add-two&lt;&lt;&lt; 2 + . ;
</pre></div>

<span id="index-modifying-_003eIN"></span>
<p>しかし、 これが起こらなかった理由は、 <code>:</code> の動作方法に関係しています。 <code>:</code> というワードは 2 つの特別な働きをします。
1つ目の特別な機能は、 テキスト・インタプリタが <code>add-two</code> という文字を認識できないようにすることです。 テキスト・インタプリタは、
<code>&gt;IN</code> (to-in;トゥーイン)という変数を使用して、 入力行のどこを追跡するかを保持し、 <code>:</code> というワードに遭遇すると、
他のワードの場合とまったく同じように動作します。 名前ディクショナリでそれを検索し、 その xt を見つけて実行します。  実行される <code>:</code>
は、 入力バッファーを調べてワード <code>add-two</code> を見つけ、 <code>&gt;IN</code> の値をその後ろを指すように進めておきます。 次に、
新しい定義の作成に関連するその他の処理を実行します(名前ディクショナリに <code>add-two</code> のエントリを作成する等)。 <code>:</code>
の実行が完了すると、 制御はテキスト・インタプリタに戻ります。 テキスト・インタプリタは、
このトリックにより入力行の一部をスキップしていることに気づきません。
</p>
<span id="index-parsing-words-1"></span>
<p><code>:</code> のようなワード(<code>&gt;IN</code> の値を進めて、 テキスト・インタプリタが入力行全体に作用するのを妨げるワード)は、
「構文解析ワード」(parsing words)と呼ばれます。
</p>
<span id="index-state-_002d-effect-on-the-text-interpreter"></span>
<span id="index-text-interpreter-_002d-effect-of-state"></span>
<p><code>:</code> が行う 2 つ目の特別な処理は、 <code>state</code> と呼ばれる変数の値を変更することです。 これは、
テキスト・インタプリタの振る舞いに影響します。 Gforth が起動するとき、 <code>state</code> の値は 0 であり、
テキスト・インタプリタはインタプリタ状態(<em>interpreting</em>)であると言われます。 (<code>:</code> で始まる)コロン定義中 、
<code>state</code> は -1 に設定され、テキスト・インタプリタはコンパイル状態(<em>compiling</em>)と言われます。
</p>
<p>この例では、 テキスト・インタプリタは文字列 &ldquo;<code>2 + . ;</code>&rdquo;。引き続き同じ方法で文字列を文字シーケンスに分割します。ただし、数値
<code>2</code> をスタックにプッシュする代わりに、 数値 <code>2</code> を取得する魔法を <code>add-two</code>
の定義に組み込み(コンパイル)、 <code>add-two</code> が「実行」されたときスタックにプッシュされます。 同様に、 <code>+</code> と
<code>.</code> の振る舞いも定義にコンパイルされます。
</p>
<p>特定の種類のワードはコンパイルされません。 これらのいわゆる「即実行ワード」(immediate word)は、
テキスト・インタプリタがインタプリタ状態であるかコンパイル状態であるかに関係なく、 実行されます(今、 直ちに実行されます)。 <code>;</code>
というワードは即実行ワードです。 定義にコンパイルされるのではなく、 実行されます。 その効果は、 <code>state</code> の値を 0
に戻すことを含む、 現在の定義を終了することです。
</p>
<p>あなたが <code>add-two</code> を実行すると、 その定義の外で <code>2 + . <span class="key">RET</span></code>
と入力した場合とまったく同一の「実行時効果」(run-time effect) が生じます。
</p>
<p>Forth では、 すべてのワードまたは数値は以下の 2 つの性質を持ちます:
</p>
<ul>
<li> <span id="index-interpretation-semantics"></span>
その インタプリタ機能(interpretation semantics)は、
テキスト・インタプリタがインタプリタ状態でどのように動作するかを記述します。 ワードのインタプリタ機能は、 その「実行トークン」(execution
token)(see <a href="Execution-token.html">Execution token</a>)によって表されます。
</li><li> <span id="index-compilation-semantics"></span>
その コンパイル機能(compilation semantics)は、 テキスト・インタプリタがコンパイル状態でどのように動作するかを記述します。
ワードのコンパイル機能は、 その「コンパイル・トークン」(see <a href="Compilation-token.html">Compilation token</a>)によって表されます。
</li></ul>

<p>数値は常に決まった方法で処理されます:
</p>
<ul>
<li> その数値が解釈(interpret)される場合、 その振る舞いは、 その数値をスタックにプッシュすることです。
</li><li> その数値がコンパイルされる場合、 実行時にその数値をプッシュするコードが現在の定義に追加されます。 (言い換えれば、
数値のコンパイル機能(compilation semantics)は、 コンパイルされる定義の実行時まで、
その数値のインタプリタ機能(interpretation semantics)の実行を延期します。)
</li></ul>

<p>ワードは常にこのような通常の振る舞いをするとは限りませんが、 ほとんどのワードにはデフォルトの機能(default semantics)があり、
以下のように振る舞うことを意味します:
</p>
<ul>
<li> ワードのインタプリタ機能(<em>interpretation semantics</em>)は、 何かしら役に立つことを行うことです。
</li><li> ワードのコンパイル機能(compilation semantics)は、 そのワードのインタプリタ機能(interpretation
semantics)を現在の定義に追加します(よって、 それは実行時に何かしら役に立つことを行います)。
</li></ul>

<span id="index-immediate-words"></span>
<p>特定のワードの実際の振る舞いは、 ワードの定義時に <code>immediate</code> や <code>compile-only</code>
というワードを使用することで制御できます。 これらのワードは、 最後に定義されたワードの名前ディクショナリ・エントリにフラグを設定します。
これらのフラグは、 名前ディクショナリでワードが見つかったときにテキスト・インタプリタによって取得されます。
</p>
<p><em>immediate</em> としてマークされたワードは、 そのインタプリタ機能(interpretation
semantics)と同じコンパイル機能(compilation semantics)を持ちます。 つまり、 以下のように振る舞います:
</p>
<ul>
<li> ワードのインタプリタ機能(<em>interpretation semantics</em>)は、 何かしら役に立つことを行うことです。
</li><li> このワードのコンパイル機能(compilation semantics)は、
何かしら役に立つことを行うことです(実際にはインタプリタ機能と同一のことを行うことです)。 つまり、
このワードのコンパイル機能はコンパイル中に実行されます。
</li></ul>

<p>ワードを <em>compile-only</em> としてマークすると、 解釈状態(interpretation
state)でこのワードを検出したときにテキスト・インタプリタが警告を生成することを意味します。 (<code>'</code> または <code>[']</code>
を使用して) ワードをティックすると、 警告が生成されます。
</p>
<p><code>compile-only</code> を使用する必要はありません(多くの実装によって提供されてはいますが、 標準 Forth
の一部でもありません)が、 解釈状態(interpret state)で正しく振る舞わないワードに <code>compile-only</code>
を適用するのは良いエチケットです(そして予期しない副作用が発生する可能性があります)。 たとえば、 定義内で条件ワード <code>IF</code>
を使用することのみが正当です。 これを忘れて別の場所で使用しようとすると、 (Gforth では) <code>compile-only</code>
としてマークされているため、 テキスト・インタプリタが有用な警告を生成できます。
</p>
<p>以下の例は、 即実行ワードと非即実行ワードの違いを示しています:
</p>
<div class="example">
<pre class="example">: show-state state @ . ;
: show-state-now show-state ; immediate
: word1 show-state ;
: word2 show-state-now ;
</pre></div>

<p><code>show-state-now</code> の定義の後にあるワード <code>immediate</code> は、そのワードを即実行ワードにします。
これらの定義では、 <code>@</code>(「フェッチ」と発音します) という新しいワードが導入されています。
このワードは変数の値を取り出し(フェッチし)、 それをスタックに残します。 したがって、 <code>show-state</code> の振る舞いは、
<code>state</code> の現在の値を表す数値を出力することです。
</p>
<p><code>word1</code> を実行すると、 システムがインタプリタ状態であることを示す数値 0 が出力されます。 テキスト・インタプリタが
<code>word1</code> の定義をコンパイルしたときに、 コンパイル機能が現在の定義に実行時コードを追加する <code>show-state</code>
に遭遇しました。 <code>word1</code> を実行すると、 <code>show-state</code> のインタプリタ機能(interpretation
semantics)が実行されます。  <code>word1</code> (つまり <code>show-state</code>) が実行される時点で、
システムはインタプリタ状態です。
</p>
<p><code>word2</code> の定義を入力した後に <tt class="key">RET</tt> を押すと、 数値 -1 が出力され、 その後に <code> ok</code>
が表示されるはずです。 テキスト・インタプリタが <code>word2</code> の定義をコンパイルすると、 即実行ワードである
<code>show-state-now</code> が検出されたため、 そのコンパイル機能(compilation
semantics)はインタプリタ機能(interpretation semantics)を実行します。
これは直ちにに実行されます(テキスト・インタプリタが次の文字グループ(この例では <code>;</code>)の処理に移る前に)。 これを実行すると、
<code>word2</code> の定義途中の <code>state</code> の値が表示されます。 -1 を出力するので、
システムがその時点でコンパイル状態であることがわかります。 もし あなたが <code>word2</code> を「実行」しても何も行いません。
</p>
<span id="index-_002e_0022_002c-how-it-works"></span>
<p>即実行ワードの話題を離れる前に、 前のセクションの <code>greet</code> の定義における <code>.&quot;</code> の振る舞いについて検討してみましょう。
このワードは構文解析ワード(parsing word)でもあり、 かつ、 即実行ワードでもあります。  <code>.&quot;</code> とそのテキストの先頭
<code>Hello and welcome</code> の間にはスペースがありますが、 <code>welcome</code> の最後の文字と <code>&quot;</code>
文字の間にはスペースがありません。 これは、<code>.&quot;</code> が Forth ワードであるということです。 テキスト・インタプリタがその Forth
ワード <code>.&quot;</code> を識別できるように、 <code>.&quot;</code> の後ろにスペースが必要です。 <code>&quot;</code> は Forth ワードではなく、
区切り文字(delimiter)です。 先の例では、 文字列が表示されるときに、 <code>H</code> の前にも <code>e</code>
の後ろにもスペースがないことを示しています。 <code>.&quot;</code> は即実行ワードなので、 <code>greet</code> の定義中に実行されます。
実行されると、 入力行内を前方に走査して区切り文字を探します。 区切り文字が見つかると、 区切り文字の後ろを指すように <code>&gt;IN</code>
を更新します。 また、 いくつかのマジック・コード、 つまりテキスト文字列を出力する実行時コード xtを <code>greet</code>
の定義にコンパイルします。 文字列 <code>Hello and welcome</code> をメモリにコンパイルして、 後で出力できるようにします。 その後、
テキスト・インタプリタが制御を取得すると、 入力ストリーム内で次に検出されるワードは <code>;</code> であるため、 <code>greet</code>
の定義を終了します。
</p>

</div>
<hr>
<div class="header">
<p>
Next: <a href="Forth-is-written-in-Forth.html">Forth is written in Forth</a>, Previous: <a href="Your-first-definition.html">Your first Forth definition</a>, Up: <a href="Introduction.html">An Introduction to Standard Forth</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Word-Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
