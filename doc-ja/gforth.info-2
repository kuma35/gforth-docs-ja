This is gforth.info, produced by makeinfo version 6.8 from gforth.texi.

このマニュアルは、 標準 Forth 言語の高速で移植可能な実装である Gforth (バ
ージョン 0.7.9_20240418, April 18, 2024)用です。 これはリファレンス・マ
ニュアルとして機能しますが、 Forth の概要と Forth チュートリアルも含まれ
ています。

   Authors: Bernd Paysan, Anton Ertl, Gerald Wodni Copyright © 1995,
1996, 1997, 1998, 2000, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
2011, 2012, 2013, 2014,2015,2016,2017,2018,2019,2020,2021,2022,2023 Free
Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover texts
     being “A GNU Manual,” and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by the
     Free Software Foundation raise funds for GNU development.”
INFO-DIR-SECTION Software development
START-INFO-DIR-ENTRY
* Gforth: (gforth).          forth言語のための高速インタプリタ
END-INFO-DIR-ENTRY


File: gforth.info,  Node: $tring words,  Next: Counted string words,  Prev: String words,  Up: Strings and Characters

6.8.5 $tring words
------------------

以下の文字列ライブラリは、 文字列を通常のセル・サイズの変数(文字列ハンド
ル;string handle)に格納します。 これらのハンドルには、 ヒープに割り当て
られたセル・カウント文字列(cell-counted string;カウンタがセルサイズであ
るカウンタ付き文字列)へのポインタが含まれています。 この文字列ライブラリ
は bigFORTH 由来です。

   内容への恒久的な参照は 1 つだけ(ハンドル内の参照)しかないため、 未解
決の参照を恐れることなく文字列を再配置または削除できます。 これには、 プ
ログラマが、 例えば ‘$@’ 等によって生成された参照を一時的な目的でのみ使
用する必要があります。 つまり、 これらの一時的な参照は、 戻り値として渡
されたり、 グローバル・メモリに格納されたりすることはなく、 ハンドルを変
更する可能性のあるワードは、 これらの一時的な参照が存在する間は呼び出さ
れません。

   このライブラリを補完するものとしてセルペア表現(cell-pair
representation)があります。 文字列変数に対して $tring ワードを使用します
が、 これは c-addr u 表現では面倒です。 セルペア表現は、 文字列を変更し
ないで処理(検査など)するために使用します。

‘$!’ ( addr1 u $addr –  ) gforth-0.7 “string-store”
   新しく割り当てられた文字列バッファーをアドレス($addr)が指す先に格納し
、 必要に応じて以前のバッファーを解放します。

‘$@’ ( $addr – addr2 u  ) gforth-0.7 “string-fetch”
   格納された文字列のアドレスと長さを返します。

‘$@len’ ( $addr – u  ) gforth-0.7 “string-fetch-len”
   格納されている文字列の長さを返します。

‘$!len’ ( u $addr –  ) gforth-0.7 “string-store-len”
   格納されている文字列(string)領域の長さを変更します(足し算ではない。 長
さを直にいじる) それゆえ、メモリ領域を変更し、 アドレスとカウンタ・セル
も調整(adjust)する必要があります(訳注: 元の長さより長くした場合、 領域を
拡張するだけで初期化はしない。 そこにはゴミが入っているので自分で初期化
する必要がある)

‘$+!len’ ( u $addr – addr  ) gforth-1.0 “string-plus-store-len”
   $addr によって参照されるメモリ領域の最後に u バイト用の空間を確保しま
す(追加。確保するだけで初期化はしない。 $addr の「長さ」に追加もする)。
addr は、 確保した空間の最初のアドレスです。

‘$del’ ( addr off u –  ) gforth-0.7 “string-del”
   文字列のオフセット位置 OFF から U バイト削除します。

‘$ins’ ( addr1 u $addr off –  ) gforth-0.7 “string-ins”
   オフセット位置 OFF に文字列を挿入します。

‘$+!’ ( addr1 u $addr –  ) gforth-0.7 “string-plus-store”
   文字列(addr1 u)を別の文字列($addr)に追加します。

‘c$+!’ ( char $addr –  ) gforth-1.0 “c-string-plus-store”
   文字列に文字を追加します。

‘$free’ ( $addr –  ) gforth-1.0 “string-free”
   $addr が指す文字列を解放し、 $addr のポインタを 0 にします( $ すると
0 0 を返す)

‘$init’ ( $addr –  ) gforth-1.0 “string-init”
   以前に何があったかに関係なく、そこに空の文字列を保存します(訳注: ポイ
ンタを 0 にする訳ではなくて、 ポインタの指す先に長さゼロの文字列がある)

‘$split’ ( addr u char – addr1 u1 addr2 u2  ) gforth-0.7 “string-split”
   文字列中で最初に現れる char を区切り文字として文字列を 2 つに分割しま
す(例: HTML クエリの引数の ’?’)(訳注: 区切り文字 char 自体は分割後の文字
列に含まれない)

‘$iter’ ( .. $addr char xt – ..  ) gforth-0.7 “string-iter”
   区切り文字 char で切り出した部分文字列(addr u)ごとに xt を呼び出しま
す。 xt は (addr u – ) でなければなりません。 これにより、 例えば ’&’ で
区切られた引数を簡単に分解できます(訳注: : my-type ( addr u – ) ."  ["
type ."  ]"  ; variable title s" GNU gforth manual" title $!  title
$ my-type [GNU gforth manual] title bl ’ my-type $iter
[GNU][gforth][manual] ok)。

‘$over’ ( addr u $addr off –  ) gforth-1.0 “string-over”
   $addr の文字列のオフセット位置 off から文字列(addr u)で上書きします。

‘$exec’ ( xt addr –  ) gforth-1.0 “string-exec”
   実行トークン xt を実行し、 その標準出力(TYPE や EMIT やそれらを使用す
るすべてのもの)を addr が指す文字列の末尾に「追加」します。

‘$tmp’ ( xt – addr u  ) gforth-1.0 “string-t-m-p”
   ワードの出力から一時的な文字列を生成します

‘$.’ ( addr –  ) gforth-1.0 “string-dot”
   文字列を出力する、 ショートカット( $ TYPE → $.  )

‘$slurp’ ( fid addr –  ) gforth-1.0 “string-slurp”
   (slurp;音を立ててすする)ファイル fid を最後まで読み取り(ファイルのク
ローズは行いません)、 読み取ったデータを addr の指す文字列に入れます。

‘$slurp-file’ ( c-addr u addr –  ) gforth-1.0 “string-slurp-file”
   c-addr u という名前のファイル内のすべてのデータを addr の文字列に入力
します。

‘$+slurp’ ( fid addr –  ) gforth-1.0 “string-plus-slurp”
   ファイル fid を最後まで読み取り(但しクローズはしません)、 読み取った
データを addr の文字列に「追加」します。

‘$+slurp-file’ ( c-addr u addr –  ) gforth-1.0 “string-plus+slurp-file”
   c-addr u という名前のファイル内のすべてのデータを addr の文字列に「追
加」します。

‘$[]’ ( u $[]addr – addr’  ) gforth-1.0 “string-array”
   addr’ は、 文字列配列 $[]addr の u 番目の要素のアドレスです。 配列の
サイズは必要に応じて変更されます。

‘$[]!’ ( c-addr u n $[]addr –  ) gforth-1.0 “string-array-store”
   文字列 c-addr u を文字列配列 $[]addr のインデックス n に格納します。
必要に応じて配列のサイズが変更されます。

‘$[]+!’ ( c-addr u n $[]addr –  ) gforth-1.0 “string-array-plus-store”
   文字列 c-addr u をインデックス n の文字列に「追加」します。 必要に応
じて配列のサイズが変更されます。 これを ‘$+[]!’ と混同しないでください。

‘$+[]!’ ( c-addr u $[]addr –  ) gforth-1.0 “string-append-array”
   文字列 c-addr u を文字列配列 $[]addr の新しい最後の要素として保存しま
す(つまり要素が1つ増える)。 必要に応じて配列のサイズが変更されます。

‘$[]@’ ( n $[]addr – addr u  ) gforth-1.0 “string-array-fetch”
   配列インデックス n から文字列を取得します — 空の場合はゼロ文字列( 0 0
)を返し、 誤って配列が成長しないようにします(訳注:要素はあるけど空文字列
(長さ0)の場合と、範囲外の要素を指した場合の区別は付かないので注意)

‘$[]#’ ( addr – len  ) gforth-1.0 “string-array-num”
   配列内の要素の数を返します

‘$[]map’ ( addr xt –  ) gforth-1.0 “string-array-map”
   文字列配列 ADDR のすべての要素に対して 実行トークン XT を実行します。
xt は ( ADDR U – ) で、一度に 1 つの文字列を取得します

‘$[]slurp’ ( fid addr –  ) gforth-1.0 “string-array-slurp”
   ファイル FID の内容を 1 行ずつ文字列配列 ADDR に入れます

‘$[]slurp-file’ ( addr u $addr –  ) gforth-1.0 “string-array-slurp-file”
   名前付きファイル ADDR U を 1 行ずつ文字列配列 $ADDR に入れます。

‘$[].’ ( addr –  ) gforth-1.0 “string-array-dot”
   すべての配列エントリを出力します

‘$[]free’ ( addr –  ) gforth-1.0 “string-array-free”
   addr は沢山のセルカウント文字列(string)へのアドレス達を含む、 セル・
カウント文字列(string)へのアドレスで、 $[]free はこれらの文字列を解放、
つまり、 この配列を開放し、 addr の値を 0 にセットします。

‘$save’ ( $addr –  ) gforth-1.0 “string-save”
   savesys のディクショナリに文字列(string)をプッシュします

‘$[]save’ ( addr –  ) gforth-1.0 “string-array-save”
   文字列配列を savesys のディクショナリにプッシュ

‘$boot’ ( $addr –  ) gforth-1.0 “string-boot”
   ディクショナリから文字列を新しく割り当てたメモリに取り込みます。 その
後、 ディクショナリのその文字列の領域を(0で)クリアします(長さはそのまま
)。

‘$[]boot’ ( addr –  ) gforth-1.0 “string-array-boot”
   ディクショナリから、 文字列配列を割り当てられたメモリに取得します

‘$saved’ ( addr –  ) gforth-1.0 “string-saved”
   アドレスを ブート済み(booted)/保存済み(saved) としてマークする

‘$[]saved’ ( addr –  ) gforth-1.0 “string-array-saved”
   アドレスを ブート済み(booted)/保存済み(saved) としてマークする

‘$Variable’ ( –  ) gforth-1.0 “string-variable”
   savesystem 全体にわたって保存される文字列変数。

‘$[]Variable’ ( –  ) gforth-1.0 “string-array-variable”
   savesystem 全体にわたって保存される文字列変数。


File: gforth.info,  Node: Counted string words,  Prev: $tring words,  Up: Strings and Characters

6.8.6 Counted string words
--------------------------

カウンタ付文字列(counted string)は、 指定のアドレスのバイトとして長さを
格納し、 その後に文字列のバイトが続きます。 可能な長さは厳しく制限されて
おり、 入力文字列を破壊せずにその場で部分文字列を作成することはできませ
ん。 したがって、 カウンタ付文字列を使用しないことをお勧めします。 それ
でも、 カウンタ付文字列を処理する必要がある場合、 以下のようなワード群が
あります:

‘count’ ( c-addr1 – c-addr2 u ) core “count”
   c-addr2 は最初の文字で、 u は c-addr1 のカウンタ付文字列の、 長さです
。

   以下のワードは、 (‘s"’ とは異なり) 有用なインタプリタ機能
(interpretation semantics)がなく、 (‘[char]’ とは異なり) 対応するインタ
プリタ用コードがないため、 コロン定義内でのみ使用する必要があります(コロ
ン定義がある場合):

‘C"’ ( compilation "ccc<quote>" – ; run-time  – c-addr  ) core-ext “c-quote”
   コンパイル状態: ‘"’ (二重引用符) を区切り文字として文字列 ccc をパー
スします。 その実行時コードは、 指定のカウンタ付文字列 ccc のアドレスを
c-addr として返します。 インタプリタ機能は未定義です。

   ( gforth-obsolete ) ‘place’ ( c-addr1 u c-addr2 –) \ C-ADDR2 に長さ U
のカウンタ付き文字列を作成し、 文字列 C-ADDR1 U をその場所にコピーします
。
‘string,’ ( c-addr u –  ) gforth-0.2 “string,”
   文字列をカウンタ付き文字列として(here以降の)データ空間に書き込みます
。


File: gforth.info,  Node: Control Structures,  Next: Defining Words,  Prev: Strings and Characters,  Up: Words

6.9 Control Structures
======================

Forth の制御構造は、 コロン定義内のみで、 対話的(interpretively)に使用す
ることはできません(1)。 私たちもこのような制限を好まないので、 多くのス
キームが提案されてはいますが、 これを回避する満足のいく方法はまだ見つか
っていません。

* Menu:

* Selection::                IF ... ELSE ... ENDIF
* Simple Loops::             BEGIN ...
* Counted Loops::            DO
* BEGIN loops with multiple exits::
* General control structures with CASE::
* Arbitrary control structures::
* Calls and returns::
* Exception Handling::

   ---------- Footnotes ----------

   (1) 正確には、 インタプリタ機能(interpretation semantics)(*note
Interpretation and Compilation Semantics::)を持っていません


File: gforth.info,  Node: Selection,  Next: Simple Loops,  Prev: Control Structures,  Up: Control Structures

6.9.1 Selection
---------------

     flag
     IF
       code
     ENDIF

   flag がゼロ以外の場合(‘IF’ などに関する限り、 任意のビットが設定され
たセルは true 扱いです)、 code が実行されます。

     flag
     IF
       code1
     ELSE
       code2
     ENDIF

   FLAG が true の場合は code1 が実行され、 それ以外の場合は code2 が実
行されます。

   ‘ENDIF’ の代わりに ‘THEN’ を使用できます。 実際 ‘THEN’ は標準です、 が
しかし、 ‘ENDIF’ は非常に人気があるものの、 標準ではありません。 私達は
‘ENDIF’ の使用をお勧めします。 なぜなら、 他の言語を知っている人にとって
も混乱が少ないためです(また、 ‘ENDIF’ に対しては、 これらの人々の Forth
に対する否定的な偏見が強化される傾向が見られません)。 なお、 ‘THEN’ のみ
を提供するシステムに ‘ENDIF’ を追加するのは以下のように簡単です:
     : ENDIF   POSTPONE then ; immediate

   [‘Webster’s New Encyclopedic Dictionary’ によると、“then (副詞)” には
以下の意味があります:
     ...  2b: 順番に次の後に続く ...  3d: 必然的な結果として (if you
     were there, then you saw them)
   Forth の ‘THEN’ は 2b の意味を持ちますが、 Pascal や他の多くのプログ
ラミング言語の ‘THEN’ は 3d の意味を持ちます。]

   Gforth には ‘?DUP-IF’ および ‘?DUP-0=-IF’ というワードも用意されてい
るため、 ‘?dup’ の使用を避けることができます。これらの代替手段を使用する
ことは、 ‘?dup’ を使用するよりも効率的です。 ‘ENDIF’ や ‘?DUP-IF’ や
‘?DUP-0=-IF’ の標準 Forth での定義は、‘compat/control.fs’ で提供されます
。

     x
     CASE
       x1 OF code1 ENDOF
       x2 OF code2 ENDOF
       ...
       ( x ) default-code ( x )
     ENDCASE ( )

   xi が x に等しいなら、 最初の codei を実行します。 x1 〜 xn のいずれ
も一致しない場合は、 オプションの default-code が実行されます。 オプショ
ンのデフォルト・ケースは、 最後の ‘ENDOF’ の後にコードを記述するだけで追
加できます。 スタック頂上にある x を使用することはできますが、 それを消
費してはなりません。 値 x は、 この構造によって(一致する ‘OF’ によって、
または一致する OF がない場合は ‘ENDCASE’ によって) 消費されます。 例:

     : num-name ( n -- c-addr u )
      case
        0 of s" zero " endof
        1 of s" one "  endof
        2 of s" two "  endof
        \ default case:
        s" other number"
        rot \ get n on top so ENDCASE can drop it
      endcase ;

   (非標準の) ‘?of’ を使用して、 ‘case’ を 3 つ以上の選択肢の一般的な選
択構造として使用することもできます。 ‘?Of’ はフラグを受け取ります。 例:

     : sgn ( n1 -- n2 )
         \ sign function
         case
     	dup 0< ?of drop -1 endof
     	dup 0> ?of drop 1 endof
     	dup \ n1=0 -> n2=0; dup an item, to be consumed by ENDCASE
         endcase ;

   プログラミング・スタイル・メモ: コードを理解しやすくするには、 選択構
造を介したすべての経路で同一の方法でスタックを変更(消費およびプッシュさ
れるスタック項目の数と型)するようにする必要があります。


File: gforth.info,  Node: Simple Loops,  Next: Counted Loops,  Prev: Selection,  Up: Control Structures

6.9.2 Simple Loops
------------------

     BEGIN
       code1
       flag
     WHILE
       code2
     REPEAT

   code1 が実行され、 flag が計算されます。 flag が true の場合、 code2
が実行され、 BEGIN からループが再開されます。 flag が false の場合、
‘REPEAT’ の後へ実行が続行されます。

     BEGIN
       code
       flag
     UNTIL

   code が実行されます。 ‘flag’ が false の場合、 BEGIN からループが再開
されます。

   プログラミング・スタイル・メモ: コードを理解しやすくするために、 ルー
プの完全な反復(complete iteration)によってスタック上の項目の数と型が変更
されるべきではありません。

     BEGIN
       code
     AGAIN

   これは無限ループです。


File: gforth.info,  Node: Counted Loops,  Next: BEGIN loops with multiple exits,  Prev: Simple Loops,  Up: Control Structures

6.9.3 Counted Loops
-------------------

基本のカウント・ループ:
     limit start ?DO
       body
     LOOP

   これは、 start から始まり limit まで(limit 自身は除く)、 各整数値に対
して 1 回の反復を実行します。 カウンタ、 つまりインデックスには、 ‘i’ を
使用してアクセスできます。 たとえば、 以下のループをご覧ください:
     10 0 ?DO
       i .
     LOOP
出力: ‘0 1 2 3 4 5 6 7 8 9’

   最も内側のループのインデックスには ‘i’ を使用してアクセスでき、 その
一つ外側のループのインデックスには ‘j’ を使用してアクセスでき、 さらにも
う一つ外側のループのインデックスには ‘k’ を使用してアクセスできます。

   ‘i'’ を使用すると最も内側のループの limit にアクセスでき、 ‘delta-i’
を使用すると ‘i'’ - ‘i’ にアクセスできます。

     : foo 7 5 ?do cr i . i' . delta-i . loop ;

   出力:

     5 7 2
     6 7 1

   ループ制御データはリターン・スタックに保持されるため、 リターン・スタ
ックへのアクセスとカウント・ループ・ワードの混在にはいくつかの制限があり
ます。 特に、ループの外側のリターン・スタックに値を置いた場合、 ループ内
で値を読み取る事はできません(1)。 ループ内のリターン・スタックに値を置く
場合は、 ループの終了前、 およびループのインデックスにアクセスする前に値
を削除する必要があります。

   カウント・ループにはいくつかのバリエーションがあります:

   • ‘LEAVE’ は、 最も内側のカウント・ループを直ちに抜け出します。 それ
     が関係する ‘LOOP’ または ‘NEXT’ の後へ実行は移ります。 例:

          10 0 ?DO  i DUP . 3 = IF LEAVE THEN LOOP
     出力: ‘0 1 2 3’

   • ‘UNLOOP’ は、 例えば ‘EXIT’ などを介しての異常なループ終了の準備を
     行います。 ‘UNLOOP’ は、 ‘EXIT’ がリターン・アドレスに到達できるよ
     うに、 リターン・スタックからループ制御パラメーターを削除します(訳
     注: 1重ループなので unloop 1つ。2重ループなら unloop 2つ)。 例:

          : demo 10 0 ?DO i DUP . 3 = IF UNLOOP EXIT THEN LOOP ." Done" ;
     出力: ‘0 1 2 3’

   • start が limit より大きい場合でも、 ‘?DO’ はループを開始します(ラッ
     プアラウンド演算(処理可能な範囲をの最後に達した後に最初に戻る事)に
     よって両者が等しくなるまで ‘LOOP’ を反復します)。 通常、 この振る舞
     いは望ましくないものです。 したがって、 Gforth は (‘?DO’ の代替とし
     て、) ‘+DO’ と ‘U+DO’ を提供します。 これらは、 start が limit より
     大きい場合にはループを開始しません。 ‘+DO’ は符号付きループ・パラメ
     ータ用で、 ‘U+DO’ は符号なしループ・パラメータ用です。

   • ‘?DO’ は ‘DO’ に置き換えることはできます。 ‘DO’ は、 ループ・パラメ
     ータ に関係なく、 常にループに入ります。 あなたが、 どの場合にもル
     ープに入ることを知っている場合でも ‘DO’ は使用しないでください。 こ
     のような知恵はプログラムを保守していく中で無効になる傾向があり、 そ
     れゆえ ‘DO’ が問題を引き起こすことになります。

   • ‘LOOP’ は ‘n +LOOP’ に置き換えることができます。 これにより、インデ
     ックスが 1 ではなく n によって更新されます。 limit-1 と limit の間
     の境界を越えると、 ループは終了します。 例:

          4 0 +DO  i .  2 +LOOP
     出力: ‘0 2’

          4 1 +DO  i .  2 +LOOP
     出力: ‘1 3’

   • n が負数の場合、 ‘n +LOOP’ の動作は奇妙です:

          -1 0 ?DO  i .  -1 +LOOP
     出力: ‘0 -1’

          0 0 ?DO  i .  -1 +LOOP
     出力: なし。

     私たちは ‘?DO’ と ‘+LOOP’ を組み合わせないことをお勧めします。
     Gfors はいくつかの代替手段を提供します:

     ‘I’=limit の反復を含める ‘-1 +LOOP’ の振る舞いが必要な場合、 ‘-[DO’
     または ‘U-[DO’] でループを開始します(ここで、 ‘[’ は、 包含範囲の数
     学的表記法(例: [1,n] からインスピレーションを得ています):

          -1 0 -[DO  i .  -1 +LOOP

     出力: ‘0 -1’.

          0 0 -[DO  i .  -1 +LOOP

     出力: ‘0’

          0 -1 -[DO  i .  -1 +LOOP

     出力: なし。

     limit を除外したい場合、 代わりに ‘1 -LOOP’ (または一般的には ‘u
     -LOOP’)を使用し、 ‘?DO’ または ‘-DO ’ または ‘U-DO’ でループを開始
     します。 ‘-LOOP’ は、limit+1 と limit の間の境界を越えたときにルー
     プを終了します。 例:

          -2 0 -DO  i .  1 -LOOP
     出力: ‘0 -1’

          -1 0 -DO  i .  1 -LOOP
     出力: ‘0’

          0 0 -DO  i .  1 -LOOP
     出力: なし。

     残念ながら、 ‘+DO’, ‘U+DO’, ‘-DO’, ‘U-DO’, ‘-LOOP’ は 標準 Forth で
     は定義されていません。 ただし、 標準のワードのみを使用するこれらの
     ワードの実装が ‘compat/loops.fs’ にて提供されています。

   • よくある作業は、 配列の要素を前方または後方に反復処理することです。
     要素のアドレスに対して反復処理することには 2 つの利点があります。 配
     列の開始アドレスを保持する必要がなくなり、 データ・スタックの負荷が
     軽減されます。 また、 反復ごとにアドレス計算を実行する必要がなくな
     ります。 欠点は、 通常の配列表現 addr u要素 または addr uバイト か
     ら始めて、 start アドレスと limit アドレスを生成するために何らかの
     処理が必要なことです。 Gforth には、addr ubytes 表現からそこに到達
     するために ‘bounds’ があるため、セル配列 ‘v’ を介した前方ループを以
     下のように記述できます:

          create v 1 , 3 , 7 ,
          : foo v 3 cells bounds U+DO i  . cell +LOOP ;
          foo

     これは ‘1 3 7’ を出力します。 逆方向にたどるための入力の前処理はよ
     り複雑であるため、 Gforth はそれを行う ‘MEM-DO’ … ‘LOOP’ 形式のルー
     プ構造を提供します。 これは addr uバイト 表現の配列と要素サイズを受
     け取り、 要素のアドレスを逆順に反復処理します。

          create v 1 , 3 , 7 ,
          : foo1 v 3 cell array>mem MEM-DO i  . LOOP ;
          foo1

     これは ‘7 3 1’ を出力します。‘ARRAY>MEM’ は addr uelems uelemsize を
     ‘MEM-DO’ が期待する addr ubytes uelemsize に変換します(ubytes は
     uelems * uelmsize です)。 このループは ‘MEM-DO’ 通過後にuelemsize ず
     つ減算される、 ‘LOOP’ と対になるループとなります。

     Gforth は、 完全を期すために ‘MEM+DO’ も追加します。 ‘MEM-DO’ と同
     一のパラメータを受け取りますが、 配列を順(forwards)に処理します:

          create v 1 , 3 , 7 ,
          : foo2 v 3 cell array>mem MEM+DO i  . LOOP ;
          foo2

     出力: ‘1 3 7’

   • 別のカウント・ループ:
          n
          FOR
            body
          NEXT
     これは、 ‘?DO’ ループを適切に最適化するのが面倒な、 ネイティブ・コ
     ード・コンパイラ作成者達が好むループです。 このループ構造は標準
     Forth では定義されていません。 Gforth では、 このループは n+1 回繰
     り返します。 ‘i’ は、 n で始まり 0 で終わる値を生成します。 他の
     Forth システムは、‘FOR’ ループをサポートしている場合でも、 振る舞い
     が異なる場合があります。 この問題を回避するには、 ‘FOR’ ループを使
     用しないようにしてください。

   カウント・ループ・ワード群:

‘?DO’ ( compilation – do-sys ; run-time w1 w2 – | loop-sys  ) core-ext “question-do”
   *Note Counted Loops::.

‘+DO’ ( compilation – do-sys ; run-time n1 n2 – | loop-sys  ) gforth-0.2 “plus-do”
   *Note Counted Loops::.

‘U+DO’ ( compilation – do-sys ; run-time u1 u2 – | loop-sys  ) gforth-0.2 “u-plus-do”
   *Note Counted Loops::.

‘bounds’ ( addr u – addr+u addr ) gforth-0.2 “bounds”
   開始アドレス addr と長さ u で表されるメモリ・ブロックを指定すると、
‘u+do’ または ‘?do’ の終了アドレス addr+u と開始アドレス addr を正しい順
序で生成します。

‘-[do’ ( compilation – do-sys ; run-time n1 n2 – | loop-sys  ) gforth-experimental “minus-bracket-do”
   負の方向へカウントされるループを開始します。 n2<n1 の場合、 ループを
スキップします。 このようなカウント・ループは、 増分が負である ‘+loop’ と
対になります。 ‘I’>=n1 である限り実行されます。

‘u-[do’ ( compilation – do-sys ; run-time u1 u2 – | loop-sys  ) gforth-experimental “u-minus-bracket-do”
   負の方向へカウントするループを開始します。 u2<u1 の場合、ループをスキ
ップします。 このようなカウント・ループは、 増分が負の ‘+loop’ と対にな
ります。 ‘I’>=u1 である限り実行されます。

‘-DO’ ( compilation – do-sys ; run-time n1 n2 – | loop-sys  ) gforth-0.2 “minus-do”
   *Note Counted Loops::.

‘U-DO’ ( compilation – do-sys ; run-time u1 u2 – | loop-sys  ) gforth-0.2 “u-minus-do”
   *Note Counted Loops::.

   ‘array>mem’ ( uelements uelemsize – ubytes uelemsize) \ ubytes は
uelements * uelementsize です
‘mem+do’ ( compilation – w xt do-sys; run-time addr ubytes +nstride –  ) gforth-experimental “mem-plus-do”
   ‘I’ を addr から開始し、 ‘I’<addr+ubytes である限り、 nstride 幅のス
テップでメモリ内をアドレスが増える方向にカウント・アップするカウント・ル
ープを開始します。 loop と対にする必要があります。

‘mem-do’ ( compilation – w xt do-sys; run-time addr ubytes +nstride –  ) gforth-experimental “mem-minus-do”
   ‘I’ を addr+ubytes-ustride として開始し、 ‘I’>=addr である間 -nstride
幅のステップでメモリをアドレス下位方向(backward)にステップするカウント・
ループを開始します。 loop と対にしなければなりません。

‘DO’ ( compilation – do-sys ; run-time w1 w2 – loop-sys  ) core “DO”
   *Note Counted Loops::.

‘FOR’ ( compilation – do-sys ; run-time u – loop-sys  ) gforth-0.2 “FOR”
   *Note Counted Loops::.

‘LOOP’ ( compilation do-sys – ; run-time loop-sys1 – | loop-sys2  ) core “LOOP”
   *Note Counted Loops::.

‘+LOOP’ ( compilation do-sys – ; run-time loop-sys1 n – | loop-sys2  ) core “plus-loop”
   *Note Counted Loops::.

‘-LOOP’ ( compilation do-sys – ; run-time loop-sys1 u – | loop-sys2  ) gforth-0.2 “minus-loop”
   *Note Counted Loops::.

‘NEXT’ ( compilation do-sys – ; run-time loop-sys1 – | loop-sys2  ) gforth-0.2 “NEXT”
   *Note Counted Loops::.

‘i’ ( R:n – R:n n ) core “i”
   n は、最も内側のカウント・ループのインデックスです。

‘j’ ( R:n R:w1 R:w2 – n R:n R:w1 R:w2 ) core “j”
   n は、 最も内側から数えて 2 番目のカウント・ループのインデックスです
。

‘k’ ( R:n R:w1 R:w2 R:w3 R:w4 – n R:n R:w1 R:w2 R:w3 R:w4 ) gforth-0.3 “k”
   n は、 最も内側から数えて3番目のカウント・ループのインデックスです。

‘i'’ ( R:w R:w2 – R:w R:w2 w ) gforth-0.2 “i-tick”
   最も内側のカウント・ループの limit

‘delta-i’ ( r:ulimit r:u – r:ulimit r:u u2 ) gforth-1.0 “delta-i”
   u2=‘I'’-‘I’ (limit とインデックスの差)

‘LEAVE’ ( compilation – ; run-time loop-sys –  ) core “LEAVE”
   *Note Counted Loops::.

‘?LEAVE’ ( compilation – ; run-time f | f loop-sys –  ) gforth-0.2 “question-leave”
   *Note Counted Loops::.

‘unloop’ ( R:w1 R:w2 – ) core “unloop”

‘DONE’ ( compilation do-sys – ; run-time –  ) gforth-0.2 “DONE”
   do-sys までのすべての LEAVE を解決します(訳注: loop, +loop , next 等
の中で内部的に呼び出されます)。

   標準では、 do-sys で ‘CS-PICK’ や ‘CS-ROLL’ を使用することは許可され
ていません。 ‘MEM+DO’ と ‘MEM-DO’ によって生成される do-sys を除いて、
Gforth では ‘CS-PICK’ や ‘CS-ROLL’ の使用を許可しますが、 すべての ‘?DO’
などに対して、 定義を介した任意の経路上に ‘UNLOOP’ が正確に 1 つだけ存在
すること(‘LOOP’ などの失敗経路上で ‘UNLOOP’ コンパイルするなど)を確認す
るのはあなたの仕事です。 また、 すべての ‘LEAVE’ が（ループ終了ワードの
1 つまたは ‘DONE’ を使用して)解決されていることを確認する必要があります
。

   ---------- Footnotes ----------

   (1) ええ、まぁ、 移植可能な方法ではできません、 ぐらいな


File: gforth.info,  Node: BEGIN loops with multiple exits,  Next: General control structures with CASE,  Prev: Counted Loops,  Up: Control Structures

6.9.4 ‘Begin’ loops with multiple exits
---------------------------------------

カウント・ループの場合、 複数箇所で ‘leave’ を使用できます。 ‘begin’ ル
ープの場合は、 以下の選択肢があります:

   ループ内で ‘exit’ を使用(複数記述できます)すると、 ループだけでなくコ
ロン定義全体からも去ります。 例:

     : foo
       begin
         condition1 while
           condition2 if
             exit-code2 exit then
           condition3 if
             exit-code3 exit then
         ...
       repeat
       exit-code1 ;

   このアプローチの欠点は、 ループ後に共通コードが必要な場合、 共通コー
ドを含む別のワードで ‘foo’ を包むか、 または、 それぞれの exit-code から
共通コードを呼び出す必要があることです。

   もう 1 つのアプローチは、 ‘begin’ ループ内で複数の ‘while’ を使用する
ことです。 追加の ‘while’ ごとにループの後ろに ‘then’ を追加する必要があ
ります。 例:

     begin
       condition1 while
         condition2 while
           condition3 while
     again then then then

   ここでは、 ループの最後に ‘again’ を使用して、 各 ‘while’ に ‘then’ を
用意しました。 ‘repeat’ は ‘then’ を 1 つ減らしますが、 それ以外の場合は
同じ動作になります。 これが機能する理由の説明については、 *Note
Arbitrary control structures:: をご覧下さい。

   後で共通のコードを使用することはできますが、 上で示したように、 異な
る出口(exit)に対して異なる exit-code を使用することはできません。 以下の
ようにすると、 これらの異なる exit-code を使用できます:

     begin
       condition1 while
         condition2 while
           condition3 while
     again then exit-code3
     else exit-code2 then
     else exit-code1 then

   exit-code は終了条件から比較的離れているため、 これを理解するのは比較
的困難です(このような制御構造に慣れていないことも理由にはなりません)。


File: gforth.info,  Node: General control structures with CASE,  Next: Arbitrary control structures,  Prev: BEGIN loops with multiple exits,  Up: Control Structures

6.9.5 General control structures with ‘case’
--------------------------------------------

Gforth は、 拡張 ‘case’ を提供することで、 上で説明した複数出口ループの
問題を解決する追加のオプションを提供します。 この拡張 ‘case’ の移植可能
な実装は ‘compat/caseext.fs’ にあります。

   この拡張には 3 つの追加ワードがあります。 1 つ目は ‘?of’ で、 ‘case’
内で(単なる同等性のテストではなく、)一般的なテストが可能です。 例:

     : sgn ( n -- -1|0|1 )
       ( n ) case
         dup 0 < ?of drop -1 endof
         dup 0 > ?of drop 1  endof
         \ otherwise leave the 0 on the stack
       0 endcase ;

   注意: ‘endcase’ は値(a value)を drop することに注意してください。 こ
れは ‘of’ ではほとんどうまいこと機能しますが、 ‘?of’ ではたいていうまい
こといかないので、 今回も ‘endcase’ で drop するための値として 0 をスタ
ック置きます。 ここでは、 ‘sgn’ に渡される n は、 いずれの ‘?of’ もトリ
ガーしない場合返り値の 0 そのものになります。

   2 番目の追加ワードは ‘next-case’ で、 これにより ‘case’ をループに変
えることができます。 出口が3つのループは以下のようになります:

     case
       condition1 ?of exit-code1 endof
       condition2 ?of exit-code2 endof
       condition3 ?of exit-code3 endof
       ...
     next-case
     common code afterwards

   ご覧のとおり、 これにより、 先程議論したバリエーションの両方の問題が
解決されます(*note BEGIN loops with multiple exits::)。 注意: ‘endcase’
とは異なり、 ‘next-case’ は値をドロップしないことに注意してください。
(1)

   最後の追加ワードは ‘contof’ です。 これは ‘endof’ の代わりに使用され
、 ループを終了する代わりに次の反復を開始します。 これは、 ダイクストラ
のガード付きコマンド 繰り返し: do と同様の方法で使用できます。 例:

     : gcd ( n1 n2 -- n )
         case
             2dup > ?of tuck - contof
             2dup < ?of over - contof
         endcase ;

   ここで、 2 つの ‘?of’ はループを継続する異なる方法を持っています。 ど
ちらの ‘?of’ もトリガーされない場合、 2 つの数値は等しく、gcd(最大公約数
) になります。 ‘Endcase’ はそれらの 1 つを削除し、もう 1 つは n として残
します。

   これらのワードを組み合わせることもできます。 以下は、 ‘endcase’ を除
く、 各 ‘case’ ワードをそれぞれ 1 回使用する例です:

     : collatz ( u -- )
         \ print the 3n+1 sequence starting at u until we reach 1
         case
             dup .
             1 of endof
             dup 1 and ?of 3 * 1+ contof
             2/
         next-case ;

   この例では、 シーケンスの現在の値をスタックに保持します。 1 の場合、
‘of’ がトリガーされ、 値が削除され、 ‘case’ 構造から去ります。 奇数の場
合、 ‘?of’ がトリガーされ、 3n+1 が計算され、 ‘contof’ で次の反復が開始
されます。 それ以外の場合、 数値が偶数の場合は 2 で除算され、
‘next-case’ でループが再開されます。

   ---------- Footnotes ----------

   (1) ‘next-case’ は、 他の ‘case’ ワード群とは異なり、 名前にハイフン
(‘-’)が含まれています。 VFX Forth には値をドロップする ‘nextcase’ がある
ので、これと区別するためです。


File: gforth.info,  Node: Arbitrary control structures,  Next: Calls and returns,  Prev: General control structures with CASE,  Up: Control Structures

6.9.6 Arbitrary control structures
----------------------------------

標準 Forth は、 ネストされない方法での制御構造の使用を許可・サポートしま
す。 まだ完成されてない制御構造に関する情報は、 制御フロー・スタック
(control-flow stack)に保存されます。 このスタックは Forth のデータ・スタ
ック上に実装でき、 Gforth はそうしました。

   orig エントリは未解決の前方分岐を表し、 dest エントリは後方分岐ターゲ
ットを表します。 いくつかのワードは、 可能なあらゆる制御構造を構築するた
めの基礎となります(ストレージを必要とする制御構造を除く、 呼び出しやコル
ーチンやバックトラッキングなど)。

‘IF’ ( compilation – orig ; run-time f –  ) core “IF”
   実行時(run-time)、 f=0 の場合、 orig を消費する ‘THEN’ (または
‘ELSE’) の後から実行が続行されます。 それ以外の場合は、 ‘IF’ の直後に続
きます(*note Selection::)。

‘AHEAD’ ( compilation – orig ; run-time –  ) tools-ext “AHEAD”
   実行時、 orig を消費する ‘THEN’ の後から実行が続行されます。

‘THEN’ ( compilation orig – ; run-time –  ) core “THEN”
   orig にプッシュした ‘IF’ または ‘AHEAD’ または ‘ELSE’ または ‘WHILE’
は、 ‘THEN’ の直後にジャンプします(*note Selection::)。

‘BEGIN’ ( compilation – dest ; run-time –  ) core “BEGIN”
   dest を消費する ‘UNTIL’ または ‘AGAIN’ または ‘REPEAT’ は、 ‘BEGIN’ の
直後へジャンプします(*note Simple Loops::)。

‘UNTIL’ ( compilation dest – ; run-time f –  ) core “UNTIL”
   実行時、 f=0 の場合、 dest を生成した ‘BEGIN’ の後で実行が続行されま
す。 それ以外の場合は、 ‘UNTIL’の直後から実行が続行されます(*note Simple
Loops::)。

‘AGAIN’ ( compilation dest – ; run-time –  ) core-ext “AGAIN”
   実行時、 dest を生成した ‘BEGIN’ の後から実行が続行されます(*note
Simple Loops::)。

‘CS-PICK’ ( orig0/dest0 orig1/dest1 ... origu/destu u – ... orig0/dest0  ) tools-ext “c-s-pick”

‘CS-ROLL’ ( destu/origu .. dest0/orig0 u – .. dest0/orig0 destu/origu  ) tools-ext “c-s-roll”

‘CS-DROP’ ( dest –  ) gforth-1.0 “CS-DROP”

   標準ワードの ‘CS-PICK’ や ‘CS-ROLL’ を使用すると、 移植可能な方法で制
御フロー・スタックを操作できます。 これら無しだと制御フロー・エントリが
占めるスタック項目の数を知る必要があります(多くのシステムは 1 つのセルを
使用します。 Gforth では現在 3 つを使用しますが、 これは将来変更される可
能性があります)。

   orig は 1 回だけ解決する必要があるため、 ‘CS-PICK’ は dest を pick す
ることしかできず、 かつ、 ‘CS-DROP’ は dest を drop することしかできませ
ん。

   一部の標準の制御構造ワードは、 以下のワード群から構築されます:

‘ELSE’ ( compilation orig1 – orig2 ; run-time –  ) core “ELSE”
   実行時、 orig を消費する ‘THEN’ の後から実行が続行されます。 orig1 を
プッシュした ‘IF’ または ‘AHEAD’ または ‘ELSE’ または ‘WHILE’ は、
‘ELSE’ の直後にジャンプします(*note Selection::)。

‘WHILE’ ( compilation dest – orig dest ; run-time f –  ) core “WHILE”
   実行時、 f=0 の場合、 orig を消費する ‘REPEAT’ (または ‘THEN’ または
‘ELSE’) の後から実行が継続されます。 それ以外の場合は、 ‘WHILE’ の直後か
ら実行されます(*note Simple Loops::)。

‘REPEAT’ ( compilation orig dest – ; run-time –  ) core “REPEAT”
   実行時、 dest を生成した ‘BEGIN’ の後から実行が続行されます。 orig を
プッシュした ‘WHILE’ または ‘IF’ または ‘AHEAD’ または ‘ELSE’ は、
‘REPEAT’ の直後にジャンプします(*note Simple Loops::)。

Gforth は、さらにいくつかの制御構造ワードを追加します:

‘ENDIF’ ( compilation orig – ; run-time –  ) gforth-0.2 “ENDIF”
   ‘THEN’ と同一です。

‘?dup-IF’ ( compilation – orig ; run-time n – n|  ) gforth-0.2 “question-dupe-if”
   これは、スタック・チェッカー(stack checker)などのツールでより適切に処
理できるため、 イディオム「‘?DUP IF’」の代替として推奨されます。 しかも
、 ‘?DUP IF’ より速いです。

‘?DUP-0=-IF’ ( compilation – orig ; run-time n – n|  ) gforth-0.2 “question-dupe-zero-equals-if”

制御構造ワードのもう一つのグループ:

‘case’ ( compilation  – case-sys ; run-time  –  ) core-ext “case”
   ‘case’ 構造の開始。

‘endcase’ ( compilation case-sys – ; run-time x –  ) core-ext “end-case”
   ‘case’ 構造を終わらせます。 x を drop して、‘endcase’ の後ろへ進みま
す。 x の drop は、 元の(‘of’ のみの)‘case’ 構造では便利ですが、 他の場
合(特に ‘?of’ を使用する場合)では(drop する為の) x を明示的に指定する必
要がある場合があります。

‘next-case’ ( compilation case-sys – ; run-time –  ) gforth-1.0 “next-case”
   マッチする ‘case’ にジャンプして、 ‘case’ ループを再開します。
‘endcase’ とは異なり、 ‘next-case’ はセルを drop しないことに注意してく
ださい。

‘of’ ( compilation  – of-sys ; run-time x1 x2 – |x1  ) core-ext “of”
   x1=x2 の場合は続行します(両方を drop します)。 それ以外の場合は、 x1
をスタック上に残し、 ‘endof’ または ‘contof’ の後ろにジャンプします。

‘?of’ ( compilation  – of-sys ; run-time  f –  ) gforth-1.0 “question-of”
   f が true の場合は続行します。 それ以外の場合は、 ‘endof’ または
‘contof’ の後ろにジャンプします。

‘endof’ ( compilation case-sys1 of-sys – case-sys2 ; run-time  –  ) core-ext “end-of”
   ‘endcase’/‘next-case’ の後ろにジャンプして、 囲んでいる ‘case’ 構造体
を終了(exit)します。

‘contof’ ( compilation case-sys1 of-sys – case-sys2 ; run-time  –  ) gforth-1.0 “cont-of”
   囲んでいる ‘case’ にジャンプして、 ‘case’ ループを再開します。

   内部的には、 of-sys は ‘orig’ で、 case-sys はセルとスタック深さ情報
と、0 個以上の ‘orig’ と、 ‘dest’ です。

6.9.6.1 Programming Style
.........................

読みやすさを確保するために、 任意の制御構造を直接作成せず、 必要な制御構
造に対して新しい制御構造ワードを定義し、 プログラム内でこれらのワードを
使用することをお勧めします。たとえば、 以下のように書く代わりに:

     BEGIN
       ...
     IF [ 1 CS-ROLL ]
       ...
     AGAIN THEN

以下のように制御構造のワードを定義することをお勧めします。 例:

     : WHILE ( DEST -- ORIG DEST )
      POSTPONE IF
      1 CS-ROLL ; immediate

     : REPEAT ( orig dest -- )
      POSTPONE AGAIN
      POSTPONE THEN ; immediate

そして、 次に、 これらを使用して制御構造を作成します:

     BEGIN
       ...
     WHILE
       ...
     REPEAT

   このほうがずっと読みやすいですよね。 もちろん、 ‘REPEAT’ と ‘WHILE’ は
定義済みなので、 この例を見て改めて定義する必要はありません。


File: gforth.info,  Node: Calls and returns,  Next: Exception Handling,  Prev: Arbitrary control structures,  Up: Control Structures

6.9.7 Calls and returns
-----------------------

呼び出す定義の名前を記述するだけで定義を呼び出すことができます。 通常、
定義はそれ自身の定義中は表示されません。 直接再帰的な定義を記述したい場
合は、 ‘recursive’ を使用して現在の定義を見えるようにする(使えるようにす
る)か、 ‘recurse’ を使用して現在の定義を直接呼び出すことができます。

‘recursive’ ( compilation – ; run-time –  ) gforth-0.2 “recursive”
   現在の定義中の定義をその定義内で呼び出せるように(表示できるように)し
、 それ自体を再帰的に呼び出せるようにします。

‘recurse’ ( ... – ...  ) core “recurse”
   現在の定義の別名(alias)。

これらのワードの使用例については *Note Recursion Tutorial:: を参照してく
ださい。

   プログラミング・スタイル・メモ: 私は、‘recurse’ よりも ‘recursive’ を
使用することを好みます。 名前で定義を呼び出す方が、 やや難解な ‘recurse’
よりも説明的であるためです(名前が適切に選択されていれば)。 たとえば、ク
イックソートの実装では、「今、再帰呼び出しを行う」(now do a recursive
call)と読むよりも、「今、パーティションをソートする」(now sort the
partitions)と読む(そして考える)方がはるかに優れています。

   相互再帰(mutual recursion)の場合は、 以下のように ‘defer’ ワードを使
用します:

     Defer foo

     : bar ( ... -- ... )
      ... foo ... ;

     :noname ( ... -- ... )
      ... bar ... ;
     IS foo

   defer された ワードについては、 *note Deferred Words:: で詳しく説明し
ます。

   定義の終わりに達するか、 ‘EXIT’ に遭遇すると、 現在の定義は呼び出し元
の定義に制御を返します。

‘EXIT’ ( compilation – ; run-time nest-sys –  ) core “EXIT”
   呼び出し元の定義に戻る(return): 通常、 定義から速やかに戻るのを強制す
る方法として使用されます。 ‘EXIT’ する前に、 リターン・スタックをクリー
ンアップし、 未処理の ‘?DO’...‘LOOP’ を ‘UNLOOP’ する必要があります。 ロ
ーカル変数(local)が無い場合に ‘exit’ のように動作するティック可能なワー
ド(tickable word)には ‘;s’ を使用します。

‘?EXIT’ ( –  ) gforth-0.2 “?EXIT”
   f が true の場合、 呼び出し元の定義に戻ります(return)。

‘;s’ ( R:w – ) gforth-0.2 “semis”
   ‘EXIT’ によってコンパイルされたプリミティブ。


File: gforth.info,  Node: Exception Handling,  Prev: Calls and returns,  Up: Control Structures

6.9.8 Exception Handling
------------------------

ワードが処理できないエラー状態を検出した場合、 例外を投げる(‘throw’)こと
ができます。 最も単純なケースでは、 これによりプログラムが終了し、適切な
エラーが報告されます。

‘throw’ ( y1 .. ym nerror – y1 .. ym / z1 .. zn error  ) exception “throw”
   nerror が 0 の場合は、 それを drop して続行します。 それ以外の場合は
、 動的に囲んでいる次の例外ハンドラー(next dynamically enclosing
exception handler)に制御を移し、 それに応じてスタックをリセットし、
nerror をプッシュします。

‘fast-throw’ ( ... wball – ... wball ) gforth-experimental “fast-throw”
   軽量の ‘throw’ バリエーション: ゼロ以外のみに使用され、 バックトレー
スを保存したり、 欠落している ‘catch’ を扱ったりしません。

   ‘throw’ は、スタック上のセル・サイズのエラー番号数値を消費します。 標
準 Forth には事前定義されたエラー番号がいくつかあります(‘errors.fs’ 参照
)。 Gforth (および他のほとんどのシステム)では、 さまざまなワードによって
生成された ior をエラー番号として使用できます(たとえば、 ‘allocate’ の一
般的な使用法は ‘allocate throw’ です)。 Gforth は、 (適切なエラー報告付
きで)独自のエラー番号を定義するための ‘Exception’ というワードも提供しま
す。 このワードの標準 Forth バージョン(ただしエラー・メッセージなし) は
‘compat/excel.fs’ で入手できます。 最後に、 あなた独自のエラー番号(-4095
〜 0 の範囲以外の任意の番号)を使用できますが、 表示されるのは適切なエラ
ー・メッセージではなく、数字のみです。 たとえば、 以下のことを試してみて
ください:

     -10 throw                    \ 標準で定義済
     -267 throw                   \ システムで定義済
     s" my error" exception throw \ ユーザー定義
     7 throw                      \ 思いつくままの任意の番号

‘exception’ ( addr u – n  ) gforth-0.2 “exception”
   N は、 -4095 〜 -256 の範囲内で以前に使用されていなかった ‘throw’ 値
です。 ‘Exception’ を連続して呼び出すと、 連続して減少する数値が返されま
す。 Gforth は文字列 ADDR U をエラー・メッセージとして使用します(訳注: 同
じエラーメッセージを使いまわすには、 s" hoge err msg" exception constant
hoge-error hoge-error !  などとして得られた hoge-error を使いまわす。
hoge-error throw 等する)

   エラー番号を文字列に変換するためのワード(通常は POSIX の ‘strerror’ を
モデルにしたもの)がある場合もあります。 以下のワードを使用すると、 これ
らの文字列を Gforth のエラー処理に取り込むことができます:

‘exceptions’ ( xt n1 – n2  ) gforth-1.0 “exceptions”
   throw時: xt ‘( +n -- c-addr u )’ は、 0<=n<n1 の範囲のローカルのエラ
ー・コードをエラー・メッセージに変換します。 ‘Exceptions’ は、
n2-n1<n3<=n2 の範囲で n1 個(0 〜 n1)のエラー・コードを予約します。 n2 に
、 対応する Gforth エラー・コード(ローカルのエラー番号 0 に対応。 つまり
、 0<=n<n1 の範囲のローカルのエラー・コードに 対応する Gforth エラー・コ
ードは n2 <= n3 < n2+n1)を返します。 (後の時点で)その範囲に対応した
Gforth エラー・コード n3 が throw されると、 n2-n3 がプッシュされ(つまり
ローカルのエラー番号に変換した値をプッシュし)、 xt が実行されて、 xt が
エラー・メッセージを生成します(訳注: minos2/pulse-audio.fs 等で確認。 xt
にC-interface ワードをセットし、 外部Cライブラリのエラー・メッセージを
gforth 内から表示するのに使っているようだ)

   たとえば、 C言語ライブラリの ‘errno’ エラー (および ‘strerror’ を使用
した変換) がまだ Gforth で直接サポートされていないとした場合、 以下のよ
うにして ‘strerror’ を gforth と結び付けることができます:

     ' strerror 1536 exceptions constant errno-base
     : errno-ior ( -- n )
     \ n は errno の値に対応する Gforth ior を求めなければならないので、
     \ ここでerrno 範囲と Gforth ior の範囲の間で変換する必要があります。
     \ ERRNO は Gforth ワードではないため、
     \ それにアクセスするには C インターフェイスを使用する必要があります。
       errno errno-base over - swap 0<> and ;

   C言語の関数(C言語インターフェイス(C interface)を使用)を呼び出し、 そ
の戻り値がエラーが発生したことを示している場合、 ‘errno-ior throw’ を実
行して、適切なエラー・メッセージ (“Permission denied” など)を含む例外を
生成できます。

   フラグが true の場合、 特定の err# でエラーを投げる(‘THROW’)一般的な
慣用句は以下のとおりです:

     ( flag ) 0<> err# and throw

   あなたのプログラムで、 例外をキャッチする例外ハンドラーを提供できます
。 例外ハンドラーを使用すると、 問題を修正したり、 一部のデータ構造をク
リーンアップして例外を次の例外ハンドラーに投げたり(throw)することができ
ます。 ‘throw’ は動的に最も内側の例外ハンドラー(the dynamically
innermost exception handler)にジャンプすることに注意してください。 シス
テムの例外ハンドラーは最も外側にあり、 エラーを出力してコマンド・ライン
の通訳(interpretation)を再開するだけです(または、 バッチ・モード(つまり
、 シェル・コマンド・ラインの処理中)では Gforth を終了します)。

   例外をキャッチする標準 Forth での方法は ‘catch’ です:

‘catch’ ( x1 .. xn xt – y1 .. ym 0 / z1 .. zn error  ) exception “catch”
   xt を実行します。 実行から正常に戻った場合、 ‘catch’ はスタックに 0 を
プッシュします。 ‘throw’ を介して実行が戻った場合、 すべてのスタックは
‘catch’ へ入る時点の深さにリセットされ、 TOS (xt の位置) は throw コード
に置き換えられます。

‘nothrow’ ( –  ) gforth-0.7 “nothrow”
   再 throw しない ‘catch’ または ‘endtry’ の後ろでこれ (または標準のシ
ーケンス ‘['] false catch 2drop’) を使用します。 これにより、 次の
‘throw’ でバックトレースが確実に記録されます。

   例外ハンドラーの最も一般的な使用法は、 エラーが発生したときに状態をク
リーンアップすることです。 例：

     base @ >r hex \ actually the HEX should be inside foo to protect
                   \ against exceptions between HEX and CATCH
     ['] foo catch ( nerror|0 )
     r> base !
     ( nerror|0 ) throw \ pass it on

   ‘myerror’ というエラー番号を処理するための ‘catch’ の使用は以下のよう
になります:

     ['] foo catch
     CASE
       myerror OF ... ( do something about it ) nothrow ENDOF
       dup throw \ default: pass other errors on, do nothing on non-errors
     ENDCASE

   コードを別のワードでくるむ要があるのは面倒な場合が多いため、 Gforth で
は代替構文を提供しています:

     TRY
       code1
       IFERROR
         code2
       THEN
       code3
     ENDTRY

   これは、 code1 を実行しします。 code1 が正常に完了すると、 code3 の実
行へ続きます。 code1 または、 ‘endtry’ より前で例外があった場合、 スタッ
クは ‘try’ 時の深さにリセットされ、 throw された値をデータ・スタックにプ
ッシュし、 code2 の実行に続き、 そして、 最終的に code3 に到達します。

‘try’ ( compilation  – orig ; run-time  – R:sys1  ) gforth-0.5 “try”
   例外キャッチ領域の開始

‘endtry’ ( compilation  – ; run-time  R:sys1 –  ) gforth-0.5 “endtry”
   例外キャッチ領域の終わり

‘iferror’ ( compilation  orig1 – orig2 ; run-time  –  ) gforth-0.7 “iferror”
   例外処理コードを開始します(‘try’ と ‘endtry’ の間に例外がある場合に実
行されます)。 この部分は ‘then’ で終了する必要があります。

   code2 が必要ない場合は、 ‘iferror then’ の代わりに ‘restore’ を記述で
きます:

     TRY
       code1
     RESTORE
       code3
     ENDTRY

   先程の例をこの構文で身綺麗にしてみます:

     base @ { oldbase }
     TRY
       hex foo \ now the hex is placed correctly
       0       \ value for throw
     RESTORE
       oldbase base !
     ENDTRY
     throw

   このバリエーションの追加の利点は、 ‘restore’ と ‘endtry’ の間の例外
(たとえば、 ユーザーが ‘Ctrl-C’ を押すことによる例外)でも、 ‘restore’ の
直後へコードの実行が移ることです。 ゆえに、 いかなる状況であっても base
は復元されます。

   ただし、 このコード自体が例外を引き起こさないようにする必要があります
。 そうしないと、 ‘iferror’/‘restore’ コードがループします。 さらに、
‘iferror’/‘restore’ コードで必要なスタックの内容が ‘try’ と ‘endtry’ の
間のあらゆる場所に存在することも確認する必要があります。 この例では、 こ
れは ‘try’ の前にデータをローカル変数(local)に置くことによって実現されま
す(リターン・スタック上の例外フレーム(sys1)が邪魔なのでリターン・スタッ
クは使用できません)。

   この種の使用法は、 Lisp の ‘unwind-protect’ と同様のものです。

   もし、あなたが、 この例外再開始(exception-restarting)の振る舞いを望ま
ない場合は、 以下のようにしてください:

     TRY
       code1
     ENDTRY-IFERROR
       code2
     THEN

   code1 に例外がある場合は code2 が実行され、 それ以外の場合は ‘then’ の
後ろ (または ‘else’ 分岐の可能性あり) から実行が続行されます。 これはバ
ージョン 0.7 より前の Gforth では以下の構成要素に該当します

     TRY
       code1
     RECOVER
       code2
     ENDTRY

   つまり、 この ‘recover’ を使用しているコードを直に ‘try ...
entry-iferror ... then’ へと置き換えることができます。 ただし、 その置き
換え作業中に他の ‘try’ バリエーションのいずれかを使用した方が良いかどう
かも検討することをお勧めします。

   移行を容易にするために、 Gforth は 2 つの互換性ファイルを提供します:
1つ目は ‘endtry-iferror.fs’ で、 古いシステム用に ‘try ...
endtry-iferror ... then’ 構文を提供します(ただし、 ‘iferror’ または
‘restore’ は提供しません)。 2つ目の ‘recover-endtry.fs’ は、 新しいシス
テム上で古い構文の ‘try ... recover ... endtry’ 構文を提供するので、 古
いプログラムを実行するための一時しのぎとして使用できます。 どちらのファ
イルもどのシステムでも動作します(システムが、 実装する構文を既に定義済み
の場合は何も行わないだけです)。 そのため、 古いシステムと新しいシステム
を混在させて使用している場合でも、 これらのファイルのいずれかを無条件に
‘require’ することができます。

‘restore’ ( compilation  orig1 – ; run-time  –  ) gforth-0.7 “restore”
   コードの復元(restore)を開始します。 これは、 例外がある場合と無い場合
に行われます。

‘endtry-iferror’ ( compilation  orig1 – orig2 ; run-time  R:sys1 –  ) gforth-0.7 “endtry-iferror”
   例外キャッチ領域を終了し、 その領域外で例外処理コードを開始します
(‘try’ と ‘endtry-iferror’ の間に例外がある場合に実行されます)。 この部
分は ‘then’ (または ‘else’...‘then’) で終了する必要があります。

   ここで、 エラー処理の例を以下に示します:

     TRY
       foo
     ENDTRY-IFERROR
       CASE
         myerror OF ... ( do something about it ) nothrow ENDOF
         throw \ pass other errors on
       ENDCASE
     THEN

   プログラミング・スタイル・メモ: いつものように、 エラーを渡すための
‘throw’ の後、 または ‘ENDTRY’ の後のいずれか(または、‘catch’ を使用する
場合は、エラーを処理するための選択構造の終了後)で、 スタックの深さが静的
に明白であることを保証する必要があります。

   ‘throw’ の代替は 2 つあります: ‘Abort"’ は条件付きでエラー・メッセー
ジを提供できます。 ‘Abort’ は「中止」(Abort)エラーを生成するだけです。

   これらのワードの問題は、 例外ハンドラーが、 異なる ‘abort"’ を区別で
きないことです。 例外ハンドラーにとってはそれらは ‘-2 throw’ のように見
えるだけです(標準のプログラムではエラー・メッセージにアクセスできません
)。 同様に、 ‘abort’ は例外ハンドラーに対して ‘-1 throw’ のように見えま
す。

‘ABORT"’ ( compilation ’ccc"’ – ; run-time f –  ) core,exception-ext “abort-quote”
   f のいずれかのビットがゼロ以外の場合、 ‘-2 throw’ の機能を実行し、 例
外スタック上例外フレームがない場合は文字列 ccc を表示します。

‘abort’ ( ?? – ??  ) core,exception-ext “abort”
   ‘-1 throw’.

   実行を中止する必要があるほど深刻でない問題の場合は、 警告を表示するだ
けで済みます。 変数 ‘warnings’ を使用すると、 表示される警告の数を調整で
きます。

‘WARNING"’ ( compilation ’ccc"’ – ; run-time f –  ) gforth-1.0 “WARNING"”
   f がゼロ以外の場合、 警告メッセージとして文字列 ccc を表示します。

‘warnings’ ( – addr  ) gforth-0.2 “warnings”
   以下の警告レベルをセットしてください
‘0’
     警告オフ
‘-1’
     通常警告オン
‘-2’
     初心者警告オン
‘-3’
     偏執狂的警告オン
‘-4’
     全ての警告をエラーとして扱います(初心者警告を含む)


File: gforth.info,  Node: Defining Words,  Next: Interpretation and Compilation Semantics,  Prev: Control Structures,  Up: Words

6.10 Defining Words
===================

定義ワード(defining word)は、 ディクショナリに新しいエントリを作成するこ
とによって Forth を拡張するために使用されます。

* Menu:

* CREATE::
* Variables::                Variables and user variables
* Constants::
* Values::                   Initialised variables
* Varues::
* Colon Definitions::
* Anonymous Definitions::    名前無しのワード定義
* Quotations::
* Supplying names::          定義ワードの名前を文字列として渡す
* User-defined Defining Words::
* Deferred Words::           前方参照の許容
* Forward::                  自動解決される前方参照
* Aliases::


File: gforth.info,  Node: CREATE,  Next: Variables,  Prev: Defining Words,  Up: Defining Words

6.10.1 ‘CREATE’
---------------

定義ワードは、 ディクショナリに新しいエントリを作成するために使用されま
す。 最も単純な定義ワードは ‘CREATE’ です。 ‘CREATE’ は以下のように使用
します:

     CREATE new-word1

   ‘CREATE’ はパース・ワード(parsing word)です。 つまり、入力ストリーム
から引数(argument)を受け取ります(この例では ‘new-word1’ です)。 ‘CREATE’
は ‘new-word1’ のディクショナリ・エントリを作成します。 ‘new-word1’ が実
行される時は、 アドレスがスタックに残されるだけです。 そのアドレスは、
‘new-word1’ が定義された時点のデータ空間ポインタ(‘HERE’)の値を表します。
したがって、 ‘CREATE’ は名前をメモリ領域のアドレスに関連付ける方法です。

‘Create’ ( "name" –  ) core “Create”

   注意: 標準 Forth は、 ‘create’ に対してのみ、 そのボディ部分がディク
ショナリのデータ空間(つまり、 ‘here’ や ‘allot’ などが機能する空間。
*note Dictionary allocation::)にあることを保証することに注意してください
。 また、 標準 Forth では、 ‘does>’ で変更できるのは ‘create’ で作成され
たワードのみで(*note User-defined Defining Words::)、 標準 Forth の
‘>body’ は ‘create’ されたワードにのみ適用できます。

   この new-word1 の例を拡張して、 データ空間にメモリを少々確保すると、
最終的には variable のような代物になります。 これを行う 2 つの異なる方法
を以下に示します:

     CREATE new-word2 1 cells allot  \ 1 セル予約 - 初期値未定義
     CREATE new-word3 4 ,            \ 1 セル予約 かつ (4で)初期化

   これらの変数は、 以下のように ‘@’ (「フェッチ」(fetch;取り出す)) と
‘!’ (「ストア」(store;格納する)) を使用して検査(examine)および変更
(modify)できます:

     new-word2 @ .      \ get address, fetch from it and display
     1234 new-word2 !   \ new value, get address, store to it

   同様のメカニズムを使用して配列を作成できます。 たとえば、 80 文字のテ
キスト入力バッファーです:

     CREATE text-buf 80 chars allot

     text-buf 0 chars + c@ \ the 1st character (offset 0)
     text-buf 3 chars + c@ \ the 4th character (offset 3)

   メモリに適切な領域を割り当てることで、 思いつく限りの複雑なデータ構造
を構築できます。 これについてさらに詳しく説明し、 それを容易にする
Gforth ツールについて知りたい場合は、 *Note Structures:: を参照ください
。


File: gforth.info,  Node: Variables,  Next: Constants,  Prev: CREATE,  Up: Defining Words

6.10.2 Variables
----------------

前のセクションでは、 一連のコマンドを使用して変数を生成する方法を説明し
ました。 最終的な改良として、 (次のセクションの主題を先取りして)そのコー
ド・シーケンス全体を定義ワードでまとめることができ、 新しい変数の作成が
容易になります:

     : myvariableX ( "name" -- a-addr ) CREATE 1 cells allot ;
     : myvariable0 ( "name" -- a-addr ) CREATE 0 , ;

     myvariableX foo \ variable foo starts off with an unknown value
     myvariable0 joe \ whilst joe is initialised to 0

     45 3 * foo !   \ set foo to 135
     1234 joe !     \ set joe to 1234
     3 joe +!       \ increment joe by 3.. to 1237

   当然のことながら、 Forth にはすでに ‘Variable’ の定義があるため、
‘myvariable’ を定義する必要はありません。 標準 Forth は、 ‘Variable’ が
作成時に初期化されることを保証しません(つまり、 ‘myvariableX’ のように振
る舞う可能性があります)。 対照的に、Gforth の ‘Variable’ は変数を 0 に初
期化します(つまり、 ‘myvariable0’ とまったく同じように振る舞います)。
Forth は、 倍精度変数と浮動小数点変数に対して、 それぞれ ‘2Variable’ と
‘fvariable’ も提供します。 これらは、Gforth ではそれぞれ 0.  と 0e に初
期化されます。 ‘Variable’ を使用してブール値を保存する場合、 ‘on’ と
‘off’ を使用してその状態を切り替えることができます。

‘Variable’ ( "name" –  ) core “Variable”
   name を定義し、 addr で始まるセルを予約します。 name 実行時: ‘( --
addr )’

‘AVariable’ ( "name" –  ) gforth-0.2 “AVariable”
   ‘variable’ と同様に機能しますが、 (クロス・コンパイルされたコードで使
用される場合)その変数に格納されているセルがアドレスであることをクロス・
コンパイラーに伝えます。

‘2Variable’ ( "name" –  ) double “two-variable”

‘fvariable’ ( "name" –  ) floating “f-variable”

   最後に、 任意の長さのバッファーは以下のようになります

‘buffer:’ ( u "name" –  ) core-ext “buffer-colon”
   name を定義し、addr から始まる u バイトを予約します。 name 実行時: ‘(
-- addr )’ なお、 Gforth は予約したバイトを 0 に初期化しますが、 標準で
は保証されません。


File: gforth.info,  Node: Constants,  Next: Values,  Prev: Variables,  Up: Defining Words

6.10.3 Constants
----------------

‘constant’ を使用すると、 固定値を宣言し、 名前でそれを参照できます。 例
:

     12 Constant INCHES-PER-FOOT
     3E+08 fconstant SPEED-O-LIGHT

   ‘Variable’ は読み取りと書き込みの両方ができるため、 その実行時の振る
舞いは、 現在の値を操作できるアドレスを提供することです。 それとは対照的
に、 ‘Constant’ の値は一度宣言すると変更できないため、 アドレスを指定す
る必要はありません(1) – 定数の値を直接返す方が効率的です。 そして正にそ
のとおりになります。 つまり、 定数の実行時の効果は、その値をスタックの頂
上に置くことです((‘Constant’ を実装する方法の1つは *note User-defined
Defining Words:: で見つけることができます)。

   Forth は、それぞれ2倍長定数と浮動小数点定数を定義するための
‘2Constant’ と ‘fconstant’ も提供します。

‘Constant’ ( w "name" –  ) core “Constant”
   定数 name を値 w で定義します。

   name 実行時: – w

‘AConstant’ ( addr "name" –  ) gforth-0.2 “AConstant”
   ‘constant’ と似ていますが、 アドレスのための定数を定義します(これはク
ロス・コンパイラーでのみ違いが生じます)。

‘2Constant’ ( w1 w2 "name" –  ) double “two-constant”

‘fconstant’ ( r "name" –  ) floating “f-constant”

   Forth の定数は、他のプログラミング言語の定数とは異なる振る舞いをしま
す。 他の言語では、 定数(アセンブラの EQU や C の #define など)はコンパ
イル時にのみ存在します。 実行プログラム(executable program)では、 定数は
即値(absolute number)に変換されているため、 シンボリック・デバッガを使用
しない限り、 その数値がどのような抽象的なものを表しているかを知ることは
不可能です。 Forth では、 定数はヘッダー空間にエントリを持ち、 それを使
用するコードが定義された後もそこに残ります。 実際、 実行時に機能する義務
があるため、 それをディクショナリに残しておく必要があります。 例:

     12 Constant INCHES-PER-FOOT
     : FEET-TO-INCHES ( n1 -- n2 ) INCHES-PER-FOOT * ;

   ここで、 ‘FEET-TO-INCHES’ が実行されると、 定数 ‘INCHES-PER-FOOT’ に
関連付けられた xt が実行されます。 ‘see’ を使用して ‘FEET-TO-INCHES’ の
定義を逆コンパイルすると、 ‘INCHES-PER-FOOT’ を呼び出していることがわか
ります。 一部の Forth コンパイラは、定数を使用する場所にインライン展開
(in-lining)することによって定数を最適化しようとします。 以下のようにして
Gforth に定数をインライン化するように強制できます:

     : FEET-TO-INCHES ( n1 -- n2 ) [ INCHES-PER-FOOT ] LITERAL * ;

   ここで、 ‘see’ を使用して ‘FEET-TO-INCHES’ の このバージョンを逆コン
パイルすると、 ‘INCHES-PER-FOOT’ が存在しないことがわかります。 これがど
のように機能するかを理解するには、 *note Interpret/Compile states:: と
*note Literals:: を読んでください。

   この方法で定数をインライン化すると、 実行時間がわずかに改善される可能
性があり、 定数がコンパイル時にのみ参照されるようにすることができます。
ただし、 定数の定義はまだディクショナリに残っています。 一部の Forth コ
ンパイラは、 一時的なワード(transient words)を保持する 2 番目のディクシ
ョナリを制御するメカニズムを提供し、 メモリ領域を回復するために後でこの
2 番目のディクショナリを削除できるようしています。 ただし、 これを行う標
準の方法はありません。

   ---------- Footnotes ----------

   (1) まあ、 多くの場合、 それは可能ではありますが、 標準的な移植可能な
方法では変更できません。 ‘Value’ を使用する方が安全です (続きを読んでく
ださい)まあ、多くの場合変更できますが、標準的な移植可能な方法では変更で
きません。 ‘Value’ (続きを読んでください)


File: gforth.info,  Node: Values,  Next: Varues,  Prev: Constants,  Up: Defining Words

6.10.4 Values
-------------

‘Value’ は ‘Constant’ のように動作しますが、 変更することができます。
‘TO’ は、‘Values’ を変更するパース・ワード(parsing word)です。 (標準
Forth ではなく) Gforth では、 ‘>body’ を使用しても ‘value’ にアクセス(お
よび変更)できます。

   ここで幾つか例を示します:

     12 Value APPLES     \ APPLES を初期値 12 で定義
     34 TO APPLES        \ APPLES の値を変更。 TO はパース・ワード
     1 ' APPLES >body +! \ APPLES をインクリメント。 非標準の使い方
     APPLES              \ スタック頂上に 35 を置く(はず)

‘Value’ ( w "name" –  ) core-ext “Value”
   name を初期値 w で定義します。 この値は ‘to name’ または ‘->name’ で
変更できます(訳注: -> と name の間に空白を開けない。 ->name とする。 ワ
ードではなく、 テキスト・インタプリタの認識器(recognizer)機能によるもの
)。

   name 実行時: – w2

‘AValue’ ( w "name" –  ) gforth-0.6 “AValue”
   ‘value’ と似ていますが、 アドレスの為の値を定義します(これはクロス・
コンパイラーでのみ違いが生じます)。

‘2Value’ ( d "name" –  ) double-ext “two-value”

‘fvalue’ ( r "name" –  ) floating-ext “f-value”
   実行時: ‘( -- r1 )’ な name を定義します。 ここで r は初期値です。 値
は ‘to name’ または ‘->name’ で変更できます。

‘TO’ ( value "name" –  ) core-ext “TO”
   NAME の値を VALUE に変更します

‘+TO’ ( value "name" –  ) gforth-1.0 “+TO”
   NAME の値に VALUE を足し込みます


File: gforth.info,  Node: Varues,  Next: Colon Definitions,  Prev: Values,  Up: Defining Words

6.10.5 Varues
-------------

(訳注: vaLue ではなくて vaRue) value のようなワードでアドレスを取得した
い場合があります。 これにはいくつかの欠点があるため、 Gforth では、 これ
について明示的に指定し、 ‘varue’を使用して名前を宣言するように求めます
(variable と value の特性を組み合わせたものであるため、 そのように名付け
られました)。

‘Varue’ ( w "name" –  ) gforth-1.0 “Varue”
   ‘value’ と似ていますが、 ‘addr name’ で得たアドレスで値にアクセスする
こともできます。 将来的には、 varues の効率が values よりも低くなる可能
性があります。

‘2varue’ ( x1 x2 "name" –  ) gforth-1.0 “2varue”
   ‘2value’ と似ていますが、 ‘addr name’ で得たアドレスで値にアクセスす
ることもできます。 将来的には、2varues は 2values よりも効率が低くなる可
能性があります。

‘fvarue’ ( r "name" –  ) gforth-1.0 “fvarue”
   ‘fvalue’ と似ていますが、 ‘addr name’ で得たアドレスで値にアクセスす
ることもできます。 将来的には、fvarues は fvalues よりも効率が低くなる可
能性があります。

‘addr’ ( "name" – addr  ) gforth-1.0 “addr”
   varue NAME または 2varue NAME または fvarue NAME のアドレスを提供しま
す。 または ‘wa: ca: da: fa: xta:’ のいずれかで定義されたローカル変数
name のアドレスを提供します。


File: gforth.info,  Node: Colon Definitions,  Next: Anonymous Definitions,  Prev: Varues,  Up: Defining Words

6.10.6 Colon Definitions
------------------------

     : name ( ... -- ... )
         word1 word2 word3 ;

‘name’ というワードを作成し、 実行時に ‘word1 word2 word3’ を実行します
。 ‘name’ は 定義(コロン定義)(“(colon) definition”) です。

   上記の説明はやや表面的です。 コロン定義の簡単な例については、 *note
Your first definition:: を参照してください。 関連する問題の一部について
の詳細な説明については、 *Note Interpretation and Compilation
Semantics:: を参照してください。

‘:’ ( "name" – colon-sys  ) core “colon”

‘;’ ( compilation colon-sys – ; run-time nest-sys –  ) core “semicolon”

   最終的には自動インライン化を実行する予定ですが、 今のところは以下のよ
うにしてインライン化を実行できます

‘inline:’ ( "name" – inline:-sys  ) gforth-experimental “inline-colon”
   インライン・コロン定義を開始します。 ‘inline:’ と ‘;inline’ の間のコ
ードは、 インライン化するコードを(実行するのではなく)コンパイルする必要
がありますが、 結果の定義 name は、 インライン化されたコードを実行するコ
ロン定義です。 コンパイルするコードはスタック効果が‘( -- )’ (スタックの
深さが変わらない)である必要があることに注意してください。 さもないと、
Gforth が name のコロン定義を作成しようとしたときにエラーが発生します。

‘;inline’ ( inline:-sys –  ) gforth-experimental “semi-inline”
   ‘inline:’ で始まるインライン定義を終了します

   例として、 インライン化されたワードを定義し、 以下のようにして使いま
す

     inline: my2dup ( a b -- a b a b )
         ]] over over [[ ;inline

     #1. my2dup d. d.
     : foo my2dup ;
     #1. foo d. d.
     see foo

   インライン・ワードはマクロ(*note Macros::)に関連しています。 マクロと
の違いは、マクロには即時コンパイル機能(immediate compilation semantics)が
あるのに対し、 ‘inline:’ で定義されたワードにはデフォルトのコンパイル機
能(compilation semantics)があることです。 つまり、 通常はコロン定義内で
のみマクロを使用しますが、 ‘inline:’ ワードは対話的(interpretively)にも
使用できることを意味します。 しかしそれは、 ‘inline:’ ワードとしては実行
できないいくつかのことをマクロでは実行できることも意味します。 例:

     \ Doesn't work:
     \   inline: endif ]] then [[ ;inline
     \ Instead, write a macro:
     : endif ]] then [[ ; immediate

   逆に、 非即時コロン定義(non-immediate colon definitions)として問題な
いワードについては、 非即時コロン定義として定義するか、 (最大限のパフォ
ーマンスが必要な場合) ‘inline:’ ワードとして定義します。 それらをマクロ
として定義しないでください。 対話的(interpretively)に適切に使用できなく
なります:

     : another2dup ]] over over [[ ; immediate
     \ Doesn't work:
     \   #1. another2dup d. d.

   なぜ ‘inline:’ と ‘;inline’ の間にコンパイル・コードを書かなければな
らないのか疑問に思われるかもしれません。 これは、 上記の ‘my2dup’ のよう
なインライン・ワードの実装が以下のように動作するためです:

     : compile-my2dup ( xt -- )
         drop ]] over over [[ ;

     : my2dup [ 0 compile-my2dup ] ;
     ' compile-my2dup set-optimizer

   ‘DROP’ や ‘0’ があるのは、 ‘compile-my2dup’ が ‘my2dup’ ための
‘compile,’ の実装であり、 ‘compile,’ は xt を期待する為です(*note
User-defined compile-comma::)。


File: gforth.info,  Node: Anonymous Definitions,  Next: Quotations,  Prev: Colon Definitions,  Up: Defining Words

6.10.7 Anonymous Definitions
----------------------------

しばしば匿名のワード(“anonymous word”)を定義したい場合があります。 つま
り、 名前無しのワードです。 これは以下のようにします:

‘:noname’ ( – xt colon-sys  ) core-ext “colon-no-name”

   これにより、 終わりの ‘;’ の後にワードの実行トークンがスタックに残り
ます。 以下は、 defer された ワード(deferred word)が匿名コロン定義
(anonymous colon definition)の ‘xt’ で初期化される例です:

     Defer deferred
     :noname ( ... -- ... )
       ... ;
     IS deferred

Gforth は、 2 つの別々のワードを使用して、 これを行う別の方法を提供しま
す:

‘noname’ ( –  ) gforth-0.2 “noname”
   次に定義するワードは匿名になります。 その定義するワードは(‘noname’が
いじる訳ではなくて)入力ストリームからのをそのままを使います(The defining
word will leave the input stream alone)。 その定義したワードの xt は
‘latestxt’ で取得します。

‘latestxt’ ( – xt  ) gforth-0.6 “latestxt”
   xt は、 最後に定義されたワードの実行トークンです。

先の例を、 ‘noname’ と ‘latestxt’ を使用して書き直すことができます:

     Defer deferred
     noname : ( ... -- ... )
       ... ;
     latestxt IS deferred

‘noname’ は、 ‘:’ だけでなく、 あらゆる定義ワードで機能します。

   ‘latestxt’ は、 最後のワードが ‘noname’ として定義されていない場合に
も機能します。 ただし、 複合ワード(combined words)には機能しません。 ま
た、 これは、 定義のヘッダーが構築されるやいなや有効になる便利なプロパテ
ィでもあります。 したがって、 以下のようにすると:

     latestxt . : foo [ latestxt . ] ; ' foo .

これは3つの数値を出力: 後ろの2つは同一の数値です。


File: gforth.info,  Node: Quotations,  Next: Supplying names,  Prev: Anonymous Definitions,  Up: Defining Words

6.10.8 Quotations
-----------------

引用(quotation)は、 別のコロン定義内の匿名コロン定義です。 引用
(quotation)は、 ‘catch’ や ‘outfile-execute’ など、 実行トークンを消費す
るワードを扱うときに便利です。 例えば、 以下の ‘outfile-execute’ (*note
Redirection::) の使用例を考えてみましょう:

     : some-warning ( n -- )
         cr ." warning# " . ;

     : print-some-warning ( n -- )
         ['] some-warning stderr outfile-execute ;

   ここで、 ‘some-warning’ をヘルパー・ワードとして定義し、 その xt を
outfile-execute に渡すことができます。 その代わりに、 引用(quotation)を
使用して ‘print-some-warning’ 内でそのようなワードを匿名で定義できます:

     : print-some-warning ( n -- )
       [: cr ." warning# " . ;] stderr outfile-execute ;

   引用(quotation)は ‘[:’ と ‘;]’ で囲まれています。 それは実行時に実行
トークンを生成します。

‘[:’ ( compile-time: – quotation-sys flag colon-sys  ) gforth-1.0 “bracket-colon”
   引用(quotation)を開始します

‘;]’ ( compile-time: quotation-sys – ; run-time: – xt  ) gforth-1.0 “semi-bracket”
   引用(quotation)を終了します


File: gforth.info,  Node: Supplying names,  Next: User-defined Defining Words,  Prev: Quotations,  Up: Defining Words

6.10.9 Supplying the name of a defined word
-------------------------------------------

デフォルトでは、 定義ワードは入力ストリームから定義されるワードの名前を
取得します。 しばしば文字列から名前を指定したい場合があります。 これは以
下のようにして行うことができます:

‘nextname’ ( c-addr u –  ) gforth-0.2 “nextname”
   次に定義されるワードの名前は C-ADDR U になります。 定義中のワードは入
力ストリームからそのままで ‘nextname’ がいじることはありません。

   例:

     s" foo" nextname create

これは以下と同等です:

     create foo

‘nextname’ は、 あらゆる定義ワードで機能します。


File: gforth.info,  Node: User-defined Defining Words,  Next: Deferred Words,  Prev: Supplying names,  Up: Defining Words

6.10.10 User-defined Defining Words
-----------------------------------

既存の定義ワードに基づいて新しい定義ワードを定義できますが、 ‘:’ と
‘create’...‘does>’/‘set-does>’ は特に柔軟です。 一方、 たとえば、
‘constant’ の子供達は全て単なる定数です。

* Menu:

* User-defined defining words with colon definitions::
* User-defined defining words using CREATE::
* CREATE..DOES> applications::
* CREATE..DOES> details::
* Advanced does> usage example::
* User-defined TO and DEFER@::
* User-defined compile-comma::
* Creating from a prototype::
* Making a word current::
* Const-does>::


File: gforth.info,  Node: User-defined defining words with colon definitions,  Next: User-defined defining words using CREATE,  Prev: User-defined Defining Words,  Up: User-defined Defining Words

6.10.10.1 User-defined defining words with colon definitions
............................................................

既存の定義ワードを定義時(defining-time)コードで取り囲み、 その取り囲んだ
一連のコードをコロン定義に入れることで、 新しい定義ワードを作成できます
。

   たとえば、 定義の xt を指定してコロン定義に関する統計を収集するワード
‘stats’ があり、 アプリケーション内のすべてのコロン定義で ‘stats’ を呼び
出す必要があるとします。 これには、 以下のように ‘:’ の新しいバージョン
を定義して使用できます:

     : stats
       ( xt -- ) DUP ." (Gathering statistics for " . ." )"
       ... ;  \ other code

     : my: : latestxt postpone literal ['] stats compile, ;

     my: foo + - ;

   ‘my:’ を使用して ‘foo’ を定義する場合、 以下のステップが実行されます:

   • ‘my:’ が実行されます。
   • 定義内の ‘:’ (‘my:’ と ‘latestxt’ の間にあるもの) が実行され、 ‘:’
     として、 いつもと同じことを行います。 名前を得るために入力ストリー
     ムをパースし、 名前 ‘foo’ のディクショナリ・ヘッダーを構築し、
     ‘state’ をインタプリタ状態からコンパイル状態に切り替えます。
   • ‘latestxt’ というワードが実行されます。 定義中のワード(‘foo’)の xt
     をスタックに置きます。
   • ‘postpone literal’ によって生成されたコードが実行されます。 これに
     より、 スタック上の値(‘foo’ の xt)が ‘foo’ のコード領域にリテラルと
     してコンパイルされます。
   • コード ‘['] stats’ は、 ‘my:’ の定義時に、 リテラルを ‘my:’ の定義
     内にコンパイルします(訳注: そして、 ‘my:’ の実行時は ‘stats’ の xt
     をスタックに積みます)。 そして、 ‘compile,’ が実行されると、 ‘foo’
     のコード領域に、 上記に続けて ‘stats’ の xt をコンパイルします(1)。
   • この時点で、 ‘my:’ の実行が完了し、 制御がテキスト・インタプリタに
     戻ります。 テキスト・インタプリタはコンパイル状態にあるため、 後続
     のテキスト ‘+ -’ は ‘foo’ の定義にコンパイルされ、 いつものように
     ‘;’ によって定義が終了します。

   ‘see’ を使用すると、 ‘my:’ を使用して定義されたワードを逆コンパイルし
、 それが通常の ‘:’ 定義とどのように異なるかを確認できます。 例:

     : bar + - ;  \ like foo but using : rather than my:
     see bar
     : bar
       + - ;
     see foo
     : foo
       `foo stats + - ;

   ‘`foo’ は ‘['] foo’ を記述する別の方法です。

   ---------- Footnotes ----------

   (1) 厳密に言えば、 ‘compile,’ が xt をコード領域内の何かに変換するた
めに使用するメカニズムは実装に依存します。 スレッド実装は実行トークンを
直接吐き出す場合がありますが、 別の実装はネイティブ・コード・シーケンス
を吐き出す場合があります


File: gforth.info,  Node: User-defined defining words using CREATE,  Next: CREATE..DOES> applications,  Prev: User-defined defining words with colon definitions,  Up: User-defined Defining Words

6.10.10.2 User-defined defining words using create
..................................................

定義ワードで定義されたワードを、 標準の定義ワードで定義されたワードとは
異なる振る舞いにしたい場合は、 以下のように定義ワードを記述できます:

     : def-word ( "name" -- )
         CREATE code1
     DOES> ( ... -- ... )
         code2 ;

     def-word name

   このコード断片は 定義ワード(“defining word”) ‘def-word’ を定義し、 そ
して、 それを実行します。 ‘def-word’ が実行されると、 新しいワード
‘name’ が ‘CREATE’ され、コード code1 が実行されます。 コード code2 は現
時点では実行されません。 ‘name’ というワードは、 ‘def-word’ の子供
(“child”)と呼ばれることもあります。

   ‘name’ を実行すると、 ‘name’ の本体のアドレスがデータ・スタックに置か
れ、 code2 が実行されます(‘name’ の本体のアドレスは、 ‘CREATE’ の直後に
‘HERE’ が返すアドレス、 つまり、 ‘create’ されたワードがデフォルトで返す
アドレスです)。

   ‘def-word’ を使用して、 同様に動作する一連の子ワード達を定義できます
。 つまり、 これらはすべて code2 によって決定される共通の実行時の振る舞
いを持っています。 通常、 code1 シーケンスは、 子ワードの本体にデータ領
域を構築します。 データの構造は ‘def-word’ のすべての子に共通ですが、 デ
ータ値は各子ワードに固有で、 そして、 プライベートです。 子ワードが実行
されると、 そのプライベート・データ領域のアドレスが TOS 上のパラメータと
して渡され、 code2 によって使用および操作されます(1)。

   定義ワードを構成する 2 つのコード断片は、 完全に別々の 2 つの時点で動
作(実行)されます:

   • 定義時 、定義ワードが code1 を実行して子ワードを生成します
   • 子の実行時、 子ワードが呼び出されると、 子ワード固有のプライベート
     なパラメータ達(データ)を使って、 code2 が実行されます。

   ‘def-word’ と ‘name’ の振る舞いを理解するもう 1 つの方法は、 以下のよ
うに定義することです:
     : def-word1 ( "name" -- )
         CREATE code1 ;

     : action1 ( ... -- ... )
         code2 ;

     def-word1 name1

この場合、 ‘name1 action1’ を使用することは、 ‘name’ を使用することと同
じです。

   ‘def-word’ を記述するもう 1 つの方法が引用(*note Quotations::)です:

     : def-word ( "name" -- ; name execution: ... -- ... )
         create code1
         [: code2 ;] set-does> ;

   Gforth は実際は ‘does>’ を使用してコードを後者のコードと同等のコード
にコンパイルします。 ‘set-does>’ アプローチの利点は、 その背後に他のコー
ドを配置でき、 回避策を必要とせずに制御構造内でそれを使用できることです
。 欠点は、 Gforth 固有であることです。

   典型的な例は、 以下のようにして ‘CONSTANT’ を定義できることです:

     : CONSTANT ( w "name" -- )
         CREATE ,
     DOES> ( -- w )
         @ ;

または同等の

     : CONSTANT ( w "name" -- ; name execution: -- w )
         create ,
         ['] @ set-does> ;

   ‘5 CONSTANT five’ を使用して定数を作成すると、 一連の定義時アクション
が実行されます。 最初に新しいワード ‘five’ が作成され、 次に ‘,’ を使用
して ‘five’ の本体に値 5 が配置されます。 ‘five’ が実行されると、 その本
体のアドレスがスタックに置かれ、 ‘@’ は値 5 を取得します。 ワード ‘five’
にはそれ自体のコードはありません。 ワード ‘five’ には、 データ・フィール
ドと、 引用(quotation) の xt または ‘@’ の xt が含まれるだけです。

   このセクションの最後の例は、 ‘CREATE’ されたワードで予約されている空
間はデータ空間であるため、 標準プログラムによる読み取りと書き込みの両方
が可能であることを思い出していただくことを目的としています(2):

     : foo ( "name" -- )
         CREATE -1 ,
     DOES> ( -- )
         @ . ;

     foo first-word
     foo second-word

     123 ' first-word >BODY !

   ‘first-word’ が ‘CREATE’ されたワードであった場合、 単純にそれを実行
してデータ・フィールドのアドレスを取得できます。 ただし、 ‘DOES>’ アクシ
ョンを持つように定義されているため、 その実行機能(execution semantics)は
、 それらの ‘DOES>’ アクションを実行することになります。 データ・フィー
ルドのアドレスを取得するには、 ‘'’ を使用して xt を取得し、 次に ‘>BODY’
を使用して xt をデータ・フィールドのアドレスに変換する必要があります。
‘first-word’ を実行すると、 ‘123’ が表示されます。 ‘second-word’ を実行
すると、‘-1’ が表示されます。

   上記の例では、 ‘DOES>’ の後のスタック・コメントは、 ‘DOES>’ に続くコ
ードのスタック効果ではなく、 定義されたワードのスタック効果を指定してい
ます(‘DOES>’ に続くコードは、 本体のアドレスがスタックの先頭にある事を期
待しています。 これはスタック・コメントには反映されません)。 これは著者
の私が使用し、 推奨している規則です(ただし、 スタック効果の指定にローカ
ル変数宣言を使うのと少々衝突する)。

   ---------- Footnotes ----------

   (1) このデータ領域への読み取りと書き込みは両方とも正当です。

   (2) 研究課題: この例は ‘Value’ と ‘TO’ をあなた独自に実装するための出
発点として使って見ましょう。 もし、 あなたが行き詰まった場合は、 ‘'’ と
‘[']’ の振る舞いを調べてください。


File: gforth.info,  Node: CREATE..DOES> applications,  Next: CREATE..DOES> details,  Prev: User-defined defining words using CREATE,  Up: User-defined Defining Words

6.10.10.3 Applications of ‘CREATE..DOES>’
.........................................

あなたは、 この機能をどのように使用するのか不思議に思うかもしれません。
いくつかの使用パターンを以下に示します:

   とあるコードのフレーズが複数回出現し、 その意味を同一視できる場合は、
それをコロン定義としてくくり出します。 類似のコロン定義が見つかった場合
は、 ‘CREATE..DOES>’ を使用してそれらをファクタリングできます。 たとえば
、 アセンブラは通常、 非常によく似たいくつかのワードを定義します:
     : ori, ( reg-target reg-source n -- )
         0 asm-reg-reg-imm ;
     : andi, ( reg-target reg-source n -- )
         1 asm-reg-reg-imm ;

これは以下のようにファクタリングできます:
     : reg-reg-imm ( op-code -- )
         CREATE ,
     DOES> ( reg-target reg-source n -- )
         @ asm-reg-reg-imm ;

     0 reg-reg-imm ori,
     1 reg-reg-imm andi,

   ‘CREATE..DOES>’ の別の観点は、 これをワードのパラメータの一部を提供す
る素朴な方法(関数型言語コミュニティではカリー化(“currying”)として知られ
ています)とみなすことです。 たとえば、 ‘+’ には 2 つのパラメータが必要で
すが、そのうち 1 つのパラメータを固定した ‘+’ のバージョンを作成するには
、 以下のようにします:

     : curry+ ( n1 "name" -- )
         CREATE ,
     DOES> ( n2 -- n1+n2 )
         @ + ;

      3 curry+ 3+
     -2 curry+ 2-


File: gforth.info,  Node: CREATE..DOES> details,  Next: Advanced does> usage example,  Prev: CREATE..DOES> applications,  Up: User-defined Defining Words

6.10.10.4 The gory details of ‘CREATE..DOES>’
.............................................

‘DOES>’ ( compilation colon-sys1 – colon-sys2  ) core “does”

   以下は、 一つの定義内で ‘CREATE’ と ‘DOES>’ の両方を使用する必要がな
いことを意味します。 ‘DOES>’ 部分を別の定義に置くことができます。 これに
より、 たとえば、 さまざまな ‘DOES>’ 部分から選択するようにすることがで
きます:
     : does1
     DOES> ( ... -- ... )
         code1 ;

     : does2
     DOES> ( ... -- ... )
         code2 ;

     : def-word ( ... -- ... )
         create ...
         IF
            does1
         ELSE
            does2
         ENDIF ;

   この例では、 ‘does1’ と ‘does2’ のどちらを使用するかの選択は、 子ワー
ドが ‘CREATE’ される定義時に行われます。

   注意: 定義を終了する ‘does>’ の性質により、 追加の定義 ‘does1’ と
‘does2’ を導入する必要があることに注意してください。 ‘set-does>’ を使用
するとこれを回避できます:

     : def-word ( ... -- ... )
         create ...
         IF
            [: code1 ;] set-does>
         ELSE
            [: code2 ;] set-does>
         ENDIF ;

   標準のプログラムでは、 最後のワードが ‘CREATE’ で定義されている場合に
のみ ‘DOES>’ 部分を適用できます。 Gforth では、 ‘DOES>’ 部分は、 いかな
る場合でも定義された最後のワードの振る舞いをオーバーライドします。 標準
のプログラムでは、 ‘DOES>’ はコロン定義でのみ使用できます。 Gforth では
、 一種のワンショット・モードとして、 インタプリタ状態で使用することもで
きます。 例:
     CREATE name ( ... -- ... )
       initialization
     DOES>
       code ;

これは、 以下の標準のと同等です:
     :noname
     DOES>
         code ;
     CREATE name EXECUTE ( ... -- ... )
         initialization

   Gforth は対話時に打ち込んだコード内での引用(quotations)もサポートして
おり、 引用は現在の定義を保存および復元するため、 上記の例を以下のように
記述することもできます:

     CREATE name ( ... -- ... )
       initialization
     [: code ;] set-does>

‘set-does>’ ( xt –  ) gforth-1.0 “set-does>”
   現在のワードを変更して、 本体アドレスをプッシュしてから xt を実行しま
す。 それに応じて ‘compile,’ の実装も変更します。 より効率的な実装が必要
な場合、 この後で ‘set-optimizer’ を呼び出します。

‘>body’ ( xt – a_addr  ) core “to-body”
   xt で表されるワードの本体(body)のアドレス(ワードのデータ・フィールド
のアドレス)を取得します。


File: gforth.info,  Node: Advanced does> usage example,  Next: User-defined TO and DEFER@,  Prev: CREATE..DOES> details,  Up: User-defined Defining Words

6.10.10.5 Advanced does> usage example
......................................

MIPS 逆アセンブラ(‘arch/mips/disasm.fs’)には、 非常に反復的なスキームに
従って逆アセンブルするための多くのワードが含まれています(訳注: very
repetetive scheme; repetitiveのスペルミスっぽい):

     :noname DISASM-OPERANDS s" INST-NAME" type ;
     ENTRY-NUM cells TABLE + !

   もちろん、 これは共通点をくくり出して以下のような定義を可能にするとい
うアイデアを刺激します:

     DISASM-OPERANDS ENTRY-NUM TABLE define-inst INST-NAME

   通常、 パラメータ DISASM-OPERANDS と TABLE は相関しています。 さらに
、 私が逆アセンブラを作成する前に、 以下のような命令を定義するコードがす
でに存在していました:

     ENTRY-NUM INST-FORMAT INST-NAME

   このコードは assembler 由来で、 ‘arch/mips/insts.fs’ にあります。

   したがって、 実行時に上記のスキームを実行する INST-FORMAT ワードを定
義する必要がありました。 私は、 まず最初に、ランタイム・コード生成を使用
することを選択しました:

     : INST-FORMAT ( entry-num "name" -- ; compiled code: addr w -- )
       :noname Postpone DISASM-OPERANDS
       name Postpone sliteral Postpone type Postpone ;
       swap cells TABLE + ! ;

   注意: これにより、 上記のスキームの他に 2 つのパラメータが提供される
ことに注意してください。

   別の方法として、 ‘create’/‘does>’ を使用してこれを記述することもでき
ます:

     : INST-FORMAT ( entry-num "name" -- )
       here name string, ( entry-num c-addr ) \ parse and save "name"
       noname create , ( entry-num )
       latestxt swap cells TABLE + !
     does> ( addr w -- )
       \ disassemble instruction w at addr
       @ >r
       DISASM-OPERANDS
       r> count type ;

   どういうわけか、 最初の解決策の方が簡単です。 その主な理由は、
‘string,’ やその友達を使用するよりも、 ‘sliteral’ を使用した方が、 文字
列を定義時から使用時へシフトするのが簡単だからです。

   私はこのスキームに従ってたくさんのワードを書き、 すぐにそれらの共通点
を取り出すことを考えました。 これは 2 レベルの定義ワード、 つまり通常の
定義ワードを定義するワードを使用していることに注意してください。

   今回は、 ‘postpone’ とそのファミリーが関与する解決策はより困難に思え
たので(研究課題として試してみましょう)、 ‘create’/‘does>’ というワードを
使用することにしました。 私はすでにそれを行っていたので、 下位レベルにも
‘create’/‘does>’ を使用しました(研究課題として ‘postpone’ などを使用して
みましょう)。 その結果、 以下の定義が得られました:

     : define-format ( disasm-xt table-xt -- )
         \ 逆アセンブルに disasm-xt を使用する命令フォーマットを定義し、
         \ 定義された命令を
         \ 表(table) table-xt に入れます
         create 2,
     does> ( u "inst" -- )
         \ 命令 inst を逆アセンブルする匿名ワードを定義し、
         \ それを u 番目のエントリとして table-xt に入れます
         2@ swap here name string, ( u table-xt disasm-xt c-addr ) \ remember string
         noname create 2,      \ define anonymous word
         execute latestxt swap ! \ enter xt of defined word into table-xt
     does> ( addr w -- )
         \ disassemble instruction w at addr
         2@ >r ( addr w disasm-xt R: c-addr )
         execute ( R: c-addr ) \ disassemble operands
         r> count type ; \ print name

   注意: ここでのテーブルは(上記とは対照的に) ‘cells +’ を単独で実行する
ことに注意してください (そのため、xt を渡す必要があります)。 このワード
は以下のように使用されます:

     ' DISASM-OPERANDS ' TABLE define-format INST-FORMAT

   上に示したように、 定義された命令フォーマットは以下のように使用されま
す:

     ENTRY-NUM INST-FORMAT INST-NAME

   カリー化に関しては、 この種の 2 レベルの定義ワードは 3 段階でパラメー
タを提供します。 最初に DISASM-OPERANDS と TABLE、 次に ENTRY-NUM と
INST-NAME 、最後に ‘addr w’ つまり、 逆アセンブル対象の命令です。

   もちろん、 これは ‘insts.fs’ で使用されるすべての命令フォーマット名に
完全に適合するわけではないため、 パラメータを正しい形式に条件付けるいく
つかのラッパーを定義する必要がありました。

   あなたが、 このセクションを理解するのが難しい場合でも、 心配する必要
はありません。 まず、 これは複雑であり、 理解するのに時間がかかります(お
そらく多少いじくりまわすことも必要です)。 2 番目に、 これは私が Forth の
17 年間で書いた最初の 2 レベルの ‘create’/‘does>’ ワードです。 また、 最
初に ‘insts.fs’ がなかった場合は、 1 レベルの定義ワードのみを使用するこ
とを選択した可能性があります(定義ワードを使用するときにパラメータをいく
つか繰り返します)。 したがって、 これを理解する必要はありませんが、 あな
たの Forth についての理解が深まるかもしれません。


File: gforth.info,  Node: User-defined TO and DEFER@,  Next: User-defined compile-comma,  Prev: Advanced does> usage example,  Up: User-defined Defining Words

6.10.10.6 User-defined ‘to’ and ‘defer@’
........................................

Gforth の value にはいくつかの操作子(operators)があります。 ‘to’ (‘is’ は
エイリアスであり、 ‘defer!’ は入力ストリーム内の名前の代わりに xt を受け
取ります)や ‘+to’ や ‘addr’ や ‘action-of’ (‘defer@’ は入力ストリーム内
の名前の代わりに xt を受け取ります)です。

   Gforth を使用すると、 ワードの ‘(to)’ アクションを変更できます。

‘(to)’ ( val operation xt –  ) gforth-1.0 “paren-to”
   name という名前の、 ワードに似ている value の xt です。 name に val を
保存します。 operation は、 ‘to’ と ‘+to’ と ‘addr’ と ‘action-of’ から
選択します。

‘to-table:’ ( "name" "xt1" .. "xtn" –  ) gforth-experimental “to-table-colon”
   ‘TO’ や ‘+TO’ や ‘ADDR’ や ‘ACTION-OF’ のエントリを含むテーブルを作成
します。 ‘n/a’ を使用して、 サポートされていない操作をマークします。

‘to-method:’ ( xt table "name" –  ) gforth-experimental “to-method-colon”
   to-method を作成します。 ここで、XT はフィールドにアクセスするための
アドレスを計算し、 TABLE にはそれに格納する操作子(operators)が含まれます
。

‘set-to’ ( to-xt –  ) gforth-1.0 “set-to”
   現在のワードの ‘(to) ( val xt -- )’ メソッドの実装を to-xt に設定しま
す。

‘n/a’ ( –  ) gforth-experimental “not-available”
   このワードをチック(tick)することはできますが、 インタプリタ時およびコ
ンパイル時に “Operation not supported” (操作はサポートされていません)と
いう例外が投げられます(throw)。 サポートされていないメソッドなどにこれを
使用します。

   ‘(to)’ は ‘to’ 内で使用されるワードです。 実行時(run-time)に値を保存
します。 ‘(to)’ メソッドの一般的なスタック効果は ‘( val Operation xt --
)’ です。 ここで、 xt は格納されているワードを示し、 operation は ‘to’ 風
の操作の実際のバリエーションを示します。 val はそこに格納されている (適
切な型の) 値です。

   ‘to-table:’ を使用して ‘to’ メソッドを実装し、 タイプ固有の操作テーブ
ルを作成し(テーブルの最後にある指定されていないスロットは ‘n/a’ で埋めら
れます)、 ‘to-method:’ を、 value の xt からそのデータ・フィールドを取得
する操作と組み合わせて使用​​します(通常、 ディクショナリ内の値の場合は
‘>body’ ですが、 value-style データは構造体またはユーザー領域に存在する
こともできます)。

   たとえば、 以下のように ‘fvalue’ を実装できます:

     to-table: f!-table f! f+!
     ' >body f!-table to-method: fvalue-to

     : fvalue ( r "name" -- ; name: -- r )
       create f,
       ['] f@ set-does>
       ['] fvalue-to set-to ;

     5e fvalue foo
     : bar foo 1e f+ to foo ;
     see bar


File: gforth.info,  Node: User-defined compile-comma,  Next: Creating from a prototype,  Prev: User-defined TO and DEFER@,  Up: User-defined Defining Words

6.10.10.7 User-defined ‘compile,’
.................................

以下を使用して、 とあるワードのための ‘compile,’ の実装を変更することも
できます

‘set-optimizer’ ( xt –  ) gforth-1.0 “set-optimizer”
   ‘compile,’ で xt execute するように現在のワードを変更します
(‘compile,’ に渡されたものと同じスタック内容を使用)。 注意: ‘compile,’ は
‘execute’ とスタック内容が一致している必要があるため、 ‘set-optimizer’ は
同じ振る舞いの、 より効率的な実装をインストールする場合にのみ使用しなけ
ればならないことに注意してください。

‘opt:’ ( compilation – colon-sys2 ; run-time – nest-sys  ) gforth-1.0 “opt:”
   名前無しのコロン定義を開始します。 完了すると、 このコロン定義は
(‘opt:’ の前の)最新のワードの ‘compile,’ の実装になります。

   注意: 結果として得られる ‘compile,’ は、 依然として ‘postpone literal
postpone execute’ と同等である必要があることに注意してください。 そのた
め、 ‘set-optimizer’ は、 振る舞いを変更するためではなく、 効率化のため
に役立てるものです。 しかし、 あなたが自分の足を撃つことを妨げるものは何
もありません。 あなたが ‘set-optimizer’ を使用したときの結果と、 最初に
以下を定義して使用を無効にしたときに得られる結果を比較することで、
‘set-optimizer’ の使用が正しいかどうかを確認できます。

     : set-optimizer drop ;

   ‘set-optimizer’ の使用例として、 上記の ‘CONSTANT’ の定義の 1 つを以
下のように拡張できます。

     : CONSTANT ( n "name" -- ; name: -- n )
       create ,
       ['] @ set-does>
       [: >body @ postpone literal ;] set-optimizer
     ;

   唯一の変更は、 ‘set-optimizer’ 行の追加です。 あなたが定数を定義して
コンパイルすると、 以下のようになります:

     5 constant five
     : foo five ;

   ‘foo’ 内のコンパイル済み ‘five’ は、 ‘five’ の一般的な呼び出しではな
く、 literal 5 とコンパイルされるようになりました。 引用(quotation)には
、 ‘compile,’ と同じスタック効果があり、 それは ‘( xt -- )’ です。 渡さ
れた xt は ‘compile,’ されたワード、 つまりこの例では ‘five’ に属します
。 この例では、 まず xt が本体アドレスに変換され、 次にその場所の値 5 が
取り出され、 その値が ‘postpone literal’ でコンパイルされます(*note
Literals::)。

   この ‘set-optimizer’ の使用は、 ユーザーが、 例えば ‘6 ' five >body
!’ などして定数の値を変更しないことを前提としています。 ‘five’ は
‘create’ で定義されていますが、 これは ‘CONSTANT’ の実装の詳細であり、 そ
れを文書化しない場合、 ユーザーはそれに依存してはなりません。 また、 本
体(body)が変更されないことを前提とした方法で ‘set-optimizer’ を使用する
場合、 (ここで行われているように) ‘create’ が使用されていることを文書化
してはなりません。 逆に、 それを文書化する場合は、 本体の変更を処理でき
るように ‘compile,’ 実装を記述する必要があります。

   もう一つの例は、 前述の ‘fvalue’ の例をさらに最適化したものです:

     : compile-fvalue-to ( xt-value-to -- )
       drop ]] >body f! [[ ;

     : fvalue-to ( r xt -- )
       >body f! ;
     ' compile-fvalue-to set-optimizer

     : fvalue ( r "name" -- ; name: -- r )
       create f,
       ['] f@ set-does>
       [: >body ]] literal f@ [[ ;] set-optimizer
       ['] fvalue-to set-to ;

     5e fvalue foo
     : bar foo 1e f+ to foo ;
     see bar

   ‘bar’ のコードを以前の定義のコードと比較します。 ここでは、 fvalue を
読み取るコード(‘fvalue’ の ‘set-optimizer’ より)と、 fvalue を書き込むコ
ード(‘fvalue-to’ に適用された ‘set-optimizer’ より)の両方の最適化が見ら
れます。 fvalue は(定数とは異なり)変化する可能性があるため、 (‘fvalue’ 内
部の)読み取り部分が、 アドレスと、 実行時に実行される ‘f@’ をコンパイル
します。

   ‘fvalue-to’ の場合、 ‘compile,’ の実装は基本的に、 ‘fvalue’ によって
インラインで実行されるコードをコンパイルするだけです。 ‘to’ のコンパイル
機能(compilation semantics)は、アドレスをリテラルとしてコンパイルしてか
ら、 ‘(to)’ の実装(つまり、 ‘fvalue-to’)をコンパイルします。 この処理で
は、 ‘>body’ が最適化されて削除されます。

   実際には、 Gforth の ‘fvalue’ は、 たとえば ‘+TO’ をサポートするなど
、 いくつかの追加の工夫が含まれています。

   注意: ‘set-optimizer’ の呼び出しは、 ‘set-does>’ (または ‘does>’ の呼
び出しの後に実行する必要があることに注意してください。 なぜなら、
‘set-does>’ は ‘compile,’ の実装それ自体を上書きするからです。

   ‘fvalue-to’ の例でわかるように、 ‘set-optimizer’ を ‘constant’ や
‘fvalue’ のような定義ワード内ではなく、 個々のワードに適用することもでき
ます。 この場合、 オプティマイザに渡されるワードの xt は通常は不要であり
、 ‘compile-fvalue-to’ のように ‘drop’ されます。

   エンジン ‘gforth-itc’ は ‘compile,’ に ‘,’ を使用するので、 そこでは
‘set-optimizer’ は効果ありません。


File: gforth.info,  Node: Creating from a prototype,  Next: Making a word current,  Prev: User-defined compile-comma,  Up: User-defined Defining Words

6.10.10.8 Creating from a prototype
...................................

上記では、 最初に ‘create’ を使用してワードを定義し、 それから
‘set-does>’ や ‘set-to’ や ‘set-optimizer’ などで変更する方法を示しまし
た。

   別の方法として、 以下のワード群を使用してプロトタイプを作成し、そのプ
ロトタイプから新しいワードを作成します。 この種のコピーでは本体(body)部
分は網羅されないため、 明示的に割り当てて初期化する必要があります。 上記
の ‘fvalue’ を例に取ると、 代わりに以下のように定義できます:

     create fvalue-prototype ( -- r )
     ['] f@ set-does>
     [: >body ]] literal f@ [[ ;] set-optimizer
     ['] fvalue-to set-to

     : fvalue ( r "name" -- ; name: -- r )
       ``fvalue-prototype create-from f, reveal ;

   このアプローチの利点は、まず ‘create’ ヘッダー・メソッド達を複製し、
それらを変更し、 最終的に重複排除する必要がないため、 ‘fvalue’ ワード群
の作成が高速化されることだ。 ただし、 この利点は、 この定義ワードで作成
されるワードの数が膨大な場合にのみ意味があります。

‘create-from’ ( nt "name" –  ) gforth-1.0 “create-from”
   指定の nt のように振る舞うが、 ボディが空のワード name を作成します。
nt は名前付きワードの nt でなければなりません。 結果として得られるヘッダ
ーはまだ非公開状態です(訳注: not yet reveal;ワードリスト未登録なので普通
は呼び出せない)。 ‘set-’ ワード群を使用せずに ‘create-from’ でワードを作
成すると、 ‘set-’ ワード群または ‘immediate’ または ‘does>’ を使用してワ
ードを作成するよりも高速になります。 ‘noname’ で ‘create-from’ を使用で
きます。

‘reveal’ ( –  ) gforth-0.2 “reveal”
   (reveal;明らかにする、暴露する)ヘッダー定義時の現在のワード・リスト
(wordlist current)に現在のワードを入れます。

   ‘noname’ を定義ワードとともに使用しても、 パフォーマンス上の利点は得
られません。 したがって、 以下もいっしょに使います

‘noname-from’ ( xt –  ) gforth-1.0 “noname-from”
   指定の xt のように動作するが、 本体が空の名前のないワードを作成します
。 xt は、 名前のないワードの xt でなければなりません。

   以下に使用例を示します:

     ``fvalue-prototype noname create-from
     latestnt constant noname-fvalue-prototype

     : noname-fvalue ( r -- xt ; xt execution: -- r )
       noname-fvalue-prototype noname-from f,
       latestxt ;


File: gforth.info,  Node: Making a word current,  Next: Const-does>,  Prev: Creating from a prototype,  Up: User-defined Defining Words

6.10.10.9 Making a word current
...............................

‘immediate’ や ‘set-optimizer’ など、 上記の多くのワードは、「現在の」
(current)ワードまたは「一番最近定義された」(most recently defined)ワード
を変更します。 しばしば以前のワードを変更したい場合があると思います。 そ
の場合は以下のようにして行うことができます

‘make-latest’ ( nt –  ) gforth-1.0 “make-latest”
   nt を最新の定義にし、 ‘immediate’ および ‘set-*’ 操作で操作できるよう
にします。 nt によって参照されるワードを既に使用している(特にコンパイル
済みの)場合、 そのワードの振る舞いを変更しないでください(その実装だけを
変更してください)。 さもないと、 Gforth エンジンやバージョン間で一貫性の
ない驚くべき振る舞いの組み合わせが発生する可能性があります。


File: gforth.info,  Node: Const-does>,  Prev: Making a word current,  Up: User-defined Defining Words

6.10.10.10 ‘Const-does>’
........................

‘create’...‘does>’ は、 定義時から実行時に幾つかの値を転送(transfer)する
ためによく使用されます。 Gforth は、 このために以下を用意しています

‘const-does>’ ( run-time: w*uw r*ur uw ur "name" –  ) gforth-obsolete “const-does”
   定義時: NAME を定義して返ります。

   NAME 実行時: W*UW R*UR をプッシュし、 ‘const-does>’ に続くコードを実
行します。

   このワードの一般的な使用例は以下のとおりです:

     : curry+ ( n1 "name" -- )
     1 0 CONST-DOES> ( n2 -- n1+n2 )
         + ;

     3 curry+ 3+

   ここで ‘1 0’ は、 1 つのセルと 0 の浮動小数点が定義時から実行時に転送
されることを意味します。

   ‘const-does>’ を使用する利点は以下のとおりです:

   • 値の保存と取得を扱う必要がなくなります。 つまり、 プログラムの書き
     込みと読み取りがより容易になります。

   • ‘does>’ を使用する場合は、 最適化できない ‘@’ を導入する必要があり
     ます(なぜなら ‘>body’...‘!’ を使用してデータを変更できるため)。
     ‘const-does>’ はこの問題を回避します。

   ‘const-does>’ の標準 Forth 実装は ‘compat/const-does.fs’ で利用できま
す。


File: gforth.info,  Node: Deferred Words,  Next: Forward,  Prev: User-defined Defining Words,  Up: Defining Words

6.10.11 Deferred Words
----------------------

定義ワード ‘defer’ (訳注: (期限を定めない)延期)を使用すると、 その振る舞
いを定義せずに名前でワードを定義できます。 その振る舞いの定義は延期
(defer)されます。 これが役立つ 2 つの状況を以下に示します:

   • ワードの振る舞いを後で変更できるようにし、 振る舞いが変更されたとき
     にそのワードへの全てのプリコンパイルされた参照も変更できるようにし
     たい場合。
   • 相互再帰(mutual recursion)の場合。 *Note Calls and returns::

   以下の例では、 ‘foo’ は常に ‘greet’ の「‘Good breakfast’」を出力する
バージョンを呼び出し、 ‘bar’ は常に‘greet’ の「‘Hello’」を出力するバージ
ョンを呼び出します。 ソースコードを並べ替えて再コンパイルすることなく、
‘foo’ で新しいバージョンを使用できるようにする方法はありません。

     : greet ." Good morning" ;
     : foo ... greet ... ;
     : greet ." Hello" ;
     : bar ... greet ... ;

   この問題は、 ‘greet’ を ‘defer’ された ワードとして定義することで解決
できます。 ‘defer’ された ワードの振る舞いは、 ‘IS’ を使用して以前に定義
されたワードの xt と関連付けることによって、 いつでも定義および再定義で
きます。 上記の例は以下のようになります:

     Defer greet ( -- )
     : foo ... greet ... ;
     : bar ... greet ... ;
     : greet1 ( -- ) ." Good morning" ;
     : greet2 ( -- ) ." Hello" ;
     ' greet2 IS greet  \ make greet behave like greet2

   プログラミング・スタイル・メモ: すべての defer された ワードに対して
スタック・コメントを記述し、 かつ、 そのスタック効果に一致する XT のみを
defer されたワードに入れる必要があります。 そうしないと、 defer されたワ
ードを使用するのは非常に困難です。

   defer された ワードを使用すると、 *note User-defined Defining Words::
の統計収集の例(statistics-gathering example)を改善できます。 アプリケー
ションのソース・コードを編集してすべての ‘:’ を ‘my:’ に変更するのではな
く、 以下のようにします:

     : real: : ;     \ retain access to the original
     defer :         \ redefine as a deferred word
     ' my: IS :      \ use special version of :
     \
     \ load application here
     \
     ' real: IS :    \ go back to the original

   注意すべき点の 1 つは、 ‘IS’ には特別なコンパイル機能(compilation
semantics)があり、 (‘TO’ のように)コンパイル時に名前をパースするというこ
とです:

     : set-greet ( xt -- )
       IS greet ;

     ' greet1 set-greet

   ‘IS’ が適合しない状況では、 代わりに ‘defer!’ を使用してください。

   defer された ワードは、 xt から実行機能(execution semantics)のみを継
承できます(xt が表現できるのはそれだけであるためです – これについての詳
しい説明は *note Tokens for Words:: 参照)。 デフォルトでは、この実行機能
(execution semantics)から派生したデフォルトのインタプリタ機能
(interpretation semantics)とコンパイル機能(compilation semantics)を持ち
ます。 ただし、 defer された ワードのインタプリタ機能とコンパイル機能は
、 通常の方法で変更できます。

     : bar .... ; immediate
     Defer fred immediate
     Defer jim

     ' bar IS jim  \ jim has default semantics
     ' bar IS fred \ fred is immediate

‘Defer’ ( "name" –  ) core-ext “Defer”
   defer された ワード name を定義します。 その実行機能(execution
semantics)は ‘defer!’ または ‘is’ で設定できます(最初に name を実行する
前に設定する必要があります)。

‘defer!’ ( xt xt-deferred –  ) core-ext “defer-store”
   xt (XT-DEFERRED) で表される defer された ワードに実行のための XT を設
定します。

‘IS’ ( xt "name" –  ) core-ext “IS”
   ‘defer’ された ワード NAME に実行のための XT を設定します。

‘defer@’ ( xt-deferred – xt  ) core-ext “new-defer-fetch”
   xt は、 defer された ワード xt-deferred に現在関連付けられているワー
ドを表します。

‘action-of’ ( interpretation "name" – xt; compilation "name" – ; run-time – xt  ) core-ext “action-of”
   Xt は、 現在 name に割り当てられている XT です。

   Forth-94 では、 これら Forth-2012 のワードの定義は、‘compat/defer.fs’
で提供されます。 さらに、 Gforth は以下を提供します:

‘defers’ ( compilation "name" – ; run-time ... – ...  ) gforth-0.2 “defers”
   defer された ワード name の現在の内容を現在の定義にコンパイルします。
つまり、 これにより、 name が defer されなかったかのように静的結び付け
(static binding)が生成されます。

‘wrap-xt’ ( xt1 xt2 xt: xt3 – ...  ) gforth-1.0 “wrap-xt”
   defer された ワード xt2 の現在の xt-current をどこかに退避して xt1 に
設定した上で、 xt3 を実行し、 xt3 実行後、 退避した xt-current を defer
されたワード xt2 に戻します(訳注: xt3 の内部のどこかで defer されたワー
ド xt2 を使っているとして、 xt2 の実行機能を一時的に xt1 に設定してから
xt3 を実行し、 実行後に xt2 の実行機能を元に戻しておく。 元に戻すのは
try ...  restore ...  endtry で囲まれた部分なので xt3 実行中にエラーがあ
っても確実に復旧される。 詳しくはソースコード見て下さい。 なお、 xt: は
xt3 を deferフレーバーに設定する)

‘preserve’ ( "name" –  ) gforth-1.0 “preserve”
   指定の defer された ワード name で、 現在設定されている実行機能 xt を
、 その場で ‘is’ や ‘defer!’ したかのようなコードに変換します(訳注: 上記
例より、 ’ greet2 is greet : preserve-greet2 preserve greet ; → greet1
is greet ok → greet Good morning ok → preserve-greet2 ok → greet Hello
ok ; see preserve-greet2 → : preserve-greet2 ‘greet2 ‘greet !  ; ok)


File: gforth.info,  Node: Forward,  Next: Aliases,  Prev: Deferred Words,  Up: Defining Words

6.10.12 Forward
---------------

‘forward.fs’ 内の定義ワード ‘forward’ を使用すると、 前方参照(forward
references)を作成できます。 これは自動的に解決され、 ‘Defer’ の間接化
(indirection)のような追加コストは発生しません。 ただし、 これらの
forward 定義はコロン定義に対してのみ機能します。

‘forward’ ( "name" –  ) gforth-1.0 “forward”
   コロン定義への前方参照(forward reference)を定義します。 同一のワード
リスト内(wordlist)で同一の名前のコロン定義を定義すると、 前方参照が解決
されます。 ‘.unresolved’ を使用して、 未解決の forward があるかどうかを
確認します。

‘.unresolved’ ( –  ) gforth-1.0 “.unresolved”
   未解決の前方参照(forward references)をすべて出力します


File: gforth.info,  Node: Aliases,  Prev: Forward,  Up: Defining Words

6.10.13 Aliases
---------------

定義ワード ‘synonym’ を使用すると、 他のワードと同一の振る舞いをするワー
ドを名前で定義できます。 これが役立つ 2 つの状況を以下に示します:

   • 別のワードリストからワードの定義にアクセスしたい場合(この例について
     は、 Gforth ソースの ‘root’ ワードリストの定義を参照してください)。
   • あなたが同義語(synonym)を作成したい場合。 2つの名前どちらでも認識で
     きる定義(たとえば、 ‘THEN’ と ‘ENDIF’ は同義語(synonyms)です)。

‘Synonym’ ( "name" "oldname" –  ) tools-ext “Synonym”
   oldname と同一に振る舞うように name を定義します。 つまり、 同一のイ
ンタプリタ機能(interpretation semantics)と、 同一のコンパイル機能
(compilation semantics)と、 同一の ‘to’/‘defer!’ や ‘defer@’ 機能を持ち
ます。

   Gforth は、 コンパイル機能、 または ‘to’/‘defer!’ や ‘defer@’ 機能を
親から継承しない、 非標準の ‘alias’ も提供します。 あなたは後で、 例えば
‘immediate’ などを使用してコンパイル機能などを変更できます。

‘Alias’ ( xt "name" –  ) gforth-0.2 “Alias”
   name を xt を実行するワードとして定義します。 defer された ワードとは
異なり、 エイリアス(aliase)にはコンパイル時に間接的なオーバーヘッドがあ
りません。

   Example:

     : foo ... ; immediate

     ' foo Alias bar1           \ bar1 is not an immediate word
     ' foo Alias bar2 immediate \ bar2 is an immediate word
     synonym bar3 foo           \ bar3 is an immediate word

   synonyms(同義語)とaliases(別名)はどちらも元の nt とは異なる nt を持ち
ますが、 それをチック(tick)すると(または ‘name>interpret’ を使用すると
)、 元の xt と同じ xt が生成されます(*note Tokens for Words::)。


File: gforth.info,  Node: Interpretation and Compilation Semantics,  Next: Tokens for Words,  Prev: Defining Words,  Up: Words

6.11 Interpretation and Compilation Semantics
=============================================

(名前付き)ワード(word)のインタプリタ機能(“interpretation semantics”)は、
テキスト・インタプリタがインタプリタ状態でワードに遭遇したときに行うこと
です。 これは他の文脈でも表れます。 たとえば、 ‘' word’ によって返される
実行トークンは、 word のインタプリタ機能(“interpretation semantics”)を識
別します(つまり、 ‘' word execute’ は、 ‘word’ のインタプリタ状態でのテ
キスト通訳(interpretation)と同等です)。

   (名前付き)ワード(word)のコンパイル機能(“compilation semantics”)は、 テ
キスト・インタプリタがコンパイル状態でワードに遭遇したときに行うことです
。 これは他の文脈でも表れます。 たとえば、 ‘POSTPONE word’ は、 word の
コンパイル機能(compilation semantics)コンパイルします(1)。

   ほとんどのワードにはデフォルトのコンパイル機能(compilation
semantics)があります。 つまり実行機能(execution semantics)(スタック効果
‘( -- )’)をコンパイルします。 ただし、多くのワードが他のコンパイル機能
(compilation semantics)を持っていて、 その個々のワードについては文書化さ
れています(スタック効果を含む)。

   標準では、 実行機能(“execution semantics”)についても述べています。 標
準では、 両方が定義されている場合はインタプリタ機能(interpretation
semantics)と異なることはありませんが、 一方が定義されていない、 または、
両方とも定義されていない場合もあります。 Gforth ではインタプリタ機能
(interpretation semantics)と実行機能(execution semantics)には違いがない
ため、 これらの用語は同じ意味で使用されます。

   Gforth (1.0 以降)では、 すべてのワードに インタプリタ機能/実行機能 が
定義されています。 標準でインタプリタ機能も実行機能も定義されていない多
くのワード(‘if’ など)については、 Gforth の インタプリタ機能/実行機能 が
コンパイル機能を実行します。

   標準では、 実行機能はデフォルトでインタプリタ機能とコンパイル機能を定
義するために使用されます。 デフォルトでは、ワードのインタプリタ機能はそ
の実行機能を ‘execute’ し、 ワードのコンパイル機能はその実行機能を
‘compile,’ します(2)。

   名前無しワード(*note Anonymous Definitions::)は、 テキスト・インタプ
リタまたはチック(tick)または ‘postpone’ では検出できません。 このような
ワードはその xt (*note Tokens for Words::) によって表され、 この xt が
‘execute’ されたときは、 その実行機能が呼び出されます。

   あなたは、 最後に定義されたワードの機能(semantics)を変更できます:

‘immediate’ ( –  ) core “immediate”
   ワードのコンパイル機能を、 その実行機能を実行するように設定します。

‘compile-only’ ( –  ) gforth-0.2 “compile-only”
   最後の定義をコンパイル専用としてマークします。 その結果、 テキスト・
インタプリタと ‘'’ は、 そのようなワードに遭遇すると警告を発します。

‘restrict’ ( –  ) gforth-0.2 “restrict”
   ‘compile-only’ の同義語(synonym)

   慣習により、 デフォルト以外のコンパイル機能を持つワード(即実行ワード
など)は、多くの場合、 名前が括弧(brackets;角括弧)で囲まれています(例:
‘[']’ *note Execution token::)。

   注意: compile-only のワードにチック(tick)(‘'’)を付けると、警告
(“<word> is compile-only”)が表示されることに注意してください。

* Menu:

* Combined words::

   ---------- Footnotes ----------

   (1) 標準の用語では、 「現在の定義に追加する」と言います

   (2) 標準の用語でいうと、 デフォルトのインタプリタ機能はその実行機能で
す。 デフォルトのコンパイル機能は、 その実行機能を現在の定義の実行機能に
追加します


File: gforth.info,  Node: Combined words,  Prev: Interpretation and Compilation Semantics,  Up: Interpretation and Compilation Semantics

6.11.1 Combined Words
---------------------

Gforth を使用すると、 複合ワード(“combined words”)、 つまりインタプリタ
機能(interpretation semantics)とコンパイル機能(compilation semantics)を
任意に組み合わせたワードを定義できます。

‘interpret/compile:’ ( interp-xt comp-xt "name" –  ) gforth-0.2 “interpret/compile:”

   この機能は、 ‘TO’ と ‘S"’ を実装するために導入されました。 このような
ワードは、 たとえ小さなかわいいものであっても定義しないことをお勧めしま
す。 なぜなら、 ワードによっては、 いくつかの文脈でワードの両方の部分を
理解するのが困難になるからです。 たとえば、 あなたがコンパイル部分の実行
トークンを取得したいとすると、 代わりに、 2つのワードを定義します。 1つ
はインタプリタ機能部分を具体化するもで、 もう一つはコンパイル機能部分を
具体化するものです。 それら完成したら、 あなたのユーザーの便宜のために
‘interpret/compile:’ を使用して、 それらを組み合わせた複合ワード
(combined word)を定義できます。

   この機能を使用して、 ワードのデフォルトのコンパイル機能(compilation
semantics)の最適化実装を提供してみるとしましょう。 たとえば、 以下のよう
に定義します:
     :noname
        foo bar ;
     :noname
        POSTPONE foo POSTPONE bar ;
     interpret/compile: opti-foobar

上記は以下の最適化バージョンです:

     : foobar
         foo bar ;

   残念ながら、 これは ‘[compile]’ では正しく動きません。 なぜなら、
‘[compile]’ では、 すべての ‘interpret/compile:’ ワードのコンパイル機能
がデフォルトでは無いと想定しているためです。 つまり、 ‘[compile]
opti-foobar’ はコンパイル機能をコンパイルしますが、 ‘[compile] foobar’ は
インタプリタ機能をコンパイルします。

   “state-smart” ワードを使用して、‘interpret/compile:’ によって提供され
る機能をエミュレートしようとする人もいます(実行途中に ‘STATE’ をチェック
する場合、 ワードは state-smart になります)。 たとえば、‘foobar’ を以下
のようにコーディングしようとします:

     : foobar
       STATE @
       IF ( compilation state )
         POSTPONE foo POSTPONE bar
       ELSE
         foo bar
       ENDIF ; immediate

   これは ‘foobar’ がテキスト・インタプリタによってのみ処理される場合に
は機能しますが、 他のコンテキスト(‘'’ や ‘POSTPONE’ など)では機能しませ
ん。 たとえば、 ‘' foobar’ は、 元の ‘foobar’ のインタプリタ機能ではなく
、 state-smart ワードの実行トークンを生成します。 この実行トークンを
(‘EXECUTE’ で直接、 または ‘COMPILE,’ で間接的に)コンパイル状態において
実行(execute)すると、 結果は期待したものになりません(つまり、 ‘foo bar’
は実行されません)。 state-smart ワードは良くないアイディアです。 対策は
、 こんなの書かない事！です(1)。

   ---------- Footnotes ----------

   (1) このトピックに関する議論の詳細は M. Anton Ertl,
‘‘State’-smartness—Why it is Evil and How to Exorcise it
(https://www.complang.tuwien.ac.at/papers/ertl98.ps.gz)’, EuroForth ’98.
をご覧ください。


File: gforth.info,  Node: Tokens for Words,  Next: Compiling words,  Prev: Interpretation and Compilation Semantics,  Up: Words

6.12 Tokens for Words
=====================

このセクションでは、 ワードを表すトークンの作成とその使用について説明し
ます。

* Menu:

* Execution token::          実行/インタプリタ
                               機能(execution/interpretation semantics)
* Name token::               名前付きワード
* Compilation token::        コンパイル機能(compilation semantics)


File: gforth.info,  Node: Execution token,  Next: Name token,  Prev: Tokens for Words,  Up: Tokens for Words

6.12.1 Execution token
----------------------

実行トークン(“execution token”)(xt)はワードの振る舞いを表します。
‘execute’ を使用して xt で表される振る舞いを呼び出すことができ、 そして
、 ‘compile,’ (*note Macros::) を使用してそれを現在の定義にコンパイルで
きます。 その他の使用法としては、 defer された ワード(*note Deferred
Words::) があります。

   特に、 ワードのインタプリタ機能(interpretation semantics)(別名 実行機
能(execution semantics))を表す「実行トークン」(execution token)がありま
す(1)。

   名前付きワード x の場合、 ‘`x’(訳注:アポストロフィではなくてバックス
ラッシュ)を使用してその実行トークンを取得できます:

     5 `. ( n xt )
     execute ( )      \ execute the xt (i.e., ".")
     : foo `. execute ;
     5 foo

   しかしながら、 ‘`’ プレフィックスは Gforth 拡張であるため、 以下の標
準 Forth のワードを使用する方が好ましいです:

‘'’ ( "name" – xt  ) core “tick”
   xt は name のインタプリタ機能(interpretation semantics)を表します。 ワ
ードにインタプリタ機能が無い場合、 ‘-14 throw’ を実行します。

‘[']’ ( compilation. "name" – ; run-time. – xt  ) core “bracket-tick”
   xt は name のインタプリタ機能(interpretation semantics)を表します。 ワ
ードにインタプリタ機能が無い場合、 ‘-14 throw’ を実行します。

   これらはパース・ワード(parsing words)であるため(なお、 ‘`x’ は認識器
(recognizer)によってリテラルとして扱われます)、 通訳(interpret)されたり
コンパイルされたコードの振る舞いが直感的ではない場合があります:

     5 ' .   ( n xt )
     execute ( -- )      \ execute the xt of .
     \ 以下は意図したとおりに動きません:
     \ : foo ' . ;
     \ 5 foo execute
     \ その代わりに以下のようにします:
     : foo ['] . ;
     5 foo execute    \ execute the xt of .
     \ コロン定義内で ' を使った場合:
     : bar ' execute ;
     5 bar .          \ execute the xt of .
     \ 訳注: 一見普段と変わらないように見えるが、
     \       テキスト・インタプリタが . を実行するのではなく、
     \       bar が その後ろのワードの xt を execute している。
     \       よって bar の後ろを省略すると下記のようにエラーとなる
     5 bar
     *the terminal*:10:6: error: Attempt to use zero-length string as a name
     5 bar>>><<<

   ‘'’ は実行時にパースするため、 ‘bar’ のようにコロン定義に置くと、 コ
ロン定義内の次のワードを消費せずに実行時に次のワードが消費されます。
‘`x’ と書かずにリテラル xt をコロン定義に入れたい場合は、 ‘['] x’ と書き
ます。

   Gforth の ‘`x’ や ‘'’ や ‘[']’ は、 compile-only ワードで使用すると警
告(warn)します。 そのような使用法が、 異なる Forth システム間で移植でき
ない可能性があるためです。

   ワードの immediate のバリエーションを定義することで、 この警告
(warning)と移植性の問題を回避できます。 例:

     : if postpone if ; immediate
     : test [ ' if execute ] ." test" then ;

   結果として得られる実行トークンが ‘execute’ されたときは、 ‘if’ のコン
パイル機能(compilation semantics)を実行します。

   xt を取得するもう一つ方法は、 ‘:noname’ または ‘latestxt’ です(*note
Anonymous Definitions::)。 匿名のワードの場合、 ‘:noname’ または
‘latestxt’ により、 そのワードが持つ唯一の振る舞い(実行機能(execution
semantics)) の xt が得られますが、 名前付きワードの定義の後ろで
‘latestxt’ を使用して、 その xt を取得することもできます。

     :noname ." hello" ;
     execute

   xt は 1 つのセルを占有し、 他のセルと同様に操作できます。

   標準 Forth では、 xt は単なる抽象データ型です(つまり、 xt を生成また
は消費する操作によって定義されます)。 (Gforth 1.0 以降の)具体的な実装は
、 ワードの本体アドレス(昔は PFA だった)です。 Gforth 0.7 以前では、 xt
はコード・フィールド・アドレス(CFA は PFA の 2 セル前)として実装されてい
ました。

‘execute’ ( xt – ) core “execute”
   実行トークン xt によって表される機能(semantics)を実行します。

‘execute-exit’ ( compilation – ; run-time xt nest-sys –  ) gforth-1.0 “execute-exit”
   ‘xt’ を実行し、 末尾呼び出し最適化法(tail-call-optimized way)で現在の
定義から戻ります。 戻りアドレス ‘nest-sys’ とローカル変数(local)は、
‘xt’ を execute する前に割り当て解除(deallocate)されます。

‘perform’ ( a-addr – ) gforth-0.2 “perform”
   ‘@ execute’.

   ‘Noop’ は、 しばしば実行トークンのプレースホルダーとして使用されます:

‘noop’ ( – ) gforth-0.2 “noop”

   ---------- Footnotes ----------

   (1) 標準 Forth には、 インタプリタ機能(interpretation semantics)が未
定義のワード(例: ‘r@’)や、 定義された実行機能(execution semantics)が無い
ワード(例: ‘s"’)や、 およびそのどちらも持たないワード(例: ‘if’)がありま
す。 ただし、 インタプリタ機能(interpretation semantics)と実行機能
(execution semantics)の両方が定義されている場合、 それらは同一でであるた
め、 それらを同一のものとして扱います


File: gforth.info,  Node: Name token,  Next: Compilation token,  Prev: Execution token,  Up: Tokens for Words

6.12.2 Name token
-----------------

Gforth は、名前付きワードを「名前トークン」“name token”(nt)で表します。
名前トークンは、 引数または、 以下のワードの結果として発生するセル・サイ
ズの抽象データ型です。

   Gforth 1.0 以降、 ほとんどのワードの nt の具体的な実装は、 xt と同一
アドレスです(これは xt のための基本 nt (primary nt)です)。 ただし、
synonym と、 aliase と、 ‘interpret/compile:’ で定義されたワードは、 別
のワードから xt を取得しますが、 (xt とは異なり)依然として自分独自の nt
を持ちます。 したがって、 Gforth 1.0 固有のコードを作成する準備ができて
いる場合でも、 xt と nt を同一の意味で使用することはできません。 ‘>name’
を使用してこれら自分独自の nt を持つワードの xt から代替 nt を取得するこ
とはできません。

   ‘``x’ (Gforth 1.0 以降) または、 以下を使用して、 ワード x の nt を取
得します

‘find-name’ ( c-addr u – nt | 0  ) gforth-0.2 “find-name”
   現在の検索順序スタック(the search order)で名前 c-addr u を見つけます
。 nt が見つかった場合はそれを返し、 それ以外の場合は 0 を返します。

‘find-name-in’ ( c-addr u wid – nt | 0  ) gforth-1.0 “find-name-in”
   wid で識別されるワードリストで、 c-addr u の文字列で指定された定義を
検索します。 nt が見つかった場合はそれを返し、 それ以外の場合は 0 を返し
ます。

‘latest’ ( – nt  ) gforth-0.6 “latest”
   NT は、 最後に定義されたワードの名前トークンです。 最後のワードに名前
がない場合は 0 です。

‘latestnt’ ( – nt  ) gforth-1.0 “latestnt”
   nt は、 最後に定義されたワードの名前トークンです(訳注: 名前が無い場合
でも nt を返す。 その nt を name>string すると、 長さ 0 の文字列(addr u)
を返す)

‘>name’ ( xt – nt|0  ) gforth-0.2 “to-name”
   xt で表されるワードの基本名前トークン(primary name token) nt を取得し
ます。 xt が ぢつは xt でない場合(非 xt を xt と誤認する可能性が低いヒュ
ーリスティック・チェックを使用)、 または基本 nt (primary nt)が名前無しワ
ードである場合は 0 を返します。 Gforth 1.0 の時点では、 すべての xt に基
本 nt がありますが、 他の名前付きワードも同一のインタプリタ機能
(interpretation sematics) xt を持つ可能性があります。

‘xt>name’ ( xt – nt  ) gforth-1.0 “xt-to-name”
   xt の基本 nt (primary nt)を生成します。 xt が、 ぢつは xt でない場合
、 nt は nt であるとは保証されません。

   以下を使用すると、 ワードリスト内のすべての nt を取得できます

‘traverse-wordlist’ ( ... xt wid – ...  ) tools-ext “traverse-wordlist”
   f が false になるかワードリストがなくなるまで、 ワードリスト wid 内の
ワード nt ごとに xt ( ...  nt – f ...  )  を 1 回実行します。 xt はスタ
ックその下側を自由に使用できます(訳注: つまり TOS に f さえ返せばスタッ
クに何が積まれても(積まれなくても)気にしない)

   nt を使用すると、 ワードのインタプリタ機能(interpretation semantics)と
コンパイル機能(compilation semantics)や、 その名前や、 ワードリスト内の
次のワードのワード、 にアクセスできます:

‘name>interpret’ ( nt – xt  ) tools-ext “name-to-interpret”
   xt はワード nt のインタプリタ機能(interpretation semantics)を表します
。

‘name>compile’ ( nt – w xt  ) tools-ext “name-to-compile”
   w xt はワード nt のコンパイル・トークン(compilation token)です(訳注:
コンパイル・トークン CT は 2セル構成)。

‘name>string’ ( nt – addr u  ) tools-ext “name-to-string”
   addr count は、 nt で表されるワードの名前です。

‘id.’ ( nt –  ) gforth-0.6 “i-d-dot”
   NT で表されるワードの名前を出力します。

‘.id’ ( nt –  ) gforth-0.6 “dot-i-d”
   ‘id.’ の F83 での名前です。

‘name>link’ ( nt1 – nt2 / 0  ) gforth-1.0 “name-to-link”
   ワード nt1 の場合、 同じワードリスト内の1つ前のワード nt2 を返します
。 前のワードがない場合は 0 を返します。

   名前なしワードは通常、 インタプリタ機能(interpretation compilation)も
無く、 コンパイル機能(compilation semantics)も無く、 名前も無く、 単語リ
ストにもありません。 しかし、Gforth (1.0 以降) ではすべてのワードは等し
いため、 名前無しのワードにも nt があります(ただし、 ワードリストには含
まれません)。 その nt は ‘latestnt’ で取得でき、 nt を消費する上記のワー
ド群はこれらの nt に対して適切な処理を行います。

   使用例として、 以下のコードは、デフォルト以外のコンパイル機能
(compilation semantics)を持つ ‘forth-wordlist’ 内のすべてのワードをリス
トします:

     : ndcs-words ( wid -- )
       [: dup name>compile ['] compile, <> if over id. then 2drop true ;]
       swap traverse-wordlist ;

     forth-wordlist ndcs-words

   このコードは、 コンパイル・トークンの xt 部分が ‘compile,’ の xt であ
る場合、 ワードがデフォルトのコンパイル機能(compilation semantics)を持っ
ていると仮定しています。

   いにしえの Forth システムの nt に最も近いのはネーム・フィールド・アド
レス(NFA)ですが、 Gforth とは顕著な違いがあります。 いにしえの Forth シ
ステムでは、 各ワードに一意の NFAとLFAとCFAとPFA(または、LFAとNFAとCFAと
PFAの順)があり、 あるワードから次のワードへと進むためのワードがありまし
た。 これとは対照的に、 Gforth では、 いくつかの nt が ‘name>interpret’
xt からは同一の xt を取得できます。 名前トークンによって識別される構造体
にリンク・フィールドがありますが、 通常、 検索にはこれらの構造体の外部に
あるハッシュ・テーブルが使用されます。 Gforth の名前はセル幅のカウントお
よびフラグ・フィールド(cell-wide count-and-flags field)がありますが、 nt
はそのカウント・フィールドへのアドレスとしては実装されていません。


File: gforth.info,  Node: Compilation token,  Prev: Name token,  Up: Tokens for Words

6.12.3 Compilation token
------------------------

名前付きワードのコンパイル機能(compilation semantics)は、 2 つのセル w
xt で構成されるコンパイル・トークン(“compilation token”)によって表されま
す。 一番上のセル xt は実行トークンです。 コンパイル・トークンによって表
されるコンパイル機能は、 ‘execute’ で実行できます。 これは、 コンパイル
・トークン全体を消費し、 コンパイル・トークンが表すコンパイル機能
(compilation semantics)によって決定される追加のスタック効果を伴います。

   現時点では、 コンパイル・トークンの w 部分は実行トークンで、 xt 部分
は ‘execute’ または ‘compile,’ のいずれかを表します(1)。 ただし、 必要な
場合を除き、 この知識に頼らないでください。 Gforth の将来のバージョンで
は、 普通でない(unusual)なコンパイル・トークン(リテラルのコンパイル機能
を表すコンパイル・トークンなど)が導入される可能性があります。

   たとえば、 ‘if’ のコンパイル・ークンは、 ‘name>compile’ を使用した標
準的な方法(例: ‘`if name>compile’)で取得できますが、 コンパイル・トーク
ンを取得するためのパース・ワードもあります:

‘[COMP']’ ( compilation "name" – ; run-time – w xt  ) gforth-0.2 “bracket-comp-tick”
   コンパイル・トークン w xt は、 name のコンパイル機能(compilation
semantics)を表します。

‘COMP'’ ( "name" – w xt  ) gforth-0.2 “comp-tick”
   コンパイル・トークン w xt は、 name のコンパイル機能(compilation
semantics)を表します。

   ‘execute’ を使用して、 コンパイル・トークンによって表されるコンパイル
機能(compilation semantics)を実行できます。 ‘postpone,’ を使用してコンパ
イル機能(compilation semantics)をコンパイルできます。 つまり、 ‘``x
name>compile postpone,’ は ‘postpone x’ と同等です。

‘postpone,’ ( w xt –  ) gforth-0.2 “postpone-comma”
   コンパイル・トークン w xt で表されるコンパイル機能(compilation
semantics)をコンパイルします。

   ---------- Footnotes ----------

   (1) これは、 ワードのコンパイル機能(compilation semantics)に依存しま
す。 ワードにデフォルトのコンパイル機能(compilation semantics)がある場合
、 xt は ‘compile,’ を表します。 それ以外の場合(たとえば、 即実行ワード
の場合)、 xt は ‘execute’ を表します


File: gforth.info,  Node: Compiling words,  Next: The Text Interpreter,  Prev: Tokens for Words,  Up: Words

6.13 Compiling words
====================

他のほとんどの言語とは異なり、 Forth にはコンパイルと実行時(run-time)の
間に厳密な境界がありません。 たとえば、 ワードの定義中(または ‘constant’
のようなワードの定義によって使用されるデータのための計算)に任意のコード
を実行できます。 さらに、 ‘immediate’ (*note Interpretation and
Compilation Semantics::) や ‘[’...‘]’  (下記参照)を使用すると、 コロン定
義のコンパイル中に任意のコードを実行できます(例外: ディクショナリ空間で
割り当てしてはいけません)。

* Menu:

* Literals::                 データ値をコンパイルします
* Macros::                   Compiling words


File: gforth.info,  Node: Literals,  Next: Macros,  Prev: Compiling words,  Up: Compiling words

6.13.1 Literals
---------------

最も単純で最も頻繁に使用される例は、 コンパイル中にリテラルを計算するこ
とです。 たとえば、 以下の定義は、 文字列の配列を 1 行に 1 つの文字列で
出力します:

     : .strings ( addr u -- ) \ gforth
         2* cells bounds U+DO
             cr i 2@ type
         2 cells +LOOP ;

   Gforth のような愚かで低能なコンパイラを使用すると、 ループ反復ごとに
‘2 cells’ が計算されます。 あなたは、 この値をコンパイル時に一度だけ計算
し、 定義にコンパイルできます。 以下のようにします:

     : .strings ( addr u -- ) \ gforth
         2* cells bounds U+DO
             cr i 2@ type
         [ 2 cells ] literal +LOOP ;

   ‘[’ は、 テキスト・インタープリタをインタプリタ状態に切り替えます(こ
の例を対話的に入力し、 ‘[’ と ‘]’ の間に改行を挿入すると、 ‘ok’ プロンプ
トが表示されます)。 ‘2 cells’ のインタプリタ機能(interpretation
semantics)を実行します。 ここでは数値を計算します。 ‘]’ は、 テキスト・
インタプリタをコンパイル状態に戻します。 次に、 この数値を現在のワードに
コンパイルする ‘Literal’ のコンパイル機能(compilation semantics)を実行し
ます。 ‘see .strings’ を使用してワードを逆コンパイルすると、 コンパイル
されたコードへの影響を確認できます。

   この方法で ‘2* cells’ を ‘[ 2 cells ] literal *’ に最適化することもで
きます。

‘[’ ( –  ) core “left-bracket”
   インタプリタ状態にします。 即実行ワードです。

‘]’ ( –  ) core “right-bracket”
   コンパイル状態にします。

‘Literal’ ( compilation n – ; run-time – n  ) core “Literal”
   コンパイル機能(compilation semantics): 実行機能(run-time semantics)を
コンパイルします。 実行機能(run-time semantics): n をスタックにプッシュ
します。 インタプリタ機能(interpretation semantics): 未定義です。

‘ALiteral’ ( compilation addr – ; run-time – addr  ) gforth-0.2 “ALiteral”
   ‘literal’ と同様に機能しますが、 (クロス・コンパイルされたコードで使
用される場合、)リテラルがアドレスであることをクロス・コンパイラーに伝え
ます。

‘]L’ ( compilation: n – ; run-time: – n  ) gforth-0.5 “]L”
   ‘] literal’ と同等。

   単一セル以外のデータ型をリテラルとしてコンパイルするためのワードもあ
ります:

‘2Literal’ ( compilation w1 w2 – ; run-time  – w1 w2  ) double “two-literal”
   実行時に w1 w2 がスタックに配置されるように、 適切なコードをコンパイ
ルします。 インタプリタ機能(interpretation semantics)は未定義です。

‘FLiteral’ ( compilation r – ; run-time – r  ) floating “f-literal”
   実行時に r が(浮動小数点)スタックに配置されるように、 適切なコードを
コンパイルします。 インタプリタ機能(interpretation semantics)は未定義で
す。

‘SLiteral’ ( Compilation c-addr1 u ; run-time – c-addr2 u  ) string “SLiteral”
   コンパイル時: c-addr1, u で指定された文字列を現在の定義にコンパイルし
ます。 実行時: 文字列のアドレスと長さを記述する c-addr2 u を返します。

   データ・スタック上のコロン定義の外側から内側にデータを渡したいと思う
かもしれません。 ‘:’ がコロン colon-sys をプッシュし、 colon-sys より下
のモノのにアクセスできなくなるため、 これは機能しません。 たとえば、 以
下は機能しません:

     5 : foo literal ; \ error: "unstructured"

   代わりに、 変数など、 他の方法で値を渡す必要があります:

     variable temp
     5 temp !
     : foo [ temp @ ] literal ;


File: gforth.info,  Node: Macros,  Prev: Literals,  Up: Compiling words

6.13.2 Macros
-------------

‘Literal’ とその仲間たちは、 データ値を現在の定義にコンパイルします。 他
のワードを現在の定義にコンパイルするワードを記述することもできます。 例
えば:

     : compile-+ ( -- ) \ compiled code: ( n1 n2 -- n )
       POSTPONE + ;

     : foo ( n1 n2 -- n )
       [ compile-+ ] ;
     1 2 foo .

   これは ‘: foo + ;’ と同等です(確認するには ‘see foo’ としてください
)。 この例では何が起こっているのでしょうか?  ‘Postpone’ は、 ‘+’ のコン
パイル機能(compilation semantics)を ‘compile-+’ にコンパイルします。 そ
の後、 テキスト・インタプリタは ‘compile-+’ を実行し、 + のコンパイル機
能(compilation semantics)を実行します。 これにより、‘+’ (の実行機能
(execution semantics)) が ‘foo’ にコンパイルされます(1)。

‘postpone’ ( "name" –  ) core “postpone”
   name の コンパイル機能(compilation semantics)をコンパイルする。

   ‘compile-+’ のようなコンパイル・ワード(compiling words)のコンパイルは
通常即実行ワード(または即実行同様)であるため、 それらを実行するためにイ
ンタプリタ状態に切り替える必要はありません。 最後の例をそれに応じて変更
すると、 以下のようになります:

     : [compile-+] ( compilation: --; interpretation: -- )
       \ compiled code: ( n1 n2 -- n )
       POSTPONE + ; immediate

     : foo ( n1 n2 -- n )
       [compile-+] ;
     1 2 foo .

   場合によっては、 複数のワードを POSTPONE する必要があることに気づくで
しょう。 このような各ワードの前に POSTPONE を置くのは面倒なので、 Gforth
ではより便利な構文 ‘]] ... [[’ を提供しています。 これにより、
‘[compile-+]’ を以下のように記述できるようになります:

     : [compile-+] ( compilation: --; interpretation: -- )
       ]] + [[ ; immediate

‘]]’ ( –  ) gforth-0.6 “right-bracket-bracket”
   postpone 状態に切り替え: すべてのワードと認識器(recognizers)は、 その
前に ‘postpone’ があるかのように処理されます。 ‘[[’ が認識されると、
postpone 状態は終了します。

   角括弧の珍しい方向はその機能を示しています。 ‘]’ が即時実行(インタプ
リタ状態)からコンパイルに切り替えるのと同じように、 ‘]]’ はコンパイルか
ら postpone 状態(つまり、 コンパイル機能のコンパイル)に切り替えます。 逆
に、 ‘[[’ は postpone 状態からコンパイル状態に切り替えます。 これは、 コ
ンパイル状態から即時実行(インタプリタ状態)に切り替える ‘[’ に似ています
。

   ‘]] ’...‘ [[’ の本当の利点は、 POSTPONE するワードがたくさんある場合
に明らかになります。 たとえば、 ワード ‘compile-map-array’ (*note
Advanced macros Tutorial::) は、 以下のようにさらに短く書くことができま
す:

     : compile-map-array ( compilation: xt -- ; run-time: ... addr u -- ... )
     \ at run-time, execute xt ( ... x -- ... ) for each element of the
     \ array beginning at addr and containing u elements
       {: xt: xt :}
       ]] cells over + swap ?do
         i @ xt 1 cells +loop [[ ;

     : sum-array ( addr u -- n )
       0 [ ' + compile-map-array ] ;

   ‘see sum-array’ すると、 以下のコードが表示されます:

     : sum-array
       #0 over + swap ?do
         i  + #8 +LOOP
     ;

   ‘]]’...‘[[’ に加えて、 この例では他の機能もいくつかお披露目しています
:

   • (‘xt:’ を指定する) defer フレーバーのローカル変数 ‘xt’ を使用してい
     ます。 ‘]]’...‘[[’ 内でローカル変数 xt に遭遇すると、 ローカル変数
     xt を ‘compile,’ します。

   • ‘]]’...‘[[’ 内でリテラル ‘1’ を使用します。 これにより、 ‘1’ が
     postpone (延期)されます。 つまり、 ‘compile-map-array’ の実行時にコ
     ンパイルされます。

   • ‘compile-map-array’ が実行されると、 ‘1 cells’ がコンパイルされ、
     Gforth の定数折りたたみによって ‘#8’ に最適化(optimize)されます。

   注意: ‘s\"’ などのワードのパースは postpone 指定時にはパースされない
ため、 ‘]]’...‘[[’ 内ではパースされないことに注意してください。 ‘s\"
mystring\n"’ の代わりに、 文字列認識器(string recognizer)を使用して、
‘]]’...‘[[’ 内で動作する ‘"mystring\n"’ で記述することができます。これは
‘]]’...‘[[’ 内で機能します。 同様に、 パース・ワード ‘[']’ についても、
‘`’ で始まる認識器(recognizer)表記で記述することができます。

   ただし、 あなたが ‘s\"’ を使用したい場合(または、 認識器
(recognizer)置換がないパース・ワードがある場合)、 以下のようにコンパイル
状態に切り替えることで実行できます:

     ]] ... [[ s\" mystring\n" ]] 2literal ... [[

   標準 Forth での ‘]]’ と、 その仲間の定義は、 ‘compat/macros.fs’ で提
供されます。

   即時コンパイル・ワード(immediate compiling words)は、 他の言語(特に
Lisp)のマクロに似ています。 C言語などのマクロとの重要な違いは以下のとお
りです:

   • マクロの定義と処理には、 別個の前処理用の言語や処理器ではなく、 同
     一の言語を使用します。

   • したがって、 Forth の全機能をマクロ定義で利用できます。 たとえば、
     任意の複雑な計算を実行したり、 条件付きまたはループで異なるコードを
     生成したりできます (例: *note Advanced macros Tutorial::)。 この能
     力は、 パーサ・ジェネレータや、 その他のコード生成ソフトウェアを作
     成するときに非常に役立ちます。

   • ‘postpone’ などを使用して定義されたマクロは、 文字列よりも高いレベ
     ルで言語を扱います。 名前との結び付け(name binding)はマクロ定義時に
     行われるため、 C言語のマクロで発生する可能性のある名前の衝突の落と
     し穴を回避できます。 もちろん、 Forth は自由主義の言語(liberal
     language)であり、 以下のようなテキスト解釈マクロ(text-interpreted
     macros)を使用して自分自身を攻撃することもできます

          : [compile-+] s" +" evaluate ; immediate

     マクロ使用時に名前を結びつける(bind)だけでなく、 ‘evaluate’ を使用
     すると、 あなたの定義は ‘state’-smart (*note state-smartness::) に
     なります。

   マクロで数値をワードにコンパイルすることが必要な場合があります。 これ
を行うためのワードは ‘literal’ ですが、 ‘postpone’ する必要があるため、
‘literal’ のコンパイル機能(compilation semantics)はマクロがコンパイルさ
れる時ではなくマクロの実行時に効果を発揮します:

     : [compile-5] ( -- ) \ compiled code: ( -- n )
       5 POSTPONE literal ; immediate

     : foo [compile-5] ;
     foo .

   マクロにパラメータを渡して、 マクロを現在の定義にコンパイルする必要が
ある場合があります。 パラメータが数値の場合は、 ‘postpone literal’ を使
用できます(他の値の場合も同様)。

   コンパイルされるワードを渡したい場合、 通常の方法は、実行トークンと
‘compile,’ を渡すことです:

     : twice1 ( xt -- ) \ compiled code: ... -- ...
       dup compile, compile, ;

     : 2+ ( n1 -- n2 )
       [ ' 1+ twice1 ] ;

‘compile,’ ( xt –  ) core-ext “compile-comma”
   xt で表される機能(semantics)を現在の定義に追加します。 結果のコード断
片が実行されると、 xt が ‘execute’ されたのと同一の振る舞いをします。

   Gforth で利用可能な代替方法では、 コンパイル機能をパラメータ
(compilation semantics)として渡すことができる、 コンパイル・トークンを使
用します(*note Compilation token::)。 以下は、 上記と同じ例にこの方法を
使ったものです:

     : twice ( ... ct -- ... ) \ compiled code: ... -- ...
       2dup 2>r execute 2r> execute ;

     : 2+ ( n1 -- n2 )
       [ comp' 1+ twice ] ;

   この例では、 ‘2>r’ と ‘2r>’ により、 実行(execute)されるコンパイル機
能(compilation semantics)がデータ・スタックに影響を与える場合でも、
‘twice’ が確実に機能するようにします(訳注: 2dup ( ct ct ) 2>r ( ct r:ct
) execute ( ??  r:ct ) 2r> ( ??  ct ) execute ( ???  )  。 最初の
execute でデータ・スタックのTOSがどうなろうとも、 2つ目の execute のため
に ct を tos に与えるため。 ct は 2セル単位なので、 2dupで複製、 2>r ...
2r> で ct を1つ退避となる)

   これらのワードを使用して完全な定義を定義することもできます。 これは、
‘does>’ を使用する代わりの方法を提供します(*note User-defined Defining
Words::)。 たとえば以下の代わりに

     : curry+ ( n1 "name" -- )
         CREATE ,
     DOES> ( n2 -- n1+n2 )
         @ + ;

   以下のように定義することができます

     : curry+ ( n1 "name" -- )
       \ name execution: ( n2 -- n1+n2 )
       >r : r> POSTPONE literal POSTPONE + POSTPONE ; ;

     -3 curry+ 3-
     see 3-

   n1 にアクセスするために ‘>r : r>’ というシーケンスが必要です。 なぜな
ら、 ‘:’ はデータ・スタックに colon-sys をプッシュし、 それより下にある
全てのモノにアクセスできなくなるためです。

   ワードを定義するこの方法は、 ‘does>’ を使用するよりも便利な場合もあれ
ば、 そうでない場合もあります(*note Advanced does> usage example::)。 こ
の方式の利点の 1 つは、 コンパイラは、 ‘literal’ でコンパイルされた値が
固定されているのに対して、 ‘create’ されたワードに関連付けられたデータは
変更可能なことを認識しているため、 より適切に最適化できることです。

‘[compile]’ ( compilation "name" – ; run-time ? – ?  ) core-ext “bracket-compile”
   古いワード(lLegacy word)です。 代わりに ‘postpone’ を使用してください
。 name がデフォルト以外のコンパイル機能(compilation semantics)を持つ場
合は、 ‘postpone’ と同様に機能します。 name がデフォルトのコンパイル機能
を持つ(つまり、 通常のワードである)場合、 ‘[compile] name’ をコンパイル
することは、 name をコンパイルすることと同じです(つまり、 この場合
‘[compile]’ は冗長です)。

   ---------- Footnotes ----------

   (1) 最近の RFI の回答では、 ワードのコンパイルはコンパイル状態でのみ
実行する必要があるとしているため、 この例はすべての標準システムで動作す
ることは保証されませんが、 ちゃんとした(decent)システムであれば動作しま
す


File: gforth.info,  Node: The Text Interpreter,  Next: The Input Stream,  Prev: Compiling words,  Up: Words

6.14 The Text Interpreter
=========================

テキスト・インタプリタ(text interpreter)は、 現在の入力デバイスからの入
力を処理する無限ループです。 インタプリタの実装上でコンパイルされた
Forth コードを実行する内部インタプリタ(inner interpreter)(*note
Engine::)とは対照的に、 これは外部インタプリタ(outer interpreter)とも呼
ばれます(1)。

   テキスト・インタプリタは、 インタプリタ状態(“interpret state”) と コ
ンパイル状態(“compile state”)の 2 つの状態のいずれかで動作します。 現在
の状態は、 それにふさわしい名前の変数である ‘state’ によって定義されます
。

   このセクションでは、 テキスト・インタプリタがインタプリタ状態にあると
きに、 ユーザー入力デバイス(キーボード)からの入力処理についてどのように
振る舞うかについて説明することから始めます。 これは Forth システムが動き
始めた時のモードです。

   テキスト・インタプリタは、 入力バッファー(“input buffer”)(2)と呼ばれ
るメモリ領域で動作します。 この領域には、 <RET> キーを押したときにキーボ
ードからの入力が保存され、 入力バッファーの先頭から開始して、 先頭の空白
文字達(デリミタ(“delimiters”)と呼ばれる)をスキップし、 空白文字、 または
バッファーの終わりに達するまで文字列(空白以外の文字のシーケンス)をパース
します。 文字列をパースした後、 以下の2つの試行を行います:

   • 定義のディクショナリ(“dictionary”)内でその文字列を検索します。 その
     文字列が見つかった場合、 その文字列は、 とある定義(“definition”)(ワ
     ード(“word”)とも呼ばれる)を指し示していて、 そして、 ディクショナリ
     検索機能は、 テキスト・インタプリタがそのワードのインタプリタ機能
     (“interpretation semantics”)を実行できるようにするための情報を返し
     ます。 ほとんどの場合、 これは、 単にそのワードが execute されるこ
     とを意味します。
   • 文字列がディクショナリに見つからない場合、 テキスト・インタプリタは
     *note Number Conversion:: で説明されているルールを使用して、 文字列
     を数値として処理しようと試みます。 文字列が現在の基数で有効な数値を
     表す場合、 その数値はパラメータ・スタック(整数の場合はデータ・スタ
     ック、 浮動小数点数の場合は浮動小数点スタック)にプッシュされます。

   上記両方の試行が失敗した場合、 テキスト・インタプリタは入力バッファー
の残りを破棄し、 そして、 エラー・メッセージを発行して、そして、 さらな
る入力を待ちます。 いずれかの試行が成功すると、 テキスト・インタプリタは
入力バッファー全体が処理されるまでパース処理を繰り返し、 全体が処理され
た時点でステータス・メッセージ “‘ ok’” を出力し、 そして、 さらなる入力
を待ちます。

   テキスト・インタプリタは、 ‘>IN’ (“to-in”(トゥーイン)と発音します)と
呼ばれる変数を更新することにより、 入力バッファー内の位置を追跡します。
‘>IN’ の値は 0 で始まり、 入力バッファーの先頭からのオフセットが 0 であ
ることを示します。 オフセット ‘>IN @’ から入力バッファーの末尾までの領域
は、 パース領域(“parse area”)と呼ばれます(3)。 以下の例は、 テキスト・イ
ンタプリタが入力バッファーをパースする際に ‘>IN’ がどのように変化するか
を示しています:

     : remaining source >in @ /string
       cr ." ->" type ." <-" ; immediate

     1 2 3 remaining + remaining .

     : foo 1 2 3 remaining swap remaining ;

これらの結果はそれぞれ以下のようになります:

     ->+ remaining .<-
     ->.<-5  ok

     ->swap remaining ;-<
     ->;<-  ok

   ‘>IN’ の値は、 テキスト・インタプリタによって実行される入力バッファー
内のワードによって変更することもできます。 これは、 ワードがテキスト・イ
ンタプリタをだまして、 入力バッファーの一節をスキップしたり(4)、 一節を
2 回パースしたりすることができることを意味します。 例:

     : lat ." <<foo>>" ;
     : flat ." <<bar>>" >IN DUP @ 3 - SWAP ! ;

‘flat’ が実行されると、 以下の出力が生成されます(5)(訳注:ユーザーが flat
と打ち込と、 入力バッファーには flat があり、 ワード flat の実行が初まっ
たときは >IN は flatの t の次を指している。 そこから 3 戻ると >IN が 指
すのは flat の l で、 そこからテキスト・インタプリタがパースを再開すると
、 テキスト・インタプリタに見えるのは lat である。 よって lat が実行され
て <<foo>> が出力される):

     <<bar>><<foo>>

   この手法を使用すると、 ワードのパースにおける相互運用性の問題
(interoperability problems)の一部を回避できます。 もちろん、 ワードのパ
ースは可能な限り避けた方が良いです。

テキスト・インタプリタの振る舞いに関する 2 つの重要な注意事項:

   • 入力バッファーからの追加の文字達をパースする前に、 各入力文字列の処
     理を完了させます。
   • 入力バッファーを読み取り専用領域(region)として扱います(そして、 コ
     ードも同様に読み取り専用でなければなりません)。

テキスト・インタプリタがコンパイル状態にある場合、 その振る舞いは以下の
ように変化します:

   • パースされた文字列がディクショナリ内で見つかった場合、 テキスト・イ
     ンタプリタはそのワードのコンパイル機能(“compilation semantics”)を実
     行します。 ほとんどの場合、これは単にそのワードの実行機能(execution
     semantics)が現在の定義に追加されることを意味します。
   • 数値が検出されると、 パラメータ・スタックにプッシュされるのではなく
     、 現在の定義に(リテラルとして)コンパイルされます。
   • エラーが発生した場合、 ‘state’ が変更され、 テキスト・インタプリタ
     はインタプリタ状態に戻ります。
   • キーボードから行が入力されるたびに、 Gforth は “ ‘ok’” ではなく “‘
     compiled’” を出力します。

   テキスト・インタプリタがキーボード以外の入力デバイスを使用している場
合、 その振る舞いは以下のように変化します:

   • パース領域が空の場合、 テキスト・インタプリタは入力ソースから入力バ
     ッファーを再充填(refill)しようと試みます。 入力ソースを使い尽くすと
     、 入力ソースは以前の入力ソースに戻ります。
   • パース領域が空になるたびに “‘ ok’” や “‘ compiled’” メッセージは出
     力されません。
   • エラーが発生した場合、 入力ソースはユーザー入力デバイスに戻されます
     。

   これについて詳しくは、 *note Input Sources:: をご覧ください。

‘>in’ ( – addr  ) core “to-in”
   ‘uvar’ 変数 – a-addr は、 入力バッファーの先頭からパース領域の先頭ま
での char オフセットを格納するセルへのアドレスです。

‘source’ ( – addr u  ) core “source”
   現在の入力バッファーのアドレス addr と長さ u を返します

‘tib’ ( – addr  ) core-ext-obsolescent “t-i-b”

‘#tib’ ( – addr  ) core-ext-obsolescent “number-t-i-b”
   ‘uvar’ 変数 – a-addr は、 端末の入力バッファー内の文字数を含むセルの
アドレスです。 OBSOLESCENT(時代遅れ): 代わりに ‘source’ を使ってください
。

‘interpret’ ( ... – ...  ) gforth-0.2 “interpret”

* Menu:

* Input Sources::
* Number Conversion::
* Interpret/Compile states::
* Interpreter Directives::
* Recognizers::
* Text Interpreter Hooks::

   ---------- Footnotes ----------

   (1) このセクションは *note Introducing the Text Interpreter:: の拡大
バージョンです

   (2) テキスト・インタプリタがキーボードからの入力を処理している時、 こ
のメモリ領域はターミナル入力バッファー(“terminal input buffer” (TIB))と
呼ばれ、 (既に廃止されていますが) ワード ‘TIB’ および ワード ‘#TIB’ によ
ってアドレス指定されます

   (3) 言い換えると、 テキスト・インタプリタは、 パース領域が空になるま
で、 パース領域からの文字列をパースすることによって、 入力バッファーの内
容を処理します

   (4) これがワードのパースの仕組みです

   (5) 研究課題: ‘3’ を ‘4’ に置き換えたらどうなるでしょうか？


File: gforth.info,  Node: Input Sources,  Next: Number Conversion,  Prev: The Text Interpreter,  Up: The Text Interpreter

6.14.1 Input Sources
--------------------

デフォルトでは、 テキスト・インタプリタは、 Forth の起動時にユーザー入力
デバイス(キーボード)からの入力を処理します。 テキスト・インタプリタは、
以下のいずれかの入力ソースからの入力を処理できます:

   • ユーザー入力デバイス – つまり、キーボード。
   • ファイル。 *note Forth source files:: で説明されているワードを使用
     。
   • ブロック。 *note Blocks:: で説明されているワードを使用。
   • テキスト文字列。 ‘evaluate’ 使用。

   プログラムは、 ‘source-id’ と ‘blk’ の値から現在の入力デバイスを識別
できます。

‘source-id’ ( – 0 | -1 | fileid  ) core-ext,file “source-i-d”
   戻り値: 0 (入力ソースはユーザー入力デバイス)または、 -1 (入力ソースは
‘evaluate’ によって処理されている文字列)または、 fileid (入力ソースは
fileid で指定されたファイル)です。

‘blk’ ( – addr  ) block “b-l-k”
   ‘uvar’ 変数 – このセルには現在のブロック番号(現在の入力ソースがブロッ
クでない場合は 0)が格納されています。

‘save-input’ ( – x1 .. xn n  ) core-ext “save-input”
   n 個のエントリ xn 〜 x1 は、 ‘restore-input’ で使用できるプラットフォ
ーム依存の方法で、 入力ソース仕様(input source specification)の現在の状
態を記述します。

‘restore-input’ ( x1 .. xn n – flag  ) core-ext “restore-input”
   入力ソース仕様(input source specification)を n 個のエントリ xn 〜 x1
で記述された状態に復元しようとします。 復元が失敗した場合は flag が true
になります。 新しい入力プログラムを使用した Gforth では、 再度 throw す
るために使用できるフラグがある場合にのみ失敗します。 異なるアクティブな
入力ストリーム間で保存および復元することも可能です。 注意: 入力ストリー
ムを閉じる場合は、 開いたときとは逆の順序で行う必要がありますが、 その間
はすべて許可されます。

‘evaluate’ ( ... addr u – ...  ) core,block “evaluate”
   現在の入力ソース仕様(input source specification)を保存します。 そして
、 ‘-1’ を ‘source-id’ に保存し、 かつ、 ‘0’ を ‘blk’ に保存します。 そ
れから、 ‘>IN’ を ‘0’ に設定し、 文字列 c-addr u を入力ソースおよび入力
バッファーにし、 通訳(interpret)します。 そしてパース領域が空になったら
、 入力ソース仕様を復元します。

‘query’ ( –  ) core-ext-obsolescent “query”
   ユーザー入力デバイスを入力ソースにします。 入力を端末入力バッファー
(Terminal Input Buffer)で受け取ります。 ‘>IN’ をゼロに設定します。
OBSOLESCENT(時代遅れ): 代わりに ‘accept’ を使ってください。


File: gforth.info,  Node: Number Conversion,  Next: Interpret/Compile states,  Prev: Input Sources,  Up: The Text Interpreter

6.14.2 Number Conversion
------------------------

テキスト・インタプリタが数値入力をどのように変換するかの概要は *note
Literals in source code:: にあります。 このセクションでは、 関連するいく
つかのワードについて説明します。

   デフォルトでは、 整数変換に使用される基数は変数 ‘base’ の内容によって
与えられます。 注意: 予期しない ‘base’ の値によって多くの混乱が生じる可
能性があることに注意してください。 ‘base’ を変更する場合、 必ず古い値を
保存し、 後で復元してください。 さらに良いのは、これを自動的に実行する
‘base-execute’ を使用することです。 一般に、 ‘base’ を 10 進数のままにし
、 一般的な 10 進数以外の基数については *note Literals in source code::
で説明されている接頭辞を使用することをお勧めします。

‘base-execute’ ( i*x xt u – j*x  ) gforth-0.7 “base-execute”
   ‘BASE’ の内容を u にして xt を実行し、 その後元の ‘BASE’ を復元します
。

‘base’ ( – a-addr  ) core “base”
   ‘User’ 変数 – a-addr は、 入出力時の数値変換にデフォルトで使用される
基数を格納するセルへのアドレスです。 ‘base’ に保存せず、 代わりに
‘base-execute’ を使用してください。

‘hex’ ( –  ) core-ext “hex”
   ‘base’ を &16 (16 進数) に設定します。 ‘hex’ を使用せず、 代わりに
‘base-execute’ を使用してください。

‘decimal’ ( –  ) core “decimal”
   ‘base’ を &10 (10 進数) に設定します。 ‘10 進数’ を使用せず、 代わり
に ‘base-execute’ を使用してください。

‘dpl’ ( – a-addr  ) gforth-0.2 “Decimal-PLace”
   ‘User’ 変数 – a-addr は、 最新の数値変換における小数点の位置を格納す
るセルのアドレスです。 -1 に初期化されます。 小数点を含まない数値を変換
すると、 ‘dpl’ は -1 になります。 ‘2.’ の変換後は 0 が保持されます。
234123.9 の変換後は 1 が保持されます。

数値変換は、 不注意な人にとっては多くの罠があります:

   • コード・シーケンス ‘base @ .’ を使用して現在の基数を測定することは
     できません。 これは現在の基数では常に 10 と表示されます。 代わりに
     、 ‘base @ dec.’ なととしてください。
   • ‘bin’ というワードがありますが、 これは基数を設定するものではありま
     せん(*note General files::)。
   • 標準 Forth では、 2倍長数値の ‘.’ が文字列の最後の文字である必要が
     あります。 Gforth では ‘.’ をどこにでも置くことができます。
   • 数値変換プロセスではオーバーフローはチェックされません。

   *note Line input and conversion:: で説明されているワードを使用して、
プログラムに数値を読み込むことができます。


File: gforth.info,  Node: Interpret/Compile states,  Next: Interpreter Directives,  Prev: Number Conversion,  Up: The Text Interpreter

6.14.3 Interpret/Compile states
-------------------------------

標準のプログラムでは ‘state’ を明示的に変更することは許可されていません
。 ただし、‘[’ と ‘]’ というワードを使用して、 ‘state’ を暗黙的に変更で
きます。 ‘[’ が実行されると、 ‘state’ がインタプリタ状態に切り替わり、 テ
キスト・インタプリタが通訳(interpret)を開始します。 ‘]’ が実行されると、
‘state’ がコンパイル状態に切り替わり、 テキスト・インタプリタはコンパイ
ルを開始します。 これらのワードの最も一般的な使用法は、コロン定義内でイ
ンタプリタ状態に切り替えたり、 元の状態に戻したりすることです。 この手法
は、 リテラルのコンパイル(*note Literals:: の例参照)または条件付きコンパ
イル(例: *note Interpreter Directives:: の例を参照)に使用できます。


File: gforth.info,  Node: Interpreter Directives,  Next: Recognizers,  Prev: Interpret/Compile states,  Up: The Text Interpreter

6.14.4 Interpreter Directives
-----------------------------

以下のワード群は通常、 インタプリタ状態で使用されます。 通常は、 ソース
・ファイルのどの部分がテキスト・インタプリタによって処理されるかを制御し
ます。 これらは、 標準 Forth のワードには少数しかありませんが、 Gforth で
は、 非即実行バージョンがコンパイル状態でのみ使用できるという事実を補う
ために、 豊富な即実行制御構造ワードのセットでこれらを補っています(*note
Control Structures::)。 一般的な使用法は以下のとおりです:

     [undefined] \G [if]
       : \G ... ; immediate
     [endif]

   これは、 システムが ‘\G’ を定義していない場合は、 幾つかの置き換えプ
ログラムをコンパイルします(機能が制限される可能性があります)。

‘[IF]’ ( flag –  ) tools-ext “bracket-if”
   flag が ‘TRUE’ の場合は何もしません(したがって、 後続のワードは通常ど
おり実行されます)。 flag が ‘FALSE’ の場合、 対になる ‘[ELSE]’ または
‘[THEN]’ がパースされて破棄されるまで、 ‘[IF]’..  ‘[ELSE]’..  ‘[THEN]’ や
‘[IF]’..  ‘[THEN]’ の入れ子になったモノを含むパース領域(入力バッファー
/パース領域 は、 必要に応じて ‘REFILL’ を使用して再充填します)からワード
をパースして破棄します。 即実行ワードです。

‘[ELSE]’ ( –  ) tools-ext “bracket-else”
   対になる ‘[THEN]’ がパースされて破棄されるまで、 ‘[IF]’..  ‘[ELSE]’..
‘[THEN]’ や ‘[IF]’..  ‘[THEN]’ の入れ子になったモノを含むパース領域(入力
バッファー/パース領域 は、 必要に応じて ‘REFILL’ を使用して再充填します
)からワードをパースして破棄します。 ‘FALSE’ の場合、‘[IF]’ は ‘[ELSE]’ を
解析して破棄し、後続のワードは通常どおり実行されたままになります。 即実
行ワードです。

‘[THEN]’ ( –  ) tools-ext “bracket-then”
   何もしない。 パースして破棄する他のワードのマーカーとして使用されます
。 即実行ワードです。

‘[ENDIF]’ ( –  ) gforth-0.2 “bracket-end-if”
   何もしません。 ‘[THEN]’ の同義語(synonym)です。

‘[defined]’ ( "<spaces>name" – flag  ) tools-ext “bracket-defined”
   現在の検索順序スタック(the search order)で名前が見つかった場合は true
を返します

‘[undefined]’ ( "<spaces>name" – flag  ) tools-ext “bracket-undefined”
   現在の検索順序スタック(the search order)で名前が見つかった場合は
false を返します

‘[IFDEF]’ ( "<spaces>name" –  ) gforth-0.2 “bracket-if-def”
   現在の検索順序スタック(the search order)で name が見つかった場合は、
‘TRUE’ フラグを伴った ‘[IF]’ のように振る舞いし、 そうでない場合は、
‘FALSE’ フラグを伴った ‘[IF]’ のように動作します。 即実行ワードです。

‘[IFUNDEF]’ ( "<spaces>name" –  ) gforth-0.2 “bracket-if-un-def”
   現在の検索順序スタック(the search order)で name が見つからない場合は
、 ‘TRUE’ フラグを伴った ‘[IF]’ のように動作し、 それ以外の場合は、
‘FALSE’ フラグを伴った ‘[IF]’ のように動作します。 即実行ワード。

‘[?DO]’ ( n-limit n-index –  ) gforth-0.2 “bracket-question-do”

‘[DO]’ ( n-limit n-index –  ) gforth-0.2 “bracket-do”

‘[LOOP]’ ( –  ) gforth-0.2 “bracket-loop”

‘[+LOOP]’ ( n –  ) gforth-0.2 “bracket-question-plus-loop”

‘[FOR]’ ( n –  ) gforth-0.2 “bracket-for”

‘[NEXT]’ ( n –  ) gforth-0.2 “bracket-next”

‘[I]’ ( run-time – n  ) gforth-0.2 “bracket-i”
   実行時、 ‘[I]’ はテキスト・インタプリタ時の ‘[do]’ の反復
(iteration)のループ・インデックスをプッシュします。 インタプリタ時にイン
デックスを処理したい場合は、 ‘[I]’ を対話的に通訳(interpret)するか、 ま
たは ‘INT-[I]’ を使用します。

‘INT-[I]’ ( – n  ) gforth-1.0 “int-bracket-i”
   テキスト・インタプリタ時に ‘[do]’ 反復のループ・インデックスをプッシ
ュします。

‘[BEGIN]’ ( –  ) gforth-0.2 “bracket-begin”

‘[UNTIL]’ ( flag –  ) gforth-0.2 “bracket-until”

‘[AGAIN]’ ( –  ) gforth-0.2 “bracket-again”

‘[WHILE]’ ( flag –  ) gforth-0.2 “bracket-while”

‘[REPEAT]’ ( –  ) gforth-0.2 “bracket-repeat”

   ‘#line’ を使用すると、 現在のソース行番号とソース・ファイルに関する
Gforth の認識を変更できます。 これは、 Forth ファイルが他のソース・コー
ド・ファイルから生成されており、 たとえば、 オリジナルのソース・コードを
参照するエラー・メッセージなどを取得したい場合に便利です。 その場合、
Forth コード・ジェネレーターは、 必要に応じて Forth コードに ‘#line’ 行
を挿入する必要があります。

‘#line’ ( "u" "["file"]" –  ) gforth-1.0 “#line”
   行番号を u に設定し、 (存在する場合)ファイル名を file に設定します。
行の残りの部分を消費します。


File: gforth.info,  Node: Recognizers,  Next: Text Interpreter Hooks,  Prev: Interpreter Directives,  Up: The Text Interpreter

6.14.5 Recognizers
------------------

テキスト・インタプリタはソース・コードを処理するときに、 コードを空白で
区切られた文字列に分割し、 認識器群(recognizers)の中からどれか1つの認識
器が文字列を識別(identify)(認識(recognize))するまで認識器群を呼び出して
、 それらをワードや数値などとして識別します。 その文字列が認識されない場
合、 テキスト・インタプリタはエラー(‘undefined word’)を報告します。

   認識器を取り扱う通常の方法は、 認識器の 1 つを識別(identify)するコー
ドを記述するだけです(*note Default Recognizers::)。 ただし、 それらを操
作したり(*note Dealing with existing Recognizers::)、 新しい認識器を定義
したりすることもできます(*note Defining Recognizers::)。

* Menu:

* Default Recognizers::
* Dealing with existing Recognizers::
* Defining Recognizers::


File: gforth.info,  Node: Default Recognizers,  Next: Dealing with existing Recognizers,  Prev: Recognizers,  Up: Recognizers

6.14.5.1 Default Recognizers
............................

標準の Forth テキスト・インタプリタは、 検索順序スタック(the search
order)内のワード(‘rec-nt’) と、 整数(‘rec-num’)と、 浮動小数点数
(‘rec-float’)を認識します。 デフォルトでは、 Gforth は 以下の構文も認識
します

   • 文字列 例: ‘"mystring"’ (‘rec-string’)

   • 混合数値(complex numbers) 例: ‘0e+1ei’ (‘rec-complex’)

   • value への格納または defered word の変更 例: ‘->myvalue’ (‘rec-to’)

   • ワードのインタプリタ機能(interpretation semantics)表す xt です。 例
     : ‘`dup’ (‘rec-tick’)

   • ワードの nt です。 例: ‘``mysynonym’ (‘rec-dtick’)

   • ワードのボディのアドレス 例: ‘<myarray+8>’ (‘rec-body’)

   • オペレーティング・システムの環境変数へのアクセス 例: ‘${HOME}’
     (‘rec-env’)

   • ボキャブラリ内のワード 例: ‘myvoc1:myvoc2:myword’ (‘rec-scope’)

   • 指定の認識器(recognizer)使用して何かを認識する(訳注: RECOGNIZER‘?’
     というプレフィックスが付いたワードは、 ‘rec-’RECOGNIZER によって処
     理され、 認識器の曖昧さを排除します。 例: ‘hex num?cafe num?add’
     rec-num としてのみパースさせる、 ‘float?1.’ rec-floatとしてパースさ
     せる)(‘rec-meta’)

   ‘locate’ (*note Locating source code definitions::) を使用して、 ソー
ス・コードの一片を、 どの認識器(recognizer)が認識するか調べられます。 例
:

     defer mydefer
     locate ->mydefer

   これは ‘rec-to’ が ‘->mydefer’ を認識したことを示すハズです。 ただし
、 認識器がディクショナリのワードを認識する場合(スコープ認識機能など)、
locate はそのワードを表示します。

   以下を使用すると、 使用されている認識器と認識器の順序を確認できます

‘.recognizers’ ( –  ) gforth-experimental “dot-recognizers”
   (.order とは異なり、)最初に検索された認識器を左端にして、 現在の認識
器の順序を出力します。 すべての認識器に共通のプレフィックスである ‘rec-’
の代わりに、 反転表示の ‘~’ が表示されます。

   通常、 認識器は、 他の認識器と同一の文字列との一致を避けるように設計
されています。 たとえば、‘rec-env’ (環境変数認識器)には、 ‘$ADD’ のよう
な入力文字列の数値認識器との競合を避けるために中かっこ(braces)が必要です
。 ただし、 このポリシーにはいくつかの例外があります:

   • ワード名には任意の名前を付けることができるため、 他の認識器と競合す
     る可能性があります(また、 検索順序スタック(the search order)は他の
     認識器よりも前に検索されます)。

     ただし、 名前は ‘0’ (ゼロ)で始まらない傾向がある(そして ‘0’ (ゼロ)
     で始まる場合は特殊文字が含まれる傾向がある)ため、 base が ‘hex’ の
     場合は、 数値を ‘0’ (ゼロ)で始めることをお勧めします。

     これまで私たちが見てきた幾多のコードでは、 ワードを ‘'’ (クォート。
     別名ティック)で始める方が、 ‘`’ (バック・クォート。別名バック・ティ
     ック) で始めるよりもはるかに一般的であるため、 xt と nt の認識器は
     ‘`’ (バック・クォート)を使用して競合を減らしてください。

   • 整数認識器 ‘rec-num’ と、 浮動小数点認識器 ‘rec-float’ は、 どちら
     も、 たとえば ‘1.’ を認識します。 しかし、 ‘rec-num’ が(デフォルト
     では)先にあるため、 ‘1.’ は2倍長セルの整数として認識されます。
     ‘rec-float’ を最初に使用するように認識順序を変更すると、 ‘1.’ は浮
     動小数点数として認識されますが、 標準 Forth で書かれたコードを読み
     込むと、 非標準的な振る舞いになる可能性があります。

     いずれの場合も、 以下のようにして、 あなた独自のコード内では、 この
     競合を回避することをお勧めします。 つまり、 常に数値プレフィックス
     を付けて2倍長セル整数を記述します(例: ‘#1.’)。 また、 浮動小数点数
     は常に ‘e’ を使用して記述します(例: ‘1e’)。

   • ‘->’ で始まるワードをいくつか見てきました。 ‘to myvalue’ または
     ‘to?->myvalue’ (訳注: rec-meta 構文で rec-to を指定の上で ->myvalue
     を評価)を使用すると競合を回避できます(後者は ‘postpone’ で機能しま
     す)。


File: gforth.info,  Node: Dealing with existing Recognizers,  Next: Defining Recognizers,  Prev: Default Recognizers,  Up: Recognizers

6.14.5.2 Dealing with existing Recognizers
..........................................

認識器(recognizer)は、 あなたが文字列を渡すワードです。 認識器が文字列を
認識すると、 通常はデータとそのデータを処理するためのワードの xt を返し
ます。 このワードはトランスレーター(translator)と呼ばれます。 認識器が文
字列を認識しない場合は、 ‘notfound’ の xt を返します。

   すべての認識器(recognizers)のスタック効果は ( c-addr u – ...  xt ) で
す。

   認識器は文字列を受け取り、 いくつかのデータと、 そのデータを通訳
(interpret)するためのトランスレーター(翻訳器)を返します。 Gforth はその
トランスレーターを xt として実装します(これを実行すると、 現在の state で
その文字列を処理する適切なアクションが実行されます)。 しかし、 他の
Forth システムでは、 内部に 3 つの xt を含む実際のテーブルとして実装する
可能性があります。 最初の xt は 通訳時(interpretation)/実行時(run-time)
xt で、 データのインタプリタ機能(interpretation semantics)を実行します
(通常はデータをスタックに置くだけです)。 2 番目の xt はコンパイル機能
(compilation semantics)を実行し、 データと実行時機能(run-time
semantics)の xt を取得します。 3 番目の xt は postpone 機能(postpone
semantics)を実行し、 データと実行時機能の xt も取得します。 ‘>postpone’
を使用すると、 実行時機能の xt を postpone できます。

   認識器群はスタックとして編成されるため、 ボキャブラリ・スタックと同じ
方法で認識器群のシーケンスを配置できます。 認識器スタックはそれ自体が認
識器群です。 つまり、 認識器スタックは実行可能であり、 文字列を受け取り
、 トランスレーターを返します。

‘notfound’ ( state –  ) gforth-experimental “notfound”
   認識器の認識が失敗すると、 ‘notfound’ の認識器トークン(訳注: 現状では
‘notfound’ の xt )を返します

‘rec-nt’ ( addr u – nt translate-nt | notfound  ) gforth-experimental “rec-nt”
   名前トークンを認識します

‘rec-num’ ( addr u – n/d table | notfound  ) gforth-experimental “rec-num”
   数値を 1倍長/2倍長 整数に変換します

‘rec-float’ ( addr u – r translate-float | notfound  ) gforth-experimental “rec-float”
   浮動小数点数を認識します

‘rec-string’ ( addr u – addr u’ r:string | rectype-null  ) gforth-experimental “rec-string”
   二重引用符(double quotes)で囲まれた文字列(strings)を文字列リテラルに
変換します。 エスケープは ‘S\"’ と同様に扱われます。

‘rec-to’ ( addr u – xt n r:to | rectype-null  ) gforth-experimental “rec-to”
   ‘->’ で始まるワードは、 ‘TO’ が前にあるものとして扱い、 ‘+>’ で始まる
ワードは ‘+TO’ が前にあるものとして扱い、 ‘'>’ で始まるワードは ‘ADDR’ が
前にあるものとして扱い、 ‘@>’ で始まるワードは ‘ACTION-OF’ が前にあるも
のとして扱い、 ‘=>’ で始まるワードは ‘IS’ が前にあるものとして扱います。

‘rec-tick’ ( addr u – xt rectype-num | rectype-null  ) gforth-experimental “rec-tick”
   ‘`’ (バッククォート)の接頭辞が付いたワードはその xt を返します。 例:
‘`dup’ は dup の xt を返します

‘rec-dtick’ ( addr u – nt rectype-num | rectype-null  ) gforth-experimental “rec-dtick”
   ‘``’ (バッククォート2つ)で始まるワードは、 その nt を返します。 例:
‘``S"’ は ‘S"’ の nt を返します。

‘rec-body’ ( addr u – xt translate-tick | translate-null  ) gforth-experimental “rec-body”
   ‘'<'’ ‘'>'’ で囲まれたワードはその本体(body)を返します。 例: ‘<dup>’
は dup の本体(body)を返します

‘get-recognizers’ ( – xt1 .. xtn n  ) gforth-experimental “get-recognizers”
   認識器スタックの内容(content)をスタックにプッシュします。 n は xt の
個数です。

‘set-recognizers’ ( xt1 .. xtn n –  ) gforth-experimental “set-recognizers”
   スタック上の内容(content)を認識器スタックに設定します。 n は xt の個
数です。

‘recognize’ ( addr u rec-addr – ... rectype  ) gforth-experimental “recognize”
   訳注: 認識器スタック rec-addr の認識器を順に文字列 addr u に適用し、
認識したら、 そのトランスレーター rectype (の xt ) を得ます。 何も適用で
きなかった場合はトランスレーター ‘notfound’ (の xt )を返します

‘recognizer-sequence:’ ( xt1 .. xtn n "name" –  ) gforth-experimental “recognizer-sequence:”
   訳注: xt1 ..  xtn n という内容で "name" という名前の認識器スタックを
作成します。

‘forth-recognize’ ( c-addr u – ... translate-xt  ) recognizer “forth-recognize”
   システム認識器スタックです。

‘forth-recognizer’ ( – xt  ) gforth-experimental “forth-recognizer”
   Matthias Trute recognizer API との下位互換性があります。 この構造は、
defer されたワードを value のようなワードに変換します。

‘set-forth-recognize’ ( xt –  ) recognizer “set-forth-recognize”
   システム認識器スタックを変更する

‘translate:’ ( int-xt comp-xt post-xt "name" –  ) gforth-experimental “translate:”
   name という名前のトランスレーター(トランスレーター・テーブル)を作成し
、 トランスレーターのインタプリンタ機能アクション int-xt と、 トランスレ
ーターのコンパイル機能アクション comp-xt と、 トランスレーターの
postpone 機能アクション post-xt を格納します。 加えて拡張機能
(extensions)用に 7 つのスロットを用意します(拡張機能スロット初期値は
no.extensions の xt で埋めます)。 実行時: name の 実行時は state の値に
応じてアクションが実行されます。 state が 0 (インタプリンタ状態)ならばイ
ンタプリンタ機能アクションを実行し、 stete が -1 (コンパイル状態) ならば
コンパイル機能アクションを実行し、 state が -2 (通常無い値。このために特
別にセットする。アクション実行後は以前の値復元の事) ならばpostpone 機能
アクションを実行します。

‘translate-nt’ ( i*x nt – j*x  ) gforth-experimental “translate-nt”
   名前トークンのトランスレーター

‘translate-num’ ( x – | x  ) gforth-experimental “translate-num”
   数値のトランスレーター

‘translate-dnum’ ( dx – | dx  ) gforth-experimental “translate-dnum”
   2倍長整数のトランスレーター

   doc-translate-float(訳注: まだ説明書いて無いっぽい)
‘try-recognize’ ( addr u xt – results | false  ) gforth-experimental “try-recognize”
   入れ子(nested)になった認識器(recognizers)用です: ADDR U の認識を試み
、 XT を実行して結果が望ましいかどうかを確認します。 XT が false を返し
た場合は、 認識器の副作用をすべてクリーンアップして false を返します。 そ
れ以外の場合は、 XT 呼び出しの結果をスタックに返し、 そのTOSはゼロ以外で
なければなりません。

‘>interpret’ ( translator –  ) gforth-experimental “>interpret”
   指定のトランスレーターのインタプリンタ機能アクションを実行します。

‘>compile’ ( translator –  ) gforth-experimental “>compile”
   指定のトランスレーターのコンパイル機能アクションを実行します。

‘>postpone’ ( translator –  ) gforth-experimental “>postpone”
   指定のトランスレーターの postpone 機能アクションを実行します

‘translate-method:’ ( "name" –  ) gforth-experimental “translate-method:”
   新しいトランスレーター・メソッドを作成し、 トランスレーター・テーブル
を拡張します。 XT RECTYPE ‘to’ TRANSLATOR を使用して、 xt を既存の
rectypeに割り当てることができます(訳注: ‘>interpret’ や ‘>compile’ や
‘>postpone’ 定義用。 あなたが更に トランスレーター・メソッドを定義した場
合はこれ以降の新規 state 値に対するアクションとなる。 現時点で 7 つまで
追加可能)

‘translate-state’ ( xt –  ) gforth-experimental “translate-state”
   XT として渡された translate-method に一致するトランスレーターのアクシ
ョンを実行するように、 システムの現在の state を変更します。


File: gforth.info,  Node: Defining Recognizers,  Prev: Dealing with existing Recognizers,  Up: Recognizers

6.14.5.3 Defining Recognizers
.............................

doc-defining-recognizers(訳注: まだ説明書けて無いっぽい)


File: gforth.info,  Node: Text Interpreter Hooks,  Prev: Recognizers,  Up: The Text Interpreter

6.14.6 Text Interpreter Hooks
-----------------------------

‘before-line’ ( –  ) gforth-1.0 “before-line”
   テキスト・インタプリタが次の行をパースする前に呼び出される defer され
たワード(訳注: 初期値 ‘noop’ 。 ‘interpret’ 実行開始時にも呼び出される)

‘before-word’ ( –  ) gforth-0.7 “before-word”
   テキスト・インタプリタが次のワードをパースする前に呼び出される deferd
されたワード(訳注: 初期値 ‘noop’)

‘line-end-hook’ ( –  ) gforth-0.7 “line-end-hook”
   ファイルからテキスト通訳(text-interpreting)するときに行末ごとに呼び出
される defer されたワード(訳注: 初期値 ‘noop’ )


File: gforth.info,  Node: The Input Stream,  Next: Word Lists,  Prev: The Text Interpreter,  Up: Words

6.15 The Input Stream
=====================

テキスト・インタプリタは、 複数のソース(*note Input Sources::)が利用可能
な入力ストリームから読み取ります。 いくつかのワード、特に定義ワードや
‘'’ のようなワードは、 スタックからではなく入力ストリームからパラメータ
を読み込みます。

   このようなワードは入力ストリームをパース(parse)するため、 パース・ワ
ードと呼ばれます。 パース・ワードの使用は困難です。 なぜならプログラムで
生成されたパラメーターを入力ストリームを通じて渡すのが難しいからです。 ま
た、 素朴な実装をすると、 インタプリタ機能(interpretation semantics)とコ
ンパイル機能(compilation semantics)の組み合わせが直感的でないことが多く
、 より直感的な振る舞いを実現しようとする様々なアプローチが生まれていま
す(*note Combined words::)。

   ワードをパースするのは悪い考えであることは、 最早明らかです。 あなた
が、 利便性のためにパース・ワードを実装したいなら、 非パースのバリエーシ
ョン、 つまり、 パースを行わずスタック上のパラメータを受け取るワードも提
供してください。 もし、 その上でパース・ワードを実装するなら、 以下のワ
ード群を使用できます:

‘parse’ ( xchar "ccc<xchar>" – c-addr u  ) core-ext,xchar-ext “parse”
   パース領域で xchar で区切られた ccc をパースします。 c-addr u は、 パ
ース領域内でパースされた文字列を指します。 パース領域が空の場合、 u は 0
です(訳注: ‘bl parse ccc type ccc ok’ 。 直後でENTERキーを押して行を終了
すると(‘parse’ ENTER)、 長さ0の文字列をスタックに積む)

‘string-parse’ ( c-addr1 u1 "ccc<string>" – c-addr2 u2  ) gforth-1.0 “string-parse”
   文字列 c-addr1 u1 で区切られた ccc をパース領域でパースします。
c-addr2 u2 は、 パース領域内のパースされた文字列を指します。 パース領域
が空の場合、 u2 は 0 です(訳注: ‘" " string-parse ccc type ccc ok’)

‘parse-name’ ( "name" – c-addr u  ) core-ext “parse-name”
   入力バッファーから次の単語(word)を取得します(訳注: ‘parse-name ccc
type ccc ok’)

‘parse-word’ ( – c-addr u  ) gforth-obsolete “parse-word”
   ‘parse-name’ の古い名前。 このワード語は、他の一部のシステムでは矛盾
する振る舞いをします。

‘name’ ( – c-addr u  ) gforth-obsolete “name”
   ‘parse-name’ の古い名前

‘word’ ( char "<chars>ccc<char>– c-addr  ) core “word”
   先頭の区切り文字をスキップします。 パース領域で char で区切られた ccc
をパースします。 c-addr は、 カウンタ付き文字列形式で、 パースされた文字
列を格納する一時領域のアドレスです。 パース領域が空であるか、 区切り文字
以外の文字が含まれてい無い場合、 結果の文字列の長さはゼロになります。 プ
ログラムは、 カウンタ付き文字列内の文字を置き換える場合があります。
OBSOLESCENT(時代遅れ): カウンタ付き文字列の末尾に、 その長さに含まれない
スペースがあります。

‘refill’ ( – flag  ) core-ext,block-ext,file-ext “refill”
   入力ソースにより入力バッファーを満たすことを試みます。 入力ソースがユ
ーザー入力デバイスの場合、 端末入力デバイスからの入力の受け取りを試みま
す。 成功した場合は、 結果を入力バッファーにし、 ‘>IN’ を 0 に設定して
true を返します。 それ以外の場合は false を返します。 入力ソースがブロッ
クの場合、 ‘BLK’ の値に 1 を加算して、 次のブロックを入力ソースかつ現在
の入力バッファーにし、 ‘>IN’ を 0 に設定します。 ‘BLK’ の新しい値が有効
なブロック番号の場合は true を返し、 それ以外の場合は false を返します。
入力ソースがテキスト・ファイルの場合、 ファイルから次の行を読み取ろうと
試みます。 成功した場合は、 結果を現在の入力バッファーにし、 ‘>IN’ を 0
に設定して true を返します。 それ以外の場合は false を返します。 いずれ
の場合も、 成功した結果には、0 文字を含む行の受け取りが含まれます。

   非パースなバリエーションが無いパース・ワードを取り扱う必要がある場合
、 ‘execute-parsing’ を使用して(スタック経由で)文字列を渡すことができま
す:

‘execute-parsing’ ( ... addr u xt – ...  ) gforth-0.6 “execute-parsing”
   addr u を現在の入力ソースにして xt ‘( ... -- ... )’ を実行してから、
以前の入力ソースを復元します。

   Example:

     5 s" foo" ' constant execute-parsing
     \ これは、以下と同等です
     5 constant foo

   標準 Forth でのこのワードの定義は ‘compat/execute-parsing.fs’ で提供
されます。

   ファイルに対してワードのパースを実行したい場合は、 以下のワードが役に
立ちます:

‘execute-parsing-file’ ( i*x fileid xt – j*x  ) gforth-0.6 “execute-parsing-file”
   fileid を現在の入力ソースにして、 xt ‘( i*x -- j*x )’ を実行してから
、 以前の入力ソースを復元します。


File: gforth.info,  Node: Word Lists,  Next: Environmental Queries,  Prev: The Input Stream,  Up: Words

6.16 Word Lists
===============

ワードリスト(wordlist)は名前付きワードのリストです。 新しいワードを追加
したり、 ワードを名前で探したりできます(マーカー(markers)を使用して制限
された方法でワードを削除することもできます)。 全ての名前付き(および
‘reveal’ された)ワードは 1 つのワードリスト内にあります。

   テキスト・インタプリタは、 検索順序スタック(the search order;ワードリ
ストのスタック)に存在するワードリストをTOSから下へ検索します。 各ワード
リスト内では、 概念的には最新のワードから検索が開始されます。 つまり、 ワ
ードリスト内に同一の名前の 2 つのワードがある場合、 新しいワードが検索に
ヒットします。

   新しいワードは「コンパイル・ワードリスト」(“compilation wordlist”)(現
在のワードリスト(current wordlist)とも呼ばれます)に追加されます。

   ファイルがファイル・ハンドルによって識別されるのとほぼ同じ方法で、 ワ
ードリストはセル・サイズのワードリスト識別子(word list identifier; wid)に
よって識別されます。 wid の数値には(移植可能な)意味はなく、 セッションご
とに変わる可能性があります。

   標準 Forth の “Search order” ワード・セットは、 さまざまな異なるスキ
ームの実装を可能にする低レベル・ツールのセットを提供することを目的として
います。 Gforth は、 伝統的な Forth ワードである ‘vocabulary’ も提供しま
す。 ‘compat/vocabulary.fs’ は、 標準 Forth での実装を提供します。

‘forth-wordlist’ ( – wid  ) search “forth-wordlist”
   定数(‘Constant’) – wid は、Gforth が提供するすべての標準のワードを含
むワードリストを識別します。 Gforth が呼び出されると、 このワードリスト
がコンパイル・ワードリストとなり、 検索順序スタック(the search order)の
TOSになります。

‘definitions’ ( –  ) search “definitions”
   現在検索順序スタック(the search order)のTOSにあるワードリストをコンパ
イル・ワードリストにします(訳注: : ‘definitions context  current ! ;’ )

‘get-current’ ( – wid  ) search “get-current”
   wid は、 現在のコンパイル・ワードリストのワードリスト識別子です。

‘set-current’ ( wid –  ) search “set-current”
   wid で識別されるワードリストをコンパイル・ワードリストに設定します。

‘get-order’ ( – widn .. wid1 n  ) search “get-order”
   検索順序スタック(the search order)の内容をデータ・スタックにコピーし
ます。 現在の検索順序スタックには n 個のエントリがあり、 そのうち wid1 は
最初に検索されるワードリスト(検索順序スタックのTOSにあるワードリスト) を
表し、 widn は最後に検索されるワードリストを表します。

‘set-order’ ( widn .. wid1 n –  ) search “set-order”
   N=0 の場合、 検索順序スタック(the search order)を空(empty)にします。
N=-1 の場合、 検索順序スタックを実装定義で最小化します (Gforth の場合、
これはワードリスト ‘Root’ です)。 それ以外の場合は、 N 個の wid エントリ
を持ち、 WID1 が最初に検索されるワードリストを表し、 WIDN が最後に検索さ
れるワードリストを表すように、 既存の検索順序スタックを置き換えます。

‘wordlist’ ( – wid  ) search “wordlist”
   wid で表される新しい空(empty)のワードリストを作成します。

‘table’ ( – wid  ) gforth-0.2 “table”
   検索テーブル(lookup table)を作成します(英大文字と小文字を区別し、 警
告なし)。

‘cs-wordlist’ ( – wid  ) gforth-1.0 “cs-wordlist”
   英大文字小文字を区別するワードリストを作成する。

‘cs-vocabulary’ ( "name" –  ) gforth-1.0 “cs-vocabulary”
   英大文字小文字を区別するボキャブラリを作成する

‘>order’ ( wid –  ) gforth-0.5 “to-order”
   検索順序スタック(the search order)というワードリストのスタックにワー
ドリスト WID をプッシュする(訳注: WID が 検索順序スタックの TOS になる
)。

‘previous’ ( –  ) search-ext “previous”
   検索順序スタック(the search order)というワードリスト・スタックのTOSを
捨てる

‘also’ ( –  ) search-ext “also”
   検索順序スタック(the search order)でTOSを ‘DUP’ するかのように振る舞
います(訳注: ‘: also context  >order ;’)。 通常はボキャブラリの前で使い
ます(例えば ‘also Forth’)。 これにより、 ボキャブラリによって表されるワ
ードリストが検索順序スタックへプッシュされるという複合的な効果が得られま
す(訳注:検索順序スタックのTOSを指定のボキャブラリで置き換えるのではなく
て、 検索順序スタックのTOSにさらにプッシュする形にして、 ボキャブラリの
次が以前の検索順序スタックのTOSになるようにする)

‘Forth’ ( –  ) search-ext “Forth”
   検索順序スタック(the search order)の先頭にある wid を、 ワードリスト
‘forth-wordlist’ に関連付けられた wid に置き換えます。

‘Only’ ( –  ) search-ext “Only”
   検索順序スタック(the search order)を実装定義で最小化します(Gforth の
場合、 これはワードリスト ‘Root’ です)。

‘order’ ( –  ) search-ext “order”
   検索順序スタック(the search order)とコンパイル・ワードリストを出力し
ます。 検索順序スタックのワードリストは検索される順序で出力されます(従来
のスタック表示方法とは逆になります)。 続けて、 コンパイル・ワードリスト
が最後に表示されます。

‘.voc’ ( wid –  ) gforth-0.2 “dot-voc”
   WID で表されるワードリストの名前を出力します。 ‘vocabulary’ または
‘wordlist constant’ で定義された名前のみ出力できます。 それ以外の場合は
アドレスを出力します。

‘find’ ( c-addr – xt +-1 | c-addr 0  ) core,search “find”
   カウンタ付き文字列 c-addr によって指定された定義の名前を現在の検索順
序スタック(the search order)内の全てのワードリストで検索します。 定義が
見つからない場合、 0 を返します。 定義が見つかった場合は、 1 (定義にデフ
ォルト以外のコンパイル機能(compilation semantics)ある場合)または、 -1 (定
義にデフォルトのコンパイル機能(compilation semantics)がある場合)を返しま
す。 インタプリタ状態で返される xt はインタプリタ機能(interpretation
semantics)を表します。 コンパイル状態で返される xt は、 コンパイル機能
(デフォルト以外のコンパイル機能の場合)を表すか、または、 コンパイル機能
が ‘compile,’ (デフォルトのコンパイル機能の場合)となる実行時機能
(run-time semantics)を表します。 ANS Forth 標準では、 返される xt が何を
表すかを明確に規定していない(または、 デフォルト以外のコンパイル機能では
なく即実行性についても言及している)ため、 このワードは移植可能なプログラ
ムでは問題があります。 移植性がなくても問題ない場合には、 ‘find-name’ と
その友達の方が優れています(*note Name token::)。

‘search-wordlist’ ( c-addr count wid – 0 | xt +-1  ) search “search-wordlist”
   wid で識別されるワードリスト内で、 c-addr count の文字列で指定された
定義を検索します。 定義が見つからない場合は 0 を返します。 定義が見つか
った場合は、 xt とともに 1 (定義が即実行である場合)または、 -1 (定義が即
実行でない場合)を返します。 Gforth では、返される xt はインタプリタ機能
(interpretation semantics)を表します。 ANS Forth では、 xt が何を表すか
明確に規定していません。

‘words’ ( –  ) tools “words”
   検索順序スタック(the search order)の先頭にあるワードリスト内のすべて
の定義のリストを表示します。

‘vlist’ ( –  ) gforth-0.2 “vlist”
   ‘WORDS’ の古い(Forth-83 より前の)名前。

‘wordlist-words’ ( wid –  ) gforth-0.6 “wordlist-words”
   ワードリスト wid の内容を表示します(訳注: ワードリストに含まれている
ワードをリストする)。

‘mwords’ ( ["pattern"] –  ) gforth-1.0 “mwords”
   オプションのパラメータ PATTERN にマッチするすべてのワードをリストしま
す。 指定しない場合合、 すべてのワードが一致します。 ワードは古い方から
新しい方へとリストされます。 ‘search’ のようなパターン・マッチ(デフォル
ト)ですが、 ‘' mword-filename-match is mword-match’ を使用してワイルドカ
ード(globbing)に切り替えることができます(訳注: ‘mwords’ ENTER で全部リス
ト、 ‘mwords value’ で value を含む名前をリスト)。

‘Root’ ( –  ) gforth-0.2 “Root”
   root ワードリストを検索順序スタック(the search order)に追加します。 こ
のボキャブラリは最小の検索順序を構成し、 search-order のワードのみが含ま
れます。

‘Vocabulary’ ( "name" –  ) gforth-0.2 “Vocabulary”
   "name" の定義を作成し、 それに新しいワードリストを関連付けます。
"name" の実行時の効果は、 検索順序スタック(the search order)のTOSにある
wid を、 "name" に関連付けられた wid に置き換えることです。

‘seal’ ( –  ) gforth-0.2 “seal”
   現在検索順序スタック(the search order)のTOSにあるワードリスト以外のす
べてのワードリストを検索順序スタックから削除します。

‘vocs’ ( –  ) gforth-0.2 “vocs”
   システムで定義されているボキャブラリとワードリストをリストします。

‘current’ ( – addr  ) gforth-0.2 “current”
   変数(‘Variable’) – コンパイル・ワードリストの wid を保持。

‘context’ ( – addr  ) gforth-0.2 “context”
   ‘context’ ‘@’ すると、 検索順序スタック(the search order)のTOSにある
ワードリストの wid が得られます。

‘map-vocs’ ( ... xt – ...  ) gforth-1.0 “map-vocs”
   システム内のすべてのワードリスト(テーブルと cs-wordlist を含む)に対し
て xt ( ...  wid – ...)  を実行します。

* Menu:

* Vocabularies::
* Why use word lists?::
* Word list example::


File: gforth.info,  Node: Vocabularies,  Next: Why use word lists?,  Prev: Word Lists,  Up: Word Lists

6.16.1 Vocabularies
-------------------

以下は、 標準の Forth ワード群を使用して新しいワードリストを作成および使
用する例です:

     wordlist constant my-new-words-wordlist
     : my-new-words get-order nip my-new-words-wordlist swap set-order ;

     \ add it to the search order
     also my-new-words

     \ alternatively, add it to the search order and make it
     \ the compilation word list
     also my-new-words definitions
     \ type "order" to see the problem

   この例での問題は、 ‘order’ には ‘my-new-words’ という名前をワードリス
ト の wid に関連付ける方法がないことです(Gforth では、 ‘order’ と ‘vocs’
において、 名前が関連付けられていない wid では wid そのものが表示されま
す)。 名前を wid に関連付ける標準の方法はありません。

   Gforth では、 この例は、 以下のように、 名前を wid に関連付ける
‘vocabulary’ を使用して再コーディングできます:

     vocabulary my-new-words

     \ add it to the search order
     also my-new-words

     \ alternatively, add it to the search order and make it
     \ the compilation word list
     my-new-words definitions
     \ type "order" to see that the problem is solved


File: gforth.info,  Node: Why use word lists?,  Next: Word list example,  Prev: Vocabularies,  Up: Word Lists

6.16.2 Why use word lists?
--------------------------

人々がワードリストを使用する理由は以下のとおりです:

   • 一連のワードが、 それらが有効なコンテキスト外で使用されるのを防ぐた
     め。 この典型的な 2 つの例が、 統合エディター(すべての編集コマンド
     は別個のワードリストで定義されます。 エディターの起動時に検索順序ス
     タック(the search order)がエディターのワードリストに設定されます。
     エディターが終了すると古い検索順序スタックが復元されます)。 )と、 統
     合されたアセンブラ(マシンのオペコードは、‘CODE’ ワードが定義される
     ときに使用される別のワードリストで定義されます)。

   • アプリケーションまたはライブラリのワードを、 ユーザーに表示される組
     (‘forth-wordlist’ または、 他の一般的なワードリスト内)と、 実装のた
     めだけに使用されるヘルパー・ワードの組(別のワードリストに隠されてい
     る)に編成します。 これにより、 ‘words’ の出力が少なくなり、 実装と
     インターフェイスが分離され、 共通のワードリスト内で名前が競合する可
     能性が減ります。

   • 同じ名前を持つ複数の定義間の名前空間の衝突を防ぐため。 たとえば、 ク
     ロス・コンパイラを構築する場合、 ターゲット・システムの条件付きコー
     ドを生成するワード ‘IF’ が存在する場合があります。 この定義を別のワ
     ードリストに配置すると、 検索順序スタック上のワードリストの順序を制
     御することで、 ホスト・システムの ‘IF’ またはターゲット・システムの
     ‘IF’ を特定の文脈で使用するかどうかを制御できます。

   ワードリストを使用する場合の欠点は以下のとおりです:

   • デバッグがさらに面倒になります。

   • ワードリストを使用して回避された名前の競合は依然として存在しており
     、 望ましい結果を得るには検索順序を慎重に調整する必要があります。 こ
     れを怠ると、 見つけにくいエラーが発生します(コンパイラとは異なる方
     法でコードを読み取る場合と同様に、 ‘see’ は、 そのような場合に、 名
     前がいくつかの考えられるワードのうちのどれに解決(resolve)されるかを
     確認するのに役立ちます）。 ‘see’ はワードの名前だけを表示し、 ワー
     ドがどのワードリストに属しているかを表示しないため、 誤解を招く可能
     性があります。 一意の名前を使用することは、 名前の競合を避けるため
     のより良いアプローチです。

   • あなたは、 検索順序スタック(the search order)の変更を明示的に元に戻
     す必要があります。 多くの場合、 これは暗黙的に行われた方が便利です
     。 Gforth は現在そのような機能を提供していませんが、 将来的には提供
     される可能性があります。


File: gforth.info,  Node: Word list example,  Prev: Why use word lists?,  Up: Word Lists

6.16.3 Word list example
------------------------

以下の例は garbage collector
(https://www.complang.tuwien.ac.at/forth/garbage-collection.zip) からの
もので、 ワードリストを使用してパブリック・ワードとヘルパー・ワードを分
離しています:

     get-current ( wid )
     vocabulary garbage-collector also garbage-collector definitions
     ... \ define helper words
     ( wid ) set-current \ restore original (i.e., public) compilation wordlist
     ... \ define the public (i.e., API) words
         \ they can refer to the helper words
     previous \ restore original search order (helper words become invisible)


File: gforth.info,  Node: Environmental Queries,  Next: Files,  Prev: Word Lists,  Up: Words

6.17 Environmental Queries
==========================

Forth-94 は、システム上で実行されているプログラムがシステムの特定の特性
を判断する方法として「環境問い合わせ」(“environmental query”)という概念
を導入しました。 標準では、 システムが認識できるたくさんの文字列と、 そ
れらを問い合わせする方法が指定されています。

‘environment?’ ( c-addr u – false / ... true  ) core “environment-query”
   文字列 c-addr, u を指定します。 文字列が認識されない場合は、 ‘false’
フラグを返します。 それ以外の場合は、‘true’ フラグと、 問い合わせした文
字列に関する(それ固有の)情報を返します。

   注意: 例えば ‘ADDRESS-UNIT-BITS’ のドキュメントではスタック上に 1 つ
のセルを返すことが示されていますが、 ‘environment?’ を使用して問い合わせ
すると、 文字列が認識されたことを示す ‘true’ フラグという追加の項目が返
されることに注意してください。 ‘ADDRESS-UNIT-BITS’ を問い合わせた場合、
‘environment?’ のスタック効果は ‘( c-addr u -- n true )’ です。

   いくつかの環境問い合わせ(environmental query)はシステムの制限を取り扱
います:

‘ADDRESS-UNIT-BITS’ ( – n  ) environment “ADDRESS-UNIT-BITS”
   1 つのアドレス単位のサイズ(ビット単位)。

‘MAX-CHAR’ ( – u  ) environment “MAX-CHAR”
   文字セット内の任意の文字の最大値

‘/COUNTED-STRING’ ( – n  ) environment “slash-counted-string”
   カウンタ付き文字列の最大サイズ(文字単位)。

‘/HOLD’ ( – n  ) environment “slash-hold”
   描写された数値文字列の出力バッファーのサイズ(文字単位)。

‘/PAD’ ( – n  ) environment “slash-pad”
   ‘PAD’ が指すスクラッチ領域のサイズ(文字数)。

‘CORE’ ( – f  ) environment “CORE”
   完全なコア・ワード・セットが存在する場合は true。 Gforth では常に当て
はまります。

‘CORE-EXT’ ( – f  ) environment “CORE-EXT”
   完全なコア拡張ワード・セットが存在する場合は true。 Gforth では常に当
てはまります。

‘FLOORED’ ( – f  ) environment “FLOORED”
   true ならば、 ‘/’ などで、 フロア除算(floored division)を実行します。

‘MAX-N’ ( – n  ) environment “MAX-N”
   使用可能な符号付き整数の最大値。

‘MAX-U’ ( – u  ) environment “MAX-U”
   使用可能な符号なし整数の最大値。

‘MAX-D’ ( – d  ) environment “MAX-D”
   使用可能な符号付き2倍長数の最大値。

‘MAX-UD’ ( – ud  ) environment “MAX-UD”
   使用可能な符号なし2倍長数の最大値。

‘return-stack-cells’ ( – n  ) environment “return-stack-cells”
   リターン・スタックの最大サイズ(セル単位)。

‘stack-cells’ ( – n  ) environment “stack-cells”
   データ・スタックの最大サイズ(セル単位)。

‘floating-stack’ ( – n  ) environment “floating-stack”
   N はゼロ以外で、 Gforth が深さ N の別個の浮動小数点スタックを維持して
いることを示しています。

‘#locals’ ( – n  ) environment “number-locals”
   定義内のローカル変数の最大数

‘wordlists’ ( – n  ) environment “wordlists”
   検索順序スタック(the search order)で使用できるワード・リストの最大数

‘max-float’ ( – r  ) environment “max-float”
   使用可能な浮動小数点数の最大値(Gforth では最大の有限数(finite
number)として実装)

‘XCHAR-ENCODING’ ( – addr u  ) environment “XCHAR-ENCODING”
   エンコーディングを表す印刷可能なASCII文字列を返し、 (あれば)、 優先さ
れるMIME名、 または “ISO-LATIN-1” や “UTF-8” のような
<http://www.iana.org/assignments/character-sets> の名前を使用します。 た
だし、“ASCII” の場合は、 エイリアスの “ASCII” を優先します。

‘MAX-XCHAR’ ( – xchar  ) environment “MAX-XCHAR”
   xchar の最大値。 これはエンコーディングによって異なります。

‘XCHAR-MAXMEM’ ( – u  ) environment “XCHAR-MAXMEM”
   1 つの xchar によって消費される最大メモリをアドレス単位で返します。

   Forth-94 バージョンのワードセットの存在を確認するための環境問い合わせ
(environemtal query)がいくつかあります。 当該文字列が存在する場合、 それ
らはすべて ‘( -- f )’ のスタック効果を持ちます(つまり、 これらの問い合わ
せの ‘environment?’ のスタック効果は ‘( c-addr u -- false / f true )’ で
す)。

   ‘block block-ext double double-ext exception exception-ext facility
facility-ext file file-ext floating floating-ext locals locals-ext
memory-alloc memory-alloc-ext tools tools-ext search-order
search-order-ext string string-ext’

   上記ワードセットの問い合わせは、 ほとんど使用および実装されなかったた
め、 Forth-2012 ではこれらのワードセットの Forth-2012 バリエーションを問
い合わせする方法が導入されませんでした。 代わりに、 ‘[defined]’ (*note
Interpreter Directives::) を使用するというアイディアです。

   Forth-200x (次の標準に取り組むグループ。 このグループが作成するドキュ
メントも Forth-200x と呼ばれます)は、 提案された拡張機能(extension
proposals)の変更が完了すると(CfV 段階)、 提案された拡張機能に対する拡張
機能問い合わせ(extension query)を定義します。 そのため、 これらの提案を
採用するプログラムは、 提案された拡張機能が適切かどうかを確認できます。
システムにはそれらがあり、 おそらくリファレンス実装(存在する場合)をロー
ドします。 ‘environment?’ がそのような問い合わせを見つけた場合、
<www.forth200x.org> 上の対応する提案がシステムに実装されます(ただし、
‘environment?’ の場合と同様、 存在しないモノは何も分かりません)。 これら
の問い合わせにはスタック効果 ‘( -- )’ があります。 つまり、 問い合わせに
対して ‘environment?’ ではスタック効果 ‘( c-addr u -- false / true )’ が
あり、 これはワードセット問い合わせよりも便利です。。 これらの提案の多く
は Forth-2012 に組み込まれています。 拡張機能問い合わせも Forth システム
実装者の間で特に人気があるわけではないため、 ‘[define]’ を使用する方が良
いアプローチである可能性があります。 とにもかくにも、 Gforth は以下の拡
張機能問い合わせ(extension query)を実装します:

   ‘X:2value X:buffer X:deferred X:defined X:ekeys X:escaped-strings
X:extension-query X:fp-stack X:ftrunc X:fvalue X:locals X:n-to-r
X:number-prefixes X:parse-name X:required X:s-escape-quote X:s-to-f
X:structures X:synonym X:text-substitution X:throw-iors
X:traverse-wordlist X:xchar’

   さらに、 Gforth は以下の Gforth 固有の問い合わせを実装します:

‘gforth’ ( – c-addr u  ) gforth-environment “gforth”
   Gforth のこのバージョン(バージョン > 0.3.0)のバージョン文字列を表す文
字列。 さまざまなバージョンのバージョン文字列は、 辞書順
(lexicographically)に並べることができることが保証されています。

‘os-class’ ( – c-addr u  ) gforth-environment “os-class”
   ホスト・オペレーティング・システムを説明する文字列。

‘os-type’ ( – c-addr u  ) gforth-environment “os-type”
   $host_os に等しい文字列

   標準の問い合わせでは、 環境問い合わせ(environmental query)に使用され
るヘッダー・スペース(header space)が、 定義に使用されるヘッダー・スペー
スとは異なることが要求されます。

   通常、 Forth システムは、 環境問い合わせ(environmental query)「だけ」
に使用されるワードリスト内に定義を作成することにより、 環境問い合わせを
サポートします。 それが Gforth のやっていることです。 認知されている環境
問い合わせのセットに定義を追加する標準的な方法はありませんが、 Gforth や
、 ワードリスト・メカニズムを使用するその他のシステムでは、 環境問い合わ
せを受け入れるために使用されるワードリストは、 他のワードリストと同様に
操作できます。

‘environment-wordlist’ ( – wid  ) gforth-0.2 “environment-wordlist”
   wid は、 環境問い合わせ(environmental query)によって検索されるワード
リストを識別します(SwiftForth および VFX に存在)。

‘environment’ ( –  ) gforth-0.6 “environment”
   ‘environment-wordlist’ のボキャブラリ (Win32Forth および VFX に存在
)。

   以下に、 環境問い合わせ(environmental query)の使用例をいくつか示しま
す:

     s" address-unit-bits" environment? 0=
     [IF]
          cr .( environmental attribute address-units-bits unknown... ) cr
     [ELSE]
          drop \ ensure balanced stack effect
     [THEN]

     \ 標準で throw を使うときにプログラムの冒頭でありそうなコード断片
     \ 訳注: throw をサポートしていなければ abort" に置き換え
     s" exception" environment? [IF]
        0= [IF]
           : throw abort" exception thrown" ;
        [THEN]
     [ELSE] \ we don't know, so make sure
        : throw abort" exception thrown" ;
     [THEN]

     s" gforth" environment? [IF] .( Gforth version ) TYPE
                             [ELSE] .( Not Gforth..) [THEN]

     \ a program using v*
     s" gforth" environment? [IF]
       s" 0.5.0" compare 0< [IF] \ v* is a primitive since 0.5.0
        : v* ( f_addr1 nstride1 f_addr2 nstride2 ucount -- r )
          >r swap 2swap swap 0e r> 0 ?DO
            dup f@ over + 2swap dup f@ f* f+ over + 2swap
          LOOP
          2drop 2drop ;
       [THEN]
     [ELSE] \
       : v* ( f_addr1 nstride1 f_addr2 nstride2 ucount -- r )
       ...
     [THEN]

   以下は、 environment ワードリストに定義を追加する例です:

     get-current environment-wordlist set-current
     true constant block
     true constant block-ext
     set-current

   以下のようにして、 environment ワードリストどのような定義があるかを確
認できます:

     environment-wordlist wordlist-words


File: gforth.info,  Node: Files,  Next: Blocks,  Prev: Environmental Queries,  Up: Words

6.18 Files
==========

Gforth は、 ホスト・オペレーティング・システムのファイル・ システムに保
存されているファイルにアクセスするための機能を提供します。 Gforth によっ
て処理されるファイルは、 以下の 2 つのカテゴリに分類できます:

   • テキスト・インタプリタによって処理されるファイル(“Forth source
     files”)
   • 他のプログラムによって処理されるファイル(“general files”)。

* Menu:

* Forth source files::
* General files::
* Redirection::
* Directories::
* Search Paths::


File: gforth.info,  Node: Forth source files,  Next: General files,  Prev: Files,  Up: Files

6.18.1 Forth source files
-------------------------

ファイルの内容を通訳(interpret)する最も簡単な方法は、 以下の 2 つの形式
のいずれかを使用することです:

     include mysource.fs
     s" mysource.fs" included

   通常、 ファイルをインクルードする必要があるのは、 そのファイルがまだ
インクルードされていない場合(たとえば、 別のソース・ファイルなど)です。
その場合、 以下の 3 つの形式のいずれかを使用できます:

     require mysource.fs
     needs mysource.fs
     s" mysource.fs" required

   ソース・ファイルを通訳(interpret)してもスタックが変更されないようにソ
ース・ファイルを作成することをお勧めします。 この方法で設計されたソース
・ファイルは、 ‘required’ やそのファミリーと一緒に問題なく使用できます。
例:

     1024 require foo.fs drop

   ここでは、 引数 1024 (バ​​ッファ・サイズなど) を ‘foo.fs’ に渡してい
ます。 ‘foo.fs’ の通訳(interpret)にはスタック効果 ( n – n ) があり、
‘require’ での使用が可能になります。 もちろん、 require されるファイルに
このようなパラメーターを指定する場合は、 最初の ‘require’ がすべての用途
に適合することを確認する必要があります(つまり、 マスター・ロード・ファイ
ルの早い段階で ‘require’ することになります)。

‘include-file’ ( i*x wfileid – j*x  ) file “include-file”
   ファイル WFILEID の内容を通訳(interpret)します(テキスト・インタプリタ
を使用して処理します)。

‘included’ ( i*x c-addr u – j*x  ) file “included”
   文字列 C-ADDR U で指定される名前のファイルを ‘include-file’ します。

‘included?’ ( c-addr u – f  ) gforth-0.2 “included?”
   ファイル C-ADDR U が以前にインクルードされたファイルのリストにある場
合にのみ true。 ファイルがロードされている場合、 たとえば ‘foo.fs’ とし
て指定されたのが Forth 検索パスのどこかで見つかった可能性があります。
‘include?’ から ‘true’ を返すには、 ファイルへの正確なパス (‘./foo.fs’<
であっても) を指定する必要があります。

‘include’ ( ... "file" – ...  ) file-ext “include”
   FILE を ‘include-file’ する。

‘required’ ( i*x addr u – i*x  ) file-ext “required”
   既に ‘include’ (または ‘required’ ) されてないなら、 ADDR U で指定し
た名前のファイルを ‘include-file’ します。 現状では、 これは(パス
(path)付きの)ファイル名を以前にインクルードしたファイルの名前と比較する
ことによって機能します。

‘require’ ( ... "file" – ...  ) file-ext “require”
   FILE がまだインクルードされていない場合のみ、 ‘include-file’ します。

‘needs’ ( ... "name" – ...  ) gforth-0.2 “needs”
   ‘require’ のエイリアス。 他のシステム(Win32Forth など)に存在します。

‘\\\’ ( –  ) gforth-1.0 “\\\”
   ソース・ファイルの残りをEOFまでスキップする

‘.included’ ( –  ) gforth-0.5 “.included”
   インクルードされたファイルの名前をリストします。

‘sourcefilename’ ( – c-addr u  ) gforth-0.2 “sourcefilename”
   現在入力ソースとなっているソース・ファイルの名前。 結果は、 ファイル
がロードされている間のみ有効です。 現在の入力ソースが(ストリーム)ファイ
ルでない場合、 結果は未定義です。 Gforth では、 結果はセッション全体で有
効です(ただし、 ‘savesystem’ などを跨いで有効ではありません)。

‘sourceline#’ ( – u  ) gforth-0.2 “sourceline-number”
   (ストリーム)ファイルから現在通訳(interpret)されている行の行番号。 最
初の行は番号 1 です。 現在の入力ソースが(ストリーム)ファイルでない場合、
結果は未定義です。

   ‘required’ の標準 Forth の定義は ‘compat/required.fs’ で提供されます
。


File: gforth.info,  Node: General files,  Next: Redirection,  Prev: Forth source files,  Up: Files

6.18.2 General files
--------------------

ファイルは名前と種類によって開かれたり作成されたりします。 以下のファイ
ル・アクセス・メソッド(FAM)が認識されます:

‘r/o’ ( – fam  ) file “r-o”

‘r/w’ ( – fam  ) file “r-w”

‘w/o’ ( – fam  ) file “w-o”

‘bin’ ( fam1 – fam2  ) file “bin”

‘+fmode’ ( fam1 rwxrwxrwx – fam2  ) gforth-1.0 “plus-f-mode”
   ファイル・アクセス・モードを fam に追加 - create-file のみ(訳注:
rwxrwxrwx は chmod と同様 777 とか 666 。 ただし gforth には直接 8進数記
述する方法が無い)

   ファイルを開いたり作成したりすると、 他のすべてのファイル・コマンドに
使用されるファイル識別子 wfileid が返されます。 すべてのファイル・コマン
ドは、 ステータス値 wior も返します。 これは、 操作が成功した場合は 0 を
返し、 エラーの場合は実装で定義されたゼロ以外の値を返します。

‘open-file’ ( c-addr u wfam – wfileid wior ) file “open-file”

‘create-file’ ( c-addr u wfam – wfileid wior ) file “create-file”

‘close-file’ ( wfileid – wior ) file “close-file”

‘delete-file’ ( c-addr u – wior ) file “delete-file”

‘rename-file’ ( c-addr1 u1 c-addr2 u2 – wior ) file-ext “rename-file”
   ファイル c_addr1 u1 のファイル名を新しい名前 c_addr2 u2 に変更します
(rename)

‘read-file’ ( c-addr u1 wfileid – u2 wior ) file “read-file”
   ファイル wfileid から u1 文字を c_addr からのバッファーに読み取ります
。 ゼロ以外の wior はエラーを示します。 U2は読み出したデータの長さを示し
ます。 ファイルの終わりはエラーではなく、 u2$<$u1 かつ wior=0 によって示
されます。

‘read-line’ ( c_addr u1 wfileid – u2 flag wior  ) file “read-line”
   wfileid から c_addr u1 のバッファーに行を読み取ります。 Gforth は、
LF と CR と CRLFの 3 つの一般的な行終端文字をすべてサポートします。 ゼロ
以外の wior はエラーを示します。 false の flag は、ファイルの最後(end of
the file)で ‘read-line’ が呼び出されたことを示します。 u2 は行の長さ(タ
ーミネータなし)を示します。 u2$<$u1 は行の長さが u2 文字であることを示し
ます。 u2=u1 は、 行が少なくとも u1 文字長であり、 バッファーの u1 文字
がその行の文字で埋められており、 そして、 その行の次のスライスは次の
‘read-line’ で読み取られます。 行の長さが u1 文字の場合、最初の
‘read-line’ は u2=u1 を返し、 次の read-line は u2=0 を返します。

‘key-file’ ( wfileid – n  ) gforth-0.4 “key-file”
   wfileid から 1 文字 n を読み取ります。 このワードは wfileid のバッフ
ァリングを無効にします。 あなたが端末から非標準モード(non-canonical
mode)(RAWモード)で文字を読み取りたい場合は、(C言語インターフェイスを使用
して)自分で端末を非標準モード(non-canonical mode)にする必要があります。
例外は ‘stdin’ で、 この場合 Gforth は自動的に非正規モード(non-canonical
mode)に設定します。

‘key?-file’ ( wfileid – f ) gforth-0.4 “key-q-file”
   f は、 ブロッキング無しに wfileid から少なくとも 1 文字を読み取ること
ができる場合に true になります。 ファイルに対して ‘read-file’ または
‘read-line’ も使用したい場合は、 最初に ‘key?-file’ または ‘key-file’ を
呼び出す必要があります(これら 2 つのワードはバッファリングを無効にします
)。

‘file-eof?’ ( wfileid – flag ) gforth-0.6 “file-eof-query”
   WFILEID のファイル終了インジケーター(end-of-file indicator)がセットさ
れている場合、 FLAG は true です。

‘write-file’ ( c-addr u1 wfileid – wior ) file “write-file”

‘write-line’ ( c-addr u wfileid – ior  ) file “write-line”

‘emit-file’ ( c wfileid – wior ) gforth-0.2 “emit-file”

‘flush-file’ ( wfileid – wior ) file-ext “flush-file”

‘file-status’ ( c-addr u – wfam wior ) file-ext “file-status” \ 訳注: wior <> 0 ;ファイルが存在しない(wfamは未定義の値)、 wior=0 かつ  ( wfam=2 r/w 、 wfam=0 r/o 、 wfam=4 w/o 、 wfam=1 r/o bin いずれのacessモードチェックもエラーになった時。便宜的に読み込み専用かつバイナリとして返す)

‘file-position’ ( wfileid – ud wior ) file “file-position”

‘reposition-file’ ( ud wfileid – wior ) file “reposition-file”

‘file-size’ ( wfileid – ud wior ) file “file-size”

‘resize-file’ ( ud wfileid – wior ) file “resize-file”

‘slurp-file’ ( c-addr1 u1 – c-addr2 u2  ) gforth-0.6 “slurp-file”
   C-ADDR1 U1 はファイル名、 C-ADDR2 U2 はファイルの内容です(訳注:
slurp;音を立ててすする の意味)

‘slurp-fid’ ( fid – addr u  ) gforth-0.6 “slurp-fid”
   ADDR U はファイル FID の内容です(訳注: slurp;音を立ててすする の意味)

‘stdin’ ( – wfileid ) gforth-0.4 “stdin”
   Gforth プロセスの標準入力ファイル。

‘stdout’ ( – wfileid ) gforth-0.2 “stdout”
   Gforth プロセスの標準出力ファイル。

‘stderr’ ( – wfileid ) gforth-0.2 “stderr”
   Gforth プロセスの標準エラー出力ファイル。


File: gforth.info,  Node: Redirection,  Next: Directories,  Prev: General files,  Up: Files

6.18.3 Redirection
------------------

‘type’ や ‘emit’ の出力と、 それらを使用するすべてのワード(明示的なター
ゲット・ファイルを持たないすべての出力用ワード)を、 ‘outfile-execute’ を
使用して任意のファイルにリダイレクトできます。 以下のように使用します:

     : some-warning ( n -- )
         cr ." warning# " . ;

     : print-some-warning ( n -- )
         ['] some-warning stderr outfile-execute ;

   これは、 ‘some-warning’ を execute した後、 元の出力先を復元します。
この構造は例外に対して安全です。 同様に、 ‘key’ からの入力と、 それを利
用した入力(明示的にファイルを指定しない入力用ワード)をリダイレクトするた
めの ‘infile-execute’ があります。

‘outfile-execute’ ( ... xt file-id – ...  ) gforth-0.7 “outfile-execute”
   ‘type’ などの出力を file-id にリダイレクトして xt を execute します。

‘outfile-id’ ( – file-id  ) gforth-0.2 “outfile-id”
   File-id は、 ‘emit’ や、 ‘type’ や、 入力として file-id を受け取らな
い出力用ワードによって使用されます。 ‘outfile-execute’ で変更しない限り
、 デフォルトでは ‘outfile-id’ は実行中のプロセスの ‘stdout’ を生成しま
す。

‘infile-execute’ ( ... xt file-id – ...  ) gforth-0.7 “infile-execute”
   ‘key’ などの入力を file-id にリダイレクトして xt を実行します。

‘infile-id’ ( – file-id  ) gforth-0.4 “infile-id”
   File-id は、 ‘key’ や、 ‘?key’ や、 「ユーザー入力デバイス」(user
input device)を参照するものすべてによって使用されます。 デフォルトでは、
‘infile-execute’ で変更しない限り、‘infile-id’ は実行中のプロセスの
‘stdin’ を生成します。

   あなたが、 入力または出力をファイルにリダイレクトしたくない場合は、
‘key’ や ‘emit’ や ‘type’ が defer されたワードであるという事実を利用す
ることもできます(*note Deferred Words::)。 ただし、 その場合は、 復元と
、 例外からの保護について、 自分で心配する必要があります。 また、 この方
法で出力をリダイレクトするには、 ‘emit’ と ‘type’ の両方をリダイレクトす
る必要があることに注意してください。


File: gforth.info,  Node: Directories,  Next: Search Paths,  Prev: Redirection,  Up: Files

6.18.4 Directories
------------------

あなたは、 ファイル名をディレクトリとベース・コンポーネントに分割できま
す:

‘basename’ ( c-addr1 u1 – c-addr2 u2  ) gforth-0.7 “basename”
   ファイル名が c-addr1 u1 の場合、 c-addr2 u2 は、 先頭のディレクトリ・
コンポーネントが削除された部分です(訳注: "os-class" environment?  type
unix ok な環境では動いたが、 Windows系では不明(’/’ を区切り文字としてハ
ードコーディングしてあるっぽい)。

‘dirname’ ( c-addr1 u1 – c-addr1 u2  ) gforth-0.7 “dirname”
   C-addr1 u2 は、 ファイル名 c-addr1 u1 のディレクトリ名部分で、 末尾の
‘/’ も含まれます。 caddr1 u1 に ‘/’ が含まれていない場合、 u2=0 です(訳
注: pathの区切り文字として ‘/’ をハードコーディングしているので、
Windows系で動くかどうか不明)。

   ファイルと同様に、 ディレクトリを開いて読み取ることができます。 読む
と、 一度に 1 つのディレクトリ・エントリが得られます。 これを、 (ワイル
ドカードを使用して)ファイル名とマッチングさせることができます。

‘open-dir’ ( c-addr u – wdirid wior ) gforth-0.5 “open-dir”
   c-addr, u で指定されたディレクトリを開き、 さらにそこにアクセスするた
めに dir-id を返します。

‘read-dir’ ( c-addr u1 wdirid – u2 flag wior ) gforth-0.5 “read-dir”
   dir-id で指定されたディレクトリから、 アドレス c-addr にある長さ u1 の
バッファーへ、 次のエントリの読み取りを試みます。 これ以上エントリがない
ために試行が失敗した場合は、 ior=0 かつ flag=0 かつ u2=0 となり、 バッフ
ァーは変更されません。 他の理由で次のエントリの読み取りに失敗した場合は
、 ior<>0 を返します。 試行が成功した場合、 ファイル名を c-addr からのバ
ッファーに保存し、 ior=0 かつ flag=true かつ ファイル名のサイズに等しい
u2 を返します。 ファイル名の長さが u1 より長い場合は、 ファイル名の最初
の u1 文字をバッファーに格納し、 ior はエラー "name too long" を示し(訳
注: ior= -548 日本語環境では "ファイル名が長すぎます")、 かつ flag=true
かつ u2=u1 です。

‘close-dir’ ( wdirid – wior ) gforth-0.5 “close-dir”
   dir-id で指定されたディレクトリを閉じます。

‘filename-match’ ( c-addr1 u1 c-addr2 u2 – flag ) gforth-0.5 “match-file”
   ファイル名 C_ADDR1 U1 とパターン C_ADDR2 U2 のマッチングを行います。
パターンは、複数の文字 (’*’) または 1 つの文字 (’?’) のワイルドカードで
ある特殊文字 ’*’ と ’?’ を除き、 文字ごとにマッチします。 マッチングでき
た場合は true

‘get-dir’ ( c-addr1 u1 – c-addr2 u2 ) gforth-0.7 “get-dir”
   c-addr1, u1で指定されたバッファーにカレント・ディレクトリのパス
(path)を格納します。 バッファーサイズが十分でない場合は、 0 0 を返します
。

‘set-dir’ ( c-addr u – wior ) gforth-0.7 “set-dir”
   現在のディレクトリを c-addr, u に変更します。 これが不可能な場合はエ
ラーを返します(訳注: 例えば ior = -514 ; "そのようなファイルやディレクト
リはありません")

‘=mkdir’ ( c-addr u wmode – wior ) gforth-0.7 “equals-mkdir”
   モード wmode でディレクトリ c-addr u を作成します。

‘mkdir-parents’ ( c-addr u mode – ior  ) gforth-0.7 “mkdir-parents”
   ディレクトリ c-addr u とそのすべての親をモード mode (umask が掛けられ
ます)で作成します(訳注: フルパスで指定したディレクトリを作成する。
‘aaa/bbb/ccc’ というディレクトリを指定すればそれを一気に作る。 ここで、
ccc というファイルが既にある場合は何もせず ior=-529 「ファイルが存在しま
す」エラーとなる。 注意: aaa または bbb がファイルの場合は「削除」してか
らディレクトリを作成するので注意。 ior=-525 なら「許可がありません」(aaa
, aaa/bbb , aaa/bbb/ccc のいずれで許可が無かったのかは不明)。 注意:
gforth には8進数リテラルが無いので注意。 2進数(%0111111101 ; -rwxrwxr-x
)がおすすめ。 ディレクトリの作成であるので実行権限(x)の付与を行うこと)


File: gforth.info,  Node: Search Paths,  Prev: Directories,  Up: Files

6.18.5 Search Paths
-------------------

あなたが、 ‘included’ や、 そのファミリーのために、 直接ファイル名を指定
する場合(つまり、 ‘/’ や ‘~’ で始まるファイル名、 または 2 番目の位置に
‘:’ が付くファイル名 (‘C:...’ など))、 そのファイルは、 あなたの期待どお
りにインクルードされます。

   ファイル名が ‘./’ で始まる場合、 これは「現在の」ファイルがインクルー
ドされたディレクトリを指します。 これにより、 (現在の作業ディレクトリや
絶対位置に関係なく)ファイル自体の位置を基準にして他のファイルを含めるこ
とができます。 この機能は、 ファイルにライブラリの他のファイルが含まれる
可能性がある、 複数のファイルで構成されるライブラリにとって不可欠です。
C言語の ‘#include "..."’ に相当します。 現在の入力ソースがファイルでない
場合、 ‘.’ はインクルードされた最も内側のファイルのディレクトリを参照し
ます。 インクルードされたファイルがない場合は、 現在の作業ディレクトリか
らインクルードされます。

   (‘./’ で始まらない)相対ファイル名の場合、 Gforth は検索パス(a search
path)を使用します。 検索パスに書かれた各ディレクトリ内で、 指定のファイ
ル名を検索し、 最初に見つかったファイル名をインクルードします。 Forth の
ソース・ファイルと一般ファイルには別個の検索パスがあります。 検索パスに
ディレクトリ ‘.’ が含まれている場合、 ファイルが ‘./’ で指定されているか
のように、 「現在のファイルのディレクトリ」または作業ディレクトリを参照
します。

   ‘~+’ を使用して、 (‘bash’ の Tilde Expansion ‘~+/foo’ → ‘$PWD/foo’ の
ように)現在の作業ディレクトリを参照します(訳注: "~+/my-mkdir-parents.fs"
file-status .s <2> 2 0 ok 2 )

‘absolute-file?’ ( addr u – flag  ) gforth-1.0 “absolute-file?”
   ファイル名が ‘/’ または ‘~’ (チルダ拡張) で始まる場合、 または ‘./*’
拡張正規表現: ‘^[/~]|./’ の形式である場合、 または 2 番目の文字としてコ
ロンが含まれる場合(‘C:...’)、 絶対(absolute)ファイル名です( true を返す
)。 パスが ‘/’ を含んでいるだけでは絶対ファイル名ではありません(訳注: 厳
密にファイル名として成立するかどうかチェックしている訳では無い事に注意、
例えば ‘"~ccc.txt" absolute-file? . -1 ok’ 、また ‘./’ 形式を絶対と見な
すことも注意。 ‘"./aaa/bbb/ccc.txt" absolute-file? . -1 ok’ )

* Menu:

* Source Search Paths::
* General Search Paths::


File: gforth.info,  Node: Source Search Paths,  Next: General Search Paths,  Prev: Search Paths,  Up: Search Paths

6.18.5.1 Source Search Paths
............................

検索パス(the search path)は、 Gforth の起動時に初期化されます(*note
Invoking Gforth::)。 ‘fpath’ を一般的なパス処理ワードと組み合わせて使用
​​すると、これを表示したり変更したりできます。

‘fpath’ ( – path-addr  ) gforth-0.4 “fpath”

‘.fpath’ ( –  ) gforth-0.4 “.fpath”
   Forth 検索パスの内容を表示します。

‘file>fpath’ ( addr1 u1 – addr2 u2  ) gforth-1.0 “file>fpath”
   ‘fpath’ で c-addr1 u1 という名前のファイルを検索します。 成功した場合
、 c-addr u2 は絶対ファイル名または現在の作業ディレクトリからの相対ファ
イル名になります。 ファイルを開けない場合(ファイルが見つからない場合)は
例外を throw します。

‘fpath’ と ‘require’ の使用例を以下に示します:

     fpath path= /usr/lib/forth/|./
     require timer.fs


File: gforth.info,  Node: General Search Paths,  Prev: Source Search Paths,  Up: Search Paths

6.18.5.2 General Search Paths
.............................

あなたのアプリケーションでは、 ‘included’ のように、 複数のディレクトリ
内のファイルを探さなければならない場合があります。 これを容易にするため
に、 Gforth では、 Forth 検索パスを一般化した等価なモノを提供することで
、 あなた独自の検索パスを定義して使用できます。

‘open-path-file’ ( addr1 u1 path-addr – wfileid addr2 u2 0 | ior  ) gforth-0.2 “open-path-file”
   パス PATH-ADDR で、 指定のファイル ADDR1 U1 を探します。 見つかった場
合(IOR=0)は、 結果のパス(addr2 u2)と、 (読み取り専用の)ファイル・デスク
リプタ(open file descriptor)(wfileid)を返します。 ファイルが見つからない
場合、 IOR は(現在の実装では)ファイルを開こうとした最後の試行時点で返さ
れたものです(訳注:ファイルが見つからない場合、 つまり IOR<>0 の場合、返
されるのは IOR のみです ( addr1 u1 path-addr – ior ) )。

‘file>path’ ( c-addr1 u1 path-addr – c-addr2 u2  ) gforth-1.0 “file>path”
   path-addr に保存されたパス内で c-addr1 u1 という名前のファイルを検索
します。 成功した場合、c-addr u2 は絶対ファイル名または現在の作業ディレ
クトリからの相対ファイル名になります。 ファイルを開けない場合は例外をス
ローします。

‘clear-path’ ( path-addr –  ) gforth-0.5 “clear-path”
   パス path-addr を空(empty)にします。

‘also-path’ ( c-addr len path-addr –  ) gforth-0.4 “also-path”
   ディレクトリ c-addr len を path-addr に追加します。

‘.path’ ( path-addr –  ) gforth-0.4 “.path”
   検索パス PATH-ADDR の内容を表示します。

‘path+’ ( path-addr  "dir" –  ) gforth-0.4 “path+”
   ディレクトリ DIR を検索パス PATH-ADDR に追加します(訳注: 検索パスの後
ろに追加する)。

‘path=’ ( path-addr "dir1|dir2|dir3" –  ) gforth-0.4 “path-equals”
   パス path-addr に、 完全に新しい検索パスを作成します。 パス区切り文字
は ‘|’ です。

   カスタム検索パスの作成例を以下に示します:
     variable mypath \ no special allocation required, just a variable
     mypath path= /lib|/usr/lib \ assign initial directories
     mypath path+ /usr/local/lib \ append directory
     mypath .path \ output:"/lib /usr/lib /usr/local/lib"

   ファイルを検索し、 結果のパスを表示します(訳注: ‘file>path’ だと内部
で throw しちゃうので、代わりに ‘opne-path-file’ を使った例…だと思う):
     s" libm.so" mypath open-path-file throw type close-file \ output:"/lib/libm.so"


File: gforth.info,  Node: Blocks,  Next: Other I/O,  Prev: Files,  Up: Words

6.19 Blocks
===========

今どきのデスクトップ・コンピューターで Gforth を実行すると、 特定のサー
ビスを提供するオペレーティング・システムの制御下で Gforth が実行されます
。 これらのサービスの 1 つはファイル・サービスです。 これにより、Forth の
ソース・コードとデータをファイルに保存し、 Gforth に読み込むことができま
す(*note Files::)。

   伝統的に、 Forth は、 オペレーティング・システムを介さずに基盤となる
ハードウェアと直接インターフェイスするシステム上で有用なプログラミング言
語でした。 Forth は、 そのようなシステム上で大容量ストレージにアクセスす
るためのブロック(“blocks”)と呼ばれるメカニズムを提供します。

   ブロックは 1024 バイトのデータ領域であり、 データまたは Forth ソース
・コードを保持するために使用できます。 ブロックの内容に構造は課されませ
ん。 ブロックはその番号によって識別されます。 ブロックには、1 から実装定
義の最大値まで連続した番号が付けられます。

   ブロックを使用するが、 オペレーティング・ステムを使用しない一般的なシ
ステムでは、 大容量ストレージとして 1 台のフロッピー・ディスク・ドライブ
を使用し、 ディスクは 256 バイトのセクターを提供するようにフォーマットさ
れます。 ブロックは、 ディスクの容量の制限まで、 ディスクの最初の 4 セク
タをブロック 1 に割り当て、 次の 4 セクタをブロック 2 に割り当てることに
よって実装されます。 ディスクにはファイル・システム情報は含まれず、 ブロ
ック達のみが含まれます。

   ファイル・サービスを提供するシステムでは、 ブロックは通常、単一のブロ
ック・ファイル内に一連のブロックを格納することによって実装されます。 ブ
ロック・ファイルのサイズは、 含まれるブロックの数に対応する 1024 バイト
の正確な倍数になります。 これが Gforth が使用するメカニズムです。

   一度に開くことができるブロック・ファイルは 1 つだけです。 ブロック・
ファイルを指定せずにブロック・ワードを使用すると、 Gforth はデフォルトで
ブロック・ファイル ‘blocks.fb’ を使用します。 Gforth は、 ブロック・ファ
イルを見つけようとするときに Forth 検索パスを使用します(*note Source
Search Paths::)。

   プログラム制御下でブロックの読み取りと書き込みを行う場合、 Gforth は
中間ストレージとして多数のブロック・バッファー(“block buffers”)を使用し
ます。 ‘load’ を使用してブロックの内容を解釈する場合は、 これらのバッフ
ァーは使用されません。

   ブロック・バッファーの動作はキャッシュ(cache)の動作に似ています。 各
ブロック・バッファーには 3 つの状態(state)があります:

   • 未割り当て(unassigned)
   • 割り当て済・未変更(assigned-clean)
   • 割り当て済・変更中(assigned-dirty)

   最初は、すべてのブロック・バッファーは「未割り当て」(unassigned)です
。 ブロックにアクセスするには、 ブロック(ブロック番号で指定)をブロック・
バッファーに割り当てる必要があります。

   ブロック・バッファーへのブロックの割り当ては、 ‘block’ または
‘buffer’ によって行われます。 ブロックの既存の内容を変更する場合は、
‘block’ を使用します。 ブロックの既存の内容を気にしない場合は、 ‘buffer’
を使用します(1)。

   ‘block’ または ‘buffer’ を使用してブロックをブロック・バッファーに割
り当てると、 そのブロック・バッファーが「現在のブロック・バッファー」
(current block buffer)になります。 データは「現在のブロック・バッファー
」内でのみ操作(読み取りまたは書き込み)できます。

   「現在のブロック・バッファー」の内容が変更されている場合は、 「
‘block’ または ‘buffer’ を再度呼び出す前に、」(何もせずに)変更を破棄する
か、 ‘update’ を使用して、 ブロックを変更済みとしてマークする必要があり
ます(割り当て済・変更中;assigned-dirty)。 ‘update’ を使用してもブロック
・ファイルは変更されません。 ブロック・バッファーの状態を「割り当て済・
変更中」(assigned-dirty)に変更するだけです。 そのブロックは、 そのブロッ
ク・バッファーが別のブロックで必要なときに暗黙的に書き込まれるか、 また
は、 ‘flush’ や ‘save-buffers’ によって明示的に書き込まれます。

   word ‘flush’ は、 すべての「割り当て済・変更中」(assigned-dirty)の ブ
ロックをディスク上のブロック・ファイルに書き込みます。 ‘bye’ を指定して
Gforth を終了するときは、 ‘flush’ も実行されます。

   Gforth では、‘block’ と ‘buffer’ は direct-mapped アルゴリズムを使用
してブロック・バッファーをブロックに割り当てます。 つまり、 特定のブロッ
クは、 (特定の操作に対して)「いけにえ・バッファー」(victim buffer)と呼ば
れる 1 つの特定のブロック・バッファーにのみ割り当てることができます。 い
けにえ・バッファーが「未割り当て」(unassigned)状態または「割り当て済・未
編集」(assigned-clean)状態の場合、 直ちに新しいブロックが割り当てられま
す。 「割り当て済・編集中」(assigned-dirty)の場合、 その現在の内容は、 新
しいブロックが割り当てられる前に、 ディスク上のブロック・ファイルに書き
戻されます。

   ブロックの内容に構造は課されていませんが、 伝統的に内容は 1 行当たり
64 文字の 16 行として表示します。 一つのブロックは、 単一の連続した入力
ストリームを提供します(たとえば、単一のパース領域として機能します) – ブ
ロック内に行末文字はなく、 ブロックの末尾にファイル終端文字もありません
。 これは以下の 2 つの結果をもたらします:

   • ある行の最後の文字は、そのまま次の行の最初の文字に折り返される(訳注
     : 繋がっています)。
   • ‘\’ というワード – 行末までのコメント – は特別な処理を行います。 ブ
     ロックでは、 現在の 64 文字の「1行分」の終わりまでのすべての文字が
     無視されます。

   Gforth では、 存在しないブロック番号を指定して ‘block’ を使用すると、
現在のブロック・ファイルが適切なサイズに拡張され、 ブロック・バッファー
がスペースで初期化されます。

   Gforth にはシンプルなブロック・エディターが含まれています(詳細につい
ては ‘use blocked.fb 0 list’ と入力してください)。 ただし、ブロックの使
用は推奨されません。 このメカニズムは下位互換性のためにのみ提供されてい
ます。

   ブロックを取り扱うときに使用される一般的な手法は以下のとおりです:

   • Forth 環境を離れずにブロックを編集できるスクリーン・エディター。
   • シャドウ・スクリーン。 ここで、 すべてのコード・ブロックには、 コメ
     ントを含むブロックが関連付けられています(例: 奇数のブロック番号のコ
     ード、 偶数のブロック番号のコメント)。 通常、 ブロック・エディター
     は、 コードとコメントを切り替える便利なメカニズムを提供します。
   • ロード・ブロック。 単一のブロック(通常はブロック 1) には、 アプリケ
     ーション全体を ‘load’ する多数の ‘thru’ コマンドが含まれています。

   ブロックが Forth プログラミング環境にどの程度うまく統合できるかを確認
するには、 Frank Sergeant の Pygmy Forth を参照してください。

‘open-blocks’ ( c-addr u –  ) gforth-0.2 “open-blocks”
   c-addr u で指定された名前のファイルをブロック・ファイルとして使用しま
す(訳注: エラーの場合はその時点で throw されます)。

‘use’ ( "file" –  ) gforth-0.2 “use”
   file をブロック・ファイルとして使用します。

‘block-offset’ ( – addr  ) gforth-0.5 “block-offset”
   最初のブロックの番号を含むユーザー変数(0.5.0 以降のデフォルト: 0)。
0.5.0 より前のバージョンの Gforth で作成されたブロックファイルのオフセッ
トは 1 からです。 これらのファイルを使用する場合は、次のことができます。
‘1 offset !’ または、 使用されるすべてのブロック番号に 1 を加算します。
または、 ファイルの先頭に 1024 文字追加します。

‘get-block-fid’ ( – wfileid  ) gforth-0.2 “get-block-fid”
   現在のブロック・ファイルのファイル ID を返します。 まだブロック・ファ
イルが開かれていない場合は、 ‘blocks.fb’ をデフォルトのブロック・ファイ
ルとして ‘open-blocks’ し、 そのファイルID(現在のブロック・ファイルのフ
ァイルID)を返します。

‘block-position’ ( u –  ) block “block-position”
   ブロック・ファイル内のファイル位置をブロック番号 u のブロックの先頭に
合わせます。

‘list’ ( u –  ) block-ext “list”
   ブロック番号 u のブロックの内容を表示します。 Gforth では、ブロックは
1行 64 文字からなる 16 行の行番号付きで表示されます。

‘scr’ ( – a-addr  ) block-ext “s-c-r”
   このユーザー変数には、 ‘list’ によって最後に処理されたブロックのブロ
ック番号が含まれます。

‘block’ ( u – a-addr  ) block “block”
   ブロック番号 u のブロックにブロック・バッファーが既に割り当てられてい
る場合、 そのブロック・バッファーが更新(「割り当て済・変更中」
(assigned-dirty)とマークされているか)されているなら、 そのブロック・バッ
ファー内容を当該ブロック(大容量ストレージ)に上書きしてから、 当該ブロッ
クの内容をそのブロック・バッファーに読み込み、 そのブロック・バッファー
を「割り当て済・未変更」(assigned-clean)とマークして、 そのブロック・バ
ッファーの開始アドレス a-addr を返します。 それ以外の場合は、 ブロック u
にブロック・バッファーを新たに割り当て、 その新たに割り当てたブロック・
バッファーの開始アドレス a-addr を返します。 Gforth では、 ‘buffer’ は単
に ‘block’ を呼び出します。

‘buffer’ ( u – a-addr  ) block “buffer”
   Gforth では、 ‘buffer’ は単に ‘block’ を呼び出します。

‘empty-buffers’ ( –  ) block-ext “empty-buffers”
   すべてのブロック・バッファーを「未割り当て」(unassigned)としてマーク
します。 (‘update’ によって)「割り当て済・変更中」(assigned-dirty)として
マークされているブロックがある場合、 それらのブロックへの変更は失われま
す。

‘empty-buffer’ ( buffer –  ) gforth-0.2 “empty-buffer”

‘update’ ( –  ) block “update”
   現在のブロック・バッファー(current block buffer)の状態を「割り当て・
ダーティ」(assigned-dirty)としてマークします。

‘updated?’ ( n – f  ) gforth-0.2 “updated?”
   ブロック番号 n のブロックが更新されている(割り当て済・編集中」
(assigned-dirty)としてマークされている)なら true を返す。

‘save-buffers’ ( –  ) block “save-buffers”
   更新されている(「割り当て済・変更中」(assigned-dirty)とマークされてい
る)各ブロック・バッファーの内容を大容量ストレージに転送(上書き)し、 すべ
てのブロック・バッファーを「割当済み・未編集」(assigned-clean)としてマー
クします。

‘save-buffer’ ( buffer –  ) gforth-0.2 “save-buffer”

‘flush’ ( –  ) block “flush”
   ‘save-buffers’ の機能を実行してから ‘empty-buffers’ を実行します。

‘load’ ( i*x u – j*x  ) block “load”
   ブロック番号 u のブロックをテキスト通訳(Text-interpret)します。 ブロ
ック番号 0 のブロックは ‘load’ できません。

‘thru’ ( i*x n1 n2 – j*x  ) block-ext “thru”
   ブロック n1 〜 n2 を順番に ‘load’ します。

‘+load’ ( i*x n – j*x  ) gforth-0.2 “+load”
   現在のブロック番号に n を足した番号のブロックをロードします。 ブロッ
ク内で使います。

‘+thru’ ( i*x n1 n2 – j*x  ) gforth-0.2 “+thru”
   現在のブロック番号 + n1 の番号 〜 現在のブロック + n2 の番号の、 ブロ
ックの範囲をロードします。 ブロック内で使います。

‘-->’ ( –  ) gforth-0.2 “chain”
   ブロック番号 n のブロックのロード中にこのシンボルが見つかった場合、 そ
のブロックの残りを破棄してブロック n+1 をロードします。 複数のブロックを
単一のロード可能なユニットとして連鎖させるために使用されます。 これは ロ
ードの独立性が損なわれるため、 お勧めできません。 代わりに(標準の)
‘thru’ または ‘+thru’ を使用してください。

‘block-included’ ( a-addr u –  ) gforth-0.2 “block-included”
   ‘load’ によって処理されるブロック内で使用します。 現在のブロック・フ
ァイル仕様を保存し、 a-addr u で指定されたブロック・ファイルを開き、 そ
のファイルからブロック番号 1 のブロックを ‘load’ します(これにより、 他
のブロックがチェーンまたはロードされる可能性があります)。 そして最後に、
ブロック・ファイルを閉じて、 元のブロック・ファイルを復元します。

   ---------- Footnotes ----------

   (1) ‘buffer’ の標準 Forth での定義は、 ディスク I/O を発生させないこ
とを目的としています。 以前の ‘block’ コマンドにより、 特定のブロックに
関連付けられたデータがすでにブロック・バッファーに格納されている場合、
‘buffer’ はそのブロック・バッファーを返し、 ブロックの既存のコンテンツが
利用可能になります。 それ以外の場合、 ‘buffer’ は単にそのブロックに新し
い空のブロック・バッファーを割り当てます


File: gforth.info,  Node: Other I/O,  Next: OS command line arguments,  Prev: Blocks,  Up: Words

6.20 Other I/O
==============

* Menu:

* Simple numeric output::    定義済みの書式
* Formatted numeric output::  書式化された(目に見える)出力
* Floating-point output::
* Miscellaneous output::
* Displaying characters and strings::  その他もろもろ
* Terminal output::          カーソル移動等
* Single-key input::
* Line input and conversion::
* Pipes::                    あなた独自のパイプラインの作り方
* Xchars and Unicode::       非ASCII文字
* i18n and l10n::            国際化(I18n)とローカライズ
* Substitute::               テキストマクロ置換
* CSV Reader::               データ・インポート機能


File: gforth.info,  Node: Simple numeric output,  Next: Formatted numeric output,  Prev: Other I/O,  Up: Other I/O

6.20.1 Simple numeric output
----------------------------

最も単純な出力機能は、 データ・スタックからの数値を表示する機能です。 数
値は、 ‘base’ に保存されている基数(別名 radix)で表示されます。

‘.’ ( n –  ) core “dot”
   (符号付きの1倍長整数である) N を自由形式(free-format)で表示し、 その
後に空白1つを続けます。

‘dec.’ ( n –  ) gforth-0.2 “dec.”
   n を符号付き 10 進数として表示し、 その後に空白1つを続けます。

‘h.’ ( u –  ) gforth-1.0 “h.”
   u は、 先頭に ‘$‘ を付けた符号なし 16 進数として表示し、 その後に空白
1つ続けます。

‘hex.’ ( u –  ) gforth-0.2 “hex.”
   u を符号なし 16 進数として表示し、 先頭に ‘$’ を付け、 その後に空白
1つを付けます。 この単語の別名は ‘h.’ で、 他のいくつかのシステムには存
在しますが、 1.0 より前の Gforth には存在しません。

‘u.’ ( u –  ) core “u-dot”
   (符号なしの1倍長整数の) U を自由形式で表示し、 その後に空白1つを続け
ます。

‘.r’ ( n1 n2 –  ) core-ext “dot-r”
   N1 を N2 文字幅のフィールドに右揃えで表示します。 数値を表示するため
に N2 を超える文字が必要な場合は、 すべての桁が表示されます。 必要に応じ
て、 N2 には先頭に ‘-‘ の文字分の幅を含める必要があります。

‘u.r’ ( u n –  ) core-ext “u-dot-r”
   符号なし整数 U を N 文字幅のフィールドに右揃えで表示します。 数値を表
示するために N 文字を超える文字が必要な場合は、すべての桁が表示されます
。

‘dec.r’ ( u n –  ) gforth-0.5 “dec.r”
   符号なし整数 u を n 文字幅のフィールドに符号なし 10 進数として表示し
ます。

‘d.’ ( d –  ) double “d-dot”
   (符号付き2倍長整数の) D を自由形式で表示します。 その後に空白1つが続
きます。

‘ud.’ ( ud –  ) gforth-0.2 “u-d-dot”
   (符号付無し2倍長整数の) UD を自由形式で表示し、 その後に空白1つを続け
ます。

‘d.r’ ( d n –  ) double “d-dot-r”
   2倍長整数 D を N 文字幅のフィールドに右揃えで表示します。 数値を表示
するために N を超える文字が必要な場合は、 すべての桁が表示されます。 必
要に応じて、N には先頭に ‘-‘ 文字分の幅を含める必要があります。

‘ud.r’ ( ud n –  ) gforth-0.2 “u-d-dot-r”
   符号無し2倍長整数 UD を N 文字幅のフィールドに右揃えで表示します。 数
値を表示するために N 文字を超える文字が必要な場合は、すべての桁が表示さ
れます。

