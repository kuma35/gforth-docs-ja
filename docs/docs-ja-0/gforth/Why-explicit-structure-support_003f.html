<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<!-- Created by GNU Texinfo 6.8, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- このマニュアルは、 標準 Forth 言語の高速で移植可能な実装である Gforth (バージョン 0.7.9_20240418,
April 18, 2024)用です。 これはリファレンス・マニュアルとして機能しますが、 Forth の概要と Forth
チュートリアルも含まれています。

Authors: Bernd Paysan, Anton Ertl, Gerald Wodni Copyright (C) 1995,
1996, 1997, 1998, 2000, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
2011, 2012, 2013, 2014,2015,2016,2017,2018,2019,2020,2021,2022,2023 Free
Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.1 or any later
version published by the Free Software Foundation; with no Invariant
Sections, with the Front-Cover texts being "A GNU Manual," and with the
Back-Cover Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have freedom to copy and modify this
GNU Manual, like GNU software.  Copies published by the Free Software
Foundation raise funds for GNU development." -->
<title>Why explicit structure support? (Gforth マニュアル)</title>

<meta name="description" content="Why explicit structure support? (Gforth マニュアル)">
<meta name="keywords" content="Why explicit structure support? (Gforth マニュアル)">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Word-Index.html" rel="index" title="Word Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Structures.html" rel="up" title="Structures">
<link href="Structure-Usage.html" rel="next" title="Structure Usage">
<link href="Structures.html" rel="prev" title="Structures">
<style type="text/css">
<!--
a.copiable-anchor {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter {text-decoration: none}
blockquote.indentedblock {margin-right: 0em}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd {font-style: oblique}
pre.display {font-family: inherit}
pre.format {font-family: inherit}
pre.menu-comment {font-family: serif}
pre.menu-preformatted {font-family: serif}
span.nolinebreak {white-space: nowrap}
span.roman {font-family: initial; font-weight: normal}
span.sansserif {font-family: sans-serif; font-weight: normal}
span:hover a.copiable-anchor {visibility: visible}
ul.no-bullet {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="gforth.css">


</head>

<body lang="en">
<div class="subsection" id="Why-explicit-structure-support_003f">
<div class="header">
<p>
Next: <a href="Structure-Usage.html" accesskey="n" rel="next">Structure Usage</a>, Previous: <a href="Structures.html" accesskey="p" rel="prev">Structures</a>, Up: <a href="Structures.html" accesskey="u" rel="up">Structures</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Word-Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<span id="Why-explicit-structure-support_003f-1"></span><h4 class="subsection">6.23.1 Why explicit structure support?</h4>

<span id="index-address-arithmetic-for-structures"></span>
<span id="index-structures-using-address-arithmetic"></span>
<p>複数のフィールドを含む構造体を使用したい場合は、 その構造体用にメモリを予約し、
アドレス算術演算を使用してフィールドにアクセスするだけです(see <a href="Address-arithmetic.html">Address arithmetic</a>)。 例として、
以下のフィールドを持つ構造体を考えてみましょう
</p>
<dl compact="compact">
<dt><span><code>a</code></span></dt>
<dd><p>これは浮動小数点数(float)です
</p></dd>
<dt><span><code>b</code></span></dt>
<dd><p>これはセル(cell)です
</p></dd>
<dt><span><code>c</code></span></dt>
<dd><p>これは浮動小数点数(float)です
</p></dd>
</dl>

<p>構造体の (float 整列された) ベース・アドレスが与えられると、
</p>
<dl compact="compact">
<dt><span><code>a</code></span></dt>
<dd><p>それ以上何もせずに a フィールドが得られます。
</p></dd>
<dt><span><code>b</code></span></dt>
<dd><p><code>float+</code> すると b フィールドが得られます。
</p></dd>
<dt><span><code>c</code></span></dt>
<dd><p><code>float+ cell+ faligned</code> すると c フィールドが得られます。
</p></dd>
</dl>

<p>これが非常に疲れる可能性があることは容易にわかります。 
</p>
<p>さらに加えて、 <code>cell+</code> を見ても、 どの構造体がアクセスされているか、 どのフィールドがアクセスされているかがわからないため、
あまり読みやすくありません。 何らかの方法で構造体の種類を推測し、
その構造体のどのフィールドがそのオフセットに対応するかをドキュメントで調べる必要があります。
</p>
<p>最後に、 この種のアドレス計算はメンテナンスの問題も引き起こします。 構造体の途中にフィールドを追加・削除した場合、
その後フィールドのすべてのアドレス計算を探し出して変更する必要があります。
</p>
<p>そこで、 <code>cell+</code> とそのファミリーを直接使用する代わりに、 以下のようにオフセットを定数に保存してはどうでしょうか？:
</p>
<div class="example">
<pre class="example">0 constant a-offset
0 float+ constant b-offset
0 float+ cell+ faligned c-offset
</pre></div>

<p>これで、 <code>x-offset +</code> を使用してフィールド <code>x</code> のアドレスを取得できるようになりました。
これはあらゆる点ではるかに優れています。 もちろん、 フィールドを追加する場合は、 その後のオフセット定義をすべて変更する必要があります。 これは、
以下の方法でオフセットを宣言することで改良できます:
</p>
<div class="example">
<pre class="example">0 constant a-offset
a-offset float+ constant b-offset
b-offset cell+ faligned constant c-offset
</pre></div>

<p>オフセット計算にはいつも <code>+</code> を使うので、 定義されたワードのアクションに <code>+</code> を含む定義ワード <code>cfield</code>
を使用できます:
</p>
<div class="example">
<pre class="example">: cfield ( n &quot;name&quot; -- )
    create ,
does&gt; ( name execution: addr1 -- addr2 )
    @ + ;

0 cfield a
0 a float+ cfield b
0 b cell+ faligned cfield c
</pre></div>

<p>今や、 <code>x-offset +</code> の代わりに、 単に <code>x</code> と書くことができるようになりました。
</p>
<p>構造体フィールドのワード群が非常にうまく使用できるようになりました。 ただし、 その定義はまだ少し面倒です。 名前を繰り返す必要があり、
サイズと配置に関する情報はフィールド定義の前後に配置されます。 このセクションで紹介する構造体パッケージは、 これらの問題に対処します。
</p>
</div>



</body>
</html>
