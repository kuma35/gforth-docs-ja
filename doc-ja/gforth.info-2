This is gforth.info, produced by makeinfo version 6.8 from gforth.texi.

このマニュアルは、 標準 Forth 言語の高速で移植可能な実装である Gforth (バ
ージョン 0.7.9_20240418, April 18, 2024)用です。 これはリファレンス・マ
ニュアルとして機能しますが、 Forth の概要と Forth チュートリアルも含まれ
ています。

   Authors: Bernd Paysan, Anton Ertl, Gerald Wodni Copyright © 1995,
1996, 1997, 1998, 2000, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
2011, 2012, 2013, 2014,2015,2016,2017,2018,2019,2020,2021,2022,2023 Free
Software Foundation, Inc.

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.1 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with the Front-Cover texts
     being “A GNU Manual,” and with the Back-Cover Texts as in (a)
     below.  A copy of the license is included in the section entitled
     “GNU Free Documentation License.”

     (a) The FSF’s Back-Cover Text is: “You have freedom to copy and
     modify this GNU Manual, like GNU software.  Copies published by the
     Free Software Foundation raise funds for GNU development.”
INFO-DIR-SECTION Software development
START-INFO-DIR-ENTRY
* Gforth: (gforth).          forth言語のための高速インタプリタ
END-INFO-DIR-ENTRY


File: gforth.info,  Node: $tring words,  Next: Counted string words,  Prev: String words,  Up: Strings and Characters

6.8.5 $tring words
------------------

以下の文字列ライブラリは、 文字列を通常のセル・サイズの変数(文字列ハンド
ル;string handle)に格納します。 これらのハンドルには、 ヒープに割り当て
られたセル・カウント文字列(cell-counted string;カウンタがセルサイズであ
るカウンタ付き文字列)へのポインタが含まれています。 この文字列ライブラリ
は bigFORTH 由来です。

   内容への恒久的な参照は 1 つだけ(ハンドル内の参照)しかないため、 未解
決の参照を恐れることなく文字列を再配置または削除できます。 これには、 プ
ログラマが、 例えば ‘$@’ 等によって生成された参照を一時的な目的でのみ使
用する必要があります。 つまり、 これらの一時的な参照は、 戻り値として渡
されたり、 グローバル・メモリに格納されたりすることはなく、 ハンドルを変
更する可能性のあるワードは、 これらの一時的な参照が存在する間は呼び出さ
れません。

   このライブラリを補完するものとしてセルペア表現(cell-pair
representation)があります。 文字列変数に対して $tring ワードを使用します
が、 これは c-addr u 表現では面倒です。 セルペア表現は、 文字列を変更し
ないで処理(検査など)するために使用します。

‘$!’ ( addr1 u $addr –  ) gforth-0.7 “string-store”
   新しく割り当てられた文字列バッファをアドレス($addr)が指す先に格納し、
必要に応じて以前のバッファを解放します。

‘$@’ ( $addr – addr2 u  ) gforth-0.7 “string-fetch”
   格納された文字列のアドレスと長さを返します。

‘$@len’ ( $addr – u  ) gforth-0.7 “string-fetch-len”
   格納されている文字列の長さを返します。

‘$!len’ ( u $addr –  ) gforth-0.7 “string-store-len”
   格納されている文字列(string)領域の長さを変更します(足し算ではない。 長
さを直にいじる) それゆえ、メモリ領域を変更し、 アドレスとカウンタ・セル
も調整(adjust)する必要があります(訳注: 元の長さより長くした場合、 領域を
拡張するだけで初期化はしない。 そこにはゴミが入っているので自分で初期化
する必要がある)

‘$+!len’ ( u $addr – addr  ) gforth-1.0 “string-plus-store-len”
   $addr によって参照されるメモリ領域の最後に u バイト用の空間を確保しま
す(追加。確保するだけで初期化はしない。 $addr の「長さ」に追加もする)。
addr は、 確保した空間の最初のアドレスです。

‘$del’ ( addr off u –  ) gforth-0.7 “string-del”
   文字列のオフセット位置 OFF から U バイト削除します。

‘$ins’ ( addr1 u $addr off –  ) gforth-0.7 “string-ins”
   オフセット位置 OFF に文字列を挿入します。

‘$+!’ ( addr1 u $addr –  ) gforth-0.7 “string-plus-store”
   文字列(addr1 u)を別の文字列($addr)に追加します。

‘c$+!’ ( char $addr –  ) gforth-1.0 “c-string-plus-store”
   文字列に文字を追加します。

‘$free’ ( $addr –  ) gforth-1.0 “string-free”
   $addr が指す文字列を解放し、 $addr のポインタを 0 にします( $ すると
0 0 を返す)

‘$init’ ( $addr –  ) gforth-1.0 “string-init”
   以前に何があったかに関係なく、そこに空の文字列を保存します(訳注: ポイ
ンタを 0 にする訳ではなくて、 ポインタの指す先に長さゼロの文字列がある)

‘$split’ ( addr u char – addr1 u1 addr2 u2  ) gforth-0.7 “string-split”
   文字列中で最初に現れる char を区切り文字として文字列を 2 つに分割しま
す(例: HTML クエリの引数の ’?’)(訳注: 区切り文字 char 自体は分割後の文字
列に含まれない)

‘$iter’ ( .. $addr char xt – ..  ) gforth-0.7 “string-iter”
   区切り文字 char で切り出した部分文字列(addr u)ごとに xt を呼び出しま
す。 xt は (addr u – ) でなければなりません。 これにより、 例えば ’&’ で
区切られた引数を簡単に分解できます(訳注: : my-type ( addr u – ) ."  ["
type ."  ]"  ; variable title s" GNU gforth manual" title $!  title
$ my-type [GNU gforth manual] title bl ’ my-type $iter
[GNU][gforth][manual] ok)。

‘$over’ ( addr u $addr off –  ) gforth-1.0 “string-over”
   $addr の文字列のオフセット位置 off から文字列(addr u)で上書きします。

‘$exec’ ( xt addr –  ) gforth-1.0 “string-exec”
   実行トークン xt を実行し、 その標準出力(TYPE や EMIT やそれらを使用す
るすべてのもの)を addr が指す文字列の末尾に「追加」します。

‘$tmp’ ( xt – addr u  ) gforth-1.0 “string-t-m-p”
   ワードの出力から一時的な文字列を生成します

‘$.’ ( addr –  ) gforth-1.0 “string-dot”
   文字列を出力する、 ショートカット( $ TYPE → $.  )

‘$slurp’ ( fid addr –  ) gforth-1.0 “string-slurp”
   (slurp;音を立ててすする)ファイル fid を最後まで読み取り(ファイルのク
ローズは行いません)、 読み取ったデータを addr の指す文字列に入れます。

‘$slurp-file’ ( c-addr u addr –  ) gforth-1.0 “string-slurp-file”
   c-addr u という名前のファイル内のすべてのデータを addr の文字列に入力
します。

‘$+slurp’ ( fid addr –  ) gforth-1.0 “string-plus-slurp”
   ファイル fid を最後まで読み取り(但しクローズはしません)、 読み取った
データを addr の文字列に「追加」します。

‘$+slurp-file’ ( c-addr u addr –  ) gforth-1.0 “string-plus+slurp-file”
   c-addr u という名前のファイル内のすべてのデータを addr の文字列に「追
加」します。

‘$[]’ ( u $[]addr – addr’  ) gforth-1.0 “string-array”
   addr’ は、 文字列配列 $[]addr の u 番目の要素のアドレスです。 配列の
サイズは必要に応じて変更されます。

‘$[]!’ ( c-addr u n $[]addr –  ) gforth-1.0 “string-array-store”
   文字列 c-addr u を文字列配列 $[]addr のインデックス n に格納します。
必要に応じて配列のサイズが変更されます。

‘$[]+!’ ( c-addr u n $[]addr –  ) gforth-1.0 “string-array-plus-store”
   文字列 c-addr u をインデックス n の文字列に「追加」します。 必要に応
じて配列のサイズが変更されます。 これを ‘$+[]!’ と混同しないでください。

‘$+[]!’ ( c-addr u $[]addr –  ) gforth-1.0 “string-append-array”
   文字列 c-addr u を文字列配列 $[]addr の新しい最後の要素として保存しま
す(つまり要素が1つ増える)。 必要に応じて配列のサイズが変更されます。

‘$[]@’ ( n $[]addr – addr u  ) gforth-1.0 “string-array-fetch”
   配列インデックス n から文字列を取得します — 空の場合はゼロ文字列( 0 0
)を返し、 誤って配列が成長しないようにします(訳注:要素はあるけど空文字列
(長さ0)の場合と、範囲外の要素を指した場合の区別は付かないので注意)

‘$[]#’ ( addr – len  ) gforth-1.0 “string-array-num”
   配列内の要素の数を返します

‘$[]map’ ( addr xt –  ) gforth-1.0 “string-array-map”
   文字列配列 ADDR のすべての要素に対して 実行トークン XT を実行します。
xt は ( ADDR U – ) で、一度に 1 つの文字列を取得します

‘$[]slurp’ ( fid addr –  ) gforth-1.0 “string-array-slurp”
   ファイル FID の内容を 1 行ずつ文字列配列 ADDR に入れます

‘$[]slurp-file’ ( addr u $addr –  ) gforth-1.0 “string-array-slurp-file”
   名前付きファイル ADDR U を 1 行ずつ文字列配列 $ADDR に入れます。

‘$[].’ ( addr –  ) gforth-1.0 “string-array-dot”
   すべての配列エントリを出力します

‘$[]free’ ( addr –  ) gforth-1.0 “string-array-free”
   addr は沢山のセルカウント文字列(string)へのアドレス達を含む、 セル・
カウント文字列(string)へのアドレスで、 $[]free はこれらの文字列を解放、
つまり、 この配列を開放し、 addr の値を 0 にセットします。

‘$save’ ( $addr –  ) gforth-1.0 “string-save”
   savesys のディクショナリに文字列(string)をプッシュします

‘$[]save’ ( addr –  ) gforth-1.0 “string-array-save”
   文字列配列を savesys のディクショナリにプッシュ

‘$boot’ ( $addr –  ) gforth-1.0 “string-boot”
   ディクショナリから文字列を新しく割り当てたメモリに取り込みます。 その
後、 ディクショナリのその文字列の領域を(0で)クリアします(長さはそのまま
)。

‘$[]boot’ ( addr –  ) gforth-1.0 “string-array-boot”
   ディクショナリから、 文字列配列を割り当てられたメモリに取得します

‘$saved’ ( addr –  ) gforth-1.0 “string-saved”
   アドレスを ブート済み(booted)/保存済み(saved) としてマークする

‘$[]saved’ ( addr –  ) gforth-1.0 “string-array-saved”
   アドレスを ブート済み(booted)/保存済み(saved) としてマークする

‘$Variable’ ( –  ) gforth-1.0 “string-variable”
   savesystem 全体にわたって保存される文字列変数。

‘$[]Variable’ ( –  ) gforth-1.0 “string-array-variable”
   savesystem 全体にわたって保存される文字列変数。


File: gforth.info,  Node: Counted string words,  Prev: $tring words,  Up: Strings and Characters

6.8.6 Counted string words
--------------------------

カウンタ付文字列(counted string)は、 指定のアドレスのバイトとして長さを
格納し、 その後に文字列のバイトが続きます。 可能な長さは厳しく制限されて
おり、 入力文字列を破壊せずにその場で部分文字列を作成することはできませ
ん。 したがって、 カウンタ付文字列を使用しないことをお勧めします。 それ
でも、 カウンタ付文字列を処理する必要がある場合、 以下のようなワード群が
あります:

‘count’ ( c-addr1 – c-addr2 u ) core “count”
   c-addr2 は最初の文字で、 u は c-addr1 のカウンタ付文字列の、 長さです
。

   以下のワードは、 (‘s"’ とは異なり) 有用なインタプリタ機能
(interpretation semantics)がなく、 (‘[char]’ とは異なり) 対応するインタ
プリタ用コードがないため、 コロン定義内でのみ使用する必要があります(コロ
ン定義がある場合):

‘C"’ ( compilation "ccc<quote>" – ; run-time  – c-addr  ) core-ext “c-quote”
   コンパイル状態: ‘"’ (二重引用符) を区切り文字として文字列 ccc をパー
スします。 その実行時コードは、 指定のカウンタ付文字列 ccc のアドレスを
c-addr として返します。 インタプリタ機能は未定義です。

   ( gforth-obsolete ) ‘place’ ( c-addr1 u c-addr2 –) \ C-ADDR2 に長さ U
のカウンタ付き文字列を作成し、 文字列 C-ADDR1 U をその場所にコピーします
。
‘string,’ ( c-addr u –  ) gforth-0.2 “string,”
   文字列をカウンタ付き文字列として(here以降の)データ空間に書き込みます
。


File: gforth.info,  Node: Control Structures,  Next: Defining Words,  Prev: Strings and Characters,  Up: Words

6.9 Control Structures
======================

Forth の制御構造は、 コロン定義内のみで、 対話的(interpretively)に使用す
ることはできません(1)。 私たちもこのような制限を好まないので、 多くのス
キームが提案されてはいますが、 これを回避する満足のいく方法はまだ見つか
っていません。

* Menu:

* Selection::                IF ... ELSE ... ENDIF
* Simple Loops::             BEGIN ...
* Counted Loops::            DO
* BEGIN loops with multiple exits::
* General control structures with CASE::
* Arbitrary control structures::
* Calls and returns::
* Exception Handling::

   ---------- Footnotes ----------

   (1) 正確には、 インタプリタ機能(interpretation semantics)(*note
Interpretation and Compilation Semantics::)を持っていません


File: gforth.info,  Node: Selection,  Next: Simple Loops,  Prev: Control Structures,  Up: Control Structures

6.9.1 Selection
---------------

     flag
     IF
       code
     ENDIF

   flag がゼロ以外の場合(‘IF’ などに関する限り、 任意のビットが設定され
たセルは true 扱いです)、 code が実行されます。

     flag
     IF
       code1
     ELSE
       code2
     ENDIF

   FLAG が true の場合は code1 が実行され、 それ以外の場合は code2 が実
行されます。

   ‘ENDIF’ の代わりに ‘THEN’ を使用できます。 実際 ‘THEN’ は標準です、 が
しかし、 ‘ENDIF’ は非常に人気があるものの、 標準ではありません。 私達は
‘ENDIF’ の使用をお勧めします。 なぜなら、 他の言語を知っている人にとって
も混乱が少ないためです(また、 ‘ENDIF’ に対しては、 これらの人々の Forth
に対する否定的な偏見が強化される傾向が見られません)。 なお、 ‘THEN’ のみ
を提供するシステムに ‘ENDIF’ を追加するのは以下のように簡単です:
     : ENDIF   POSTPONE then ; immediate

   [‘Webster’s New Encyclopedic Dictionary’ によると、“then (副詞)” には
以下の意味があります:
     ...  2b: 順番に次の後に続く ...  3d: 必然的な結果として (if you
     were there, then you saw them)
   Forth の ‘THEN’ は 2b の意味を持ちますが、 Pascal や他の多くのプログ
ラミング言語の ‘THEN’ は 3d の意味を持ちます。]

   Gforth には ‘?DUP-IF’ および ‘?DUP-0=-IF’ というワードも用意されてい
るため、 ‘?dup’ の使用を避けることができます。これらの代替手段を使用する
ことは、 ‘?dup’ を使用するよりも効率的です。 ‘ENDIF’ や ‘?DUP-IF’ や
‘?DUP-0=-IF’ の標準 Forth での定義は、‘compat/control.fs’ で提供されます
。

     x
     CASE
       x1 OF code1 ENDOF
       x2 OF code2 ENDOF
       ...
       ( x ) default-code ( x )
     ENDCASE ( )

   xi が x に等しいなら、 最初の codei を実行します。 x1 〜 xn のいずれ
も一致しない場合は、 オプションの default-code が実行されます。 オプショ
ンのデフォルト・ケースは、 最後の ‘ENDOF’ の後にコードを記述するだけで追
加できます。 スタック頂上にある x を使用することはできますが、 それを消
費してはなりません。 値 x は、 この構造によって(一致する ‘OF’ によって、
または一致する OF がない場合は ‘ENDCASE’ によって) 消費されます。 例:

     : num-name ( n -- c-addr u )
      case
        0 of s" zero " endof
        1 of s" one "  endof
        2 of s" two "  endof
        \ default case:
        s" other number"
        rot \ get n on top so ENDCASE can drop it
      endcase ;

   (非標準の) ‘?of’ を使用して、 ‘case’ を 3 つ以上の選択肢の一般的な選
択構造として使用することもできます。 ‘?Of’ はフラグを受け取ります。 例:

     : sgn ( n1 -- n2 )
         \ sign function
         case
     	dup 0< ?of drop -1 endof
     	dup 0> ?of drop 1 endof
     	dup \ n1=0 -> n2=0; dup an item, to be consumed by ENDCASE
         endcase ;

   プログラミング・スタイル・メモ: コードを理解しやすくするには、 選択構
造を介したすべての経路で同一の方法でスタックを変更(消費およびプッシュさ
れるスタック項目の数と型)するようにする必要があります。


File: gforth.info,  Node: Simple Loops,  Next: Counted Loops,  Prev: Selection,  Up: Control Structures

6.9.2 Simple Loops
------------------

     BEGIN
       code1
       flag
     WHILE
       code2
     REPEAT

   code1 が実行され、 flag が計算されます。 flag が true の場合、 code2
が実行され、 BEGIN からループが再開されます。 flag が false の場合、
‘REPEAT’ の後へ実行が続行されます。

     BEGIN
       code
       flag
     UNTIL

   code が実行されます。 ‘flag’ が false の場合、 BEGIN からループが再開
されます。

   プログラミング・スタイル・メモ: コードを理解しやすくするために、 ルー
プの完全な反復(complete iteration)によってスタック上の項目の数と型が変更
されるべきではありません。

     BEGIN
       code
     AGAIN

   これは無限ループです。


File: gforth.info,  Node: Counted Loops,  Next: BEGIN loops with multiple exits,  Prev: Simple Loops,  Up: Control Structures

6.9.3 Counted Loops
-------------------

基本のカウント・ループ:
     limit start ?DO
       body
     LOOP

   これは、 start から始まり limit まで(limit 自身は除く)、 各整数値に対
して 1 回の反復を実行します。 カウンタ、 つまりインデックスには、 ‘i’ を
使用してアクセスできます。 たとえば、 以下のループをご覧ください:
     10 0 ?DO
       i .
     LOOP
出力: ‘0 1 2 3 4 5 6 7 8 9’

   最も内側のループのインデックスには ‘i’ を使用してアクセスでき、 その
一つ外側のループのインデックスには ‘j’ を使用してアクセスでき、 さらにも
う一つ外側のループのインデックスには ‘k’ を使用してアクセスできます。

   ‘i'’ を使用すると最も内側のループの limit にアクセスでき、 ‘delta-i’
を使用すると ‘i'’ - ‘i’ にアクセスできます。

     : foo 7 5 ?do cr i . i' . delta-i . loop ;

   出力:

     5 7 2
     6 7 1

   ループ制御データはリターン・スタックに保持されるため、 リターン・スタ
ックへのアクセスとカウント・ループ・ワードの混在にはいくつかの制限があり
ます。 特に、ループの外側のリターン・スタックに値を置いた場合、 ループ内
で値を読み取る事はできません(1)。 ループ内のリターン・スタックに値を置く
場合は、 ループの終了前、 およびループのインデックスにアクセスする前に値
を削除する必要があります。

   カウント・ループにはいくつかのバリエーションがあります:

   • ‘LEAVE’ は、 最も内側のカウント・ループを直ちに抜け出します。 それ
     が関係する ‘LOOP’ または ‘NEXT’ の後へ実行は移ります。 例:

          10 0 ?DO  i DUP . 3 = IF LEAVE THEN LOOP
     出力: ‘0 1 2 3’

   • ‘UNLOOP’ は、 例えば ‘EXIT’ などを介しての異常なループ終了の準備を
     行います。 ‘UNLOOP’ は、 ‘EXIT’ がリターン・アドレスに到達できるよ
     うに、 リターン・スタックからループ制御パラメーターを削除します(訳
     注: 1重ループなので unloop 1つ。2重ループなら unloop 2つ)。 例:

          : demo 10 0 ?DO i DUP . 3 = IF UNLOOP EXIT THEN LOOP ." Done" ;
     出力: ‘0 1 2 3’

   • start が limit より大きい場合でも、 ‘?DO’ はループを開始します(ラッ
     プアラウンド演算(処理可能な範囲をの最後に達した後に最初に戻る事)に
     よって両者が等しくなるまで ‘LOOP’ を反復します)。 通常、 この振る舞
     いは望ましくないものです。 したがって、 Gforth は (‘?DO’ の代替とし
     て、) ‘+DO’ と ‘U+DO’ を提供します。 これらは、 start が limit より
     大きい場合にはループを開始しません。 ‘+DO’ は符号付きループ・パラメ
     ータ用で、 ‘U+DO’ は符号なしループ・パラメータ用です。

   • ‘?DO’ は ‘DO’ に置き換えることはできます。 ‘DO’ は、 ループ・パラメ
     ータ に関係なく、 常にループに入ります。 あなたが、 どの場合にもル
     ープに入ることを知っている場合でも ‘DO’ は使用しないでください。 こ
     のような知恵はプログラムを保守していく中で無効になる傾向があり、 そ
     れゆえ ‘DO’ が問題を引き起こすことになります。

   • ‘LOOP’ は ‘n +LOOP’ に置き換えることができます。 これにより、インデ
     ックスが 1 ではなく n によって更新されます。 limit-1 と limit の間
     の境界を越えると、 ループは終了します。 例:

          4 0 +DO  i .  2 +LOOP
     出力: ‘0 2’

          4 1 +DO  i .  2 +LOOP
     出力: ‘1 3’

   • n が負数の場合、 ‘n +LOOP’ の動作は奇妙です:

          -1 0 ?DO  i .  -1 +LOOP
     出力: ‘0 -1’

          0 0 ?DO  i .  -1 +LOOP
     出力: なし。

     私たちは ‘?DO’ と ‘+LOOP’ を組み合わせないことをお勧めします。
     Gfors はいくつかの代替手段を提供します:

     ‘I’=limit の反復を含める ‘-1 +LOOP’ の振る舞いが必要な場合、 ‘-[DO’
     または ‘U-[DO’] でループを開始します(ここで、 ‘[’ は、 包含範囲の数
     学的表記法(例: [1,n] からインスピレーションを得ています):

          -1 0 -[DO  i .  -1 +LOOP

     出力: ‘0 -1’.

          0 0 -[DO  i .  -1 +LOOP

     出力: ‘0’

          0 -1 -[DO  i .  -1 +LOOP

     出力: なし。

     limit を除外したい場合、 代わりに ‘1 -LOOP’ (または一般的には ‘u
     -LOOP’)を使用し、 ‘?DO’ または ‘-DO ’ または ‘U-DO’ でループを開始
     します。 ‘-LOOP’ は、limit+1 と limit の間の境界を越えたときにルー
     プを終了します。 例:

          -2 0 -DO  i .  1 -LOOP
     出力: ‘0 -1’

          -1 0 -DO  i .  1 -LOOP
     出力: ‘0’

          0 0 -DO  i .  1 -LOOP
     出力: なし。

     残念ながら、 ‘+DO’, ‘U+DO’, ‘-DO’, ‘U-DO’, ‘-LOOP’ は 標準 Forth で
     は定義されていません。 ただし、 標準のワードのみを使用するこれらの
     ワードの実装が ‘compat/loops.fs’ にて提供されています。

   • よくある作業は、 配列の要素を前方または後方に反復処理することです。
     要素のアドレスに対して反復処理することには 2 つの利点があります。 配
     列の開始アドレスを保持する必要がなくなり、 データ・スタックの負荷が
     軽減されます。 また、 反復ごとにアドレス計算を実行する必要がなくな
     ります。 欠点は、 通常の配列表現 addr u要素 または addr uバイト か
     ら始めて、 start アドレスと limit アドレスを生成するために何らかの
     処理が必要なことです。 Gforth には、addr ubytes 表現からそこに到達
     するために ‘bounds’ があるため、セル配列 ‘v’ を介した前方ループを以
     下のように記述できます:

          create v 1 , 3 , 7 ,
          : foo v 3 cells bounds U+DO i  . cell +LOOP ;
          foo

     これは ‘1 3 7’ を出力します。 逆方向にたどるための入力の前処理はよ
     り複雑であるため、 Gforth はそれを行う ‘MEM-DO’ … ‘LOOP’ 形式のルー
     プ構造を提供します。 これは addr uバイト 表現の配列と要素サイズを受
     け取り、 要素のアドレスを逆順に反復処理します。

          create v 1 , 3 , 7 ,
          : foo1 v 3 cell array>mem MEM-DO i  . LOOP ;
          foo1

     これは ‘7 3 1’ を出力します。‘ARRAY>MEM’ は addr uelems uelemsize を
     ‘MEM-DO’ が期待する addr ubytes uelemsize に変換します(ubytes は
     uelems * uelmsize です)。 このループは ‘MEM-DO’ 通過後にuelemsize ず
     つ減算される、 ‘LOOP’ と対になるループとなります。

     Gforth は、 完全を期すために ‘MEM+DO’ も追加します。 ‘MEM-DO’ と同
     一のパラメータを受け取りますが、 配列を順(forwards)に処理します:

          create v 1 , 3 , 7 ,
          : foo2 v 3 cell array>mem MEM+DO i  . LOOP ;
          foo2

     出力: ‘1 3 7’

   • 別のカウント・ループ:
          n
          FOR
            body
          NEXT
     これは、 ‘?DO’ ループを適切に最適化するのが面倒な、 ネイティブ・コ
     ード・コンパイラ作成者達が好むループです。 このループ構造は標準
     Forth では定義されていません。 Gforth では、 このループは n+1 回繰
     り返します。 ‘i’ は、 n で始まり 0 で終わる値を生成します。 他の
     Forth システムは、‘FOR’ ループをサポートしている場合でも、 振る舞い
     が異なる場合があります。 この問題を回避するには、 ‘FOR’ ループを使
     用しないようにしてください。

   カウント・ループ・ワード群:

‘?DO’ ( compilation – do-sys ; run-time w1 w2 – | loop-sys  ) core-ext “question-do”
   *Note Counted Loops::.

‘+DO’ ( compilation – do-sys ; run-time n1 n2 – | loop-sys  ) gforth-0.2 “plus-do”
   *Note Counted Loops::.

‘U+DO’ ( compilation – do-sys ; run-time u1 u2 – | loop-sys  ) gforth-0.2 “u-plus-do”
   *Note Counted Loops::.

‘bounds’ ( addr u – addr+u addr ) gforth-0.2 “bounds”
   開始アドレス addr と長さ u で表されるメモリ・ブロックを指定すると、
‘u+do’ または ‘?do’ の終了アドレス addr+u と開始アドレス addr を正しい順
序で生成します。

‘-[do’ ( compilation – do-sys ; run-time n1 n2 – | loop-sys  ) gforth-experimental “minus-bracket-do”
   負の方向へカウントされるループを開始します。 n2<n1 の場合、 ループを
スキップします。 このようなカウント・ループは、 増分が負である ‘+loop’ と
対になります。 ‘I’>=n1 である限り実行されます。

‘u-[do’ ( compilation – do-sys ; run-time u1 u2 – | loop-sys  ) gforth-experimental “u-minus-bracket-do”
   負の方向へカウントするループを開始します。 u2<u1 の場合、ループをスキ
ップします。 このようなカウント・ループは、 増分が負の ‘+loop’ と対にな
ります。 ‘I’>=u1 である限り実行されます。

‘-DO’ ( compilation – do-sys ; run-time n1 n2 – | loop-sys  ) gforth-0.2 “minus-do”
   *Note Counted Loops::.

‘U-DO’ ( compilation – do-sys ; run-time u1 u2 – | loop-sys  ) gforth-0.2 “u-minus-do”
   *Note Counted Loops::.

   ‘array>mem’ ( uelements uelemsize – ubytes uelemsize) \ ubytes は
uelements * uelementsize です
‘mem+do’ ( compilation – w xt do-sys; run-time addr ubytes +nstride –  ) gforth-experimental “mem-plus-do”
   ‘I’ を addr から開始し、 ‘I’<addr+ubytes である限り、 nstride 幅のス
テップでメモリ内をアドレスが増える方向にカウント・アップするカウント・ル
ープを開始します。 loop と対にする必要があります。

‘mem-do’ ( compilation – w xt do-sys; run-time addr ubytes +nstride –  ) gforth-experimental “mem-minus-do”
   ‘I’ を addr+ubytes-ustride として開始し、 ‘I’>=addr である間 -nstride
幅のステップでメモリをアドレス下位方向(backward)にステップするカウント・
ループを開始します。 loop と対にしなければなりません。

‘DO’ ( compilation – do-sys ; run-time w1 w2 – loop-sys  ) core “DO”
   *Note Counted Loops::.

‘FOR’ ( compilation – do-sys ; run-time u – loop-sys  ) gforth-0.2 “FOR”
   *Note Counted Loops::.

‘LOOP’ ( compilation do-sys – ; run-time loop-sys1 – | loop-sys2  ) core “LOOP”
   *Note Counted Loops::.

‘+LOOP’ ( compilation do-sys – ; run-time loop-sys1 n – | loop-sys2  ) core “plus-loop”
   *Note Counted Loops::.

‘-LOOP’ ( compilation do-sys – ; run-time loop-sys1 u – | loop-sys2  ) gforth-0.2 “minus-loop”
   *Note Counted Loops::.

‘NEXT’ ( compilation do-sys – ; run-time loop-sys1 – | loop-sys2  ) gforth-0.2 “NEXT”
   *Note Counted Loops::.

‘i’ ( R:n – R:n n ) core “i”
   n は、最も内側のカウント・ループのインデックスです。

‘j’ ( R:n R:w1 R:w2 – n R:n R:w1 R:w2 ) core “j”
   n は、 最も内側から数えて 2 番目のカウント・ループのインデックスです
。

‘k’ ( R:n R:w1 R:w2 R:w3 R:w4 – n R:n R:w1 R:w2 R:w3 R:w4 ) gforth-0.3 “k”
   n は、 最も内側から数えて3番目のカウント・ループのインデックスです。

‘i'’ ( R:w R:w2 – R:w R:w2 w ) gforth-0.2 “i-tick”
   最も内側のカウント・ループの limit

‘delta-i’ ( r:ulimit r:u – r:ulimit r:u u2 ) gforth-1.0 “delta-i”
   u2=‘I'’-‘I’ (limit とインデックスの差)

‘LEAVE’ ( compilation – ; run-time loop-sys –  ) core “LEAVE”
   *Note Counted Loops::.

‘?LEAVE’ ( compilation – ; run-time f | f loop-sys –  ) gforth-0.2 “question-leave”
   *Note Counted Loops::.

‘unloop’ ( R:w1 R:w2 – ) core “unloop”

‘DONE’ ( compilation do-sys – ; run-time –  ) gforth-0.2 “DONE”
   do-sys までのすべての LEAVE を解決します(訳注: loop, +loop , next 等
の中で内部的に呼び出されます)。

   標準では、 do-sys で ‘CS-PICK’ や ‘CS-ROLL’ を使用することは許可され
ていません。 ‘MEM+DO’ と ‘MEM-DO’ によって生成される do-sys を除いて、
Gforth では ‘CS-PICK’ や ‘CS-ROLL’ の使用を許可しますが、 すべての ‘?DO’
などに対して、 定義を介した任意の経路上に ‘UNLOOP’ が正確に 1 つだけ存在
すること(‘LOOP’ などの失敗経路上で ‘UNLOOP’ コンパイルするなど)を確認す
るのはあなたの仕事です。 また、 すべての ‘LEAVE’ が（ループ終了ワードの
1 つまたは ‘DONE’ を使用して)解決されていることを確認する必要があります
。

   ---------- Footnotes ----------

   (1) ええ、まぁ、 移植可能な方法ではできません、 ぐらいな


File: gforth.info,  Node: BEGIN loops with multiple exits,  Next: General control structures with CASE,  Prev: Counted Loops,  Up: Control Structures

6.9.4 ‘Begin’ loops with multiple exits
---------------------------------------

カウント・ループの場合、 複数箇所で ‘leave’ を使用できます。 ‘begin’ ル
ープの場合は、 以下の選択肢があります:

   ループ内で ‘exit’ を使用(複数記述できます)すると、 ループだけでなくコ
ロン定義全体からも去ります。 例:

     : foo
       begin
         condition1 while
           condition2 if
             exit-code2 exit then
           condition3 if
             exit-code3 exit then
         ...
       repeat
       exit-code1 ;

   このアプローチの欠点は、 ループ後に共通コードが必要な場合、 共通コー
ドを含む別のワードで ‘foo’ を包むか、 または、 それぞれの exit-code から
共通コードを呼び出す必要があることです。

   もう 1 つのアプローチは、 ‘begin’ ループ内で複数の ‘while’ を使用する
ことです。 追加の ‘while’ ごとにループの後ろに ‘then’ を追加する必要があ
ります。 例:

     begin
       condition1 while
         condition2 while
           condition3 while
     again then then then

   ここでは、 ループの最後に ‘again’ を使用して、 各 ‘while’ に ‘then’ を
用意しました。 ‘repeat’ は ‘then’ を 1 つ減らしますが、 それ以外の場合は
同じ動作になります。 これが機能する理由の説明については、 *Note
Arbitrary control structures:: をご覧下さい。

   後で共通のコードを使用することはできますが、 上で示したように、 異な
る出口(exit)に対して異なる exit-code を使用することはできません。 以下の
ようにすると、 これらの異なる exit-code を使用できます:

     begin
       condition1 while
         condition2 while
           condition3 while
     again then exit-code3
     else exit-code2 then
     else exit-code1 then

   exit-code は終了条件から比較的離れているため、 これを理解するのは比較
的困難です(このような制御構造に慣れていないことも理由にはなりません)。


File: gforth.info,  Node: General control structures with CASE,  Next: Arbitrary control structures,  Prev: BEGIN loops with multiple exits,  Up: Control Structures

6.9.5 General control structures with ‘case’
--------------------------------------------

Gforth は、 拡張 ‘case’ を提供することで、 上で説明した複数出口ループの
問題を解決する追加のオプションを提供します。 この拡張 ‘case’ の移植可能
な実装は ‘compat/caseext.fs’ にあります。

   この拡張には 3 つの追加ワードがあります。 1 つ目は ‘?of’ で、 ‘case’
内で(単なる同等性のテストではなく、)一般的なテストが可能です。 例:

     : sgn ( n -- -1|0|1 )
       ( n ) case
         dup 0 < ?of drop -1 endof
         dup 0 > ?of drop 1  endof
         \ otherwise leave the 0 on the stack
       0 endcase ;

   注意: ‘endcase’ は値(a value)を drop することに注意してください。 こ
れは ‘of’ ではほとんどうまいこと機能しますが、 ‘?of’ ではたいていうまい
こといかないので、 今回も ‘endcase’ で drop するための値として 0 をスタ
ック置きます。 ここでは、 ‘sgn’ に渡される n は、 いずれの ‘?of’ もトリ
ガーしない場合返り値の 0 そのものになります。

   2 番目の追加ワードは ‘next-case’ で、 これにより ‘case’ をループに変
えることができます。 出口が3つのループは以下のようになります:

     case
       condition1 ?of exit-code1 endof
       condition2 ?of exit-code2 endof
       condition3 ?of exit-code3 endof
       ...
     next-case
     common code afterwards

   ご覧のとおり、 これにより、 先程議論したバリエーションの両方の問題が
解決されます(*note BEGIN loops with multiple exits::)。 注意: ‘endcase’
とは異なり、 ‘next-case’ は値をドロップしないことに注意してください。
(1)

   最後の追加ワードは ‘contof’ です。 これは ‘endof’ の代わりに使用され
、 ループを終了する代わりに次の反復を開始します。 これは、 ダイクストラ
のガード付きコマンド 繰り返し: do と同様の方法で使用できます。 例:

     : gcd ( n1 n2 -- n )
         case
             2dup > ?of tuck - contof
             2dup < ?of over - contof
         endcase ;

   ここで、 2 つの ‘?of’ はループを継続する異なる方法を持っています。 ど
ちらの ‘?of’ もトリガーされない場合、 2 つの数値は等しく、gcd(最大公約数
) になります。 ‘Endcase’ はそれらの 1 つを削除し、もう 1 つは n として残
します。

   これらのワードを組み合わせることもできます。 以下は、 ‘endcase’ を除
く、 各 ‘case’ ワードをそれぞれ 1 回使用する例です:

     : collatz ( u -- )
         \ print the 3n+1 sequence starting at u until we reach 1
         case
             dup .
             1 of endof
             dup 1 and ?of 3 * 1+ contof
             2/
         next-case ;

   この例では、 シーケンスの現在の値をスタックに保持します。 1 の場合、
‘of’ がトリガーされ、 値が削除され、 ‘case’ 構造から去ります。 奇数の場
合、 ‘?of’ がトリガーされ、 3n+1 が計算され、 ‘contof’ で次の反復が開始
されます。 それ以外の場合、 数値が偶数の場合は 2 で除算され、
‘next-case’ でループが再開されます。

   ---------- Footnotes ----------

   (1) ‘next-case’ は、 他の ‘case’ ワード群とは異なり、 名前にハイフン
(‘-’)が含まれています。 VFX Forth には値をドロップする ‘nextcase’ がある
ので、これと区別するためです。


File: gforth.info,  Node: Arbitrary control structures,  Next: Calls and returns,  Prev: General control structures with CASE,  Up: Control Structures

6.9.6 Arbitrary control structures
----------------------------------

標準 Forth は、 ネストされない方法での制御構造の使用を許可・サポートしま
す。 まだ完成されてない制御構造に関する情報は、 制御フロー・スタック
(control-flow stack)に保存されます。 このスタックは Forth のデータ・スタ
ック上に実装でき、 Gforth はそうしました。

   orig エントリは未解決の前方分岐を表し、 dest エントリは後方分岐ターゲ
ットを表します。 いくつかのワードは、 可能なあらゆる制御構造を構築するた
めの基礎となります(ストレージを必要とする制御構造を除く、 呼び出しやコル
ーチンやバックトラッキングなど)。

‘IF’ ( compilation – orig ; run-time f –  ) core “IF”
   実行時(run-time)、 f=0 の場合、 orig を消費する ‘THEN’ (または
‘ELSE’) の後から実行が続行されます。 それ以外の場合は、 ‘IF’ の直後に続
きます(*note Selection::)。

‘AHEAD’ ( compilation – orig ; run-time –  ) tools-ext “AHEAD”
   実行時、 orig を消費する ‘THEN’ の後から実行が続行されます。

‘THEN’ ( compilation orig – ; run-time –  ) core “THEN”
   orig にプッシュした ‘IF’ または ‘AHEAD’ または ‘ELSE’ または ‘WHILE’
は、 ‘THEN’ の直後にジャンプします(*note Selection::)。

‘BEGIN’ ( compilation – dest ; run-time –  ) core “BEGIN”
   dest を消費する ‘UNTIL’ または ‘AGAIN’ または ‘REPEAT’ は、 ‘BEGIN’ の
直後へジャンプします(*note Simple Loops::)。

‘UNTIL’ ( compilation dest – ; run-time f –  ) core “UNTIL”
   実行時、 f=0 の場合、 dest を生成した ‘BEGIN’ の後で実行が続行されま
す。 それ以外の場合は、 ‘UNTIL’の直後から実行が続行されます(*note Simple
Loops::)。

‘AGAIN’ ( compilation dest – ; run-time –  ) core-ext “AGAIN”
   実行時、 dest を生成した ‘BEGIN’ の後から実行が続行されます(*note
Simple Loops::)。

‘CS-PICK’ ( orig0/dest0 orig1/dest1 ... origu/destu u – ... orig0/dest0  ) tools-ext “c-s-pick”

‘CS-ROLL’ ( destu/origu .. dest0/orig0 u – .. dest0/orig0 destu/origu  ) tools-ext “c-s-roll”

‘CS-DROP’ ( dest –  ) gforth-1.0 “CS-DROP”

   標準ワードの ‘CS-PICK’ や ‘CS-ROLL’ を使用すると、 移植可能な方法で制
御フロー・スタックを操作できます。 これら無しだと制御フロー・エントリが
占めるスタック項目の数を知る必要があります(多くのシステムは 1 つのセルを
使用します。 Gforth では現在 3 つを使用しますが、 これは将来変更される可
能性があります)。

   orig は 1 回だけ解決する必要があるため、 ‘CS-PICK’ は dest を pick す
ることしかできず、 かつ、 ‘CS-DROP’ は dest を drop することしかできませ
ん。

   一部の標準の制御構造ワードは、 以下のワード群から構築されます:

‘ELSE’ ( compilation orig1 – orig2 ; run-time –  ) core “ELSE”
   実行時、 orig を消費する ‘THEN’ の後から実行が続行されます。 orig1 を
プッシュした ‘IF’ または ‘AHEAD’ または ‘ELSE’ または ‘WHILE’ は、
‘ELSE’ の直後にジャンプします(*note Selection::)。

‘WHILE’ ( compilation dest – orig dest ; run-time f –  ) core “WHILE”
   実行時、 f=0 の場合、 orig を消費する ‘REPEAT’ (または ‘THEN’ または
‘ELSE’) の後から実行が継続されます。 それ以外の場合は、 ‘WHILE’ の直後か
ら実行されます(*note Simple Loops::)。

‘REPEAT’ ( compilation orig dest – ; run-time –  ) core “REPEAT”
   実行時、 dest を生成した ‘BEGIN’ の後から実行が続行されます。 orig を
プッシュした ‘WHILE’ または ‘IF’ または ‘AHEAD’ または ‘ELSE’ は、
‘REPEAT’ の直後にジャンプします(*note Simple Loops::)。

Gforth は、さらにいくつかの制御構造ワードを追加します:

‘ENDIF’ ( compilation orig – ; run-time –  ) gforth-0.2 “ENDIF”
   ‘THEN’ と同一です。

‘?dup-IF’ ( compilation – orig ; run-time n – n|  ) gforth-0.2 “question-dupe-if”
   これは、スタック・チェッカー(stack checker)などのツールでより適切に処
理できるため、 イディオム「‘?DUP IF’」の代替として推奨されます。 しかも
、 ‘?DUP IF’ より速いです。

‘?DUP-0=-IF’ ( compilation – orig ; run-time n – n|  ) gforth-0.2 “question-dupe-zero-equals-if”

制御構造ワードのもう一つのグループ:

‘case’ ( compilation  – case-sys ; run-time  –  ) core-ext “case”
   ‘case’ 構造の開始。

‘endcase’ ( compilation case-sys – ; run-time x –  ) core-ext “end-case”
   ‘case’ 構造を終わらせます。 x を drop して、‘endcase’ の後ろへ進みま
す。 x の drop は、 元の(‘of’ のみの)‘case’ 構造では便利ですが、 他の場
合(特に ‘?of’ を使用する場合)では(drop する為の) x を明示的に指定する必
要がある場合があります。

‘next-case’ ( compilation case-sys – ; run-time –  ) gforth-1.0 “next-case”
   マッチする ‘case’ にジャンプして、 ‘case’ ループを再開します。
‘endcase’ とは異なり、 ‘next-case’ はセルを drop しないことに注意してく
ださい。

‘of’ ( compilation  – of-sys ; run-time x1 x2 – |x1  ) core-ext “of”
   x1=x2 の場合は続行します(両方を drop します)。 それ以外の場合は、 x1
をスタック上に残し、 ‘endof’ または ‘contof’ の後ろにジャンプします。

‘?of’ ( compilation  – of-sys ; run-time  f –  ) gforth-1.0 “question-of”
   f が true の場合は続行します。 それ以外の場合は、 ‘endof’ または
‘contof’ の後ろにジャンプします。

‘endof’ ( compilation case-sys1 of-sys – case-sys2 ; run-time  –  ) core-ext “end-of”
   ‘endcase’/‘next-case’ の後ろにジャンプして、 囲んでいる ‘case’ 構造体
を終了(exit)します。

‘contof’ ( compilation case-sys1 of-sys – case-sys2 ; run-time  –  ) gforth-1.0 “cont-of”
   囲んでいる ‘case’ にジャンプして、 ‘case’ ループを再開します。

   内部的には、 of-sys は ‘orig’ で、 case-sys はセルとスタック深さ情報
と、0 個以上の ‘orig’ と、 ‘dest’ です。

6.9.6.1 Programming Style
.........................

読みやすさを確保するために、 任意の制御構造を直接作成せず、 必要な制御構
造に対して新しい制御構造ワードを定義し、 プログラム内でこれらのワードを
使用することをお勧めします。たとえば、 以下のように書く代わりに:

     BEGIN
       ...
     IF [ 1 CS-ROLL ]
       ...
     AGAIN THEN

以下のように制御構造のワードを定義することをお勧めします。 例:

     : WHILE ( DEST -- ORIG DEST )
      POSTPONE IF
      1 CS-ROLL ; immediate

     : REPEAT ( orig dest -- )
      POSTPONE AGAIN
      POSTPONE THEN ; immediate

そして、 次に、 これらを使用して制御構造を作成します:

     BEGIN
       ...
     WHILE
       ...
     REPEAT

   このほうがずっと読みやすいですよね。 もちろん、 ‘REPEAT’ と ‘WHILE’ は
定義済みなので、 この例を見て改めて定義する必要はありません。


File: gforth.info,  Node: Calls and returns,  Next: Exception Handling,  Prev: Arbitrary control structures,  Up: Control Structures

6.9.7 Calls and returns
-----------------------

呼び出す定義の名前を記述するだけで定義を呼び出すことができます。 通常、
定義はそれ自身の定義中は表示されません。 直接再帰的な定義を記述したい場
合は、 ‘recursive’ を使用して現在の定義を見えるようにする(使えるようにす
る)か、 ‘recurse’ を使用して現在の定義を直接呼び出すことができます。

‘recursive’ ( compilation – ; run-time –  ) gforth-0.2 “recursive”
   現在の定義中の定義をその定義内で呼び出せるように(表示できるように)し
、 それ自体を再帰的に呼び出せるようにします。

‘recurse’ ( ... – ...  ) core “recurse”
   現在の定義の別名(alias)。

これらのワードの使用例については *Note Recursion Tutorial:: を参照してく
ださい。

   プログラミング・スタイル・メモ: 私は、‘recurse’ よりも ‘recursive’ を
使用することを好みます。 名前で定義を呼び出す方が、 やや難解な ‘recurse’
よりも説明的であるためです(名前が適切に選択されていれば)。 たとえば、ク
イックソートの実装では、「今、再帰呼び出しを行う」(now do a recursive
call)と読むよりも、「今、パーティションをソートする」(now sort the
partitions)と読む(そして考える)方がはるかに優れています。

   相互再帰(mutual recursion)の場合は、 以下のように ‘defer’ ワードを使
用します:

     Defer foo

     : bar ( ... -- ... )
      ... foo ... ;

     :noname ( ... -- ... )
      ... bar ... ;
     IS foo

   defer された ワードについては、 *note Deferred Words:: で詳しく説明し
ます。

   定義の終わりに達するか、 ‘EXIT’ に遭遇すると、 現在の定義は呼び出し元
の定義に制御を返します。

‘EXIT’ ( compilation – ; run-time nest-sys –  ) core “EXIT”
   呼び出し元の定義に戻る(return): 通常、 定義から速やかに戻るのを強制す
る方法として使用されます。 ‘EXIT’ する前に、 リターン・スタックをクリー
ンアップし、 未処理の ‘?DO’...‘LOOP’ を ‘UNLOOP’ する必要があります。 ロ
ーカル変数(local)が無い場合に ‘exit’ のように動作するティック可能なワー
ド(tickable word)には ‘;s’ を使用します。

‘?EXIT’ ( –  ) gforth-0.2 “?EXIT”
   f が true の場合、 呼び出し元の定義に戻ります(return)。

‘;s’ ( R:w – ) gforth-0.2 “semis”
   ‘EXIT’ によってコンパイルされたプリミティブ。


File: gforth.info,  Node: Exception Handling,  Prev: Calls and returns,  Up: Control Structures

6.9.8 Exception Handling
------------------------

ワードが処理できないエラー状態を検出した場合、 例外を投げる(‘throw’)こと
ができます。 最も単純なケースでは、 これによりプログラムが終了し、適切な
エラーが報告されます。

‘throw’ ( y1 .. ym nerror – y1 .. ym / z1 .. zn error  ) exception “throw”
   nerror が 0 の場合は、 それを drop して続行します。 それ以外の場合は
、 動的に囲んでいる次の例外ハンドラー(next dynamically enclosing
exception handler)に制御を移し、 それに応じてスタックをリセットし、
nerror をプッシュします。

‘fast-throw’ ( ... wball – ... wball ) gforth-experimental “fast-throw”
   軽量の ‘throw’ バリエーション: ゼロ以外のみに使用され、 バックトレー
スを保存したり、 欠落している ‘catch’ を扱ったりしません。

   ‘throw’ は、スタック上のセル・サイズのエラー番号数値を消費します。 標
準 Forth には事前定義されたエラー番号がいくつかあります(‘errors.fs’ 参照
)。 Gforth (および他のほとんどのシステム)では、 さまざまなワードによって
生成された ior をエラー番号として使用できます(たとえば、 ‘allocate’ の一
般的な使用法は ‘allocate throw’ です)。 Gforth は、 (適切なエラー報告付
きで)独自のエラー番号を定義するための ‘Exception’ というワードも提供しま
す。 このワードの標準 Forth バージョン(ただしエラー・メッセージなし) は
‘compat/excel.fs’ で入手できます。 最後に、 あなた独自のエラー番号(-4095
〜 0 の範囲以外の任意の番号)を使用できますが、 表示されるのは適切なエラ
ー・メッセージではなく、数字のみです。 たとえば、 以下のことを試してみて
ください:

     -10 throw                    \ 標準で定義済
     -267 throw                   \ システムで定義済
     s" my error" exception throw \ ユーザー定義
     7 throw                      \ 思いつくままの任意の番号

‘exception’ ( addr u – n  ) gforth-0.2 “exception”
   N は、 -4095 〜 -256 の範囲内で以前に使用されていなかった ‘throw’ 値
です。 ‘Exception’ を連続して呼び出すと、 連続して減少する数値が返されま
す。 Gforth は文字列 ADDR U をエラー・メッセージとして使用します(訳注: 同
じエラーメッセージを使いまわすには、 s" hoge err msg" exception constant
hoge-error hoge-error !  などとして得られた hoge-error を使いまわす。
hoge-error throw 等する)

   エラー番号を文字列に変換するためのワード(通常は POSIX の ‘strerror’ を
モデルにしたもの)がある場合もあります。 以下のワードを使用すると、 これ
らの文字列を Gforth のエラー処理に取り込むことができます:

‘exceptions’ ( xt n1 – n2  ) gforth-1.0 “exceptions”
   throw時: xt ‘( +n -- c-addr u )’ は、 0<=n<n1 の範囲のローカルのエラ
ー・コードをエラー・メッセージに変換します。 ‘Exceptions’ は、
n2-n1<n3<=n2 の範囲で n1 個(0 〜 n1)のエラー・コードを予約します。 n2 に
、 対応する Gforth エラー・コード(ローカルのエラー番号 0 に対応。 つまり
、 0<=n<n1 の範囲のローカルのエラー・コードに 対応する Gforth エラー・コ
ードは n2 <= n3 < n2+n1)を返します。 (後の時点で)その範囲に対応した
Gforth エラー・コード n3 が throw されると、 n2-n3 がプッシュされ(つまり
ローカルのエラー番号に変換した値をプッシュし)、 xt が実行されて、 xt が
エラー・メッセージを生成します(訳注: minos2/pulse-audio.fs 等で確認。 xt
にC-interface ワードをセットし、 外部Cライブラリのエラー・メッセージを
gforth 内から表示するのに使っているようだ)

   たとえば、 C言語ライブラリの ‘errno’ エラー (および ‘strerror’ を使用
した変換) がまだ Gforth で直接サポートされていないとした場合、 以下のよ
うにして ‘strerror’ を gforth と結び付けることができます:

     ' strerror 1536 exceptions constant errno-base
     : errno-ior ( -- n )
     \ n は errno の値に対応する Gforth ior を求めなければならないので、
     \ ここでerrno 範囲と Gforth ior の範囲の間で変換する必要があります。
     \ ERRNO は Gforth ワードではないため、
     \ それにアクセスするには C インターフェイスを使用する必要があります。
       errno errno-base over - swap 0<> and ;

   C言語の関数(C言語インターフェイス(C interface)を使用)を呼び出し、 そ
の戻り値がエラーが発生したことを示している場合、 ‘errno-ior throw’ を実
行して、適切なエラー・メッセージ (“Permission denied” など)を含む例外を
生成できます。

   フラグが true の場合、 特定の err# でエラーを投げる(‘THROW’)一般的な
慣用句は以下のとおりです:

     ( flag ) 0<> err# and throw

   あなたのプログラムで、 例外をキャッチする例外ハンドラーを提供できます
。 例外ハンドラーを使用すると、 問題を修正したり、 一部のデータ構造をク
リーンアップして例外を次の例外ハンドラーに投げたり(throw)することができ
ます。 ‘throw’ は動的に最も内側の例外ハンドラー(the dynamically
innermost exception handler)にジャンプすることに注意してください。 シス
テムの例外ハンドラーは最も外側にあり、 エラーを出力してコマンド・ライン
の解釈(interpretation)を再開するだけです(または、 バッチ・モード(つまり
、 シェル・コマンド・ラインの処理中)では Gforth を終了します)。

   例外をキャッチする標準 Forth での方法は ‘catch’ です:

‘catch’ ( x1 .. xn xt – y1 .. ym 0 / z1 .. zn error  ) exception “catch”
   xt を実行します。 実行から正常に戻った場合、 ‘catch’ はスタックに 0 を
プッシュします。 ‘throw’ を介して実行が戻った場合、 すべてのスタックは
‘catch’ へ入る時点の深さにリセットされ、 TOS (xt の位置) は throw コード
に置き換えられます。

‘nothrow’ ( –  ) gforth-0.7 “nothrow”
   再 throw しない ‘catch’ または ‘endtry’ の後ろでこれ (または標準のシ
ーケンス ‘['] false catch 2drop’) を使用します。 これにより、 次の
‘throw’ でバックトレースが確実に記録されます。

   例外ハンドラーの最も一般的な使用法は、 エラーが発生したときに状態をク
リーンアップすることです。 例：

     base @ >r hex \ actually the HEX should be inside foo to protect
                   \ against exceptions between HEX and CATCH
     ['] foo catch ( nerror|0 )
     r> base !
     ( nerror|0 ) throw \ pass it on

   ‘myerror’ というエラー番号を処理するための ‘catch’ の使用は以下のよう
になります:

     ['] foo catch
     CASE
       myerror OF ... ( do something about it ) nothrow ENDOF
       dup throw \ default: pass other errors on, do nothing on non-errors
     ENDCASE

   コードを別のワードでくるむ要があるのは面倒な場合が多いため、 Gforth で
は代替構文を提供しています:

     TRY
       code1
       IFERROR
         code2
       THEN
       code3
     ENDTRY

   これは、 code1 を実行しします。 code1 が正常に完了すると、 code3 の実
行へ続きます。 code1 または、 ‘endtry’ より前で例外があった場合、 スタッ
クは ‘try’ 時の深さにリセットされ、 throw された値をデータ・スタックにプ
ッシュし、 code2 の実行に続き、 そして、 最終的に code3 に到達します。

‘try’ ( compilation  – orig ; run-time  – R:sys1  ) gforth-0.5 “try”
   例外キャッチ領域の開始

‘endtry’ ( compilation  – ; run-time  R:sys1 –  ) gforth-0.5 “endtry”
   例外キャッチ領域の終わり

‘iferror’ ( compilation  orig1 – orig2 ; run-time  –  ) gforth-0.7 “iferror”
   例外処理コードを開始します(‘try’ と ‘endtry’ の間に例外がある場合に実
行されます)。 この部分は ‘then’ で終了する必要があります。

   code2 が必要ない場合は、 ‘iferror then’ の代わりに ‘restore’ を記述で
きます:

     TRY
       code1
     RESTORE
       code3
     ENDTRY

   先程の例をこの構文で身綺麗にしてみます:

     base @ { oldbase }
     TRY
       hex foo \ now the hex is placed correctly
       0       \ value for throw
     RESTORE
       oldbase base !
     ENDTRY
     throw

   このバリエーションの追加の利点は、 ‘restore’ と ‘endtry’ の間の例外
(たとえば、 ユーザーが ‘Ctrl-C’ を押すことによる例外)でも、 ‘restore’ の
直後へコードの実行が移ることです。 ゆえに、 いかなる状況であっても base
は復元されます。

   ただし、 このコード自体が例外を引き起こさないようにする必要があります
。 そうしないと、 ‘iferror’/‘restore’ コードがループします。 さらに、
‘iferror’/‘restore’ コードで必要なスタックの内容が ‘try’ と ‘endtry’ の
間のあらゆる場所に存在することも確認する必要があります。 この例では、 こ
れは ‘try’ の前にデータをローカル変数(local)に置くことによって実現されま
す(リターン・スタック上の例外フレーム(sys1)が邪魔なのでリターン・スタッ
クは使用できません)。

   この種の使用法は、 Lisp の ‘unwind-protect’ と同様のものです。

   もし、あなたが、 この例外再開始(exception-restarting)の振る舞いを望ま
ない場合は、 以下のようにしてください:

     TRY
       code1
     ENDTRY-IFERROR
       code2
     THEN

   code1 に例外がある場合は code2 が実行され、 それ以外の場合は ‘then’ の
後ろ (または ‘else’ 分岐の可能性あり) から実行が続行されます。 これはバ
ージョン 0.7 より前の Gforth では以下の構成要素に該当します

     TRY
       code1
     RECOVER
       code2
     ENDTRY

   つまり、 この ‘recover’ を使用しているコードを直に ‘try ...
entry-iferror ... then’ へと置き換えることができます。 ただし、 その置き
換え作業中に他の ‘try’ バリエーションのいずれかを使用した方が良いかどう
かも検討することをお勧めします。

   移行を容易にするために、 Gforth は 2 つの互換性ファイルを提供します:
1つ目は ‘endtry-iferror.fs’ で、 古いシステム用に ‘try ...
endtry-iferror ... then’ 構文を提供します(ただし、 ‘iferror’ または
‘restore’ は提供しません)。 2つ目の ‘recover-endtry.fs’ は、 新しいシス
テム上で古い構文の ‘try ... recover ... endtry’ 構文を提供するので、 古
いプログラムを実行するための一時しのぎとして使用できます。 どちらのファ
イルもどのシステムでも動作します(システムが、 実装する構文を既に定義済み
の場合は何も行わないだけです)。 そのため、 古いシステムと新しいシステム
を混在させて使用している場合でも、 これらのファイルのいずれかを無条件に
‘require’ することができます。

‘restore’ ( compilation  orig1 – ; run-time  –  ) gforth-0.7 “restore”
   コードの復元(restore)を開始します。 これは、 例外がある場合と無い場合
に行われます。

‘endtry-iferror’ ( compilation  orig1 – orig2 ; run-time  R:sys1 –  ) gforth-0.7 “endtry-iferror”
   例外キャッチ領域を終了し、 その領域外で例外処理コードを開始します
(‘try’ と ‘endtry-iferror’ の間に例外がある場合に実行されます)。 この部
分は ‘then’ (または ‘else’...‘then’) で終了する必要があります。

   ここで、 エラー処理の例を以下に示します:

     TRY
       foo
     ENDTRY-IFERROR
       CASE
         myerror OF ... ( do something about it ) nothrow ENDOF
         throw \ pass other errors on
       ENDCASE
     THEN

   プログラミング・スタイル・メモ: いつものように、 エラーを渡すための
‘throw’ の後、 または ‘ENDTRY’ の後のいずれか(または、‘catch’ を使用する
場合は、エラーを処理するための選択構造の終了後)で、 スタックの深さが静的
に明白であることを保証する必要があります。

   ‘throw’ の代替は 2 つあります: ‘Abort"’ は条件付きでエラー・メッセー
ジを提供できます。 ‘Abort’ は「中止」(Abort)エラーを生成するだけです。

   これらのワードの問題は、 例外ハンドラーが、 異なる ‘abort"’ を区別で
きないことです。 例外ハンドラーにとってはそれらは ‘-2 throw’ のように見
えるだけです(標準のプログラムではエラー・メッセージにアクセスできません
)。 同様に、 ‘abort’ は例外ハンドラーに対して ‘-1 throw’ のように見えま
す。

‘ABORT"’ ( compilation ’ccc"’ – ; run-time f –  ) core,exception-ext “abort-quote”
   f のいずれかのビットがゼロ以外の場合、 ‘-2 throw’ の機能を実行し、 例
外スタック上例外フレームがない場合は文字列 ccc を表示します。

‘abort’ ( ?? – ??  ) core,exception-ext “abort”
   ‘-1 throw’.

   実行を中止する必要があるほど深刻でない問題の場合は、 警告を表示するだ
けで済みます。 変数 ‘warnings’ を使用すると、 表示される警告の数を調整で
きます。

‘WARNING"’ ( compilation ’ccc"’ – ; run-time f –  ) gforth-1.0 “WARNING"”
   f がゼロ以外の場合、 警告メッセージとして文字列 ccc を表示します。

‘warnings’ ( – addr  ) gforth-0.2 “warnings”
   以下の警告レベルをセットしてください
‘0’
     警告オフ
‘-1’
     通常警告オン
‘-2’
     初心者警告オン
‘-3’
     偏執狂的警告オン
‘-4’
     全ての警告をエラーとして扱います(初心者警告を含む)


File: gforth.info,  Node: Defining Words,  Next: Interpretation and Compilation Semantics,  Prev: Control Structures,  Up: Words

6.10 Defining Words
===================

定義ワード(defining word)は、 ディクショナリに新しいエントリを作成するこ
とによって Forth を拡張するために使用されます。

* Menu:

* CREATE::
* Variables::                Variables and user variables
* Constants::
* Values::                   Initialised variables
* Varues::
* Colon Definitions::
* Anonymous Definitions::    名前無しのワード定義
* Quotations::
* Supplying names::          定義ワードの名前を文字列として渡す
* User-defined Defining Words::
* Deferred Words::           前方参照の許容
* Forward::                  自動解決される前方参照
* Aliases::


File: gforth.info,  Node: CREATE,  Next: Variables,  Prev: Defining Words,  Up: Defining Words

6.10.1 ‘CREATE’
---------------

定義ワードは、 ディクショナリに新しいエントリを作成するために使用されま
す。 最も単純な定義ワードは ‘CREATE’ です。 ‘CREATE’ は以下のように使用
します:

     CREATE new-word1

   ‘CREATE’ はパース・ワード(parsing word)です。 つまり、入力ストリーム
から引数(argument)を受け取ります(この例では ‘new-word1’ です)。 ‘CREATE’
は ‘new-word1’ のディクショナリ・エントリを作成します。 ‘new-word1’ が実
行される時は、 アドレスがスタックに残されるだけです。 そのアドレスは、
‘new-word1’ が定義された時点のデータ空間ポインタ(‘HERE’)の値を表します。
したがって、 ‘CREATE’ は名前をメモリ領域のアドレスに関連付ける方法です。

‘Create’ ( "name" –  ) core “Create”

   注意: 標準 Forth は、 ‘create’ に対してのみ、 そのボディ部分がディク
ショナリのデータ空間(つまり、 ‘here’ や ‘allot’ などが機能する空間。
*note Dictionary allocation::)にあることを保証することに注意してください
。 また、 標準 Forth では、 ‘does>’ で変更できるのは ‘create’ で作成され
たワードのみで(*note User-defined Defining Words::)、 標準 Forth の
‘>body’ は ‘create’ されたワードにのみ適用できます。

   この new-word1 の例を拡張して、 データ空間にメモリを少々確保すると、
最終的には variable のような代物になります。 これを行う 2 つの異なる方法
を以下に示します:

     CREATE new-word2 1 cells allot  \ 1 セル予約 - 初期値未定義
     CREATE new-word3 4 ,            \ 1 セル予約 かつ (4で)初期化

   これらの変数は、 以下のように ‘@’ (「フェッチ」(fetch;取り出す)) と
‘!’ (「ストア」(store;格納する)) を使用して検査(examine)および変更
(modify)できます:

     new-word2 @ .      \ get address, fetch from it and display
     1234 new-word2 !   \ new value, get address, store to it

   同様のメカニズムを使用して配列を作成できます。 たとえば、 80 文字のテ
キスト入力バッファです:

     CREATE text-buf 80 chars allot

     text-buf 0 chars + c@ \ the 1st character (offset 0)
     text-buf 3 chars + c@ \ the 4th character (offset 3)

   メモリに適切な領域を割り当てることで、 思いつく限りの複雑なデータ構造
を構築できます。 これについてさらに詳しく説明し、 それを容易にする
Gforth ツールについて知りたい場合は、 *Note Structures:: を参照ください
。


File: gforth.info,  Node: Variables,  Next: Constants,  Prev: CREATE,  Up: Defining Words

6.10.2 Variables
----------------

前のセクションでは、 一連のコマンドを使用して変数を生成する方法を説明し
ました。 最終的な改良として、 (次のセクションの主題を先取りして)そのコー
ド・シーケンス全体を定義ワードでまとめることができ、 新しい変数の作成が
容易になります:

     : myvariableX ( "name" -- a-addr ) CREATE 1 cells allot ;
     : myvariable0 ( "name" -- a-addr ) CREATE 0 , ;

     myvariableX foo \ variable foo starts off with an unknown value
     myvariable0 joe \ whilst joe is initialised to 0

     45 3 * foo !   \ set foo to 135
     1234 joe !     \ set joe to 1234
     3 joe +!       \ increment joe by 3.. to 1237

   当然のことながら、 Forth にはすでに ‘Variable’ の定義があるため、
‘myvariable’ を定義する必要はありません。 標準 Forth は、 ‘Variable’ が
作成時に初期化されることを保証しません(つまり、 ‘myvariableX’ のように振
る舞う可能性があります)。 対照的に、Gforth の ‘Variable’ は変数を 0 に初
期化します(つまり、 ‘myvariable0’ とまったく同じように振る舞います)。
Forth は、 倍精度変数と浮動小数点変数に対して、 それぞれ ‘2Variable’ と
‘fvariable’ も提供します。 これらは、Gforth ではそれぞれ 0.  と 0e に初
期化されます。 ‘Variable’ を使用してブール値を保存する場合、 ‘on’ と
‘off’ を使用してその状態を切り替えることができます。

‘Variable’ ( "name" –  ) core “Variable”
   name を定義し、 addr で始まるセルを予約します。 name 実行時: ‘( --
addr )’

‘AVariable’ ( "name" –  ) gforth-0.2 “AVariable”
   ‘variable’ と同様に機能しますが、 (クロス・コンパイルされたコードで使
用される場合)その変数に格納されているセルがアドレスであることをクロス・
コンパイラーに伝えます。

‘2Variable’ ( "name" –  ) double “two-variable”

‘fvariable’ ( "name" –  ) floating “f-variable”

   最後に、 任意の長さのバッファは以下のようになります

‘buffer:’ ( u "name" –  ) core-ext “buffer-colon”
   name を定義し、addr から始まる u バイトを予約します。 name 実行時: ‘(
-- addr )’ なお、 Gforth は予約したバイトを 0 に初期化しますが、 標準で
は保証されません。


File: gforth.info,  Node: Constants,  Next: Values,  Prev: Variables,  Up: Defining Words

6.10.3 Constants
----------------

‘constant’ を使用すると、 固定値を宣言し、 名前でそれを参照できます。 例
:

     12 Constant INCHES-PER-FOOT
     3E+08 fconstant SPEED-O-LIGHT

   ‘Variable’ は読み取りと書き込みの両方ができるため、 その実行時の振る
舞いは、 現在の値を操作できるアドレスを提供することです。 それとは対照的
に、 ‘Constant’ の値は一度宣言すると変更できないため、 アドレスを指定す
る必要はありません(1) – 定数の値を直接返す方が効率的です。 そして正にそ
のとおりになります。 つまり、 定数の実行時の効果は、その値をスタックの頂
上に置くことです((‘Constant’ を実装する方法の1つは *note User-defined
Defining Words:: で見つけることができます)。

   Forth は、それぞれ2倍長定数と浮動小数点定数を定義するための
‘2Constant’ と ‘fconstant’ も提供します。

‘Constant’ ( w "name" –  ) core “Constant”
   定数 name を値 w で定義します。

   name 実行時: – w

‘AConstant’ ( addr "name" –  ) gforth-0.2 “AConstant”
   ‘constant’ と似ていますが、 アドレスのための定数を定義します(これはク
ロス・コンパイラーでのみ違いが生じます)。

‘2Constant’ ( w1 w2 "name" –  ) double “two-constant”

‘fconstant’ ( r "name" –  ) floating “f-constant”

   Forth の定数は、他のプログラミング言語の定数とは異なる振る舞いをしま
す。 他の言語では、 定数(アセンブラの EQU や C の #define など)はコンパ
イル時にのみ存在します。 実行プログラム(executable program)では、 定数は
即値(absolute number)に変換されているため、 シンボリック・デバッガを使用
しない限り、 その数値がどのような抽象的なものを表しているかを知ることは
不可能です。 Forth では、 定数はヘッダー空間にエントリを持ち、 それを使
用するコードが定義された後もそこに残ります。 実際、 実行時に機能する義務
があるため、 それをディクショナリに残しておく必要があります。 例:

     12 Constant INCHES-PER-FOOT
     : FEET-TO-INCHES ( n1 -- n2 ) INCHES-PER-FOOT * ;

   ここで、 ‘FEET-TO-INCHES’ が実行されると、 定数 ‘INCHES-PER-FOOT’ に
関連付けられた xt が実行されます。 ‘see’ を使用して ‘FEET-TO-INCHES’ の
定義を逆コンパイルすると、 ‘INCHES-PER-FOOT’ を呼び出していることがわか
ります。 一部の Forth コンパイラは、定数を使用する場所にインライン展開
(in-lining)することによって定数を最適化しようとします。 以下のようにして
Gforth に定数をインライン化するように強制できます:

     : FEET-TO-INCHES ( n1 -- n2 ) [ INCHES-PER-FOOT ] LITERAL * ;

   ここで、 ‘see’ を使用して ‘FEET-TO-INCHES’ の このバージョンを逆コン
パイルすると、 ‘INCHES-PER-FOOT’ が存在しないことがわかります。 これがど
のように機能するかを理解するには、 *note Interpret/Compile states:: と
*note Literals:: を読んでください。

   この方法で定数をインライン化すると、 実行時間がわずかに改善される可能
性があり、 定数がコンパイル時にのみ参照されるようにすることができます。
ただし、 定数の定義はまだディクショナリに残っています。 一部の Forth コ
ンパイラは、 一時的なワード(transient words)を保持する 2 番目のディクシ
ョナリを制御するメカニズムを提供し、 メモリ領域を回復するために後でこの
2 番目のディクショナリを削除できるようしています。 ただし、 これを行う標
準の方法はありません。

   ---------- Footnotes ----------

   (1) まあ、 多くの場合、 それは可能ではありますが、 標準的な移植可能な
方法では変更できません。 ‘Value’ を使用する方が安全です (続きを読んでく
ださい)まあ、多くの場合変更できますが、標準的な移植可能な方法では変更で
きません。 ‘Value’ (続きを読んでください)


File: gforth.info,  Node: Values,  Next: Varues,  Prev: Constants,  Up: Defining Words

6.10.4 Values
-------------

‘Value’ は ‘Constant’ のように動作しますが、 変更することができます。
‘TO’ は、‘Values’ を変更するパース・ワード(parsing word)です。 (標準
Forth ではなく) Gforth では、 ‘>body’ を使用しても ‘value’ にアクセス(お
よび変更)できます。

   ここで幾つか例を示します:

     12 Value APPLES     \ APPLES を初期値 12 で定義
     34 TO APPLES        \ APPLES の値を変更。 TO はパース・ワード
     1 ' APPLES >body +! \ APPLES をインクリメント。 非標準の使い方
     APPLES              \ スタック頂上に 35 を置く(はず)

‘Value’ ( w "name" –  ) core-ext “Value”
   name を初期値 w で定義します。 この値は ‘to name’ または ‘->name’ で
変更できます(訳注: -> と name の間に空白を開けない。 ->name とする。 ワ
ードではなく、 テキスト・インタプリタの認識器(recognizer)機能によるもの
)。

   name 実行時: – w2

‘AValue’ ( w "name" –  ) gforth-0.6 “AValue”
   ‘value’ と似ていますが、 アドレスの為の値を定義します(これはクロス・
コンパイラーでのみ違いが生じます)。

‘2Value’ ( d "name" –  ) double-ext “two-value”

‘fvalue’ ( r "name" –  ) floating-ext “f-value”
   実行時: ‘( -- r1 )’ な name を定義します。 ここで r は初期値です。 値
は ‘to name’ または ‘->name’ で変更できます。

‘TO’ ( value "name" –  ) core-ext “TO”
   NAME の値を VALUE に変更します

‘+TO’ ( value "name" –  ) gforth-1.0 “+TO”
   NAME の値に VALUE を足し込みます


File: gforth.info,  Node: Varues,  Next: Colon Definitions,  Prev: Values,  Up: Defining Words

6.10.5 Varues
-------------

(訳注: vaLue ではなくて vaRue) value のようなワードでアドレスを取得した
い場合があります。 これにはいくつかの欠点があるため、 Gforth では、 これ
について明示的に指定し、 ‘varue’を使用して名前を宣言するように求めます
(variable と value の特性を組み合わせたものであるため、 そのように名付け
られました)。

‘Varue’ ( w "name" –  ) gforth-1.0 “Varue”
   ‘value’ と似ていますが、 ‘addr name’ で得たアドレスで値にアクセスする
こともできます。 将来的には、 varues の効率が values よりも低くなる可能
性があります。

‘2varue’ ( x1 x2 "name" –  ) gforth-1.0 “2varue”
   ‘2value’ と似ていますが、 ‘addr name’ で得たアドレスで値にアクセスす
ることもできます。 将来的には、2varues は 2values よりも効率が低くなる可
能性があります。

‘fvarue’ ( r "name" –  ) gforth-1.0 “fvarue”
   ‘fvalue’ と似ていますが、 ‘addr name’ で得たアドレスで値にアクセスす
ることもできます。 将来的には、fvarues は fvalues よりも効率が低くなる可
能性があります。

‘addr’ ( "name" – addr  ) gforth-1.0 “addr”
   varue NAME または 2varue NAME または fvarue NAME のアドレスを提供しま
す。 または ‘wa: ca: da: fa: xta:’ のいずれかで定義されたローカル変数
name のアドレスを提供します。


File: gforth.info,  Node: Colon Definitions,  Next: Anonymous Definitions,  Prev: Varues,  Up: Defining Words

6.10.6 Colon Definitions
------------------------

     : name ( ... -- ... )
         word1 word2 word3 ;

‘name’ というワードを作成し、 実行時に ‘word1 word2 word3’ を実行します
。 ‘name’ は 定義(コロン定義)(“(colon) definition”) です。

   上記の説明はやや表面的です。 コロン定義の簡単な例については、 *note
Your first definition:: を参照してください。 関連する問題の一部について
の詳細な説明については、 *Note Interpretation and Compilation
Semantics:: を参照してください。

‘:’ ( "name" – colon-sys  ) core “colon”

‘;’ ( compilation colon-sys – ; run-time nest-sys –  ) core “semicolon”

   最終的には自動インライン化を実行する予定ですが、 今のところは以下のよ
うにしてインライン化を実行できます

‘inline:’ ( "name" – inline:-sys  ) gforth-experimental “inline-colon”
   インライン・コロン定義を開始します。 ‘inline:’ と ‘;inline’ の間のコ
ードは、 インライン化するコードを(実行するのではなく)コンパイルする必要
がありますが、 結果の定義 name は、 インライン化されたコードを実行するコ
ロン定義です。 コンパイルするコードはスタック効果が‘( -- )’ (スタックの
深さが変わらない)である必要があることに注意してください。 さもないと、
Gforth が name のコロン定義を作成しようとしたときにエラーが発生します。

‘;inline’ ( inline:-sys –  ) gforth-experimental “semi-inline”
   ‘inline:’ で始まるインライン定義を終了します

   例として、 インライン化されたワードを定義し、 以下のようにして使いま
す

     inline: my2dup ( a b -- a b a b )
         ]] over over [[ ;inline

     #1. my2dup d. d.
     : foo my2dup ;
     #1. foo d. d.
     see foo

   インライン・ワードはマクロ(*note Macros::)に関連しています。 マクロと
の違いは、マクロには即時コンパイル機能(immediate compilation semantics)が
あるのに対し、 ‘inline:’ で定義されたワードにはデフォルトのコンパイル機
能(compilation semantics)があることです。 つまり、 通常はコロン定義内で
のみマクロを使用しますが、 ‘inline:’ ワードは対話的(interpretively)にも
使用できることを意味します。 しかしそれは、 ‘inline:’ ワードとしては実行
できないいくつかのことをマクロでは実行できることも意味します。 例:

     \ Doesn't work:
     \   inline: endif ]] then [[ ;inline
     \ Instead, write a macro:
     : endif ]] then [[ ; immediate

   逆に、 非即時コロン定義(non-immediate colon definitions)として問題な
いワードについては、 非即時コロン定義として定義するか、 (最大限のパフォ
ーマンスが必要な場合) ‘inline:’ ワードとして定義します。 それらをマクロ
として定義しないでください。 対話的(interpretively)に適切に使用できなく
なります:

     : another2dup ]] over over [[ ; immediate
     \ Doesn't work:
     \   #1. another2dup d. d.

   なぜ ‘inline:’ と ‘;inline’ の間にコンパイル・コードを書かなければな
らないのか疑問に思われるかもしれません。 これは、 上記の ‘my2dup’ のよう
なインライン・ワードの実装が以下のように動作するためです:

     : compile-my2dup ( xt -- )
         drop ]] over over [[ ;

     : my2dup [ 0 compile-my2dup ] ;
     ' compile-my2dup set-optimizer

   ‘DROP’ や ‘0’ があるのは、 ‘compile-my2dup’ が ‘my2dup’ ための
‘compile,’ の実装であり、 ‘compile,’ は xt を期待する為です(*note
User-defined compile-comma::)。


File: gforth.info,  Node: Anonymous Definitions,  Next: Quotations,  Prev: Colon Definitions,  Up: Defining Words

6.10.7 Anonymous Definitions
----------------------------

しばしば匿名のワード(“anonymous word”)を定義したい場合があります。 つま
り、 名前無しのワードです。 これは以下のようにします:

‘:noname’ ( – xt colon-sys  ) core-ext “colon-no-name”

   これにより、 終わりの ‘;’ の後にワードの実行トークンがスタックに残り
ます。 以下は、 defer された ワード(deferred word)が匿名コロン定義
(anonymous colon definition)の ‘xt’ で初期化される例です:

     Defer deferred
     :noname ( ... -- ... )
       ... ;
     IS deferred

Gforth は、 2 つの別々のワードを使用して、 これを行う別の方法を提供しま
す:

‘noname’ ( –  ) gforth-0.2 “noname”
   次に定義するワードは匿名になります。 その定義するワードは(‘noname’が
いじる訳ではなくて)入力ストリームからのをそのままを使います(The defining
word will leave the input stream alone)。 その定義したワードの xt は
‘latestxt’ で取得します。

‘latestxt’ ( – xt  ) gforth-0.6 “latestxt”
   xt は、 最後に定義されたワードの実行トークンです。

先の例を、 ‘noname’ と ‘latestxt’ を使用して書き直すことができます:

     Defer deferred
     noname : ( ... -- ... )
       ... ;
     latestxt IS deferred

‘noname’ は、 ‘:’ だけでなく、 あらゆる定義ワードで機能します。

   ‘latestxt’ は、 最後のワードが ‘noname’ として定義されていない場合に
も機能します。 ただし、 複合ワード(combined words)には機能しません。 ま
た、 これは、 定義のヘッダーが構築されるやいなや有効になる便利なプロパテ
ィでもあります。 したがって、 以下のようにすると:

     latestxt . : foo [ latestxt . ] ; ' foo .

これは3つの数値を出力: 後ろの2つは同一の数値です。


File: gforth.info,  Node: Quotations,  Next: Supplying names,  Prev: Anonymous Definitions,  Up: Defining Words

6.10.8 Quotations
-----------------

引用(quotation)は、 別のコロン定義内の匿名コロン定義です。 引用
(quotation)は、 ‘catch’ や ‘outfile-execute’ など、 実行トークンを消費す
るワードを扱うときに便利です。 例えば、 以下の ‘outfile-execute’ (*note
Redirection::) の使用例を考えてみましょう:

     : some-warning ( n -- )
         cr ." warning# " . ;

     : print-some-warning ( n -- )
         ['] some-warning stderr outfile-execute ;

   ここで、 ‘some-warning’ をヘルパー・ワードとして定義し、 その xt を
outfile-execute に渡すことができます。 その代わりに、 引用(quotation)を
使用して ‘print-some-warning’ 内でそのようなワードを匿名で定義できます:

     : print-some-warning ( n -- )
       [: cr ." warning# " . ;] stderr outfile-execute ;

   引用(quotation)は ‘[:’ と ‘;]’ で囲まれています。 それは実行時に実行
トークンを生成します。

‘[:’ ( compile-time: – quotation-sys flag colon-sys  ) gforth-1.0 “bracket-colon”
   引用(quotation)を開始します

‘;]’ ( compile-time: quotation-sys – ; run-time: – xt  ) gforth-1.0 “semi-bracket”
   引用(quotation)を終了します


File: gforth.info,  Node: Supplying names,  Next: User-defined Defining Words,  Prev: Quotations,  Up: Defining Words

6.10.9 Supplying the name of a defined word
-------------------------------------------

デフォルトでは、 定義ワードは入力ストリームから定義されるワードの名前を
取得します。 しばしば文字列から名前を指定したい場合があります。 これは以
下のようにして行うことができます:

‘nextname’ ( c-addr u –  ) gforth-0.2 “nextname”
   次に定義されるワードの名前は C-ADDR U になります。 定義中のワードは入
力ストリームからそのままで ‘nextname’ がいじることはありません。

   例:

     s" foo" nextname create

これは以下と同等です:

     create foo

‘nextname’ は、 あらゆる定義ワードで機能します。


File: gforth.info,  Node: User-defined Defining Words,  Next: Deferred Words,  Prev: Supplying names,  Up: Defining Words

6.10.10 User-defined Defining Words
-----------------------------------

既存の定義ワードに基づいて新しい定義ワードを定義できますが、 ‘:’ と
‘create’...‘does>’/‘set-does>’ は特に柔軟です。 一方、 たとえば、
‘constant’ の子供達は全て単なる定数です。

* Menu:

* User-defined defining words with colon definitions::
* User-defined defining words using CREATE::
* CREATE..DOES> applications::
* CREATE..DOES> details::
* Advanced does> usage example::
* User-defined TO and DEFER@::
* User-defined compile-comma::
* Creating from a prototype::
* Making a word current::
* Const-does>::


File: gforth.info,  Node: User-defined defining words with colon definitions,  Next: User-defined defining words using CREATE,  Prev: User-defined Defining Words,  Up: User-defined Defining Words

6.10.10.1 User-defined defining words with colon definitions
............................................................

既存の定義ワードを定義時(defining-time)コードで取り囲み、 その取り囲んだ
一連のコードをコロン定義に入れることで、 新しい定義ワードを作成できます
。

   たとえば、 定義の xt を指定してコロン定義に関する統計を収集するワード
‘stats’ があり、 アプリケーション内のすべてのコロン定義で ‘stats’ を呼び
出す必要があるとします。 これには、 以下のように ‘:’ の新しいバージョン
を定義して使用できます:

     : stats
       ( xt -- ) DUP ." (Gathering statistics for " . ." )"
       ... ;  \ other code

     : my: : latestxt postpone literal ['] stats compile, ;

     my: foo + - ;

   ‘my:’ を使用して ‘foo’ を定義する場合、 以下のステップが実行されます:

   • ‘my:’ が実行されます。
   • 定義内の ‘:’ (‘my:’ と ‘latestxt’ の間にあるもの) が実行され、 ‘:’
     として、 いつもと同じことを行います。 名前を得るために入力ストリー
     ムをパースし、 名前 ‘foo’ のディクショナリ・ヘッダーを構築し、
     ‘state’ をインタプリタ状態からコンパイル状態に切り替えます。
   • ‘latestxt’ というワードが実行されます。 定義中のワード(‘foo’)の xt
     をスタックに置きます。
   • ‘postpone literal’ によって生成されたコードが実行されます。 これに
     より、 スタック上の値(‘foo’ の xt)が ‘foo’ のコード領域にリテラルと
     してコンパイルされます。
   • コード ‘['] stats’ は、 ‘my:’ の定義時に、 リテラルを ‘my:’ の定義
     内にコンパイルします(訳注: そして、 ‘my:’ の実行時は ‘stats’ の xt
     をスタックに積みます)。 そして、 ‘compile,’ が実行されると、 ‘foo’
     のコード領域に、 上記に続けて ‘stats’ の xt をコンパイルします(1)。
   • この時点で、 ‘my:’ の実行が完了し、 制御がテキスト・インタプリタに
     戻ります。 テキスト・インタプリタはコンパイル状態にあるため、 後続
     のテキスト ‘+ -’ は ‘foo’ の定義にコンパイルされ、 いつものように
     ‘;’ によって定義が終了します。

   ‘see’ を使用すると、 ‘my:’ を使用して定義されたワードを逆コンパイルし
、 それが通常の ‘:’ 定義とどのように異なるかを確認できます。 例:

     : bar + - ;  \ like foo but using : rather than my:
     see bar
     : bar
       + - ;
     see foo
     : foo
       `foo stats + - ;

   ‘`foo’ は ‘['] foo’ を記述する別の方法です。

   ---------- Footnotes ----------

   (1) 厳密に言えば、 ‘compile,’ が xt をコード領域内の何かに変換するた
めに使用するメカニズムは実装に依存します。 スレッド実装は実行トークンを
直接吐き出す場合がありますが、 別の実装はネイティブ・コード・シーケンス
を吐き出す場合があります


File: gforth.info,  Node: User-defined defining words using CREATE,  Next: CREATE..DOES> applications,  Prev: User-defined defining words with colon definitions,  Up: User-defined Defining Words

6.10.10.2 User-defined defining words using create
..................................................

定義ワードで定義されたワードを、 標準の定義ワードで定義されたワードとは
異なる振る舞いにしたい場合は、 以下のように定義ワードを記述できます:

     : def-word ( "name" -- )
         CREATE code1
     DOES> ( ... -- ... )
         code2 ;

     def-word name

   このコード断片は 定義ワード(“defining word”) ‘def-word’ を定義し、 そ
して、 それを実行します。 ‘def-word’ が実行されると、 新しいワード
‘name’ が ‘CREATE’ され、コード code1 が実行されます。 コード code2 は現
時点では実行されません。 ‘name’ というワードは、 ‘def-word’ の子供
(“child”)と呼ばれることもあります。

   ‘name’ を実行すると、 ‘name’ の本体のアドレスがデータ・スタックに置か
れ、 code2 が実行されます(‘name’ の本文のアドレスは、 ‘CREATE’ の直後に
‘HERE’ が返すアドレス、 つまり、 ‘create’ されたワードがデフォルトで返す
アドレスです)。

   ‘def-word’ を使用して、 同様に動作する一連の子ワード達を定義できます
。 つまり、 これらはすべて code2 によって決定される共通の実行時の振る舞
いを持っています。 通常、 code1 シーケンスは、 子ワードの本体にデータ領
域を構築します。 データの構造は ‘def-word’ のすべての子に共通ですが、 デ
ータ値は各子ワードに固有で、 そして、 プライベートです。 子ワードが実行
されると、 そのプライベート・データ領域のアドレスが TOS 上のパラメータと
して渡され、 code2 によって使用および操作されます(1)。

   定義ワードを構成する 2 つのコード断片は、 完全に別々の 2 つの時点で動
作(実行)されます:

   • 定義時 、定義ワードが code1 を実行して子ワードを生成します
   • 子の実行時、 子ワードが呼び出されると、 子ワード固有のプライベート
     なパラメータ達(データ)を使って、 code2 が実行されます。

   ‘def-word’ と ‘name’ の振る舞いを理解するもう 1 つの方法は、 以下のよ
うに定義することです:
     : def-word1 ( "name" -- )
         CREATE code1 ;

     : action1 ( ... -- ... )
         code2 ;

     def-word1 name1

この場合、 ‘name1 action1’ を使用することは、 ‘name’ を使用することと同
じです。

   ‘def-word’ を記述するもう 1 つの方法が引用(*note Quotations::)です:

     : def-word ( "name" -- ; name execution: ... -- ... )
         create code1
         [: code2 ;] set-does> ;

   Gforth は実際は ‘does>’ を使用してコードを後者のコードと同等のコード
にコンパイルします。 ‘set-does>’ アプローチの利点は、 その背後に他のコー
ドを配置でき、 回避策を必要とせずに制御構造内でそれを使用できることです
。 欠点は、 Gforth 固有であることです。

   典型的な例は、 以下のようにして ‘CONSTANT’ を定義できることです:

     : CONSTANT ( w "name" -- )
         CREATE ,
     DOES> ( -- w )
         @ ;

または同等の

     : CONSTANT ( w "name" -- ; name execution: -- w )
         create ,
         ['] @ set-does> ;

   ‘5 CONSTANT four’ を使用して定数を作成すると、 一連の定義時アクション
が実行されます。 最初に新しいワード ‘five’ が作成され、 次に ‘,’ を使用
して ‘five’ の本体に値 5 が配置されます。 ‘five’ が実行されると、 本文の
アドレスがスタックに置かれ、 ‘@’ は値 5 を取得します。 ワード ‘five’ に
はそれ自体のコードはありません。 ワード ‘five’ には、データ・フィールド
と、 引用(quotation) の xt または ‘@’ の xt が含まれるだけです。

   このセクションの最後の例は、 ‘CREATE’ されたワードで予約されている空
間はデータ空間であるため、 標準プログラムによる読み取りと書き込みの両方
が可能であることを思い出していただくことを目的としています(2):

     : foo ( "name" -- )
         CREATE -1 ,
     DOES> ( -- )
         @ . ;

     foo first-word
     foo second-word

     123 ' first-word >BODY !

   ‘first-word’ が ‘CREATE’ されたワードであった場合、 単純にそれを実行
してデータ・フィールドのアドレスを取得できます。 ただし、 ‘DOES>’ アクシ
ョンを持つように定義されているため、 その実行機能(execution semantics)は
、 それらの ‘DOES>’ アクションを実行することになります。 データ・フィー
ルドのアドレスを取得するには、 ‘'’ を使用して xt を取得し、 次に ‘>BODY’
を使用して xt をデータ・フィールドのアドレスに変換する必要があります。
‘first-word’ を実行すると、 ‘123’ が表示されます。 ‘second-word’ を実行
すると、‘-1’ が表示されます。

   上記の例では、 ‘DOES>’ の後のスタック・コメントは、 次のコードのスタ
ック効果ではなく、 定義されたワードのスタック効果を指定しています(次のコ
ードは、 スタックの先頭にある本体のアドレスを期待しています。 スタックコ
メントには反映されません)。 これは私が使用し、 推奨している規則です(スタ
ック効果の指定にローカル変数宣言を使うのと少々衝突する)。

   ---------- Footnotes ----------

   (1) このデータ領域への読み取りと書き込みは両方とも正当です。

   (2) 研究課題: この例は ‘Value’ と ‘TO’ をあなた独自に実装するための出
発点として使って見ましょう。 – あなたが行き詰まった場合は、 ‘'’ と ‘[']’
の振る舞いを調べてください。


File: gforth.info,  Node: CREATE..DOES> applications,  Next: CREATE..DOES> details,  Prev: User-defined defining words using CREATE,  Up: User-defined Defining Words

6.10.10.3 Applications of ‘CREATE..DOES>’
.........................................

あなたは、 この機能をどのように使用するのか不思議に思うかもしれません。
いくつかの使用パターンを以下に示します:

   とあるコードのフレーズが複数回出現し、 その意味を同一視できる場合は、
それをコロン定義としてくくり出します。 類似のコロン定義が見つかった場合
は、 ‘CREATE..DOES>’ を使用してそれらをファクタリングできます。 たとえば
、 アセンブラは通常、 非常によく似たいくつかのワードを定義します:
     : ori, ( reg-target reg-source n -- )
         0 asm-reg-reg-imm ;
     : andi, ( reg-target reg-source n -- )
         1 asm-reg-reg-imm ;

これは以下のようにファクタリングできます:
     : reg-reg-imm ( op-code -- )
         CREATE ,
     DOES> ( reg-target reg-source n -- )
         @ asm-reg-reg-imm ;

     0 reg-reg-imm ori,
     1 reg-reg-imm andi,

   ‘CREATE..DOES>’ の別の観点は、 これをワードのパラメータの一部を提供す
る粗雑な方法(関数型言語コミュニティではカリー化(“currying”)として知られ
ています)とみなすことです。 たとえば、 ‘+’ には 2 つのパラメータが必要で
すが、そのうち 1 つのパラメータを固定した ‘+’ のバージョンを作成するには
、 以下のようにします:

     : curry+ ( n1 "name" -- )
         CREATE ,
     DOES> ( n2 -- n1+n2 )
         @ + ;

      3 curry+ 3+
     -2 curry+ 2-


File: gforth.info,  Node: CREATE..DOES> details,  Next: Advanced does> usage example,  Prev: CREATE..DOES> applications,  Up: User-defined Defining Words

6.10.10.4 The gory details of ‘CREATE..DOES>’
.............................................

‘DOES>’ ( compilation colon-sys1 – colon-sys2  ) core “does”

   これは、 一つの定義内で ‘CREATE’ と ‘DOES>’ の両方を使用する必要がな
いことを意味します。 ‘DOES>’ 部分を別の定義に置くことができます。 これに
より、 たとえば、 さまざまな ‘DOES>’ 部分から選択するようにすることがで
きます:
     : does1
     DOES> ( ... -- ... )
         code1 ;

     : does2
     DOES> ( ... -- ... )
         code2 ;

     : def-word ( ... -- ... )
         create ...
         IF
            does1
         ELSE
            does2
         ENDIF ;

   この例では、 ‘does1’ と ‘does2’ のどちらを使用するかの選択は、 子ワー
ドが ‘CREATE’ される定義時に行われます。

   注意: 定義を終了する ‘does>’ の性質により、 追加の定義 ‘does1’ と
‘does2’ を導入する必要があることに注意してください。 ‘set-does>’ を使用
するとこれを回避できます:

     : def-word ( ... -- ... )
         create ...
         IF
            [: code1 ;] set-does>
         ELSE
            [: code2 ;] set-does>
         ENDIF ;

   標準のプログラムでは、 最後のワードが ‘CREATE’ で定義されている場合に
のみ ‘DOES>’ 部分を適用できます。 Gforth では、 ‘DOES>’ 部分は、 いかな
る場合でも定義された最後のワードの振る舞いをオーバーライドします。 標準
のプログラムでは、 ‘DOES>’ はコロン定義でのみ使用できます。 Gforth では
、 一種のワンショット・モードとして、 インタプリタ状態で使用することもで
きます。 例:
     CREATE name ( ... -- ... )
       initialization
     DOES>
       code ;

これは、 以下の標準のと同等です:
     :noname
     DOES>
         code ;
     CREATE name EXECUTE ( ... -- ... )
         initialization

   Gforth は対話時に打ち込んだコード内での引用(quotations)もサポートして
おり、 引用は現在の定義を保存および復元するため、 上記の例を以下のように
記述することもできます:

     CREATE name ( ... -- ... )
       initialization
     [: code ;] set-does>

‘set-does>’ ( xt –  ) gforth-1.0 “set-does>”
   現在のワードを変更して、 本体アドレスをプッシュしてから xt を実行しま
す。 それに応じて ‘compile,’ の実装も変更します。 より効率的な実装が必要
な場合、 この後で ‘set-optimizer’ を呼び出します。

‘>body’ ( xt – a_addr  ) core “to-body”
   xt で表されるワードの本体(body)のアドレス(ワードのデータ・フィールド
のアドレス)を取得します。


File: gforth.info,  Node: Advanced does> usage example,  Next: User-defined TO and DEFER@,  Prev: CREATE..DOES> details,  Up: User-defined Defining Words

6.10.10.5 Advanced does> usage example
......................................

MIPS 逆アセンブラ(‘arch/mips/disasm.fs’)には、 非常に反復的なスキームに
従って逆アセンブルするための多くのワードが含まれています(訳注: very
repetetive scheme; repetitiveのスペルミスっぽい):

     :noname DISASM-OPERANDS s" INST-NAME" type ;
     ENTRY-NUM cells TABLE + !

   もちろん、 これは共通点をくくり出して以下のような定義を可能にするとい
うアイデアを刺激します:

     DISASM-OPERANDS ENTRY-NUM TABLE define-inst INST-NAME

   通常、 パラメータ DISASM-OPERANDS と TABLE は相関しています。 さらに
、 私が逆アセンブラを作成する前に、 以下のような命令を定義するコードがす
でに存在していました:

     ENTRY-NUM INST-FORMAT INST-NAME

   このコードは assembler 由来で、 ‘arch/mips/insts.fs’ にあります。

   したがって、 実行時に上記のスキームを実行する INST-FORMAT ワードを定
義する必要がありました。 私は、 まず最初に、ランタイム・コード生成を使用
することを選択しました:

     : INST-FORMAT ( entry-num "name" -- ; compiled code: addr w -- )
       :noname Postpone DISASM-OPERANDS
       name Postpone sliteral Postpone type Postpone ;
       swap cells TABLE + ! ;

   注意: これにより、 上記のスキームの他に 2 つのパラメータが提供される
ことに注意してください。

   別の方法として、 ‘create’/‘does>’ を使用してこれを記述することもでき
ます:

     : INST-FORMAT ( entry-num "name" -- )
       here name string, ( entry-num c-addr ) \ parse and save "name"
       noname create , ( entry-num )
       latestxt swap cells TABLE + !
     does> ( addr w -- )
       \ disassemble instruction w at addr
       @ >r
       DISASM-OPERANDS
       r> count type ;

   どういうわけか、 最初の解決策の方が簡単です。 その主な理由は、
‘string,’ やその友達を使用するよりも、 ‘sliteral’ を使用した方が、 文字
列を定義時から使用時へシフトするのが簡単だからです。

   私はこのスキームに従ってたくさんのワードを書き、 すぐにそれらの共通点
を取り出すことを考えました。 これは 2 レベルの定義ワード、 つまり通常の
定義ワードを定義するワードを使用していることに注意してください。

   今回は、 ‘postpone’ とその友人が関与する解決策はより困難に思えたので
(研究課題として試してみましょう)、 ‘create’/‘does>’ というワードを使用す
ることにしました。 私はすでにそれを行っていたので、 下位レベルにも
‘create’/‘does>’ を使用しました(研究課題として ‘postpone’ などを使用して
みましょう)。 その結果、 以下の定義が得られました:

     : define-format ( disasm-xt table-xt -- )
         \ 逆アセンブルに disasm-xt を使用する命令フォーマットを定義し、
         \ 定義された命令を
         \ 表(table) table-xt に入れます
         create 2,
     does> ( u "inst" -- )
         \ 命令 inst を逆アセンブルする匿名ワードを定義し、
         \ それを u 番目のエントリとして table-xt に入れます
         2@ swap here name string, ( u table-xt disasm-xt c-addr ) \ remember string
         noname create 2,      \ define anonymous word
         execute latestxt swap ! \ enter xt of defined word into table-xt
     does> ( addr w -- )
         \ disassemble instruction w at addr
         2@ >r ( addr w disasm-xt R: c-addr )
         execute ( R: c-addr ) \ disassemble operands
         r> count type ; \ print name

   注意: ここでのテーブルは(上記とは対照的に) ‘cells +’ を単独で実行する
ことに注意してください (そのため、xt を渡す必要があります)。 このワード
は以下のように使用されます:

     ' DISASM-OPERANDS ' TABLE define-format INST-FORMAT

   上に示したように、 定義された命令フォーマットは以下のように使用されま
す:

     ENTRY-NUM INST-FORMAT INST-NAME

   カリー化に関しては、 この種の 2 レベルの定義ワードは 3 段階でパラメー
タを提供します。 最初に DISASM-OPERANDS と TABLE、 次に ENTRY-NUM と
INST-NAME 、最後に ‘addr w’ つまり、 逆アセンブル対象の命令です。

   もちろん、 これは ‘insts.fs’ で使用されるすべての命令フォーマット名に
完全に適合するわけではないため、 パラメータを正しい形式に条件付けるいく
つかのラッパーを定義する必要がありました。

   あなたが、 このセクションを理解するのが難しい場合でも、 心配する必要
はありません。 まず、 これは複雑であり、 理解するのに時間がかかります(お
そらく多少いじくりまわすことも必要です)。 2 番目に、 これは私が Forth の
17 年間で書いた最初の 2 レベルの ‘create’/‘does>’ ワードです。 また、 最
初に ‘insts.fs’ がなかった場合は、 1 レベルの定義ワードのみを使用するこ
とを選択した可能性があります(定義ワードを使用するときにパラメータをいく
つか繰り返します)。 したがって、 これを理解する必要はありませんが、 あな
たの Forth についての理解が深まるかもしれません。


File: gforth.info,  Node: User-defined TO and DEFER@,  Next: User-defined compile-comma,  Prev: Advanced does> usage example,  Up: User-defined Defining Words

6.10.10.6 User-defined ‘to’ and ‘defer@’
........................................

Gforth の value にはいくつかの操作子(operators)があります。 ‘to’ (‘is’ は
エイリアスであり、 ‘defer!’ は入力ストリーム内の名前の代わりに xt を受け
取ります)や ‘+to’ や ‘addr’ や ‘action-of’ (‘defer@’ は入力ストリーム内
の名前の代わりに xt を受け取ります)です。

   Gforth を使用すると、 ワードの ‘(to)’ アクションを変更できます。

‘(to)’ ( val operation xt –  ) gforth-1.0 “paren-to”
   name という名前の、 ワードに似ている value の xt です。 name に val を
保存します。 operation は、 ‘to’ と ‘+to’ と ‘addr’ と ‘action-of’ から
選択します。

‘to-table:’ ( "name" "xt1" .. "xtn" –  ) gforth-experimental “to-table-colon”
   ‘TO’ や ‘+TO’ や ‘ADDR’ や ‘ACTION-OF’ のエントリを含むテーブルを作成
します。 ‘n/a’ を使用して、 サポートされていない操作をマークします。

‘to-method:’ ( xt table "name" –  ) gforth-experimental “to-method-colon”
   to-method を作成します。 ここで、XT はフィールドにアクセスするための
アドレスを計算し、 TABLE にはそれに格納する操作子(operators)が含まれます
。

‘set-to’ ( to-xt –  ) gforth-1.0 “set-to”
   現在のワードの ‘(to) ( val xt -- )’ メソッドの実装を to-xt に設定しま
す。

‘n/a’ ( –  ) gforth-experimental “not-available”
   このワードをチック(tick)することはできますが、 インタプリタ時およびコ
ンパイル時に “Operation not supported” (操作はサポートされていません)と
いう例外が投げられます(throw)。 サポートされていないメソッドなどにこれを
使用します。

   ‘(to)’ は ‘to’ 内で使用されるワードです。 実行時(run-time)に値を保存
します。 ‘(to)’ メソッドの一般的なスタック効果は ‘( val Operation xt --
)’ です。 ここで、 xt は格納されているワードを示し、 operation は ‘to’ 風
の操作の実際のバリエーションを示します。 val はそこに格納されている (適
切な型の) 値です。

   ‘to-table:’ を使用して ‘to’ メソッドを実装し、 タイプ固有の操作テーブ
ルを作成し(テーブルの最後にある指定されていないスロットは ‘n/a’ で埋めら
れます)、 ‘to-method:’ を、 value の xt からそのデータ・フィールドを取得
する操作と組み合わせて使用​​します(通常、 ディクショナリ内の値の場合は
‘>body’ ですが、 value-style データは構造体またはユーザー領域に存在する
こともできます)。

   たとえば、 以下のように ‘fvalue’ を実装できます:

     to-table: f!-table f! f+!
     ' >body f!-table to-method: fvalue-to

     : fvalue ( r "name" -- ; name: -- r )
       create f,
       ['] f@ set-does>
       ['] fvalue-to set-to ;

     5e fvalue foo
     : bar foo 1e f+ to foo ;
     see bar


File: gforth.info,  Node: User-defined compile-comma,  Next: Creating from a prototype,  Prev: User-defined TO and DEFER@,  Up: User-defined Defining Words

6.10.10.7 User-defined ‘compile,’
.................................

以下を使用して、 とあるワードのための ‘compile,’ の実装を変更することも
できます

‘set-optimizer’ ( xt –  ) gforth-1.0 “set-optimizer”
   ‘compile,’ で xt execute するように現在のワードを変更します
(‘compile,’ に渡されたものと同じスタック内容を使用)。 注意: ‘compile,’ は
‘execute’ とスタック内容が一致している必要があるため、 ‘set-optimizer’ は
同じ振る舞いの、 より効率的な実装をインストールする場合にのみ使用しなけ
ればならないことに注意してください。

‘opt:’ ( compilation – colon-sys2 ; run-time – nest-sys  ) gforth-1.0 “opt:”
   名前無しのコロン定義を開始します。 完了すると、 このコロン定義は
(‘opt:’ の前の)最新のワードの ‘compile,’ の実装になります。

   注意: 結果として得られる ‘compile,’ は、 依然として ‘postpone literal
postpone execute’ と同等である必要があることに注意してください。 そのた
め、 ‘set-optimizer’ は、 振る舞いを変更するためではなく、 効率化のため
に役立てるものです。 しかし、 あなたが自分の足を撃つことを妨げるものは何
もありません。 あなたが ‘set-optimizer’ を使用したときの結果と、 最初に
以下を定義して使用を無効にしたときに得られる結果を比較することで、
‘set-optimizer’ の使用が正しいかどうかを確認できます。

     : set-optimizer drop ;

   ‘set-optimizer’ の使用例として、 上記の ‘CONSTANT’ の定義の 1 つを以
下のように拡張できます。

     : CONSTANT ( n "name" -- ; name: -- n )
       create ,
       ['] @ set-does>
       [: >body @ postpone literal ;] set-optimizer
     ;

   唯一の変更は、 ‘set-optimizer’ 行の追加です。 あなたが定数を定義して
コンパイルすると、 以下のようになります:

     5 constant five
     : foo five ;

   ‘foo’ 内のコンパイル済み ‘five’ は、 ‘five’ の一般的な呼び出しではな
く、 literal 5 とコンパイルされるようになりました。 引用(quotation)には
、 ‘compile,’ と同じスタック効果があり、 それは ‘( xt -- )’ です。 渡さ
れた xt は ‘compile,’ されたワード、 つまりこの例では ‘five’ に属します
。 この例では、 まず xt が本文アドレスに変換され、 次にその場所の値 5 が
フェッチされ、 その値が ‘postpone literal’ でコンパイルされます(*note
Literals::)。

   この ‘set-optimizer’ の使用は、 ユーザーが、 例えば ‘6 ' four >body
!’ などして定数の値を変更しないことを前提としています。 ‘five’ は
‘create’ で定義されていますが、 これは ‘CONSTANT’ の実装の詳細であり、 そ
れを文書化しない場合、 ユーザーはそれに依存してはなりません。 また、 h本
体が変更されないことを前提とした方法で ‘set-optimizer’ を使用する場合、
(ここで行われているように) ‘create’ が使用されていることを文書化してはな
りません。 逆に、 それを文書化する場合は、 本体の変更を処理できるように
‘compile,’ 実装を記述する必要があります。

   別の例は、 上記の ‘fvalue’ の例をさらに最適化したものです:

     : compile-fvalue-to ( xt-value-to -- )
       drop ]] >body f! [[ ;

     : fvalue-to ( r xt -- )
       >body f! ;
     ' compile-fvalue-to set-optimizer

     : fvalue ( r "name" -- ; name: -- r )
       create f,
       ['] f@ set-does>
       [: >body ]] literal f@ [[ ;] set-optimizer
       ['] fvalue-to set-to ;

     5e fvalue foo
     : bar foo 1e f+ to foo ;
     see bar

   ‘bar’ のコードを以前の定義のコードと比較します。 ここでは、 fvalue を
読み取るコード(‘fvalue’ の ‘set-optimizer’ より)と、 fvalue を書き込むコ
ード(‘fvalue-to’ に適用された ‘set-optimizer’ より)の両方の最適化が見ら
れます。 fvalue は(定数とは異なり)変化する可能性があるため、 (‘fvalue’ 内
部の)読み取り部分が、 アドレスと、 実行時に実行される ‘f@’ をコンパイル
します。

   ‘fvalue-to’ の場合、 ‘compile,’ の実装は基本的に、 ‘fvalue’ によって
インラインで実行されるコードをコンパイルするだけです。 ‘to’ のコンパイル
機能(compilation semantics)は、アドレスをリテラルとしてコンパイルしてか
ら、 ‘(to)’ の実装(つまり、 ‘fvalue-to’)をコンパイルします。 この処理で
は、 ‘>body’ が最適化されて削除されます。

   実際には、 Gforth の ‘fvalue’ は、 たとえば ‘+TO’ をサポートするなど
、 いくつかの追加の工夫が含まれています。

   注意: ‘set-optimizer’ の呼び出しは、 ‘set-does>’ (または ‘does>’ の呼
び出しの後に実行する必要があることに注意してください。 なぜなら、
‘set-does>’ は ‘compile,’ の実装それ自体を上書きするからです。

   ‘fvalue-to’ の例でわかるように、 ‘set-optimizer’ を ‘constant’ や
‘fvalue’ のような定義ワード内ではなく、 個々のワードに適用することもでき
ます。 この場合、 オプティマイザに渡されるワードの xt は通常は不要であり
、 ‘compile-fvalue-to’ のように ‘drop’ されます。

   エンジン ‘gforth-itc’ は ‘compile,’ に ‘,’ を使用するので、 そこでは
‘set-optimizer’ は効果ありません。


File: gforth.info,  Node: Creating from a prototype,  Next: Making a word current,  Prev: User-defined compile-comma,  Up: User-defined Defining Words

6.10.10.8 Creating from a prototype
...................................

上記では、 最初に ‘create’ を使用してワードを定義し、 それから
‘set-does>’ や ‘set-to’ や ‘set-optimizer’ などで変更する方法を示しまし
た。

   別の方法として、 以下のワード群を使用してプロトタイプを作成し、そのプ
ロトタイプから新しいワードを作成します。 この種のコピーでは本体(body)部
分は網羅されないため、 明示的に割り当てて初期化する必要があります。 上記
の ‘fvalue’ を例に取ると、 代わりに以下のように定義できます:

     create fvalue-prototype ( -- r )
     ['] f@ set-does>
     [: >body ]] literal f@ [[ ;] set-optimizer
     ['] fvalue-to set-to

     : fvalue ( r "name" -- ; name: -- r )
       ``fvalue-prototype create-from f, reveal ;

   このアプローチの利点は、まず ‘create’ ヘッダー・メソッド達を複製し、
それらを変更し、 最終的に重複排除する必要がないため、 ‘fvalue’ ワード群
の作成が高速化されることだ。 ただし、 この利点は、 この定義ワードで作成
されるワードの数が膨大な場合にのみ意味があります。

‘create-from’ ( nt "name" –  ) gforth-1.0 “create-from”
   指定の nt のように振る舞うが、 ボディが空のワード name を作成します。
nt は名前付きワードの nt でなければなりません。 結果として得られるヘッダ
ーはまだ非公開状態です(訳注: not yet reveal;ワードリスト未登録なので普通
は呼び出せない)。 ‘set-’ ワード群を使用せずに ‘create-from’ でワードを作
成すると、 ‘set-’ ワード群または ‘immediate’ または ‘does>’ を使用してワ
ードを作成するよりも高速になります。 ‘noname’ で ‘create-from’ を使用で
きます。

‘reveal’ ( –  ) gforth-0.2 “reveal”
   (reveal;明らかにする、暴露する)ヘッダー定義時の現在のワード・リスト
(wordlist current)に現在のワードを入れます。

   ‘noname’ を定義ワードとともに使用しても、 パフォーマンス上の利点は得
られません。 したがって、 以下もいっしょに使います

‘noname-from’ ( xt –  ) gforth-1.0 “noname-from”
   指定の xt のように動作するが、 本体が空の名前のないワードを作成します
。 xt は、 名前のないワードの xt でなければなりません。

   以下に使用例を示します:

     ``fvalue-prototype noname create-from
     latestnt constant noname-fvalue-prototype

     : noname-fvalue ( r -- xt ; xt execution: -- r )
       noname-fvalue-prototype noname-from f,
       latestxt ;


File: gforth.info,  Node: Making a word current,  Next: Const-does>,  Prev: Creating from a prototype,  Up: User-defined Defining Words

6.10.10.9 Making a word current
...............................

‘immediate’ や ‘set-optimizer’ など、 上記の多くのワードは、「現在の」ワ
ードまたは「一番最近定義された」ワードを変更します。 しばしば以前のワー
ドを変更したい場合があります。 これは以下のようにして行うことができます

‘make-latest’ ( nt –  ) gforth-1.0 “make-latest”
   nt を最新の定義にし、 ‘immediate’ および ‘set-*’ 操作で操作できるよう
にします。 nt によって参照されるワードを既に使用している(特にコンパイル
済みの)場合、 そのワードの振る舞いを変更しないでください(その実装だけを
変更してください)。 さもないと、 Gforth エンジンやバージョン間で一貫性の
ない驚くべき振る舞いの組み合わせが発生する可能性があります。


File: gforth.info,  Node: Const-does>,  Prev: Making a word current,  Up: User-defined Defining Words

6.10.10.10 ‘Const-does>’
........................

‘create’...‘does>’ は、 定義時から実行時に幾つかの値を転送(transfer)する
ためによく使用されます。 Gforth は、 このために以下を用意しています

‘const-does>’ ( run-time: w*uw r*ur uw ur "name" –  ) gforth-obsolete “const-does”
   定義時: NAME を定義して返ります。

   NAME 実行時: W*UW R*UR をプッシュし、 ‘const-does>’ に続くコードを実
行します。

   このワードの一般的な使用例は以下のとおりです:

     : curry+ ( n1 "name" -- )
     1 0 CONST-DOES> ( n2 -- n1+n2 )
         + ;

     3 curry+ 3+

   ここで ‘1 0’ は、 1 つのセルと 0 の浮動小数点が定義時から実行時に転送
されることを意味します。

   ‘const-does>’ を使用する利点は以下のとおりです:

   • 値の保存と取得を扱う必要がなくなります。 つまり、 プログラムの書き
     込みと読み取りがより容易になります。

   • ‘does>’ を使用する場合は、 最適化できない ‘@’ を導入する必要があり
     ます(なぜなら ‘>body’...‘!’ を使用してデータを変更できるため)。
     ‘const-does>’ はこの問題を回避します。

   ‘const-does>’ の標準 Forth 実装は ‘compat/const-does.fs’ で利用できま
す。


File: gforth.info,  Node: Deferred Words,  Next: Forward,  Prev: User-defined Defining Words,  Up: Defining Words

6.10.11 Deferred Words
----------------------

定義ワード ‘defer’ (訳注: (期限を定めない)延期)を使用すると、 その振る舞
いを定義せずに名前でワードを定義できます。 その振る舞いの定義は延期
(defer)されます。 これが役立つ 2 つの状況を以下に示します:

   • ワードの振る舞いを後で変更できるようにし、 振る舞いが変更されたとき
     にそのワードへの全てのプリコンパイルされた参照も変更できるようにし
     たい場合。
   • 相互再帰(mutual recursion)の場合。 *Note Calls and returns::

   以下の例では、 ‘foo’ は常に ‘greet’ の「‘Good breakfast’」を出力する
バージョンを呼び出し、 ‘bar’ は常に‘greet’ の「‘Hello’」を出力するバージ
ョンを呼び出します。 ソースコードを並べ替えて再コンパイルすることなく、
‘foo’ で新しいバージョンを使用できるようにする方法はありません。

     : greet ." Good morning" ;
     : foo ... greet ... ;
     : greet ." Hello" ;
     : bar ... greet ... ;

   この問題は、 ‘greet’ を ‘defer’ された ワードとして定義することで解決
できます。 ‘defer’ された ワードの振る舞いは、 ‘IS’ を使用して以前に定義
されたワードの xt と関連付けることによって、 いつでも定義および再定義で
きます。 上記の例は以下のようになります:

     Defer greet ( -- )
     : foo ... greet ... ;
     : bar ... greet ... ;
     : greet1 ( -- ) ." Good morning" ;
     : greet2 ( -- ) ." Hello" ;
     ' greet2 IS greet  \ make greet behave like greet2

   プログラミング・スタイル・メモ: すべての defer された ワードに対して
スタック・コメントを記述し、 かつ、 そのスタック効果に一致する XT のみを
延期ワードに入れる必要があります。 そうしないと、 defer された ワードを
使用するのは非常に困難です。

   defer された ワードを使用すると、 *note User-defined Defining Words::
の統計収集の例(statistics-gathering example)を改善できます。 アプリケー
ションのソース・コードを編集してすべての ‘:’ を ‘my:’ に変更するのではな
く、 以下のようにします:

     : real: : ;     \ retain access to the original
     defer :         \ redefine as a deferred word
     ' my: IS :      \ use special version of :
     \
     \ load application here
     \
     ' real: IS :    \ go back to the original

   注意すべき点の 1 つは、 ‘IS’ には特別なコンパイル機能(compilation
semantics)があり、 (‘TO’ のように)コンパイル時に名前をパースするというこ
とです:

     : set-greet ( xt -- )
       IS greet ;

     ' greet1 set-greet

   ‘IS’ が適合しない状況では、 代わりに ‘defer!’ を使用してください。

   defer された ワードは、 xt から実行機能(execution semantics)のみを継
承できます(xt が表現できるのはそれだけであるためです – これについての詳
しい説明は *note Tokens for Words:: 参照)。 デフォルトでは、この実行機能
(execution semantics)から派生したデフォルトのインタプリタ機能
(interpretation semantics)とコンパイル機能(compilation semantics)を持ち
ます。 ただし、 defer された ワードのインタプリタ機能とコンパイル機能は
、 通常の方法で変更できます。

     : bar .... ; immediate
     Defer fred immediate
     Defer jim

     ' bar IS jim  \ jim has default semantics
     ' bar IS fred \ fred is immediate

‘Defer’ ( "name" –  ) core-ext “Defer”
   defer された ワード name を定義します。 その実行機能(execution
semantics)は ‘defer!’ または ‘is’ で設定できます(最初に name を実行する
前に設定する必要があります)。

‘defer!’ ( xt xt-deferred –  ) core-ext “defer-store”
   xt (XT-DEFERRED) で表される defer された ワードに実行のための XT を設
定します。

‘IS’ ( xt "name" –  ) core-ext “IS”
   ‘defer’ された ワード NAME に実行のための XT を設定します。

‘defer@’ ( xt-deferred – xt  ) core-ext “new-defer-fetch”
   xt は、 defer された ワード xt-deferred に現在関連付けられているワー
ドを表します。

‘action-of’ ( interpretation "name" – xt; compilation "name" – ; run-time – xt  ) core-ext “action-of”
   Xt は、 現在 name に割り当てられている XT です。

   Forth-94 では、 これら Forth-2012 のワードの定義は、‘compat/defer.fs’
で提供されます。 さらに、 Gforth は以下を提供します:

‘defers’ ( compilation "name" – ; run-time ... – ...  ) gforth-0.2 “defers”
   defer された ワード name の現在の内容を現在の定義にコンパイルします。
つまり、 これにより、 name が defer されなかったかのように静的バインディ
ングが生成されます。

‘wrap-xt’ ( xt1 xt2 xt: xt3 – ...  ) gforth-1.0 “wrap-xt”
   defer された ワード xt2 の現在の xt を退避して xt1 に設定した上で、
xt3 を実行し、 xt3 実行後、 退避した xt を 延期ワード xt2 に戻します(訳
注: xt3 の内部のどこかで xt2 を使っているとして、 その実行機能を一時的に
xt1 に設定してから xt3 を実行し、 実行後に xt2 の実行機能を元に戻してお
く。 元に戻すのは try ...  restore ...  endtry で囲まれた部分なので xt3
実行中にエラーがあっても確実に復旧される。 詳しくはソースコード見て下さ
い)

‘preserve’ ( "name" –  ) gforth-1.0 “preserve”
   指定の defer された ワード name で、 現在設定されている実行機能 xt を
、 その場で ‘is’ や ‘defer!’ したかのようなコードに変換します(訳注: 上記
例より、 ’ greet2 is greet : preserve-greet2 preserve greet ; → greet1
is greet ok → greet Good morning ok → preserve-greet2 ok → greet Hello
ok ; see preserve-greet2 → : preserve-greet2 ‘greet2 ‘greet !  ; ok)


File: gforth.info,  Node: Forward,  Next: Aliases,  Prev: Deferred Words,  Up: Defining Words

6.10.12 Forward
---------------

‘forward.fs’ 内の定義ワード ‘forward’ を使用すると、 前方参照(forward
references)を作成できます。 これは自動的に解決され、 ‘Defer’ の間接化
(indirection)のような追加コストは発生しません。 ただし、 これらの
forward 定義はコロン定義に対してのみ機能します。

‘forward’ ( "name" –  ) gforth-1.0 “forward”
   コロン定義への前方参照(forward reference)を定義します。 同一のワード
リスト内(wordlist)で同一の名前のコロン定義を定義すると、 前方参照が解決
されます。 ‘.unresolved’ を使用して、 未解決の forward があるかどうかを
確認します。

‘.unresolved’ ( –  ) gforth-1.0 “.unresolved”
   未解決の前方参照(forward references)をすべて出力します


File: gforth.info,  Node: Aliases,  Prev: Forward,  Up: Defining Words

6.10.13 Aliases
---------------

定義ワード ‘synonym’ を使用すると、 他のワードと同一の振る舞いをするワー
ドを名前で定義できます。 これが役立つ 2 つの状況を以下に示します:

   • 別のワードリストからワードの定義にアクセスしたい場合(この例について
     は、 Gforth ソースの ‘root’ ワードリストの定義を参照してください)。
   • あなたが同義語(synonym)を作成したい場合。 2つの名前どちらでも認識で
     きる定義(たとえば、 ‘THEN’ と ‘ENDIF’ は同義語(synonyms)です)。

‘Synonym’ ( "name" "oldname" –  ) tools-ext “Synonym”
   oldname と同一に振る舞うように name を定義します。 つまり、 同一のイ
ンタプリタ機能(interpretation semantics)と、 同一のコンパイル機能
(compilation semantics)と、 同一の ‘to’/‘defer!’ や ‘defer@’ 機能を持ち
ます。

   Gforth は、 コンパイル機能、 または ‘to’/‘defer!’ や ‘defer@’ 機能を
親から継承しない、 非標準の ‘alias’ も提供します。 あなたは後で、 例えば
‘immediate’ などを使用してコンパイル機能などを変更できます。

‘Alias’ ( xt "name" –  ) gforth-0.2 “Alias”
   name を xt を実行するワードとして定義します。 defer された ワードとは
異なり、 エイリアス(aliase)にはコンパイル時に間接的なオーバーヘッドがあ
りません。

   Example:

     : foo ... ; immediate

     ' foo Alias bar1           \ bar1 is not an immediate word
     ' foo Alias bar2 immediate \ bar2 is an immediate word
     synonym bar3 foo           \ bar3 is an immediate word

   synonyms(同義語)とaliases(別名)はどちらも元の nt とは異なる nt を持ち
ますが、 それをチック(tick)すると(または ‘name>interpret’ を使用すると
)、 元の xt と同じ xt が生成されます(*note Tokens for Words::)。


File: gforth.info,  Node: Interpretation and Compilation Semantics,  Next: Tokens for Words,  Prev: Defining Words,  Up: Words

6.11 Interpretation and Compilation Semantics
=============================================

(名前付き)ワード(word)のインタプリタ機能(“interpretation semantics”)は、
テキスト・インタプリタがインタプリタ状態でワードに遭遇したときに行うこと
です。 これは他の文脈でも表れます。 たとえば、 ‘' word’ によって返される
実行トークンは、 word のインタプリタ機能(“interpretation semantics”)を識
別します(つまり、 ‘' word execute’ は、 ‘word’ のインタプリタ状態でのテ
キスト解釈(interpretation)と同等です)。

   (名前付き)ワード(word)のコンパイル機能(“compilation semantics”)は、 テ
キスト・インタプリタがコンパイル状態でワードに遭遇したときに行うことです
。 これは他の文脈でも表れます。 たとえば、 ‘POSTPONE word’ は、 word の
コンパイル機能(compilation semantics)コンパイルします(1)。

   ほとんどのワードにはデフォルトのコンパイル機能(compilation
semantics)があります。 つまり実行機能(execution semantics)(スタック効果
‘( -- )’)をコンパイルします。 ただし、多くのワードが他のコンパイル機能
(compilation semantics)を持っていて、 その個々のワードについては文書化さ
れています(スタック効果を含む)。

   標準では、 実行機能(“execution semantics”)についても述べています。 標
準では、 両方が定義されている場合はインタプリタ機能(interpretation
semantics)と異なることはありませんが、 一方が定義されていない、 または、
両方とも定義されていない場合もあります。 Gforth ではインタプリタ機能
(interpretation semantics)解釈セマンティクスと実行機能(execution
semantics)実行セマンティクスには違いがないため、 これらの用語は同じ意味
で使用されます。

   Gforth (1.0 以降)では、 すべてのワードに インタプリタ機能/実行機能 が
定義されています。 標準でインタプリタ機能も実行機能も定義されていない多
くのワード(‘if’ など)については、 Gforth の インタプリタ機能/実行機能 が
コンパイル機能を実行します。

   標準では、 実行機能はデフォルトでインタプリタ機能とコンパイル機能を定
義するために使用されます。 デフォルトでは、ワードのインタプリタ機能はそ
の実行機能を ‘execute’ し、 ワードのコンパイル機能はその実行機能を
‘compile,’ します(2)。

   名前無しワード(*note Anonymous Definitions::)は、 テキスト・インタプ
リタまたはチック(tick)または ‘postpone’ では検出できません。 このような
ワードはその xt (*note Tokens for Words::) によって表され、 この xt が
‘execute’ されたときは、 その実行機能が呼び出されます。

   あなたは、 最後に定義されたワードの機能(semantics)を変更できます:

‘immediate’ ( –  ) core “immediate”
   ワードのコンパイル機能を、 その実行機能を実行するように設定します。

‘compile-only’ ( –  ) gforth-0.2 “compile-only”
   最後の定義をコンパイル専用としてマークします。 その結果、 テキスト・
インタプリタと ‘'’ は、 そのようなワードに遭遇すると警告を発します。

‘restrict’ ( –  ) gforth-0.2 “restrict”
   ‘compile-only’ の同義語(synonym)

   慣習により、 デフォルト以外のコンパイル機能を持つワード(即実行ワード
など)は、多くの場合、 名前が括弧(brackets;角括弧)で囲まれています(例:
‘[']’ *note Execution token::)。

   注意: compile-only のワードにチック(tick)(‘'’)を付けると、警告
(“<word> is compile-only”)が表示されることに注意してください。

* Menu:

* Combined words::

   ---------- Footnotes ----------

   (1) 標準の用語では、 「現在の定義に追加する」と言います

   (2) 標準の用語でいうと、 デフォルトのインタプリタ機能はその実行機能で
す。 デフォルトのコンパイル機能は、 その実行機能を現在の定義の実行機能に
追加します


File: gforth.info,  Node: Combined words,  Prev: Interpretation and Compilation Semantics,  Up: Interpretation and Compilation Semantics

6.11.1 Combined Words
---------------------

Gforth を使用すると、 複合ワード(“combined words”)、 つまりインタプリタ
機能(interpretation semantics)とコンパイル機能(compilation semantics)を
任意に組み合わせたワードを定義できます。

‘interpret/compile:’ ( interp-xt comp-xt "name" –  ) gforth-0.2 “interpret/compile:”

   この機能は、 ‘TO’ と ‘S"’ を実装するために導入されました。 このような
ワードは、 たとえ小さなかわいいものであっても定義しないことをお勧めしま
す。 なぜなら、 ワードによっては、 いくつかの文脈でワードの両方の部分を
理解するのが困難になるからです。 たとえば、 あなたがコンパイル部分の実行
トークンを取得したいとすると、 代わりに、 2つのワードを定義します。 1つ
はインタプリタ機能部分を具体化するもで、 もう一つはコンパイル機能部分を
具体化するものです。 それら完成したら、 あなたのユーザーの便宜のために
‘interpret/compile:’ を使用して、 それらを組み合わせた複合ワード
(combined word)を定義できます。

   この機能を使用して、 ワードのデフォルトのコンパイル機能(compilation
semantics)の最適化実装を提供してみるとしましょう。 たとえば、 以下のよう
に定義します:
     :noname
        foo bar ;
     :noname
        POSTPONE foo POSTPONE bar ;
     interpret/compile: opti-foobar

上記は以下の最適化バージョンです:

     : foobar
         foo bar ;

   残念ながら、 これは ‘[compile]’ では正しく動きません。 なぜなら、
‘[compile]’ では、 すべての ‘interpret/compile:’ ワードのコンパイル機能
がデフォルトでは無いと想定しているためです。 つまり、 ‘[compile]
opti-foobar’ はコンパイル機能をコンパイルしますが、 ‘[compile] foobar’ は
インタプリタ機能をコンパイルします。

   “state-smart” ワードを使用して、‘interpret/compile:’ によって提供され
る機能をエミュレートしようとする人もいます(実行途中に ‘STATE’ をチェック
する場合、 ワードは state-smart になります)。 たとえば、‘foobar’ を以下
のようにコーディングしようとします:

     : foobar
       STATE @
       IF ( compilation state )
         POSTPONE foo POSTPONE bar
       ELSE
         foo bar
       ENDIF ; immediate

   これは ‘foobar’ がテキスト・インタプリタによってのみ処理される場合に
は機能しますが、 他のコンテキスト(‘'’ や ‘POSTPONE’ など)では機能しませ
ん。 たとえば、 ‘' foobar’ は、 元の ‘foobar’ のインタプリタ機能ではなく
、 state-smart ワードの実行トークンを生成します。 この実行トークンを
(‘EXECUTE’ で直接、 または ‘COMPILE,’ で間接的に)コンパイル状態において
実行(execute)すると、 結果は期待したものになりません(つまり、 ‘foo bar’
は実行されません)。 state-smart ワードは良くないアイディアです。 対策は
、 こんなの書かない事！です(1)。

   ---------- Footnotes ----------

   (1) このトピックに関する議論の詳細は M. Anton Ertl,
‘‘State’-smartness—Why it is Evil and How to Exorcise it
(https://www.complang.tuwien.ac.at/papers/ertl98.ps.gz)’, EuroForth ’98.
をご覧ください。


File: gforth.info,  Node: Tokens for Words,  Next: Compiling words,  Prev: Interpretation and Compilation Semantics,  Up: Words

6.12 Tokens for Words
=====================

このセクションでは、 ワードを表すトークンの作成とその使用について説明し
ます。

* Menu:

* Execution token::          実行/インタプリタ
                               機能(execution/interpretation semantics)
* Name token::               名前付きワード
* Compilation token::        コンパイル機能(compilation semantics)


File: gforth.info,  Node: Execution token,  Next: Name token,  Prev: Tokens for Words,  Up: Tokens for Words

6.12.1 Execution token
----------------------

実行トークン(“execution token”)(xt)はワードの振る舞いを表します。
‘execute’ を使用して xt で表される振る舞いを呼び出すことができ、 そして
、 ‘compile,’ (*note Macros::) を使用してそれを現在の定義にコンパイルで
きます。 その他の使用法としては、 defer された ワード(*note Deferred
Words::) があります。

   特に、 ワードのインタプリタ機能(interpretation semantics)(別名 実行機
能(execution semantics))を表す「実行トークン」(execution token)がありま
す(1)。

   名前付きワード x の場合、 ‘`x’(訳注:アポストロフィではなくてバックス
ラッシュ)を使用してその実行トークンを取得できます:

     5 `. ( n xt )
     execute ( )      \ execute the xt (i.e., ".")
     : foo `. execute ;
     5 foo

   しかしながら、 ‘`’ プレフィックスは Gforth 拡張であるため、 以下の標
準 Forth のワードを使用する方が好ましいです:

‘'’ ( "name" – xt  ) core “tick”
   xt は name のインタプリタ機能(interpretation semantics)を表します。 ワ
ードにインタプリタ機能が無い場合、 ‘-14 throw’ を実行します。

‘[']’ ( compilation. "name" – ; run-time. – xt  ) core “bracket-tick”
   xt は name のインタプリタ機能(interpretation semantics)を表します。 ワ
ードにインタプリタ機能が無い場合、 ‘-14 throw’ を実行します。

   これらはパース・ワード(parsing words)であるため(なお、 ‘`x’ は認識器
(recognizer)によってリテラルとして扱われます)、 インタプリタで解釈された
りコンパイルされたコードの振る舞いが直感的ではない場合があります:

     5 ' .   ( n xt )
     execute ( -- )      \ execute the xt of .
     \ 以下は意図したとおりに動きません:
     \ : foo ' . ;
     \ 5 foo execute
     \ その代わりに以下のようにします:
     : foo ['] . ;
     5 foo execute    \ execute the xt of .
     \ コロン定義内で ' を使った場合:
     : bar ' execute ;
     5 bar .          \ execute the xt of .
     \ 訳注: 一見普段と変わらないように見えるが、
     \       テキスト・インタプリタが . を実行するのではなく、
     \       bar が その後ろのワードの xt を execute している。
     \       よって bar の後ろを省略すると下記のようにエラーとなる
     5 bar
     *the terminal*:10:6: error: Attempt to use zero-length string as a name
     5 bar>>><<<

   ‘'’ は実行時にパースするため、 ‘bar’ のようにコロン定義に置くと、 コ
ロン定義内の次のワードを消費せずに実行時に次のワードが消費されます。
‘`x’ と書かずにリテラル xt をコロン定義に入れたい場合は、 ‘['] x’ と書き
ます。

   Gforth の ‘`x’ や ‘'’ や ‘[']’ は、 compile-only ワードで使用すると警
告(warn)します。 そのような使用法が、 異なる Forth システム間で移植でき
ない可能性があるためです。

   ワードの immediate のバリエーションを定義することで、 この警告
(warning)と移植性の問題を回避できます。 例:

     : if postpone if ; immediate
     : test [ ' if execute ] ." test" then ;

   結果として得られる実行トークンが ‘execute’ されたときは、 ‘if’ のコン
パイル機能(compilation semantics)を実行します。

   xt を取得するもう一つ方法は、 ‘:noname’ または ‘latestxt’ です(*note
Anonymous Definitions::)。 匿名のワードの場合、 ‘:noname’ または
‘latestxt’ により、 そのワードが持つ唯一の振る舞い(実行機能(execution
semantics)) の xt が得られますが、 名前付きワードの定義の後ろで
‘latestxt’ を使用して、 その xt を取得することもできます。

     :noname ." hello" ;
     execute

   xt は 1 つのセルを占有し、 他のセルと同様に操作できます。

   標準 Forth では、 xt は単なる抽象データ型です(つまり、 xt を生成また
は消費する操作によって定義されます)。 (Gforth 1.0 以降の)具体的な実装は
、 ワードの本体アドレス(昔は PFA だった)です。 Gforth 0.7 以前では、 xt
はコード・フィールド・アドレス(CFA は PFA の 2 セル前)として実装されてい
ました。

‘execute’ ( xt – ) core “execute”
   実行トークン xt によって表される機能(semantics)を実行します。

‘execute-exit’ ( compilation – ; run-time xt nest-sys –  ) gforth-1.0 “execute-exit”
   ‘xt’ を実行し、 末尾呼び出し最適化法(tail-call-optimized way)で現在の
定義から戻ります。 戻りアドレス ‘nest-sys’ とローカル変数(local)は、
‘xt’ を execute する前に割り当て解除(deallocate)されます。

‘perform’ ( a-addr – ) gforth-0.2 “perform”
   ‘@ execute’.

   ‘Noop’ は、 しばしば実行トークンのプレースホルダーとして使用されます:

‘noop’ ( – ) gforth-0.2 “noop”

   ---------- Footnotes ----------

   (1) 標準 Forth には、 インタプリタ機能(interpretation semantics)が未
定義のワード(例: ‘r@’)や、 定義された実行機能(execution semantics)が無い
ワード(例: ‘s"’)や、 およびそのどちらも持たないワード(例: ‘if’)がありま
す。 ただし、 インタプリタ機能(interpretation semantics)と実行機能
(execution semantics)の両方が定義されている場合、 それらは同一でであるた
め、 それらを同一のものとして扱います


File: gforth.info,  Node: Name token,  Next: Compilation token,  Prev: Execution token,  Up: Tokens for Words

6.12.2 Name token
-----------------

Gforth は、名前付きワードを「名前トークン」“name token”(nt)で表します。
名前トークンは、 引数または、 以下のワードの結果として発生するセル・サイ
ズの抽象データ型です。

   Gforth 1.0 以降、 ほとんどのワードの nt の具体的な実装は、 xt と同一
アドレスです(これは xt のための基本 nt (primary nt)です)。 ただし、
synonym と、 aliase と、 ‘interpret/compile:’ で定義されたワードは、 別
のワードから xt を取得しますが、 (xt とは異なり)依然として自分独自の nt
を持ちます。 したがって、 Gforth 1.0 固有のコードを作成する準備ができて
いる場合でも、 xt と nt を同一の意味で使用することはできません。 ‘>name’
を使用してこれら自分独自の nt を持つワードの xt から代替 nt を取得するこ
とはできません。

   ‘``x’ (Gforth 1.0 以降) または、 以下を使用して、 ワード x の nt を取
得します

‘find-name’ ( c-addr u – nt | 0  ) gforth-0.2 “find-name”
   現在の検索順序(search order)で名前 c-addr u を見つけます。 nt が見つ
かった場合はそれを返し、 それ以外の場合は 0 を返します。

‘find-name-in’ ( c-addr u wid – nt | 0  ) gforth-1.0 “find-name-in”
   wid で識別されるワードリストで、 c-addr u の文字列で指定された定義を
検索します。 nt が見つかった場合はそれを返し、 それ以外の場合は 0 を返し
ます。

‘latest’ ( – nt  ) gforth-0.6 “latest”
   NT は、 最後に定義されたワードの名前トークンです。 最後のワードに名前
がない場合は 0 です。

‘latestnt’ ( – nt  ) gforth-1.0 “latestnt”
   nt は、 最後に定義されたワードの名前トークンです(訳注: 名前が無い場合
でも nt を返す。 その nt を name>string すると、 長さ 0 の文字列(addr u)
を返す)

‘>name’ ( xt – nt|0  ) gforth-0.2 “to-name”
   xt で表されるワードの基本名前トークン(primary name token) nt を取得し
ます。 xt が ぢつは xt でない場合(非 xt を xt と誤認する可能性が低いヒュ
ーリスティック・チェックを使用)、 または基本 nt (primary nt)が名前無しワ
ードである場合は 0 を返します。 Gforth 1.0 の時点では、 すべての xt に基
本 nt がありますが、 他の名前付きワードも同一のインタプリタ機能
(interpretation sematics) xt を持つ可能性があります。

‘xt>name’ ( xt – nt  ) gforth-1.0 “xt-to-name”
   xt の基本 nt (primary nt)を生成します。 xt が、 ぢつは xt でない場合
、 nt は nt であるとは保証されません。

   以下を使用すると、 ワードリスト内のすべての nt を取得できます

‘traverse-wordlist’ ( ... xt wid – ...  ) tools-ext “traverse-wordlist”
   f が false になるかワードリストがなくなるまで、 ワードリスト wid 内の
ワード nt ごとに xt ( ...  nt – f ...  )  を 1 回実行します。 xt はスタ
ックその下側を自由に使用できます(訳注: つまり TOS に f さえ返せばスタッ
クに何が積まれても(積まれなくても)気にしない)

   nt を使用すると、 ワードのインタプリタ機能(interpretation semantics)と
コンパイル機能(compilation semantics)や、 その名前や、 ワードリスト内の
次のワードのワード、 にアクセスできます:

‘name>interpret’ ( nt – xt  ) tools-ext “name-to-interpret”
   xt はワード nt のインタプリタ機能(interpretation semantics)を表します
。

‘name>compile’ ( nt – w xt  ) tools-ext “name-to-compile”
   w xt はワード nt のコンパイル・トークン(compilation token)です(訳注:
コンパイル・トークン CT は 2セル構成)。

‘name>string’ ( nt – addr u  ) tools-ext “name-to-string”
   addr count は、 nt で表されるワードの名前です。

‘id.’ ( nt –  ) gforth-0.6 “i-d-dot”
   NT で表されるワードの名前を出力します。

‘.id’ ( nt –  ) gforth-0.6 “dot-i-d”
   ‘id.’ の F83 での名前です。

‘name>link’ ( nt1 – nt2 / 0  ) gforth-1.0 “name-to-link”
   ワード nt1 の場合、 同じワードリスト内の1つ前のワード nt2 を返します
。 前のワードがない場合は 0 を返します。

   名前なしワードは通常、 インタプリタ機能(interpretation compilation)も
無く、 コンパイル機能(compilation semantics)も無く、 名前も無く、 単語リ
ストにもありません。 しかし、Gforth (1.0 以降) ではすべてのワードは等し
いため、 名前無しのワードにも nt があります(ただし、 ワードリストには含
まれません)。 その nt は ‘latestnt’ で取得でき、 nt を消費する上記のワー
ド群はこれらの nt に対して適切な処理を行います。

   使用例として、 以下のコードは、デフォルト以外のコンパイル機能
(compilation semantics)を持つ ‘forth-wordlist’ 内のすべてのワードをリス
トします:

     : ndcs-words ( wid -- )
       [: dup name>compile ['] compile, <> if over id. then 2drop true ;]
       swap traverse-wordlist ;

     forth-wordlist ndcs-words

   このコードは、 コンパイル・トークンの xt 部分が ‘compile,’ の xt であ
る場合、 ワードがデフォルトのコンパイル機能(compilation semantics)を持っ
ていると仮定しています。

   いにしえの Forth システムの nt に最も近いのはネーム・フィールド・アド
レス(NFA)ですが、 Gforth とは顕著な違いがあります。 いにしえの Forth シ
ステムでは、 各ワードに一意の NFAとLFAとCFAとPFA(または、LFAとNFAとCFAと
PFAの順)があり、 あるワードから次のワードへと進むためのワードがありまし
た。 これとは対照的に、 Gforth では、 いくつかの nt が ‘name>interpret’
xt からは同一の xt を取得できます。 名前トークンによって識別される構造体
にリンク・フィールドがありますが、 通常、 検索にはこれらの構造体の外部に
あるハッシュ・テーブルが使用されます。 Gforth の名前はセル幅のカウントお
よびフラグ・フィールド(cell-wide count-and-flags field)がありますが、 nt
はそのカウント・フィールドへのアドレスとしては実装されていません。


File: gforth.info,  Node: Compilation token,  Prev: Name token,  Up: Tokens for Words

6.12.3 Compilation token
------------------------

名前付きワードのコンパイル機能(compilation semantics)は、 2 つのセル w
xt で構成されるコンパイル・トークン(“compilation token”)によって表されま
す。 一番上のセル xt は実行トークンです。 コンパイル・トークンによって表
されるコンパイル機能は、 ‘execute’ で実行できます。 これは、 コンパイル
・トークン全体を消費し、 コンパイル・トークンが表すコンパイル機能
(compilation semantics)によって決定される追加のスタック効果を伴います。

   現時点では、 コンパイル・トークンの w 部分は実行トークンで、 xt 部分
は ‘execute’ または ‘compile,’ のいずれかを表します(1)。 ただし、 必要な
場合を除き、 この知識に頼らないでください。 Gforth の将来のバージョンで
は、 普通でない(unusual)なコンパイル・トークン(リテラルのコンパイル機能
を表すコンパイル・トークンなど)が導入される可能性があります。

   たとえば、 ‘if’ のコンパイル・ークンは、 ‘name>compile’ を使用した標
準的な方法(例: ‘`if name>compile’)で取得できますが、 コンパイル・トーク
ンを取得するためのパース・ワードもあります:

‘[COMP']’ ( compilation "name" – ; run-time – w xt  ) gforth-0.2 “bracket-comp-tick”
   コンパイル・トークン w xt は、 name のコンパイル機能(compilation
semantics)を表します。

‘COMP'’ ( "name" – w xt  ) gforth-0.2 “comp-tick”
   コンパイル・トークン w xt は、 name のコンパイル機能(compilation
semantics)を表します。

   ‘execute’ を使用して、 コンパイル・トークンによって表されるコンパイル
機能(compilation semantics)を実行できます。 ‘postpone,’ を使用してコンパ
イル機能(compilation semantics)をコンパイルできます。 つまり、 ‘``x
name>compile postpone,’ は ‘postpone x’ と同等です。

‘postpone,’ ( w xt –  ) gforth-0.2 “postpone-comma”
   コンパイル・トークン w xt で表されるコンパイル機能(compilation
semantics)をコンパイルします。

   ---------- Footnotes ----------

   (1) これは、 ワードのコンパイル機能(compilation semantics)に依存しま
す。 ワードにデフォルトのコンパイル機能(compilation semantics)がある場合
、 xt は ‘compile,’ を表します。 それ以外の場合(たとえば、 即実行ワード
の場合)、 xt は ‘execute’ を表します


File: gforth.info,  Node: Compiling words,  Next: The Text Interpreter,  Prev: Tokens for Words,  Up: Words

6.13 Compiling words
====================

他のほとんどの言語とは異なり、 Forth にはコンパイルと実行時(run-time)の
間に厳密な境界がありません。 たとえば、 ワードの定義中(または ‘constant’
のようなワードの定義によって使用されるデータのための計算)に任意のコード
を実行できます。 さらに、 ‘immediate’ (*note Interpretation and
Compilation Semantics::) や ‘[’...‘]’  (下記参照)を使用すると、 コロン定
義のコンパイル中に任意のコードを実行できます(例外: ディクショナリ空間で
割り当てしてはいけません)。

* Menu:

* Literals::                 データ値をコンパイルします
* Macros::                   Compiling words


File: gforth.info,  Node: Literals,  Next: Macros,  Prev: Compiling words,  Up: Compiling words

6.13.1 Literals
---------------

最も単純で最も頻繁に使用される例は、 コンパイル中にリテラルを計算するこ
とです。 たとえば、 以下の定義は、 文字列の配列を 1 行に 1 つの文字列で
出力します:

     : .strings ( addr u -- ) \ gforth
         2* cells bounds U+DO
             cr i 2@ type
         2 cells +LOOP ;

   Gforth のような愚かで低能なコンパイラを使用すると、 ループ反復ごとに
‘2 cells’ が計算されます。 あなたは、 この値をコンパイル時に一度だけ計算
し、 定義にコンパイルできます。 以下のようにします:

     : .strings ( addr u -- ) \ gforth
         2* cells bounds U+DO
             cr i 2@ type
         [ 2 cells ] literal +LOOP ;

   ‘[’ は、 テキスト・インタープリタをインタプリタ状態に切り替えます(こ
の例を対話的に入力し、 ‘[’ と ‘]’ の間に改行を挿入すると、 ‘ok’ プロンプ
トが表示されます)。 ‘2 cells’ のインタプリタ機能(interpretation
semantics)を実行します。 ここでは数値を計算します。 ‘]’ は、 テキスト・
インタプリタをコンパイル状態に戻します。 次に、 この数値を現在のワードに
コンパイルする ‘Literal’ のコンパイル機能(compilation semantics)を実行し
ます。 ‘see .strings’ を使用してワードを逆コンパイルすると、 コンパイル
されたコードへの影響を確認できます。

   この方法で ‘2* cells’ を ‘[ 2 cells ] literal *’ に最適化することもで
きます。

‘[’ ( –  ) core “left-bracket”
   インタプリタ状態にします。 即実行ワードです。

‘]’ ( –  ) core “right-bracket”
   コンパイル状態にします。

‘Literal’ ( compilation n – ; run-time – n  ) core “Literal”
   コンパイル機能(compilation semantics): 実行機能(run-time semantics)を
コンパイルします。 実行機能(run-time semantics): n をスタックにプッシュ
します。 インタプリタ機能(interpretation semantics): 未定義です。

‘ALiteral’ ( compilation addr – ; run-time – addr  ) gforth-0.2 “ALiteral”
   ‘literal’ と同様に機能しますが、 (クロス・コンパイルされたコードで使
用される場合、)リテラルがアドレスであることをクロス・コンパイラーに伝え
ます。

‘]L’ ( compilation: n – ; run-time: – n  ) gforth-0.5 “]L”
   ‘] literal’ と同等。

   単一セル以外のデータ型をリテラルとしてコンパイルするためのワードもあ
ります:

‘2Literal’ ( compilation w1 w2 – ; run-time  – w1 w2  ) double “two-literal”
   実行時に w1 w2 がスタックに配置されるように、 適切なコードをコンパイ
ルします。 インタプリタ機能(interpretation semantics)は未定義です。

‘FLiteral’ ( compilation r – ; run-time – r  ) floating “f-literal”
   実行時に r が(浮動小数点)スタックに配置されるように、 適切なコードを
コンパイルします。 インタプリタ機能(interpretation semantics)は未定義で
す。

‘SLiteral’ ( Compilation c-addr1 u ; run-time – c-addr2 u  ) string “SLiteral”
   コンパイル時: c-addr1, u で指定された文字列を現在の定義にコンパイルし
ます。 実行時: 文字列のアドレスと長さを記述する c-addr2 u を返します。

   データ・スタック上のコロン定義の外側から内側にデータを渡したいと思う
かもしれません。 ‘:’ がコロン colon-sys をプッシュし、 colon-sys より下
のモノのにアクセスできなくなるため、 これは機能しません。 たとえば、 以
下は機能しません:

     5 : foo literal ; \ error: "unstructured"

   代わりに、 変数など、 他の方法で値を渡す必要があります:

     variable temp
     5 temp !
     : foo [ temp @ ] literal ;


File: gforth.info,  Node: Macros,  Prev: Literals,  Up: Compiling words

6.13.2 Macros
-------------

‘Literal’ とその仲間たちは、 データ値を現在の定義にコンパイルします。 他
のワードを現在の定義にコンパイルするワードを記述することもできます。 例
えば:

     : compile-+ ( -- ) \ compiled code: ( n1 n2 -- n )
       POSTPONE + ;

     : foo ( n1 n2 -- n )
       [ compile-+ ] ;
     1 2 foo .

   これは ‘: foo + ;’ と同等です(確認するには ‘see foo’ としてください
)。 この例では何が起こっているのでしょうか?  ‘Postpone’ は、 ‘+’ のコン
パイル機能(compilation semantics)を ‘compile-+’ にコンパイルします。 そ
の後、 テキスト・インタプリタは ‘compile-+’ を実行し、 + のコンパイル機
能(compilation semantics)を実行します。 これにより、‘+’ (の実行機能
(execution semantics)) が ‘foo’ にコンパイルされます(1)。

‘postpone’ ( "name" –  ) core “postpone”
   name の コンパイル機能(compilation semantics)をコンパイルする。

   ‘compile-+’ のようなコンパイル・ワード(compiling words)のコンパイルは
通常即実行ワード(または即実行同様)であるため、 それらを実行するためにイ
ンタプリタ状態に切り替える必要はありません。 最後の例をそれに応じて変更
すると、 以下のようになります:

     : [compile-+] ( compilation: --; interpretation: -- )
       \ compiled code: ( n1 n2 -- n )
       POSTPONE + ; immediate

     : foo ( n1 n2 -- n )
       [compile-+] ;
     1 2 foo .

   場合によっては、 複数のワードを POSTPONE する必要があることに気づくで
しょう。 このような各ワードの前に POSTPONE を置くのは面倒なので、 Gforth
ではより便利な構文 ‘]] ... [[’ を提供しています。 これにより、
‘[compile-+]’ を以下のように記述できるようになります:

     : [compile-+] ( compilation: --; interpretation: -- )
       ]] + [[ ; immediate

‘]]’ ( –  ) gforth-0.6 “right-bracket-bracket”
   postpone 状態に切り替え: すべてのワードと認識器(recognizers)は、 その
前に ‘postpone’ があるかのように処理されます。 ‘[[’ が認識されると、
postpone 状態は終了します。

   角括弧の珍しい方向はその機能を示しています。 ‘]’ が即時実行(インタプ
リタ状態)からコンパイルに切り替えるのと同じように、 ‘]]’ はコンパイルか
ら postpone 状態(つまり、 コンパイル機能のコンパイル)に切り替えます。 逆
に、 ‘[[’ は postpone 状態からコンパイル状態に切り替えます。 これは、 コ
ンパイル状態から即時実行(インタプリタ状態)に切り替える ‘[’ に似ています
。

   ‘]] ’...‘ [[’ の本当の利点は、 POSTPONE するワードがたくさんある場合
に明らかになります。 たとえば、 ワード ‘compile-map-array’ (*note
Advanced macros Tutorial::) は、 以下のようにさらに短く書くことができま
す:

     : compile-map-array ( compilation: xt -- ; run-time: ... addr u -- ... )
     \ at run-time, execute xt ( ... x -- ... ) for each element of the
     \ array beginning at addr and containing u elements
       {: xt: xt :}
       ]] cells over + swap ?do
         i @ xt 1 cells +loop [[ ;

     : sum-array ( addr u -- n )
       0 [ ' + compile-map-array ] ;

   ‘see sum-array’ すると、 以下のコードが表示されます:

     : sum-array
       #0 over + swap ?do
         i  + #8 +LOOP
     ;

   ‘]]’...‘[[’ に加えて、 この例では他の機能もいくつかお披露目しています
:

   • (‘xt:’ を指定する) defer フレーバーのローカル変数 ‘xt’ を使用してい
     ます。 ‘]]’...‘[[’ 内でローカル変数 xt に遭遇すると、 ローカル変数
     xt を ‘compile,’ します。

   • ‘]]’...‘[[’ 内でリテラル ‘1’ を使用します。 これにより、 ‘1’ が
     postpone (延期)されます。 つまり、 ‘compile-map-array’ の実行時にコ
     ンパイルされます。

   • ‘compile-map-array’ が実行されると、 ‘1 cells’ がコンパイルされ、
     Gforth の定数折りたたみによって ‘#8’ に最適化(optimize)されます。

   注意: ‘s\"’ などのワードのパースは postpone 指定時にはパースされない
ため、 ‘]]’...‘[[’ 内ではパースされないことに注意してください。 ‘s\"
mystring\n"’ の代わりに、 文字列認識器(string recognizer)を使用して、
‘]]’...‘[[’ 内で動作する ‘"mystring\n"’ で記述することができます。これは
‘]]’...‘[[’ 内で機能します。 同様に、 パース・ワード ‘[']’ についても、
‘`’ で始まる認識器(recognizer)表記で記述することができます。

   ただし、 あなたが ‘s\"’ を使用したい場合(または、 認識器
(recognizer)置換がないパース・ワードがある場合)、 以下のようにコンパイル
状態に切り替えることで実行できます:

     ]] ... [[ s\" mystring\n" ]] 2literal ... [[

   標準 Forth での ‘]]’ と、 その仲間の定義は、 ‘compat/macros.fs’ で提
供されます。

   即時コンパイル・ワード(immediate compiling words)は、 他の言語(特に
Lisp)のマクロに似ています。 C言語などのマクロとの重要な違いは以下のとお
りです:

   • マクロの定義と処理には、 別個の前処理用の言語や処理器ではなく、 同
     一の言語を使用します。

   • したがって、 Forth の全機能をマクロ定義で利用できます。 たとえば、
     任意の複雑な計算を実行したり、 条件付きまたはループで異なるコードを
     生成したりできます (例: *note Advanced macros Tutorial::)。 この能
     力は、 パーサ・ジェネレータや、 その他のコード生成ソフトウェアを作
     成するときに非常に役立ちます。

   • ‘postpone’ などを使用して定義されたマクロは、 文字列よりも高いレベ
     ルで言語を扱います。 名前との結び付け(name binding)はマクロ定義時に
     行われるため、 C言語のマクロで発生する可能性のある名前の衝突の落と
     し穴を回避できます。 もちろん、 Forth は自由主義の言語(liberal
     language)であり、 以下のようなテキスト解釈マクロ(text-interpreted
     macros)を使用して自分自身を攻撃することもできます

          : [compile-+] s" +" evaluate ; immediate

     マクロ使用時に名前を結びつける(bind)だけでなく、 ‘evaluate’ を使用
     すると、 あなたの定義は ‘state’-smart (*note state-smartness::) に
     なります。

   マクロで数値をワードにコンパイルすることが必要な場合があります。 これ
を行うためのワードは ‘literal’ ですが、 ‘postpone’ する必要があるため、
‘literal’ のコンパイル機能(compilation semantics)はマクロがコンパイルさ
れる時ではなくマクロの実行時に効果を発揮します:

     : [compile-5] ( -- ) \ compiled code: ( -- n )
       5 POSTPONE literal ; immediate

     : foo [compile-5] ;
     foo .

   マクロにパラメータを渡して、 マクロを現在の定義にコンパイルする必要が
ある場合があります。 パラメータが数値の場合は、 ‘postpone literal’ を使
用できます(他の値の場合も同様)。

   コンパイルされるワードを渡したい場合、 通常の方法は、実行トークンと
‘compile,’ を渡すことです:

     : twice1 ( xt -- ) \ compiled code: ... -- ...
       dup compile, compile, ;

     : 2+ ( n1 -- n2 )
       [ ' 1+ twice1 ] ;

‘compile,’ ( xt –  ) core-ext “compile-comma”
   xt で表される機能(semantics)を現在の定義に追加します。 結果のコード断
片が実行されると、 xt が ‘execute’ されたのと同一の振る舞いをします。

   Gforth で利用可能な代替方法では、 コンパイル機能をパラメータ
(compilation semantics)として渡すことができる、 コンパイル・トークンを使
用します(*note Compilation token::)。 以下は、 上記と同じ例にこの方法を
使ったものです:

     : twice ( ... ct -- ... ) \ compiled code: ... -- ...
       2dup 2>r execute 2r> execute ;

     : 2+ ( n1 -- n2 )
       [ comp' 1+ twice ] ;

   この例では、 ‘2>r’ と ‘2r>’ により、 実行(execute)されるコンパイル機
能(compilation semantics)がデータ・スタックに影響を与える場合でも、
‘twice’ が確実に機能するようにします(訳注: 2dup ( ct ct ) 2>r ( ct r:ct
) execute ( ??  r:ct ) 2r> ( ??  ct ) execute ( ???  )  。 最初の
execute でデータ・スタックのTOSがどうなろうとも、 2つ目の execute のため
に ct を tos に与えるため。 ct は 2セル単位なので、 2dupで複製、 2>r ...
2r> で ct を1つ退避となる)

   これらのワードを使用して完全な定義を定義することもできます。 これは、
‘does>’ を使用する代わりの方法を提供します(*note User-defined Defining
Words::)。 たとえば以下の代わりに

     : curry+ ( n1 "name" -- )
         CREATE ,
     DOES> ( n2 -- n1+n2 )
         @ + ;

   以下のように定義することができます

     : curry+ ( n1 "name" -- )
       \ name execution: ( n2 -- n1+n2 )
       >r : r> POSTPONE literal POSTPONE + POSTPONE ; ;

     -3 curry+ 3-
     see 3-

   n1 にアクセスするために ‘>r : r>’ というシーケンスが必要です。 なぜな
ら、 ‘:’ はデータ・スタックに colon-sys をプッシュし、 それより下にある
全てのモノにアクセスできなくなるためです。

   ワードを定義するこの方法は、 ‘does>’ を使用するよりも便利な場合もあれ
ば、 そうでない場合もあります(*note Advanced does> usage example::)。 こ
の方式の利点の 1 つは、 コンパイラは、 ‘literal’ でコンパイルされた値が
固定されているのに対して、 ‘create’ されたワードに関連付けられたデータは
変更可能なことを認識しているため、 より適切に最適化できることです。

‘[compile]’ ( compilation "name" – ; run-time ? – ?  ) core-ext “bracket-compile”
   古いワード(lLegacy word)です。 代わりに ‘postpone’ を使用してください
。 name がデフォルト以外のコンパイル機能(compilation semantics)を持つ場
合は、 ‘postpone’ と同様に機能します。 name がデフォルトのコンパイル機能
を持つ(つまり、 通常のワードである)場合、 ‘[compile] name’ をコンパイル
することは、 name をコンパイルすることと同じです(つまり、 この場合
‘[compile]’ は冗長です)。

   ---------- Footnotes ----------

   (1) 最近の RFI の回答では、 ワードのコンパイルはコンパイル状態でのみ
実行する必要があるとしているため、 この例はすべての標準システムで動作す
ることは保証されませんが、 ちゃんとした(decent)システムであれば動作しま
す


File: gforth.info,  Node: The Text Interpreter,  Next: The Input Stream,  Prev: Compiling words,  Up: Words

6.14 The Text Interpreter
=========================

テキスト・インタプリタ(text interpreter)は、 現在の入力デバイスからの入
力を処理する無限ループです。 インタプリタの実装上でコンパイルされた
Forth コードを実行する内部インタプリタ(inner interpreter)(*note
Engine::)とは対照的に、 これは外部インタプリタ(outer interpreter)とも呼
ばれます(1)。

   テキスト・インタプリタは、 インタプリタ状態(“interpret state”) と コ
ンパイル状態(“compile state”)の 2 つの状態のいずれかで動作します。 現在
の状態は、 それにふさわしい名前の変数である ‘state’ によって定義されます
。

   このセクションでは、 テキスト・インタプリタがインタプリタ状態にあると
きに、 ユーザー入力デバイス(キーボード)からの入力処理についてどのように
振る舞うかについて説明することから始めます。 これは Forth システムが動き
始めた時のモードです。

   テキスト・インタプリタは、 入力バッファ(“input buffer”)(2)と呼ばれる
メモリ領域で動作します。 この領域には、 <RET> キーを押したときにキーボー
ドからの入力が保存され、 入力バッファの先頭から開始して、 先頭の空白文字
達(デリミタ(“delimiters”)と呼ばれる)をスキップし、 空白文字、 またはバッ
ファの終わりに達するまで文字列(空白以外の文字のシーケンス)をパースします
。 文字列をパースした後、 以下の2つの試行を行います:

   • 定義のディクショナリ(“dictionary”)内でその文字列を検索します。 その
     文字列が見つかった場合、 その文字列は、 とある定義(“definition”)(ワ
     ード(“word”)とも呼ばれる)を指し示していて、 そして、 ディクショナリ
     検索機能は、 テキスト・インタプリタがそのワードのインタプリタ機能
     (“interpretation semantics”)を実行できるようにするための情報を返し
     ます。 ほとんどの場合、 これは、 単にそのワードが execute されるこ
     とを意味します。
   • 文字列がディクショナリに見つからない場合、 テキスト・インタプリタは
     *note Number Conversion:: で説明されているルールを使用して、 文字列
     を数値として処理しようと試みます。 文字列が現在の基数で有効な数値を
     表す場合、 その数値はパラメータ・スタック(整数の場合はデータ・スタ
     ック、 浮動小数点数の場合は浮動小数点スタック)にプッシュされます。

   上記両方の試行が失敗した場合、 テキスト・インタプリタは入力バッファの
残りを破棄し、 そして、 エラー・メッセージを発行して、そして、 さらなる
入力を待ちます。 いずれかの試行が成功すると、 テキスト・インタプリタは入
力バッファ全体が処理されるまでパース処理を繰り返し、 全体が処理された時
点でステータス・メッセージ “‘ ok’” を出力し、 そして、 さらなる入力を待
ちます。

   テキスト・インタプリタは、 ‘>IN’ (“to-in”(トゥーイン)と発音します)と
呼ばれる変数を更新することにより、 入力バッファ内の位置を追跡します。
‘>IN’ の値は 0 で始まり、 入力バッファの先頭からのオフセットが 0 である
ことを示します。 オフセット ‘>IN @’ から入力バッファの末尾までの領域は、
パース領域(“parse area”)と呼ばれます(3)。 以下の例は、 テキスト・インタ
プリタが入力バッファをパースする際に ‘>IN’ がどのように変化するかを示し
ています:

     : remaining source >in @ /string
       cr ." ->" type ." <-" ; immediate

     1 2 3 remaining + remaining .

     : foo 1 2 3 remaining swap remaining ;

これらの結果はそれぞれ以下のようになります:

     ->+ remaining .<-
     ->.<-5  ok

     ->swap remaining ;-<
     ->;<-  ok

   ‘>IN’ の値は、 テキスト・インタプリタによって実行される入力バッファ内
のワードによって変更することもできます。 これは、 ワードがテキスト・イン
タプリタをだまして、 入力バッファの一節をスキップしたり(4)、 一節を 2 回
パースしたりすることができることを意味します。 例:

     : lat ." <<foo>>" ;
     : flat ." <<bar>>" >IN DUP @ 3 - SWAP ! ;

‘flat’ が実行されると、 以下の出力が生成されます(5)(訳注:ユーザーが flat
と打ち込と、 入力バッファには flat があり、 ワード flat の実行が初まった
ときは >IN は flatの t の次を指している。 そこから 3 戻ると >IN が 指す
のは flat の l で、 そこからテキスト・インタプリタがパースを再開すると、
テキスト・インタプリタに見えるのは lat である。 よって lat が実行されて
<<foo>> が出力される):

     <<bar>><<foo>>

   この手法を使用すると、 ワードのパースにおける相互運用性の問題
(interoperability problems)の一部を回避できます。 もちろん、 ワードのパ
ースは可能な限り避けた方が良いです。

テキスト・インタプリタの振る舞いに関する 2 つの重要な注意事項:

   • 入力バッファからの追加の文字達をパースする前に、 各入力文字列の処理
     を完了させます。
   • 入力バッファを読み取り専用領域(region)として扱います(そして、 コー
     ドも同様に読み取り専用でなければなりません)。

テキスト・インタプリタがコンパイル状態にある場合、 その振る舞いは以下の
ように変化します:

   • パースされた文字列がディクショナリ内で見つかった場合、 テキスト・イ
     ンタプリタはそのワードのコンパイル機能(“compilation semantics”)を実
     行します。 ほとんどの場合、これは単にそのワードの実行機能(execution
     semantics)が現在の定義に追加されることを意味します。
   • 数値が検出されると、 パラメータ・スタックにプッシュされるのではなく
     、 現在の定義に(リテラルとして)コンパイルされます。
   • エラーが発生した場合、 ‘state’ が変更され、 テキスト・インタプリタ
     はインタプリタ状態に戻ります。
   • キーボードから行が入力されるたびに、 Gforth は “ ‘ok’” ではなく “‘
     compiled’” を出力します。

   テキスト・インタプリタがキーボード以外の入力デバイスを使用している場
合、 その振る舞いは以下のように変化します:

   • パース領域が空の場合、 テキスト・インタプリタは入力源(input
     source)から入力バッファを補充(refill)しようとします。 入力源を使い
     尽くすと、 入力源は以前の入力源に戻ります。
   • パース領域が空になるたびに “‘ ok’” や “‘ compiled’” メッセージは出
     力されません。
   • エラーが発生した場合、 入力源はユーザー入力デバイスに戻されます。

   これについて詳しくは、 *note Input Sources:: をご覧ください。

‘>in’ ( – addr  ) core “to-in”
   ‘uvar’ 変数 – a-addr は、 入力バッファの先頭からパース領域の先頭まで
の char オフセットを格納するセルへのアドレスです。

‘source’ ( – addr u  ) core “source”
   現在の入力バッファのアドレス addr と長さ u を返します

‘tib’ ( – addr  ) core-ext-obsolescent “t-i-b”

‘#tib’ ( – addr  ) core-ext-obsolescent “number-t-i-b”
   ‘uvar’ 変数 – a-addr は、 端末の入力バッファ内の文字数を含むセルのア
ドレスです。 OBSOLESCENT(時代遅れ): 代わりに ‘source’ を使ってください。

‘interpret’ ( ... – ...  ) gforth-0.2 “interpret”

* Menu:

* Input Sources::
* Number Conversion::
* Interpret/Compile states::
* Interpreter Directives::
* Recognizers::
* Text Interpreter Hooks::

   ---------- Footnotes ----------

   (1) このセクションは *note Introducing the Text Interpreter:: の拡大
バージョンです

   (2) テキスト・インタプリタがキーボードからの入力を処理している時、 こ
のメモリ領域はターミナル入力バッファ(“terminal input buffer” (TIB))と呼
ばれ、 (既に廃止されていますが) ワード ‘TIB’ および ワード ‘#TIB’ によっ
てアドレス指定されます

   (3) 言い換えると、 テキスト・インタプリタは、 パース領域が空になるま
で、 パース領域からの文字列をパースすることによって、 入力バッファの内容
を処理します

   (4) これがワードのパースの仕組みです

   (5) 研究課題: ‘3’ を ‘4’ に置き換えたらどうなるでしょうか？


File: gforth.info,  Node: Input Sources,  Next: Number Conversion,  Prev: The Text Interpreter,  Up: The Text Interpreter

6.14.1 Input Sources
--------------------

デフォルトでは、 テキスト・インタプリタは、 Forth の起動時にユーザー入力
デバイス(キーボード)からの入力を処理します。 テキスト・インタプリタは、
以下のいずれかの入力源からの入力を処理できます:

   • ユーザー入力デバイス – つまり、キーボード。
   • ファイル。 *note Forth source files:: で説明されているワードを使用
     。
   • ブロック。 *note Blocks:: で説明されているワードを使用。
   • テキスト文字列。 ‘evaluate’ 使用。

   プログラムは、 ‘source-id’ と ‘blk’ の値から現在の入力デバイスを識別
できます。

‘source-id’ ( – 0 | -1 | fileid  ) core-ext,file “source-i-d”
   戻り値: 0 (入力源はユーザー入力デバイス)または、 -1 (入力源は
‘evaluate’ によって処理されている文字列)または、 fileid (入力源は fileid
で指定されたファイル)です。

‘blk’ ( – addr  ) block “b-l-k”
   ‘uvar’ 変数 – このセルには現在のブロック番号(現在の入力源がブロックで
ない場合は 0)が格納されています。

‘save-input’ ( – x1 .. xn n  ) core-ext “save-input”
   n 個のエントリ xn 〜 x1 は、 ‘restore-input’ で使用できるプラットフォ
ーム依存の方法で、 入力源仕様の現在の状態を記述します。

‘restore-input’ ( x1 .. xn n – flag  ) core-ext “restore-input”
   入力源仕様を n 個のエントリ xn 〜 x1 で記述された状態に復元しようとし
ます。 復元が失敗した場合は flag が true になります。 新しい入力プログラ
ムを使用した Gforth では、 再度 throw するために使用できるフラグがある場
合にのみ失敗します。 異なるアクティブな入力ストリーム間で保存および復元
することも可能です。 注意: 入力ストリームを閉じる場合は、 開いたときとは
逆の順序で行う必要がありますが、 その間はすべて許可されます。

‘evaluate’ ( ... addr u – ...  ) core,block “evaluate”
   現在の入力源の仕様を保存します。 そして、 ‘-1’ を ‘source-id’ に保存
し、 かつ、 ‘0’ を ‘blk’ に保存します。 それから、 ‘>IN’ を ‘0’ に設定し
、 文字列 c-addr u を入力源および入力バッファにし、 解釈(interpret)しま
す。 そしてパース領域が空になったら、 入力源の仕様を復元します。

‘query’ ( –  ) core-ext-obsolescent “query”
   ユーザー入力デバイスを入力源にします。 入力を端末入力バッファ
(Terminal Input Buffer)で受け取ります。 ‘>IN’ をゼロに設定します。
OBSOLESCENT(時代遅れ): 代わりに ‘accept’ を使ってください。


File: gforth.info,  Node: Number Conversion,  Next: Interpret/Compile states,  Prev: Input Sources,  Up: The Text Interpreter

6.14.2 Number Conversion
------------------------

You get an overview of how the text interpreter converts its numeric
input in *note Literals in source code::.  This section describes some
related words.

   By default, the number base used for integer number conversion is
given by the contents of the variable ‘base’.  Note that a lot of
confusion can result from unexpected values of ‘base’.  If you change
‘base’ anywhere, make sure to save the old value and restore it
afterwards; better yet, use ‘base-execute’, which does this for you.  In
general I recommend keeping ‘base’ decimal, and using the prefixes
described in *note Literals in source code:: for the popular non-decimal
bases.

‘base-execute’ ( i*x xt u – j*x  ) gforth-0.7 “base-execute”
   execute xt with the content of ‘BASE’ being u, and restoring the
original ‘BASE’ afterwards.

‘base’ ( – a-addr  ) core “base”
   ‘User’ variable – a-addr is the address of a cell that stores the
number base used by default for number conversion during input and
output.  Don’t store to ‘base’, use ‘base-execute’ instead.

‘hex’ ( –  ) core-ext “hex”
   Set ‘base’ to &16 (hexadecimal).  Don’t use ‘hex’, use ‘base-execute’
instead.

‘decimal’ ( –  ) core “decimal”
   Set ‘base’ to &10 (decimal).  Don’t use ‘decimal’, use ‘base-execute’
instead.

‘dpl’ ( – a-addr  ) gforth-0.2 “Decimal-PLace”
   ‘User’ variable – a-addr is the address of a cell that stores the
position of the decimal point in the most recent numeric conversion.
Initialised to -1.  After the conversion of a number containing no
decimal point, ‘dpl’ is -1.  After the conversion of ‘2.’ it holds 0.
After the conversion of 234123.9 it contains 1, and so forth.

Number conversion has a number of traps for the unwary:

   • You cannot determine the current number base using the code
     sequence ‘base @ .’ – the number base is always 10 in the current
     number base.  Instead, use something like ‘base @ dec.’
   • There is a word ‘bin’ but it does not set the number base!  (*note
     General files::).
   • Standard Forth requires the ‘.’ of a double-precision number to be
     the final character in the string.  Gforth allows the ‘.’ to be
     anywhere.
   • The number conversion process does not check for overflow.

   You can read numbers into your programs with the words described in
*note Line input and conversion::.


File: gforth.info,  Node: Interpret/Compile states,  Next: Interpreter Directives,  Prev: Number Conversion,  Up: The Text Interpreter

6.14.3 Interpret/Compile states
-------------------------------

A standard program is not permitted to change ‘state’ explicitly.
However, it can change ‘state’ implicitly, using the words ‘[’ and ‘]’.
When ‘[’ is executed it switches ‘state’ to interpret state, and
therefore the text interpreter starts interpreting.  When ‘]’ is
executed it switches ‘state’ to compile state and therefore the text
interpreter starts compiling.  The most common usage for these words is
for switching into interpret state and back from within a colon
definition; this technique can be used to compile a literal (for an
example, *note Literals::) or for conditional compilation (for an
example, *note Interpreter Directives::).


File: gforth.info,  Node: Interpreter Directives,  Next: Recognizers,  Prev: Interpret/Compile states,  Up: The Text Interpreter

6.14.4 Interpreter Directives
-----------------------------

These words are usually used in interpret state; typically to control
which parts of a source file are processed by the text interpreter.
There are only a few Standard Forth Standard words, but Gforth
supplements these with a rich set of immediate control structure words
to compensate for the fact that the non-immediate versions can only be
used in compile state (*note Control Structures::).  Typical usage:

     [undefined] \G [if]
       : \G ... ; immediate
     [endif]

   So if the system does not define ‘\G’, compile some replacement code
(with possibly reduced functionality).

‘[IF]’ ( flag –  ) tools-ext “bracket-if”
   If flag is ‘TRUE’ do nothing (and therefore execute subsequent words
as normal).  If flag is ‘FALSE’, parse and discard words from the parse
area (refilling it if necessary using ‘REFILL’) including nested
instances of ‘[IF]’..  ‘[ELSE]’..  ‘[THEN]’ and ‘[IF]’..  ‘[THEN]’ until
the balancing ‘[ELSE]’ or ‘[THEN]’ has been parsed and discarded.
Immediate word.

‘[ELSE]’ ( –  ) tools-ext “bracket-else”
   Parse and discard words from the parse area (refilling it if
necessary using ‘REFILL’) including nested instances of ‘[IF]’..
‘[ELSE]’..  ‘[THEN]’ and ‘[IF]’..  ‘[THEN]’ until the balancing ‘[THEN]’
has been parsed and discarded.  ‘[ELSE]’ only gets executed if the
balancing ‘[IF]’ was ‘TRUE’; if it was ‘FALSE’, ‘[IF]’ would have parsed
and discarded the ‘[ELSE]’, leaving the subsequent words to be executed
as normal.  Immediate word.

‘[THEN]’ ( –  ) tools-ext “bracket-then”
   Do nothing; used as a marker for other words to parse and discard up
to.  Immediate word.

‘[ENDIF]’ ( –  ) gforth-0.2 “bracket-end-if”
   Do nothing; synonym for ‘[THEN]’

‘[defined]’ ( "<spaces>name" – flag  ) tools-ext “bracket-defined”
   returns true if name is found in current search order

‘[undefined]’ ( "<spaces>name" – flag  ) tools-ext “bracket-undefined”
   returns false if name is found in current search order

‘[IFDEF]’ ( "<spaces>name" –  ) gforth-0.2 “bracket-if-def”
   If name is found in the current search-order, behave like ‘[IF]’ with
a ‘TRUE’ flag, otherwise behave like ‘[IF]’ with a ‘FALSE’ flag.
Immediate word.

‘[IFUNDEF]’ ( "<spaces>name" –  ) gforth-0.2 “bracket-if-un-def”
   If name is not found in the current search-order, behave like ‘[IF]’
with a ‘TRUE’ flag, otherwise behave like ‘[IF]’ with a ‘FALSE’ flag.
Immediate word.

‘[?DO]’ ( n-limit n-index –  ) gforth-0.2 “bracket-question-do”

‘[DO]’ ( n-limit n-index –  ) gforth-0.2 “bracket-do”

‘[LOOP]’ ( –  ) gforth-0.2 “bracket-loop”

‘[+LOOP]’ ( n –  ) gforth-0.2 “bracket-question-plus-loop”

‘[FOR]’ ( n –  ) gforth-0.2 “bracket-for”

‘[NEXT]’ ( n –  ) gforth-0.2 “bracket-next”

‘[I]’ ( run-time – n  ) gforth-0.2 “bracket-i”
   At run-time, ‘[I]’ pushes the loop index of the
text-interpretation-time ‘[do]’ iteration.  If you want to process the
index at interpretation time, interpret ‘[I]’ interpretevely, or use
‘INT-[I]’.

‘INT-[I]’ ( – n  ) gforth-1.0 “int-bracket-i”
   Push the loop index of the ‘[do]’ iteration at text interpretation
time.

‘[BEGIN]’ ( –  ) gforth-0.2 “bracket-begin”

‘[UNTIL]’ ( flag –  ) gforth-0.2 “bracket-until”

‘[AGAIN]’ ( –  ) gforth-0.2 “bracket-again”

‘[WHILE]’ ( flag –  ) gforth-0.2 “bracket-while”

‘[REPEAT]’ ( –  ) gforth-0.2 “bracket-repeat”

   You can use ‘#line’ to change Gforth’s idea about the current source
line number and source file.  This is useful in cases where the Forth
file is generated from some other source code file, and you want to get,
e.g.  error messages etc.  that refer to the original source code; then
the Forth-code generator needs to insert ‘#line’ lines in the Forth code
wherever appropriate.

‘#line’ ( "u" "["file"]" –  ) gforth-1.0 “#line”
   Set the line number to u and (if present) the file name to file.
Consumes the rest of the line.


File: gforth.info,  Node: Recognizers,  Next: Text Interpreter Hooks,  Prev: Interpreter Directives,  Up: The Text Interpreter

6.14.5 Recognizers
------------------

テキスト・インタプリタはソース・コードを処理するときに、 コードを空白で
区切られた文字列に分割し、 認識器群(recognizers)の中からどれか1つの認識
器が文字列を識別(identify)(認識(recognize))するまで認識器群を呼び出して
、 それらをワードや数値などとして識別します。 その文字列が認識されない場
合、 テキスト・インタプリタはエラー(‘undefined word’)を報告します。

   認識器を取り扱う通常の方法は、 認識器の 1 つを識別(identify)するコー
ドを記述するだけです(*note Default Recognizers::)。 ただし、 それらを操
作したり(*note Dealing with existing Recognizers::)、 新しい認識器を定義
したりすることもできます(*note Defining Recognizers::)。

* Menu:

* Default Recognizers::
* Dealing with existing Recognizers::
* Defining Recognizers::


File: gforth.info,  Node: Default Recognizers,  Next: Dealing with existing Recognizers,  Prev: Recognizers,  Up: Recognizers

6.14.5.1 Default Recognizers
............................

標準の Forth テキスト・インタプリタは、 検索順序(search order)内のワード
(‘rec-nt’) と、 整数(‘rec-num’)と、 浮動小数点数(‘rec-float’)を認識しま
す。 デフォルトでは、 Gforth は 以下の構文も認識します

   • 文字列 例: ‘"mystring"’ (‘rec-string’)

   • 混合数値(complex numbers) 例: ‘0e+1ei’ (‘rec-complex’)

   • value への格納または defered word の変更 例: ‘->myvalue’ (‘rec-to’)

   • ワードのインタプリタ機能(interpretation semantics)表す xt です。 例
     : ‘`dup’ (‘rec-tick’)

   • ワードの nt です。 例: ‘``mysynonym’ (‘rec-dtick’)

   • ワードのボディのアドレス 例: ‘<myarray+8>’ (‘rec-body’)

   • オペレーティング・システムの環境変数へのアクセス 例: ‘${HOME}’
     (‘rec-env’)

   • ボキャブラリ内のワード 例: ‘myvoc1:myvoc2:myword’ (‘rec-scope’)

   • 指定の認識器(recognizer)使用して何かを認識する 例: ‘float?1.’
     (‘rec-meta’)

   ‘locate’ (*note Locating source code definitions::) を使用して、 ソー
ス・コードの一片を、 どの認識器(recognizer)が認識するか調べられます。 例
:

     defer mydefer
     locate ->mydefer

   これは ‘rec-to’ が ‘->mydefer’ を認識したことを示すハズです。 ただし
、 認識器がディクショナリのワードを認識する場合(スコープ認識機能など)、
locate はそのワードを表示します。

   以下を使用すると、 使用されている認識器と認識器の順序を確認できます

‘.recognizers’ ( –  ) gforth-experimental “dot-recognizers”
   (.order とは異なり、)最初に検索された認識器を左端にして、 現在の認識
器の順序を出力します。 すべての認識器に共通のプレフィックスである ‘rec-’
の代わりに、 反転表示の ‘~’ が表示されます。

   通常、 認識器は、 他の認識器と同一の文字列との一致を避けるように設計
されています。 たとえば、‘rec-env’ (環境変数認識器)には、 ‘$ADD’ のよう
な入力文字列の数値認識器との競合を避けるために中かっこ(braces)が必要です
。 ただし、 このポリシーにはいくつかの例外があります:

   • ワード名には任意の名前を付けることができるため、 他の認識器と競合す
     る可能性があります(また、 検索順序(search order)は他の認識器よりも
     前に検索されます)。

     ただし、 名前は ‘0’ (ゼロ)で始まらない傾向がある(そして ‘0’ (ゼロ)
     で始まる場合は特殊文字が含まれる傾向がある)ため、 base が ‘hex’ の
     場合は、 数値を ‘0’ (ゼロ)で始めることをお勧めします。

     これまで私たちが見てきた幾多のコードでは、 ワードを ‘'’ (クォート。
     別名ティック)で始める方が、 ‘`’ (バック・クォート。別名バック・ティ
     ック) で始めるよりもはるかに一般的であるため、 xt と nt の認識器は
     ‘`’ (バック・クォート)を使用して競合を減らしてください。

   • 整数認識器 ‘rec-num’ と、 浮動小数点認識器 ‘rec-float’ は、 どちら
     も、 たとえば ‘1.’ を認識します。 しかし、 ‘rec-num’ が(デフォルト
     では)先にあるため、 ‘1.’ は2倍長セルの整数として認識されます。
     ‘rec-float’ を最初に使用するように認識順序を変更すると、 ‘1.’ は浮
     動小数点数として認識されますが、 標準 Forth で書かれたコードを読み
     込むと、 非標準的な振る舞いになる可能性があります。

     いずれの場合も、 以下のようにして、 あなた独自のコード内では、 この
     競合を回避することをお勧めします。 つまり、 常に数値プレフィックス
     を付けて2倍長セル整数を記述します(例: ‘#1.’)。 また、 浮動小数点数
     は常に ‘e’ を使用して記述します(例: ‘1e’)。

   • ‘->’ で始まるワードをいくつか見てきました。 ‘to myvalue’ または
     ‘to?->myvalue’ を使用すると競合を回避できます(後者は ‘postpone’ で
     機能します)。


File: gforth.info,  Node: Dealing with existing Recognizers,  Next: Defining Recognizers,  Prev: Default Recognizers,  Up: Recognizers

6.14.5.2 Dealing with existing Recognizers
..........................................

A recognizer is a word to which you pass a string.  If the recognizer
recognizes the string, it typically returns some data and the xt of a
word for processing the data; this word is called the translator.  If
the recognizer does not recognize the string, it returns the xt of
‘notfound’.

   All recognizers have the stack effect ( c-addr u – ...  xt ).

   Recognizers take a string and return some data and a translator for
interpreting that data.  Gforth implements that translator as xt
(executing it will perform the appropriate action to handle the token in
the current state), but other Forth systems may implement it as actual
table, with three xts inside.  The first xt is the
interpretation/run-time xt, it performs the interpretation semantics on
the data (usually, this means it just leaves the data on the stack).
The second xt performs the compilation semantics, it gets the data and
the run-time semantics xt.  The third xt perfoms the postpone semantics,
it also gets the data and the run-time semantics xt.  You can use
‘>postpone’ to postpone the run-time xt.

   Recognizers are organized as stack, so you can arrange the sequence
of recognizers in the same way as the vocabulary stack.  Recognizer
stacks are themselves recognizers, i.e.  they are executable, take a
string and return a translator.

‘notfound’ ( state –  ) gforth-experimental “notfound”
   If a recognizer fails, it returns ‘notfound’

‘rec-nt’ ( addr u – nt translate-nt | notfound  ) gforth-experimental “rec-nt”
   recognize a name token

‘rec-num’ ( addr u – n/d table | notfound  ) gforth-experimental “rec-num”
   converts a number to a single/double integer

‘rec-float’ ( addr u – r translate-float | notfound  ) gforth-experimental “rec-float”
   recognize floating point numbers

‘rec-string’ ( addr u – addr u’ r:string | rectype-null  ) gforth-experimental “rec-string”
   Convert strings enclosed in double quotes into string literals,
escapes are treated as in ‘S\"’.

‘rec-to’ ( addr u – xt n r:to | rectype-null  ) gforth-experimental “rec-to”
   words prefixed with ‘->’ are treated as if preceeded by ‘TO’, with
‘+>’ as ‘+TO’, with ‘'>’ as ‘ADDR’, with ‘@>’ as ‘ACTION-OF’, and with
‘=>’ as ‘IS’.

‘rec-tick’ ( addr u – xt rectype-num | rectype-null  ) gforth-experimental “rec-tick”
   words prefixed with ‘`’ return their xt.  Example: ‘`dup’ gives the
xt of dup

‘rec-dtick’ ( addr u – nt rectype-num | rectype-null  ) gforth-experimental “rec-dtick”
   words prefixed with ‘``’ return their nt.  Example: ‘``S"’ gives the
nt of ‘S"’

‘rec-body’ ( addr u – xt translate-tick | translate-null  ) gforth-experimental “rec-body”
   words bracketed with ‘'<'’ ‘'>'’ return their body.  Example: ‘<dup>’
gives the body of dup

‘get-recognizers’ ( – xt1 .. xtn n  ) gforth-experimental “get-recognizers”
   push the content on the recognizer stack

‘set-recognizers’ ( xt1 .. xtn n –  ) gforth-experimental “set-recognizers”
   set the recognizer stack from content on the stack

‘recognize’ ( addr u rec-addr – ... rectype  ) gforth-experimental “recognize”
   apply a recognizer stack to a string, delivering a token

‘recognizer-sequence:’ ( xt1 .. xtn n "name" –  ) gforth-experimental “recognizer-sequence:”
   concatenate a stack of recognizers to one recognizer with the name
"name".  xtn is tried first, xt1 last, just like on the recognizer stack

‘forth-recognize’ ( c-addr u – ... translate-xt  ) recognizer “forth-recognize”
   The system recognizer

‘forth-recognizer’ ( – xt  ) gforth-experimental “forth-recognizer”
   backward compatible to Matthias Trute recognizer API. This construct
turns a deferred word into a value-like word.

‘set-forth-recognize’ ( xt –  ) recognizer “set-forth-recognize”
   Change the system recognizer

‘translate:’ ( int-xt comp-xt post-xt "name" –  ) gforth-experimental “translate:”
   create a new recognizer table.  Items are in order of STATE value,
which are 0 or negative.  Up to 7 slots are available for extensions.

‘translate-nt’ ( i*x nt – j*x  ) gforth-experimental “translate-nt”
   translate a name token

‘translate-num’ ( x – | x  ) gforth-experimental “translate-num”
   translate a number

‘translate-dnum’ ( dx – | dx  ) gforth-experimental “translate-dnum”
   translate a double number

   doc-translate-float
‘try-recognize’ ( addr u xt – results | false  ) gforth-experimental “try-recognize”
   For nested recognizers: try to recognize ADDR U, and execute XT to
check if the result is desired.  If XT returns false, clean up all side
effects of the recognizer, and return false.  Otherwise return the
results of the call to XT, of which the topmost is non-zero.

‘>interpret’ ( translator –  ) gforth-experimental “>interpret”
   perform interpreter action of translator

‘>compile’ ( translator –  ) gforth-experimental “>compile”
   perform compile action of translator

‘>postpone’ ( translator –  ) gforth-experimental “>postpone”
   perform postpone action of translator

‘translate-method:’ ( "name" –  ) gforth-experimental “translate-method:”
   create a new translate method, extending the translator table.  You
can assign an xt to an existing rectype by using XT RECTYPE ‘to’
TRANSLATOR.

‘translate-state’ ( xt –  ) gforth-experimental “translate-state”
   change the current state of the system so that executing a translator
matches the translate-method passsed as XT


File: gforth.info,  Node: Defining Recognizers,  Prev: Dealing with existing Recognizers,  Up: Recognizers

6.14.5.3 Defining Recognizers
.............................


File: gforth.info,  Node: Text Interpreter Hooks,  Prev: Recognizers,  Up: The Text Interpreter

6.14.6 Text Interpreter Hooks
-----------------------------

‘before-line’ ( –  ) gforth-1.0 “before-line”
   Deferred word called before the text interpreter parses the next line

‘before-word’ ( –  ) gforth-0.7 “before-word”
   Deferred word called before the text interpreter parses the next word

‘line-end-hook’ ( –  ) gforth-0.7 “line-end-hook”
   called at every end-of-line when text-interpreting from a file


File: gforth.info,  Node: The Input Stream,  Next: Word Lists,  Prev: The Text Interpreter,  Up: Words

6.15 The Input Stream
=====================

The text interpreter reads from the input stream, which can come from
several sources (*note Input Sources::).  Some words, in particular
defining words, but also words like ‘'’, read parameters from the input
stream instead of from the stack.

   Such words are called parsing words, because they parse the input
stream.  Parsing words are hard to use in other words, because it is
hard to pass program-generated parameters through the input stream.
They also usually have an unintuitive combination of interpretation and
compilation semantics when implemented naively, leading to various
approaches that try to produce a more intuitive behaviour (*note
Combined words::).

   It should be obvious by now that parsing words are a bad idea.  If
you want to implement a parsing word for convenience, also provide a
factor of the word that does not parse, but takes the parameters on the
stack.  To implement the parsing word on top if it, you can use the
following words:

‘parse’ ( xchar "ccc<xchar>" – c-addr u  ) core-ext,xchar-ext “parse”
   Parse ccc, delimited by xchar, in the parse area.  c-addr u specifies
the parsed string within the parse area.  If the parse area was empty, u
is 0.

‘string-parse’ ( c-addr1 u1 "ccc<string>" – c-addr2 u2  ) gforth-1.0 “string-parse”
   Parse ccc, delimited by the string c-addr1 u1, in the parse area.
c-addr2 u2 specifies the parsed string within the parse area.  If the
parse area was empty, u2 is 0.

‘parse-name’ ( "name" – c-addr u  ) core-ext “parse-name”
   Get the next word from the input buffer

‘parse-word’ ( – c-addr u  ) gforth-obsolete “parse-word”
   old name for ‘parse-name’; this word has a conflicting behaviour in
some other systems.

‘name’ ( – c-addr u  ) gforth-obsolete “name”
   old name for ‘parse-name’

‘word’ ( char "<chars>ccc<char>– c-addr  ) core “word”
   Skip leading delimiters.  Parse ccc, delimited by char, in the parse
area.  c-addr is the address of a transient region containing the parsed
string in counted-string format.  If the parse area was empty or
contained no characters other than delimiters, the resulting string has
zero length.  A program may replace characters within the counted
string.  OBSOLESCENT: the counted string has a trailing space that is
not included in its length.

‘refill’ ( – flag  ) core-ext,block-ext,file-ext “refill”
   Attempt to fill the input buffer from the input source.  When the
input source is the user input device, attempt to receive input into the
terminal input device.  If successful, make the result the input buffer,
set ‘>IN’ to 0 and return true; otherwise return false.  When the input
source is a block, add 1 to the value of ‘BLK’ to make the next block
the input source and current input buffer, and set ‘>IN’ to 0; return
true if the new value of ‘BLK’ is a valid block number, false otherwise.
When the input source is a text file, attempt to read the next line from
the file.  If successful, make the result the current input buffer, set
‘>IN’ to 0 and return true; otherwise, return false.  A successful
result includes receipt of a line containing 0 characters.

   If you have to deal with a parsing word that does not have a
non-parsing factor, you can use ‘execute-parsing’ to pass a string to
it:

‘execute-parsing’ ( ... addr u xt – ...  ) gforth-0.6 “execute-parsing”
   Make addr u the current input source, execute xt ‘( ... -- ... )’,
then restore the previous input source.

   Example:

     5 s" foo" ' constant execute-parsing
     \ equivalent to
     5 constant foo

   A definition of this word in Standard Forth is provided in
‘compat/execute-parsing.fs’.

   If you want to run a parsing word on a file, the following word
should help:

‘execute-parsing-file’ ( i*x fileid xt – j*x  ) gforth-0.6 “execute-parsing-file”
   Make fileid the current input source, execute xt ‘( i*x -- j*x )’,
then restore the previous input source.


File: gforth.info,  Node: Word Lists,  Next: Environmental Queries,  Prev: The Input Stream,  Up: Words

6.16 Word Lists
===============

A wordlist is a list of named words; you can add new words and look up
words by name (and you can remove words in a restricted way with
markers).  Every named (and ‘reveal’ed) word is in one wordlist.

   The text interpreter searches the wordlists present in the search
order (a stack of wordlists), from the top to the bottom.  Within each
wordlist, the search starts conceptually at the newest word; i.e., if
two words in a wordlist have the same name, the newer word is found.

   New words are added to the “compilation wordlist” (aka current
wordlist).

   A word list is identified by a cell-sized word list identifier (wid)
in much the same way as a file is identified by a file handle.  The
numerical value of the wid has no (portable) meaning, and might change
from session to session.

   The Standard Forth “Search order” word set is intended to provide a
set of low-level tools that allow various different schemes to be
implemented.  Gforth also provides ‘vocabulary’, a traditional Forth
word.  ‘compat/vocabulary.fs’ provides an implementation in Standard
Forth.

‘forth-wordlist’ ( – wid  ) search “forth-wordlist”
   ‘Constant’ – wid identifies the word list that includes all of the
standard words provided by Gforth.  When Gforth is invoked, this word
list is the compilation word list and is at the top of the search order.

‘definitions’ ( –  ) search “definitions”
   Set the compilation word list to be the same as the word list that is
currently at the top of the search order.

‘get-current’ ( – wid  ) search “get-current”
   wid is the identifier of the current compilation word list.

‘set-current’ ( wid –  ) search “set-current”
   Set the compilation word list to the word list identified by wid.

‘get-order’ ( – widn .. wid1 n  ) search “get-order”
   Copy the search order to the data stack.  The current search order
has n entries, of which wid1 represents the wordlist that is searched
first (the word list at the top of the search order) and widn represents
the wordlist that is searched last.

‘set-order’ ( widn .. wid1 n –  ) search “set-order”
   If N=0, empty the search order.  If N=-1, set the search order to the
implementation-defined minimum search order (for Gforth, this is the
word list ‘Root’).  Otherwise, replace the existing search order with
the N wid entries such that WID1 represents the word list that will be
searched first and WIDN represents the word list that will be searched
last.

‘wordlist’ ( – wid  ) search “wordlist”
   Create a new, empty word list represented by wid.

‘table’ ( – wid  ) gforth-0.2 “table”
   Create a lookup table (case-sensitive, no warnings).

‘cs-wordlist’ ( – wid  ) gforth-1.0 “cs-wordlist”
   Create a case-sensitive wordlist.

‘cs-vocabulary’ ( "name" –  ) gforth-1.0 “cs-vocabulary”
   Create a case-sensitive vocabulary

‘>order’ ( wid –  ) gforth-0.5 “to-order”
   Push WID on the search order.

‘previous’ ( –  ) search-ext “previous”
   Drop the wordlist at the top of the search order.

‘also’ ( –  ) search-ext “also”
   Like ‘DUP’ for the search order.  Usually used before a vocabulary
(e.g., ‘also Forth’); the combined effect is to push the wordlist
represented by the vocabulary on the search order.

‘Forth’ ( –  ) search-ext “Forth”
   Replace the wid at the top of the search order with the wid
associated with the word list ‘forth-wordlist’.

‘Only’ ( –  ) search-ext “Only”
   Set the search order to the implementation-defined minimum search
order (for Gforth, this is the word list ‘Root’).

‘order’ ( –  ) search-ext “order”
   Print the search order and the compilation word list.  The word lists
are printed in the order in which they are searched (which is reversed
with respect to the conventional way of displaying stacks).  The
compilation word list is displayed last.

‘.voc’ ( wid –  ) gforth-0.2 “dot-voc”
   print the name of the wordlist represented by WID.  Can only print
names defined with ‘vocabulary’ or ‘wordlist constant’, otherwise prints
‘address’.

‘find’ ( c-addr – xt +-1 | c-addr 0  ) core,search “find”
   Search all word lists in the current search order for the definition
named by the counted string at c-addr.  If the definition is not found,
return 0.  If the definition is found return 1 (if the definition has
non-default compilation semantics) or -1 (if the definition has default
compilation semantics).  The xt returned in interpret state represents
the interpretation semantics.  The xt returned in compile state
represented either the compilation semantics (for non-default
compilation semantics) or the run-time semantics that the compilation
semantics would ‘compile,’ (for default compilation semantics).  The ANS
Forth standard does not specify clearly what the returned xt represents
(and also talks about immediacy instead of non-default compilation
semantics), so this word is questionable in portable programs.  If
non-portability is ok, ‘find-name’ and friends are better (*note Name
token::).

‘search-wordlist’ ( c-addr count wid – 0 | xt +-1  ) search “search-wordlist”
   Search the word list identified by wid for the definition named by
the string at c-addr count.  If the definition is not found, return 0.
If the definition is found return 1 (if the definition is immediate) or
-1 (if the definition is not immediate) together with the xt.  In
Gforth, the xt returned represents the interpretation semantics.  ANS
Forth does not specify clearly what xt represents.

‘words’ ( –  ) tools “words”
   Display a list of all of the definitions in the word list at the top
of the search order.

‘vlist’ ( –  ) gforth-0.2 “vlist”
   Old (pre-Forth-83) name for ‘WORDS’.

‘wordlist-words’ ( wid –  ) gforth-0.6 “wordlist-words”
   Display the contents of the wordlist wid.

‘mwords’ ( ["pattern"] –  ) gforth-1.0 “mwords”
   list all words matching the optional parameter PATTERN; if none, all
words match.  Words are listed old to new.  Pattern match like ‘search’
(default), you can switch to globbing with ‘' mword-filename-match is
mword-match’.

‘Root’ ( –  ) gforth-0.2 “Root”
   Add the root wordlist to the search order stack.  This vocabulary
makes up the minimum search order and contains only a search-order
words.

‘Vocabulary’ ( "name" –  ) gforth-0.2 “Vocabulary”
   Create a definition "name" and associate a new word list with it.
The run-time effect of "name" is to replace the wid at the top of the
search order with the wid associated with the new word list.

‘seal’ ( –  ) gforth-0.2 “seal”
   Remove all word lists from the search order stack other than the word
list that is currently on the top of the search order stack.

‘vocs’ ( –  ) gforth-0.2 “vocs”
   List vocabularies and wordlists defined in the system.

‘current’ ( – addr  ) gforth-0.2 “current”
   ‘Variable’ – holds the wid of the compilation word list.

‘context’ ( – addr  ) gforth-0.2 “context”
   ‘context’ ‘@’ is the wid of the word list at the top of the search
order.

‘map-vocs’ ( ... xt – ...  ) gforth-1.0 “map-vocs”
   Perform xt ( ...  wid – ...  )  for all wordlists (including tables
and cs-wordlists) in the system.

* Menu:

* Vocabularies::
* Why use word lists?::
* Word list example::


File: gforth.info,  Node: Vocabularies,  Next: Why use word lists?,  Prev: Word Lists,  Up: Word Lists

6.16.1 Vocabularies
-------------------

Here is an example of creating and using a new wordlist using Standard
Forth words:

     wordlist constant my-new-words-wordlist
     : my-new-words get-order nip my-new-words-wordlist swap set-order ;

     \ add it to the search order
     also my-new-words

     \ alternatively, add it to the search order and make it
     \ the compilation word list
     also my-new-words definitions
     \ type "order" to see the problem

   The problem with this example is that ‘order’ has no way to associate
the name ‘my-new-words’ with the wid of the word list (in Gforth,
‘order’ and ‘vocs’ will display ‘???’ for a wid that has no associated
name).  There is no Standard way of associating a name with a wid.

   In Gforth, this example can be re-coded using ‘vocabulary’, which
associates a name with a wid:

     vocabulary my-new-words

     \ add it to the search order
     also my-new-words

     \ alternatively, add it to the search order and make it
     \ the compilation word list
     my-new-words definitions
     \ type "order" to see that the problem is solved


File: gforth.info,  Node: Why use word lists?,  Next: Word list example,  Prev: Vocabularies,  Up: Word Lists

6.16.2 Why use word lists?
--------------------------

Here are some reasons why people use wordlists:

   • To prevent a set of words from being used outside the context in
     which they are valid.  Two classic examples of this are an
     integrated editor (all of the edit commands are defined in a
     separate word list; the search order is set to the editor word list
     when the editor is invoked; the old search order is restored when
     the editor is terminated) and an integrated assembler (the op-codes
     for the machine are defined in a separate word list which is used
     when a ‘CODE’ word is defined).

   • To organize the words of an application or library into a
     user-visible set (in ‘forth-wordlist’ or some other common
     wordlist) and a set of helper words used just for the
     implementation (hidden in a separate wordlist).  This keeps
     ‘words’’ output smaller, separates implementation and interface,
     and reduces the chance of name conflicts within the common
     wordlist.

   • To prevent a name-space clash between multiple definitions with the
     same name.  For example, when building a cross-compiler you might
     have a word ‘IF’ that generates conditional code for your target
     system.  By placing this definition in a different word list you
     can control whether the host system’s ‘IF’ or the target system’s
     ‘IF’ get used in any particular context by controlling the order of
     the word lists on the search order stack.

   The downsides of using wordlists are:

   • Debugging becomes more cumbersome.

   • Name conflicts worked around with wordlists are still there, and
     you have to arrange the search order carefully to get the desired
     results; if you forget to do that, you get hard-to-find errors (as
     in any case where you read the code differently from the compiler;
     ‘see’ can help seeing which of several possible words the name
     resolves to in such cases).  ‘See’ displays just the name of the
     words, not what wordlist they belong to, so it might be misleading.
     Using unique names is a better approach to avoid name conflicts.

   • You have to explicitly undo any changes to the search order.  In
     many cases it would be more convenient if this happened implicitly.
     Gforth currently does not provide such a feature, but it may do so
     in the future.


File: gforth.info,  Node: Word list example,  Prev: Why use word lists?,  Up: Word Lists

6.16.3 Word list example
------------------------

The following example is from the garbage collector
(https://www.complang.tuwien.ac.at/forth/garbage-collection.zip) and
uses wordlists to separate public words from helper words:

     get-current ( wid )
     vocabulary garbage-collector also garbage-collector definitions
     ... \ define helper words
     ( wid ) set-current \ restore original (i.e., public) compilation wordlist
     ... \ define the public (i.e., API) words
         \ they can refer to the helper words
     previous \ restore original search order (helper words become invisible)


File: gforth.info,  Node: Environmental Queries,  Next: Files,  Prev: Word Lists,  Up: Words

6.17 Environmental Queries
==========================

Forth-94 introduced the idea of “environmental queries” as a way for a
program running on a system to determine certain characteristics of the
system.  The Standard specifies a number of strings that might be
recognised by a system, and a way of querying them:

‘environment?’ ( c-addr u – false / ... true  ) core “environment-query”
   c-addr, u specify a counted string.  If the string is not recognised,
return a ‘false’ flag.  Otherwise return a ‘true’ flag and some
(string-specific) information about the queried string.

   Note that, whilst the documentation for (e.g.)  ‘ADDRESS-UNIT-BITS’
shows it returning one cell on the stack, querying it using
‘environment?’ will return an additional item; the ‘true’ flag that
shows that the string was recognised; so for querying
‘ADDRESS-UNIT-BITS’ the stack effect of ‘environment?’ is ‘( c-addr u --
n true )’.

   Several environmental queries deal with the system’s limits:

‘ADDRESS-UNIT-BITS’ ( – n  ) environment “ADDRESS-UNIT-BITS”
   Size of one address unit, in bits.

‘MAX-CHAR’ ( – u  ) environment “MAX-CHAR”
   Maximum value of any character in the character set

‘/COUNTED-STRING’ ( – n  ) environment “slash-counted-string”
   Maximum size of a counted string, in characters.

‘/HOLD’ ( – n  ) environment “slash-hold”
   Size of the pictured numeric string output buffer, in characters.

‘/PAD’ ( – n  ) environment “slash-pad”
   Size of the scratch area pointed to by ‘PAD’, in characters.

‘CORE’ ( – f  ) environment “CORE”
   True if the complete core word set is present.  Always true for
Gforth.

‘CORE-EXT’ ( – f  ) environment “CORE-EXT”
   True if the complete core extension word set is present.  Always true
for Gforth.

‘FLOORED’ ( – f  ) environment “FLOORED”
   True if ‘/’ etc.  perform floored division

‘MAX-N’ ( – n  ) environment “MAX-N”
   Largest usable signed integer.

‘MAX-U’ ( – u  ) environment “MAX-U”
   Largest usable unsigned integer.

‘MAX-D’ ( – d  ) environment “MAX-D”
   Largest usable signed double.

‘MAX-UD’ ( – ud  ) environment “MAX-UD”
   Largest usable unsigned double.

‘return-stack-cells’ ( – n  ) environment “return-stack-cells”
   Maximum size of the return stack, in cells.

‘stack-cells’ ( – n  ) environment “stack-cells”
   Maximum size of the data stack, in cells.

‘floating-stack’ ( – n  ) environment “floating-stack”
   N is non-zero, showing that Gforth maintains a separate
floating-point stack of depth N.

‘#locals’ ( – n  ) environment “number-locals”
   The maximum number of locals in a definition

‘wordlists’ ( – n  ) environment “wordlists”
   the maximum number of wordlists usable in the search order

‘max-float’ ( – r  ) environment “max-float”
   The largest usable floating-point number (implemented as largest
finite number in Gforth)

‘XCHAR-ENCODING’ ( – addr u  ) environment “XCHAR-ENCODING”
   Returns a printable ASCII string that reperesents the encoding, and
use the preferred MIME name (if any) or the name in
<http://www.iana.org/assignments/character-sets> like “ISO-LATIN-1” or
“UTF-8”, with the exception of “ASCII”, where we prefer the alias
“ASCII”.

‘MAX-XCHAR’ ( – xchar  ) environment “MAX-XCHAR”
   Maximal value for xchar.  This depends on the encoding.

‘XCHAR-MAXMEM’ ( – u  ) environment “XCHAR-MAXMEM”
   Maximal memory consumed by an xchar in address units

   Several environemtal queries are there for determining the presence
of the Forth-94 version of a wordset; they all have the stack effect ‘(
-- f )’ if the string is present (so the ‘environment?’ stack effect for
these queries is ‘( c-addr u -- false / f true )’.

   ‘block block-ext double double-ext exception exception-ext facility
facility-ext file file-ext floating floating-ext locals locals-ext
memory-alloc memory-alloc-ext tools tools-ext search-order
search-order-ext string string-ext’

   These wordset queries were rarely used and implemented, so Forth-2012
did not introduce a way to query for the Forth-2012 variants of the
wordsets.  Instead, the idea is that you use ‘[defined]’ (*note
Interpreter Directives::) instead.

   Forth-200x (a group that works on the next standard; the documents
that they produce are also called Forth-200x) defines extension queries
for the extension proposals once they finish changing (CfV stage), so
programs using these proposals can check whether a system has them, and
maybe load the reference implementation (if one exists).  If
‘environment?’ finds such a query, then the corresponding proposal on
<www.forth200x.org> is implemented on the system (but the absence tells
you nothing, as usual with ‘environment?’).  These queries have the
stack effect ‘( -- )’, which means that for them ‘environment?’ has the
stack effect ‘( c-addr u -- false / true )’, which is more convenient
than that of wordset queries.  A number of these proposals have been
incorporated into Forth-2012.  The extension queries are also not
particularly popular among Forth system implementors, so going for
‘[defined]’ may be the better approach.  Anyway, Gforth implements the
following extension queries:

   ‘X:2value X:buffer X:deferred X:defined X:ekeys X:escaped-strings
X:extension-query X:fp-stack X:ftrunc X:fvalue X:locals X:n-to-r
X:number-prefixes X:parse-name X:required X:s-escape-quote X:s-to-f
X:structures X:synonym X:text-substitution X:throw-iors
X:traverse-wordlist X:xchar’

   In addition, Gforth implements the following Gforth-specific queries:

‘gforth’ ( – c-addr u  ) gforth-environment “gforth”
   Counted string representing a version string for this version of
Gforth (for versions>0.3.0).  The version strings of the various
versions are guaranteed to be ordered lexicographically.

‘os-class’ ( – c-addr u  ) gforth-environment “os-class”
   Counted string representing a description of the host operating
system.

‘os-type’ ( – c-addr u  ) gforth-environment “os-type”
   Counted string equal to "$host_os"

   The Standard requires that the header space used for environmental
queries be distinct from the header space used for definitions.

   Typically, a Forth system supports environmental queries by creating
a set of definitions in a wordlist that is only used for environmental
queries; that is what Gforth does.  There is no Standard way of adding
definitions to the set of recognised environmental queries, but in
Gforth and other systems that use the wordlist mechanism, the wordlist
used to honour environmental queries can be manipulated just like any
other word list.

‘environment-wordlist’ ( – wid  ) gforth-0.2 “environment-wordlist”
   wid identifies the word list that is searched by environmental
queries (present in SwiftForth and VFX).

‘environment’ ( –  ) gforth-0.6 “environment”
   A vocabulary for ‘environment-wordlist’ (present in Win32Forth and
VFX).

   Here are some examples of using environmental queries:

     s" address-unit-bits" environment? 0=
     [IF]
          cr .( environmental attribute address-units-bits unknown... ) cr
     [ELSE]
          drop \ ensure balanced stack effect
     [THEN]

     \ this might occur in the prelude of a standard program that uses THROW
     s" exception" environment? [IF]
        0= [IF]
           : throw abort" exception thrown" ;
        [THEN]
     [ELSE] \ we don't know, so make sure
        : throw abort" exception thrown" ;
     [THEN]

     s" gforth" environment? [IF] .( Gforth version ) TYPE
                             [ELSE] .( Not Gforth..) [THEN]

     \ a program using v*
     s" gforth" environment? [IF]
       s" 0.5.0" compare 0< [IF] \ v* is a primitive since 0.5.0
        : v* ( f_addr1 nstride1 f_addr2 nstride2 ucount -- r )
          >r swap 2swap swap 0e r> 0 ?DO
            dup f@ over + 2swap dup f@ f* f+ over + 2swap
          LOOP
          2drop 2drop ;
       [THEN]
     [ELSE] \
       : v* ( f_addr1 nstride1 f_addr2 nstride2 ucount -- r )
       ...
     [THEN]

   Here is an example of adding a definition to the environment word
list:

     get-current environment-wordlist set-current
     true constant block
     true constant block-ext
     set-current

   You can see what definitions are in the environment word list like
this:

     environment-wordlist wordlist-words


File: gforth.info,  Node: Files,  Next: Blocks,  Prev: Environmental Queries,  Up: Words

6.18 Files
==========

Gforth provides facilities for accessing files that are stored in the
host operating system’s file-system.  Files that are processed by Gforth
can be divided into two categories:

   • Files that are processed by the Text Interpreter (“Forth source
     files”).
   • Files that are processed by some other program (“general files”).

* Menu:

* Forth source files::
* General files::
* Redirection::
* Directories::
* Search Paths::


File: gforth.info,  Node: Forth source files,  Next: General files,  Prev: Files,  Up: Files

6.18.1 Forth source files
-------------------------

The simplest way to interpret the contents of a file is to use one of
these two formats:

     include mysource.fs
     s" mysource.fs" included

   You usually want to include a file only if it is not included already
(by, say, another source file).  In that case, you can use one of these
three formats:

     require mysource.fs
     needs mysource.fs
     s" mysource.fs" required

   It is good practice to write your source files such that interpreting
them does not change the stack.  Source files designed in this way can
be used with ‘required’ and friends without complications.  For example:

     1024 require foo.fs drop

   Here you want to pass the argument 1024 (e.g., a buffer size) to
‘foo.fs’.  Interpreting ‘foo.fs’ has the stack effect ( n – n ), which
allows its use with ‘require’.  Of course with such parameters to
required files, you have to ensure that the first ‘require’ fits for all
uses (i.e., ‘require’ it early in the master load file).

‘include-file’ ( i*x wfileid – j*x  ) file “include-file”
   Interpret (process using the text interpreter) the contents of the
file WFILEID.

‘included’ ( i*x c-addr u – j*x  ) file “included”
   ‘include-file’ the file whose name is given by the string C-ADDR U.

‘included?’ ( c-addr u – f  ) gforth-0.2 “included?”
   True only if the file C-ADDR U is in the list of earlier included
files.  If the file has been loaded, it may have been specified as, say,
‘foo.fs’ and found somewhere on the Forth search path.  To return ‘true’
from ‘included?’, you must specify the exact path to the file, even if
that is ‘./foo.fs’

‘include’ ( ... "file" – ...  ) file-ext “include”
   ‘include-file’ the file FILE.

‘required’ ( i*x addr u – i*x  ) file-ext “required”
   ‘include-file’ the file with the name given by ADDR U, if it is not
‘included’ (or ‘required’) already.  Currently this works by comparing
the name of the file (with path) against the names of earlier included
files.

‘require’ ( ... "file" – ...  ) file-ext “require”
   ‘include-file’ FILE only if it is not included already.

‘needs’ ( ... "name" – ...  ) gforth-0.2 “needs”
   An alias for ‘require’; exists on other systems (e.g., Win32Forth).

‘\\\’ ( –  ) gforth-1.0 “\\\”
   skip remaining source file

‘.included’ ( –  ) gforth-0.5 “.included”
   List the names of the files that have been ‘included’.

‘sourcefilename’ ( – c-addr u  ) gforth-0.2 “sourcefilename”
   The name of the source file which is currently the input source.  The
result is valid only while the file is being loaded.  If the current
input source is no (stream) file, the result is undefined.  In Gforth,
the result is valid during the whole session (but not across
‘savesystem’ etc.).

‘sourceline#’ ( – u  ) gforth-0.2 “sourceline-number”
   The line number of the line that is currently being interpreted from
a (stream) file.  The first line has the number 1.  If the current input
source is not a (stream) file, the result is undefined.

   A definition in Standard Forth for ‘required’ is provided in
‘compat/required.fs’.


File: gforth.info,  Node: General files,  Next: Redirection,  Prev: Forth source files,  Up: Files

6.18.2 General files
--------------------

Files are opened/created by name and type.  The following file access
methods (FAMs) are recognised:

‘r/o’ ( – fam  ) file “r-o”

‘r/w’ ( – fam  ) file “r-w”

‘w/o’ ( – fam  ) file “w-o”

‘bin’ ( fam1 – fam2  ) file “bin”

‘+fmode’ ( fam1 rwxrwxrwx – fam2  ) gforth-1.0 “plus-f-mode”
   add file access mode to fam - for create-file only

   When a file is opened/created, it returns a file identifier, wfileid
that is used for all other file commands.  All file commands also return
a status value, wior, that is 0 for a successful operation and an
implementation-defined non-zero value in the case of an error.

‘open-file’ ( c-addr u wfam – wfileid wior ) file “open-file”

‘create-file’ ( c-addr u wfam – wfileid wior ) file “create-file”

‘close-file’ ( wfileid – wior ) file “close-file”

‘delete-file’ ( c-addr u – wior ) file “delete-file”

‘rename-file’ ( c-addr1 u1 c-addr2 u2 – wior ) file-ext “rename-file”
   Rename file c_addr1 u1 to new name c_addr2 u2

‘read-file’ ( c-addr u1 wfileid – u2 wior ) file “read-file”
   Read u1 characters from file wfileid into the buffer at c_addr.  A
non-zero wior indicates an error.  U2 indicates the length of the read
data.  End-of-file is not an error and is indicated by u2$<$u1 and
wior=0.

‘read-line’ ( c_addr u1 wfileid – u2 flag wior  ) file “read-line”
   Reads a line from wfileid into the buffer at c_addr u1.  Gforth
supports all three common line terminators: LF, CR and CRLF. A non-zero
wior indicates an error.  A false flag indicates that ‘read-line’ has
been invoked at the end of the file.  u2 indicates the line length
(without terminator): u2$<$u1 indicates that the line is u2 chars long;
u2=u1 indicates that the line is at least u1 chars long, the u1 chars of
the buffer have been filled with chars from the line, and the next slice
of the line with be read with the next ‘read-line’.  If the line is u1
chars long, the first ‘read-line’ returns u2=u1 and the next read-line
returns u2=0.

‘key-file’ ( fd – key  ) gforth-0.4 “key-file”
   Read one character n from wfileid.  This word disables buffering for
wfileid.  If you want to read characters from a terminal in
non-canonical (raw) mode, you have to put the terminal in non-canonical
mode yourself (using the C interface); the exception is ‘stdin’: Gforth
automatically puts it into non-canonical mode.

‘key?-file’ ( wfileid – f ) gforth-0.4 “key-q-file”
   f is true if at least one character can be read from wfileid without
blocking.  If you also want to use ‘read-file’ or ‘read-line’ on the
file, you have to call ‘key?-file’ or ‘key-file’ first (these two words
disable buffering).

‘file-eof?’ ( wfileid – flag ) gforth-0.6 “file-eof-query”
   FLAG is true if the end-of-file indicator for WFILEID is set.

‘write-file’ ( c-addr u1 wfileid – wior ) file “write-file”

‘write-line’ ( c-addr u wfileid – ior  ) file “write-line”

‘emit-file’ ( c wfileid – wior ) gforth-0.2 “emit-file”

‘flush-file’ ( wfileid – wior ) file-ext “flush-file”

‘file-status’ ( c-addr u – wfam wior ) file-ext “file-status”

‘file-position’ ( wfileid – ud wior ) file “file-position”

‘reposition-file’ ( ud wfileid – wior ) file “reposition-file”

‘file-size’ ( wfileid – ud wior ) file “file-size”

‘resize-file’ ( ud wfileid – wior ) file “resize-file”

‘slurp-file’ ( c-addr1 u1 – c-addr2 u2  ) gforth-0.6 “slurp-file”
   C-ADDR1 U1 is the filename, C-ADDR2 U2 is the file’s contents

‘slurp-fid’ ( fid – addr u  ) gforth-0.6 “slurp-fid”
   ADDR U is the content of the file FID

‘stdin’ ( – wfileid ) gforth-0.4 “stdin”
   The standard input file of the Gforth process.

‘stdout’ ( – wfileid ) gforth-0.2 “stdout”
   The standard output file of the Gforth process.

‘stderr’ ( – wfileid ) gforth-0.2 “stderr”
   The standard error output file of the Gforth process.


File: gforth.info,  Node: Redirection,  Next: Directories,  Prev: General files,  Up: Files

6.18.3 Redirection
------------------

You can redirect the output of ‘type’ and ‘emit’ and all the words that
use them (all output words that don’t have an explicit target file) to
an arbitrary file with the ‘outfile-execute’, used like this:

     : some-warning ( n -- )
         cr ." warning# " . ;

     : print-some-warning ( n -- )
         ['] some-warning stderr outfile-execute ;

   After ‘some-warning’ is executed, the original output direction is
restored; this construct is safe against exceptions.  Similarly, there
is ‘infile-execute’ for redirecting the input of ‘key’ and its users
(any input word that does not take a file explicitly).

‘outfile-execute’ ( ... xt file-id – ...  ) gforth-0.7 “outfile-execute”
   execute xt with the output of ‘type’ etc.  redirected to file-id.

‘outfile-id’ ( – file-id  ) gforth-0.2 “outfile-id”
   File-id is used by ‘emit’, ‘type’, and any output word that does not
take a file-id as input.  By default ‘outfile-id’ produces the process’s
‘stdout’, unless changed with ‘outfile-execute’.

‘infile-execute’ ( ... xt file-id – ...  ) gforth-0.7 “infile-execute”
   execute xt with the input of ‘key’ etc.  redirected to file-id.

‘infile-id’ ( – file-id  ) gforth-0.4 “infile-id”
   File-id is used by ‘key’, ‘?key’, and anything that refers to the
"user input device".  By default ‘infile-id’ produces the process’s
‘stdin’, unless changed with ‘infile-execute’.

   If you do not want to redirect the input or output to a file, you can
also make use of the fact that ‘key’, ‘emit’ and ‘type’ are deferred
words (*note Deferred Words::).  However, in that case you have to worry
about the restoration and the protection against exceptions yourself;
also, note that for redirecting the output in this way, you have to
redirect both ‘emit’ and ‘type’.


File: gforth.info,  Node: Directories,  Next: Search Paths,  Prev: Redirection,  Up: Files

6.18.4 Directories
------------------

You can split a file name into a directory and base component:

‘basename’ ( c-addr1 u1 – c-addr2 u2  ) gforth-0.7 “basename”
   Given a file name c-addr1 u1, c-addr2 u2 is the part of it with any
leading directory components removed.

‘dirname’ ( c-addr1 u1 – c-addr1 u2  ) gforth-0.7 “dirname”
   C-addr1 u2 is the directory name of the file name c-addr1 u1,
including the final ‘/’.  If caddr1 u1 does not contain a ‘/’, u2=0.

   You can open and read directories similar to files.  Reading gives
you one directory entry at a time; you can match that to a filename
(with wildcards).

‘open-dir’ ( c-addr u – wdirid wior ) gforth-0.5 “open-dir”
   Open the directory specified by c-addr, u and return dir-id for
futher access to it.

‘read-dir’ ( c-addr u1 wdirid – u2 flag wior ) gforth-0.5 “read-dir”
   Attempt to read the next entry from the directory specified by dir-id
to the buffer of length u1 at address c-addr.  If the attempt fails
because there is no more entries, ior=0, flag=0, u2=0, and the buffer is
unmodified.  If the attempt to read the next entry fails because of any
other reason, return ior<>0.  If the attempt succeeds, store file name
to the buffer at c-addr and return ior=0, flag=true and u2 equal to the
size of the file name.  If the length of the file name is greater than
u1, store first u1 characters from file name into the buffer and
indicate "name too long" with ior, flag=true, and u2=u1.

‘close-dir’ ( wdirid – wior ) gforth-0.5 “close-dir”
   Close the directory specified by dir-id.

‘filename-match’ ( c-addr1 u1 c-addr2 u2 – flag ) gforth-0.5 “match-file”
   match the file name C_ADDR1 U1 with the pattern C_ADDR2 U2.  Patterns
match char by char except for the special characters ’*’ and ’?’, which
are wildcards for several (’*’) or one (’?’) character.

‘get-dir’ ( c-addr1 u1 – c-addr2 u2 ) gforth-0.7 “get-dir”
   Store the current directory in the buffer specified by c-addr1, u1.
If the buffer size is not sufficient, return 0 0

‘set-dir’ ( c-addr u – wior ) gforth-0.7 “set-dir”
   Change the current directory to c-addr, u.  Return an error if this
is not possible

‘=mkdir’ ( c-addr u wmode – wior ) gforth-0.7 “equals-mkdir”
   Create directory c-addr u with mode wmode.

‘mkdir-parents’ ( c-addr u mode – ior  ) gforth-0.7 “mkdir-parents”
   create the directory c-addr u and all its parents with mode mode
(modified by umask)


File: gforth.info,  Node: Search Paths,  Prev: Directories,  Up: Files

6.18.5 Search Paths
-------------------

If you specify an absolute filename (i.e., a filename starting with ‘/’
or ‘~’, or with ‘:’ in the second position (as in ‘C:...’)) for
‘included’ and friends, that file is included just as you would expect.

   If the filename starts with ‘./’, this refers to the directory that
the present file was ‘included’ from.  This allows files to include
other files relative to their own position (irrespective of the current
working directory or the absolute position).  This feature is essential
for libraries consisting of several files, where a file may include
other files from the library.  It corresponds to ‘#include "..."’ in C.
If the current input source is not a file, ‘.’ refers to the directory
of the innermost file being included, or, if there is no file being
included, to the current working directory.

   For relative filenames (not starting with ‘./’), Gforth uses a search
path similar to Forth’s search order (*note Word Lists::).  It tries to
find the given filename in the directories present in the path, and
includes the first one it finds.  There are separate search paths for
Forth source files and general files.  If the search path contains the
directory ‘.’, this refers to the directory of the current file, or the
working directory, as if the file had been specified with ‘./’.

   Use ‘~+’ to refer to the current working directory (as in the
‘bash’).

‘absolute-file?’ ( addr u – flag  ) gforth-1.0 “absolute-file?”
   A filename is absolute if it starts with a / or a ~ (~ expansion), or
if it is in the form ./*, extended regexp: ^[/~]|./, or if it has a
colon as second character ("C:...").  Paths simply containing a / are
not absolute!

* Menu:

* Source Search Paths::
* General Search Paths::


File: gforth.info,  Node: Source Search Paths,  Next: General Search Paths,  Prev: Search Paths,  Up: Search Paths

6.18.5.1 Source Search Paths
............................

The search path is initialized when you start Gforth (*note Invoking
Gforth::).  You can display it and change it using ‘fpath’ in
combination with the general path handling words.

‘fpath’ ( – path-addr  ) gforth-0.4 “fpath”

‘.fpath’ ( –  ) gforth-0.4 “.fpath”
   Display the contents of the Forth search path.

‘file>fpath’ ( addr1 u1 – addr2 u2  ) gforth-1.0 “file>fpath”
   Searches for a file with the name c-addr1 u1 in the ‘fpath’.  If
successful, c-addr u2 is the absolute file name or the file name
relative to the current working directory.  Throws an exception if the
file cannot be opened.

Here is an example of using ‘fpath’ and ‘require’:

     fpath path= /usr/lib/forth/|./
     require timer.fs


File: gforth.info,  Node: General Search Paths,  Prev: Source Search Paths,  Up: Search Paths

6.18.5.2 General Search Paths
.............................

Your application may need to search files in several directories, like
‘included’ does.  To facilitate this, Gforth allows you to define and
use your own search paths, by providing generic equivalents of the Forth
search path words:

‘open-path-file’ ( addr1 u1 path-addr – wfileid addr2 u2 0 | ior  ) gforth-0.2 “open-path-file”
   Look in path PATH-ADDR for the file specified by ADDR1 U1.  If found,
the resulting path and an (read-only) open file descriptor are returned.
If the file is not found, IOR is what came back from the last attempt at
opening the file (in the current implementation).

‘file>path’ ( c-addr1 u1 path-addr – c-addr2 u2  ) gforth-1.0 “file>path”
   Searches for a file with the name c-addr1 u1 in path stored in
path-addr.  If successful, c-addr u2 is the absolute file name or the
file name relative to the current working directory.  Throws an
exception if the file cannot be opened.

‘clear-path’ ( path-addr –  ) gforth-0.5 “clear-path”
   Set the path path-addr to empty.

‘also-path’ ( c-addr len path-addr –  ) gforth-0.4 “also-path”
   add the directory c-addr len to path-addr.

‘.path’ ( path-addr –  ) gforth-0.4 “.path”
   Display the contents of the search path PATH-ADDR.

‘path+’ ( path-addr  "dir" –  ) gforth-0.4 “path+”
   Add the directory DIR to the search path PATH-ADDR.

‘path=’ ( path-addr "dir1|dir2|dir3" –  ) gforth-0.4 “path-equals”
   Make a complete new search path; the path separator is |.

   Here’s an example of creating a custom search path:
     variable mypath \ no special allocation required, just a variable
     mypath path= /lib|/usr/lib \ assign initial directories
     mypath path+ /usr/local/lib \ append directory
     mypath .path \ output:"/lib /usr/lib /usr/local/lib"

   Search file and show resulting path:
     s" libm.so" mypath open-path-file throw type close-file \ output:"/lib/libm.so"


File: gforth.info,  Node: Blocks,  Next: Other I/O,  Prev: Files,  Up: Words

6.19 Blocks
===========

When you run Gforth on a modern desk-top computer, it runs under the
control of an operating system which provides certain services.  One of
these services is FILE SERVICES, which allows Forth source code and data
to be stored in files and read into Gforth (*note Files::).

   Traditionally, Forth has been an important programming language on
systems where it has interfaced directly to the underlying hardware with
no intervening operating system.  Forth provides a mechanism, called
“blocks”, for accessing mass storage on such systems.

   A block is a 1024-byte data area, which can be used to hold data or
Forth source code.  No structure is imposed on the contents of the
block.  A block is identified by its number; blocks are numbered
contiguously from 1 to an implementation-defined maximum.

   A typical system that used blocks but no operating system might use a
single floppy-disk drive for mass storage, with the disks formatted to
provide 256-byte sectors.  Blocks would be implemented by assigning the
first four sectors of the disk to block 1, the second four sectors to
block 2 and so on, up to the limit of the capacity of the disk.  The
disk would not contain any file system information, just the set of
blocks.

   On systems that do provide file services, blocks are typically
implemented by storing a sequence of blocks within a single “blocks
file”.  The size of the blocks file will be an exact multiple of 1024
bytes, corresponding to the number of blocks it contains.  This is the
mechanism that Gforth uses.

   Only one blocks file can be open at a time.  If you use block words
without having specified a blocks file, Gforth defaults to the blocks
file ‘blocks.fb’.  Gforth uses the Forth search path when attempting to
locate a blocks file (*note Source Search Paths::).

   When you read and write blocks under program control, Gforth uses a
number of “block buffers” as intermediate storage.  These buffers are
not used when you use ‘load’ to interpret the contents of a block.

   The behaviour of the block buffers is analagous to that of a cache.
Each block buffer has three states:

   • Unassigned
   • Assigned-clean
   • Assigned-dirty

   Initially, all block buffers are unassigned.  In order to access a
block, the block (specified by its block number) must be assigned to a
block buffer.

   The assignment of a block to a block buffer is performed by ‘block’
or ‘buffer’.  Use ‘block’ when you wish to modify the existing contents
of a block.  Use ‘buffer’ when you don’t care about the existing
contents of the block(1).

   Once a block has been assigned to a block buffer using ‘block’ or
‘buffer’, that block buffer becomes the current block buffer.  Data may
only be manipulated (read or written) within the current block buffer.

   When the contents of the current block buffer has been modified it is
necessary, _before calling ‘block’ or ‘buffer’ again_, to either abandon
the changes (by doing nothing) or mark the block as changed
(assigned-dirty), using ‘update’.  Using ‘update’ does not change the
blocks file; it simply changes a block buffer’s state to assigned-dirty.
The block will be written implicitly when it’s buffer is needed for
another block, or explicitly by ‘flush’ or ‘save-buffers’.

   word ‘Flush’ writes all assigned-dirty blocks back to the blocks file
on disk.  Leaving Gforth with ‘bye’ also performs a ‘flush’.

   In Gforth, ‘block’ and ‘buffer’ use a direct-mapped algorithm to
assign a block buffer to a block.  That means that any particular block
can only be assigned to one specific block buffer, called (for the
particular operation) the victim buffer.  If the victim buffer is
unassigned or assigned-clean it is allocated to the new block
immediately.  If it is assigned-dirty its current contents are written
back to the blocks file on disk before it is allocated to the new block.

   Although no structure is imposed on the contents of a block, it is
traditional to display the contents as 16 lines each of 64 characters.
A block provides a single, continuous stream of input (for example, it
acts as a single parse area) – there are no end-of-line characters
within a block, and no end-of-file character at the end of a block.
There are two consequences of this:

   • The last character of one line wraps straight into the first
     character of the following line
   • The word ‘\’ – comment to end of line – requires special treatment;
     in the context of a block it causes all characters until the end of
     the current 64-character “line” to be ignored.

   In Gforth, when you use ‘block’ with a non-existent block number, the
current blocks file will be extended to the appropriate size and the
block buffer will be initialised with spaces.

   Gforth includes a simple block editor (type ‘use blocked.fb 0 list’
for details) but doesn’t encourage the use of blocks; the mechanism is
only provided for backward compatibility.

   Common techniques that are used when working with blocks include:

   • A screen editor that allows you to edit blocks without leaving the
     Forth environment.
   • Shadow screens; where every code block has an associated block
     containing comments (for example: code in odd block numbers,
     comments in even block numbers).  Typically, the block editor
     provides a convenient mechanism to toggle between code and
     comments.
   • Load blocks; a single block (typically block 1) contains a number
     of ‘thru’ commands which ‘load’ the whole of the application.

   See Frank Sergeant’s Pygmy Forth to see just how well blocks can be
integrated into a Forth programming environment.

‘open-blocks’ ( c-addr u –  ) gforth-0.2 “open-blocks”
   Use the file, whose name is given by c-addr u, as the blocks file.

‘use’ ( "file" –  ) gforth-0.2 “use”
   Use file as the blocks file.

‘block-offset’ ( – addr  ) gforth-0.5 “block-offset”
   User variable containing the number of the first block (default since
0.5.0: 0).  Block files created with Gforth versions before 0.5.0 have
the offset 1.  If you use these files you can: ‘1 offset !’; or add 1 to
every block number used; or prepend 1024 characters to the file.

‘get-block-fid’ ( – wfileid  ) gforth-0.2 “get-block-fid”
   Return the file-id of the current blocks file.  If no blocks file has
been opened, use ‘blocks.fb’ as the default blocks file.

‘block-position’ ( u –  ) block “block-position”
   Position the block file to the start of block u.

‘list’ ( u –  ) block-ext “list”
   Display block u.  In Gforth, the block is displayed as 16 numbered
lines, each of 64 characters.

‘scr’ ( – a-addr  ) block-ext “s-c-r”
   ‘User’ variable containing the block number of the block most
recently processed by ‘list’.

‘block’ ( u – a-addr  ) block “block”
   If a block buffer is assigned for block u, return its start address,
a-addr.  Otherwise, assign a block buffer for block u (if the assigned
block buffer has been ‘update’d, transfer the contents to mass storage),
read the block into the block buffer and return its start address,
a-addr.

‘buffer’ ( u – a-addr  ) block “buffer”
   If a block buffer is assigned for block u, return its start address,
a-addr.  Otherwise, assign a block buffer for block u (if the assigned
block buffer has been ‘update’d, transfer the contents to mass storage)
and return its start address, a-addr.  The subtle difference between
‘buffer’ and ‘block’ mean that you should only use ‘buffer’ if you don’t
care about the previous contents of block u.  In Gforth, this simply
calls ‘block’.

‘empty-buffers’ ( –  ) block-ext “empty-buffers”
   Mark all block buffers as unassigned; if any had been marked as
assigned-dirty (by ‘update’), the changes to those blocks will be lost.

‘empty-buffer’ ( buffer –  ) gforth-0.2 “empty-buffer”

‘update’ ( –  ) block “update”
   Mark the state of the current block buffer as assigned-dirty.

‘updated?’ ( n – f  ) gforth-0.2 “updated?”
   Return true if ‘updated’ has been used to mark block n as
assigned-dirty.

‘save-buffers’ ( –  ) block “save-buffers”
   Transfer the contents of each ‘update’d block buffer to mass storage,
then mark all block buffers as assigned-clean.

‘save-buffer’ ( buffer –  ) gforth-0.2 “save-buffer”

‘flush’ ( –  ) block “flush”
   Perform the functions of ‘save-buffers’ then ‘empty-buffers’.

‘load’ ( i*x u – j*x  ) block “load”
   Text-interpret block u.  Block 0 cannot be ‘load’ed.

‘thru’ ( i*x n1 n2 – j*x  ) block-ext “thru”
   ‘load’ the blocks n1 through n2 in sequence.

‘+load’ ( i*x n – j*x  ) gforth-0.2 “+load”
   Used within a block to load the block specified as the current block
+ n.

‘+thru’ ( i*x n1 n2 – j*x  ) gforth-0.2 “+thru”
   Used within a block to load the range of blocks specified as the
current block + n1 thru the current block + n2.

‘-->’ ( –  ) gforth-0.2 “chain”
   If this symbol is encountered whilst loading block n, discard the
remainder of the block and load block n+1.  Used for chaining multiple
blocks together as a single loadable unit.  Not recommended, because it
destroys the independence of loading.  Use ‘thru’ (which is standard) or
‘+thru’ instead.

‘block-included’ ( a-addr u –  ) gforth-0.2 “block-included”
   Use within a block that is to be processed by ‘load’.  Save the
current blocks file specification, open the blocks file specified by
a-addr u and ‘load’ block 1 from that file (which may in turn chain or
load other blocks).  Finally, close the blocks file and restore the
original blocks file.

   ---------- Footnotes ----------

   (1) The Standard Forth definition of ‘buffer’ is intended not to
cause disk I/O; if the data associated with the particular block is
already stored in a block buffer due to an earlier ‘block’ command,
‘buffer’ will return that block buffer and the existing contents of the
block will be available.  Otherwise, ‘buffer’ will simply assign a new,
empty block buffer for the block.


File: gforth.info,  Node: Other I/O,  Next: OS command line arguments,  Prev: Blocks,  Up: Words

6.20 Other I/O
==============

* Menu:

* Simple numeric output::    定義済みの書式
* Formatted numeric output::  書式化された(目に見える)出力
* Floating-point output::
* Miscellaneous output::
* Displaying characters and strings::  その他もろもろ
* Terminal output::          カーソル移動等
* Single-key input::
* Line input and conversion::
* Pipes::                    あなた独自のパイプラインの作り方
* Xchars and Unicode::       非ASCII文字
* i18n and l10n::            国際化(I18n)とローカライズ
* Substitute::               テキストマクロ置換
* CSV Reader::               データ・インポート機能


File: gforth.info,  Node: Simple numeric output,  Next: Formatted numeric output,  Prev: Other I/O,  Up: Other I/O

6.20.1 Simple numeric output
----------------------------

The simplest output functions are those that display numbers from the
data stack.  Numbers are displayed in the base (aka radix) stored in
‘base’ (*note Number Conversion::).

‘.’ ( n –  ) core “dot”
   Display (the signed single number) N in free-format, followed by a
space.

‘dec.’ ( n –  ) gforth-0.2 “dec.”
   Display n as a signed decimal number, followed by a space.

‘h.’ ( u –  ) gforth-1.0 “h.”
   Display u as an unsigned hex number, prefixed with a "$" and followed
by a space.

‘hex.’ ( u –  ) gforth-0.2 “hex.”
   Display u as an unsigned hex number, prefixed with a ‘$’ and followed
by a space.  Another name for this word is ‘h.’, which is present in
several other systems, but not in Gforth before 1.0.

‘u.’ ( u –  ) core “u-dot”
   Display (the unsigned single number) U in free-format, followed by a
space.

‘.r’ ( n1 n2 –  ) core-ext “dot-r”
   Display N1 right-aligned in a field N2 characters wide.  If more than
N2 characters are needed to display the number, all digits are
displayed.  If appropriate, N2 must include a character for a leading
“-”.

‘u.r’ ( u n –  ) core-ext “u-dot-r”
   Display U right-aligned in a field N characters wide.  If more than N
characters are needed to display the number, all digits are displayed.

‘dec.r’ ( u n –  ) gforth-0.5 “dec.r”
   Display u as a unsigned decimal number in a field n characters wide.

‘d.’ ( d –  ) double “d-dot”
   Display (the signed double number) D in free-format.  followed by a
space.

‘ud.’ ( ud –  ) gforth-0.2 “u-d-dot”
   Display (the signed double number) UD in free-format, followed by a
space.

‘d.r’ ( d n –  ) double “d-dot-r”
   Display D right-aligned in a field N characters wide.  If more than N
characters are needed to display the number, all digits are displayed.
If appropriate, N must include a character for a leading “-”.

‘ud.r’ ( ud n –  ) gforth-0.2 “u-d-dot-r”
   Display UD right-aligned in a field N characters wide.  If more than
N characters are needed to display the number, all digits are displayed.


File: gforth.info,  Node: Formatted numeric output,  Next: Floating-point output,  Prev: Simple numeric output,  Up: Other I/O

6.20.2 Formatted numeric output
-------------------------------

Forth traditionally uses a technique called “pictured numeric output”
for formatted printing of integers.  In this technique, digits are
extracted from the number (using the current output radix defined by
‘base’, *note Number Conversion::), converted to ASCII codes and
prepended to a string that is built in a scratch-pad area of memory
(*note Implementation-defined options: core-idef.).  Arbitrary
characters can be prepended to the string during the extraction process.
The completed string is specified by an address and length and can be
manipulated (‘TYPE’ed, copied, modified) under program control.

   All of the integer output words described in the previous section
(*note Simple numeric output::) are implemented in Gforth using pictured
numeric output.

   Three important things to remember about pictured numeric output:

   • It always operates on double-precision numbers; to display a
     single-precision number, convert it first (for ways of doing this
     *note Double precision::).
   • It always treats the double-precision number as though it were
     unsigned.  The examples below show ways of printing signed numbers.
   • The string is built up from right to left; least significant digit
     first.

   Standard Forth supports a single output buffer (aka hold area) that
you empty and initialize with ‘<#’ and for which you get the result
string with ‘#>’.

   Gforth additionally supports nested usage of this buffer, allowing,
e.g., to nest output from the debugging tracer ‘~~’ inside code dealing
with the hold area: ‘<<#’ starts a new nest, ‘#>’ produces the result
string, and ‘#>>’ unnests: the hold area for the nest is reclaimed, and
‘#>’ now produces the string for the next-outer nest.  All of Gforth’s
higher-level numeric output words use ‘<<#’ ...  ‘#>’ ...  ‘#>>’ and can
be nested inside other users of the hold area.

‘<#’ ( –  ) core “less-number-sign”
   Initialise/clear the pictured numeric output string.

‘<<#’ ( –  ) gforth-0.5 “less-less-number-sign”
   Start a hold area that ends with ‘#>>’.  Can be nested in each other
and in ‘<#’.  Note: if you do not match up the ‘<<#’s with ‘#>>’s, you
will eventually run out of hold area; you can reset the hold area to
empty with ‘<#’.

‘#’ ( ud1 – ud2  ) core “number-sign”
   Used between ‘<<#’ and ‘#>’.  Prepend the least-significant digit
(according to ‘base’) of UD1 to the pictured numeric output string.  UD2
is UD1/BASE, i.e., the number representing the remaining digits.

‘#s’ ( ud – 0 0  ) core “number-sign-s”
   Used between ‘<<#’ and ‘#>’.  Prepend all digits of UD to the
pictured numeric output string.  ‘#s’ will convert at least one digit.
Therefore, if UD is 0, ‘#s’ will prepend a “0” to the pictured numeric
output string.

‘hold’ ( char –  ) core “hold”
   Used between ‘<<#’ and ‘#>’.  Prepend the character CHAR to the
pictured numeric output string.

‘holds’ ( addr u –  ) core-ext “holds”
   Used between ‘<<#’ and ‘#>’.  Prepend the string ‘addr u’ to the
pictured numeric output string.

‘sign’ ( n –  ) core “sign”
   Used between ‘<<#’ and ‘#>’.  If N (a SINGLE number) is negative,
prepend “‘-’” to the pictured numeric output string.

‘#>’ ( xd – addr u  ) core “number-sign-greater”
   Complete the pictured numeric output string by discarding XD and
returning ADDR U; the address and length of the formatted string.  A
Standard program may modify characters within the string.  Does not
release the hold area; use ‘#>>’ to release a hold area started with
‘<<#’, or ‘<#’ to release all hold areas.

‘#>>’ ( –  ) gforth-0.5 “number-sign-greater-greater”
   Release the hold area started with ‘<<#’.

Here are some examples of using pictured numeric output:

     : my-u. ( u -- )
       \ Simplest use of pns.. behaves like Standard u.
       0              \ convert to unsigned double
       <<#            \ start conversion
       #s             \ convert all digits
       #>             \ complete conversion
       TYPE SPACE     \ display, with trailing space
       #>> ;          \ release hold area

     : cents-only ( u -- )
       0              \ convert to unsigned double
       <<#            \ start conversion
       # #            \ convert two least-significant digits
       #>             \ complete conversion, discard other digits
       TYPE SPACE     \ display, with trailing space
       #>> ;          \ release hold area

     : dollars-and-cents ( u -- )
       0              \ convert to unsigned double
       <<#            \ start conversion
       # #            \ convert two least-significant digits
       '.' hold       \ insert decimal point
       #s             \ convert remaining digits
       '$' hold       \ append currency symbol
       #>             \ complete conversion
       TYPE SPACE     \ display, with trailing space
       #>> ;          \ release hold area

     : my-. ( n -- )
       \ handling negatives.. behaves like Standard .
       s>d            \ convert to signed double
       swap over dabs \ leave sign byte followed by unsigned double
       <<#            \ start conversion
       #s             \ convert all digits
       rot sign       \ get at sign byte, append "-" if needed
       #>             \ complete conversion
       TYPE SPACE     \ display, with trailing space
       #>> ;          \ release hold area

     : account. ( n -- )
       \ accountants don't like minus signs, they use parentheses
       \ for negative numbers
       s>d            \ convert to signed double
       swap over dabs \ leave sign byte followed by unsigned double
       <<#            \ start conversion
       2 pick         \ get copy of sign byte
       0< IF ')' hold THEN \ right-most character of output
       #s             \ convert all digits
       rot            \ get at sign byte
       0< IF '(' hold THEN
       #>             \ complete conversion
       TYPE SPACE     \ display, with trailing space
       #>> ;          \ release hold area


   Here are some examples of using these words:

     1 my-u. 1
     hex -1 my-u. decimal FFFFFFFF
     1 cents-only 01
     1234 cents-only 34
     2 dollars-and-cents $0.02
     1234 dollars-and-cents $12.34
     123 my-. 123
     -123 my. -123
     123 account. 123
     -456 account. (456)


File: gforth.info,  Node: Floating-point output,  Next: Miscellaneous output,  Prev: Formatted numeric output,  Up: Other I/O

6.20.3 Floating-point output
----------------------------

Floating-point output is always displayed using base 10.

‘f.’ ( r –  ) floating-ext “f-dot”
   Display (the floating-point number) r without exponent, followed by a
space.

‘fe.’ ( r –  ) floating-ext “f-e-dot”
   Display r using engineering notation (with exponent dividable by 3),
followed by a space.

‘fs.’ ( r –  ) floating-ext “f-s-dot”
   Display r using scientific notation (with exponent), followed by a
space.

‘fp.’ ( r –  ) floating-ext “f-e-dot”
   Display r using SI prefix notation (with exponent dividable by 3,
converted into SI prefixes if available), followed by a space.

   Examples of printing the number 1234.5678E23 in the different
floating-point output formats are shown below.

     f. 123456780000000000000000000.
     fe. 123.456780000000E24
     fs. 1.23456780000000E26
     fp. 123.456780000000Y

   The length of the output is influenced by:

‘precision’ ( – u  ) floating-ext “precision”
   u is the number of significant digits currently used by ‘F.’ ‘FE.’
and ‘FS.’

‘set-precision’ ( u –  ) floating-ext “set-precision”
   Set the number of significant digits currently used by ‘F.’ ‘FE.’ and
‘FS.’ to u.

   You can control the output in more detail with:

‘f.rdp’ ( rf +nr +nd +np –  ) gforth-0.6 “f.rdp”
   Print float rf formatted.  The total width of the output is nr.  For
fixed-point notation, the number of digits after the decimal point is
+nd and the minimum number of significant digits is np.  ‘Set-precision’
has no effect on ‘f.rdp’.  Fixed-point notation is used if the number of
siginicant digits would be at least np and if the number of digits
before the decimal point would fit.  If fixed-point notation is not
used, exponential notation is used, and if that does not fit, asterisks
are printed.  We recommend using nr>=7 to avoid the risk of numbers not
fitting at all.  We recommend nr>=np+5 to avoid cases where ‘f.rdp’
switches to exponential notation because fixed-point notation would have
too few significant digits, yet exponential notation offers fewer
significant digits.  We recommend nr>=nd+2, if you want to have
fixed-point notation for some numbers; the smaller the value of np, the
more cases are shown in fixed-point notation (cases where few or no
significant digits remain in fixed-point notation).  We recommend np>nr,
if you want to have exponential notation for all numbers.

   To give you a better intuition of how they influence the output, here
are some examples of parameter combinations; in each line the same
number is printed, in each column the same parameter combination is used
for printing:

         12 13 0    7 3 4   7 3 0   7 3 1   7 5 1   7 7 1   7 0 2  4 2 1
     |-1.234568E-6|-1.2E-6| -0.000|-1.2E-6|-1.2E-6|-1.2E-6|-1.2E-6|****|
     |-1.234568E-5|-1.2E-5| -0.000|-1.2E-5|-.00001|-1.2E-5|-1.2E-5|****|
     |-1.234568E-4|-1.2E-4| -0.000|-1.2E-4|-.00012|-1.2E-4|-1.2E-4|****|
     |-1.234568E-3|-1.2E-3| -0.001| -0.001|-.00123|-1.2E-3|-1.2E-3|****|
     |-1.234568E-2|-1.2E-2| -0.012| -0.012|-.01235|-1.2E-2|-1.2E-2|-.01|
     |-1.234568E-1|-1.2E-1| -0.123| -0.123|-.12346|-1.2E-1|-1.2E-1|-.12|
     |-1.2345679E0| -1.235| -1.235| -1.235|-1.23E0|-1.23E0|-1.23E0|-1E0|
     |-1.2345679E1|-12.346|-12.346|-12.346|-1.23E1|-1.23E1|   -12.|-1E1|
     |-1.2345679E2|-1.23E2|-1.23E2|-1.23E2|-1.23E2|-1.23E2|  -123.|-1E2|
     |-1.2345679E3|-1.23E3|-1.23E3|-1.23E3|-1.23E3|-1.23E3| -1235.|-1E3|
     |-1.2345679E4|-1.23E4|-1.23E4|-1.23E4|-1.23E4|-1.23E4|-12346.|-1E4|
     |-1.2345679E5|-1.23E5|-1.23E5|-1.23E5|-1.23E5|-1.23E5|-1.23E5|-1E5|

   You can generate a string instead of displaying the number with:

‘f>str-rdp’ ( rf +nr +nd +np – c-addr nr  ) gforth-0.6 “f>str-rdp”
   Convert rf into a string at c-addr nr.  The conversion rules and the
meanings of nr +nd np are the same as for ‘f.rdp’.  The result in in the
pictured numeric output buffer and will be destroyed by anything
destroying that buffer.

‘f>buf-rdp’ ( rf c-addr +nr +nd +np –  ) gforth-0.6 “f>buf-rdp”
   Convert rf into a string at c-addr nr.  The conversion rules and the
meanings of nr nd np are the same as for ‘f.rdp’.

   There is also a primitive used for implementing higher-level
FP-to-string words:

‘represent’ ( r c-addr u – n f1 f2 ) floating “represent”
   Convert the decimal significand (aka mantissa) of r into a string in
buffer c-addr u; n is the exponent, f1 is true if r is negative, and f2
is true if r is valid (a finite number in Gforth).


File: gforth.info,  Node: Miscellaneous output,  Next: Displaying characters and strings,  Prev: Floating-point output,  Up: Other I/O

6.20.4 Miscellaneous output
---------------------------

‘cr’ ( –  ) core “c-r”
   Output a newline (of the favourite kind of the host OS). Note that
due to the way the Forth command line interpreter inserts newlines, the
preferred way to use ‘cr’ is at the start of a piece of text; e.g., ‘cr
." hello, world"’.

‘space’ ( –  ) core “space”
   Display one space.

‘spaces’ ( u –  ) core “spaces”
   Display U spaces.

‘out’ ( – addr  ) gforth-1.0 “out”
   ‘Addr’ contains a number that tries to give the position of the
cursor within the current line on the user output device: It resets to 0
on ‘cr’, increases by the number of characters by ‘type’ and ‘emit’, and
decreases on ‘backspaces’.  Unfortunately, it does not take into account
tabs, multi-byte characters, or the existence of Unicode characters with
width 0 and 2, so it only works for simple cases.

‘.\"’ ( compilation ’ccc"’ – ; run-time –  ) gforth-0.6 “dot-backslash-quote”
   Like ‘."’, but translates C-like \-escape-sequences (see ‘S\"’).

‘."’ ( compilation ’ccc"’ – ; run-time –  ) core “dot-quote”
   Compilation: Parse a string ccc delimited by a " (double quote).  At
run-time, display the string.  Interpretation semantics for this word
are undefined in standard Forth.  Gforth’s interpretation semantics are
to display the string.

‘.(’ ( compilation&interpretation "ccc<paren>" –  ) core-ext “dot-paren”
   Compilation and interpretation semantics: Parse a string ccc
delimited by a ‘)’ (right parenthesis).  Display the string.  This is
often used to display progress information during compilation; see
examples below.

   If you don’t want to worry about wether to use ‘.( hello)’ or ‘."
hello"’, you can write ‘"hello" type’, which gives you what you usually
want (but is less portable to other Forth systems).

As an example, consider the following text, stored in a file ‘test.fs’:

     .( text-1)
     : my-word
       ." text-2" cr
       .( text-3)
       "text-4" type
     ;

     ." text-5"
     "text-6" type

   When you load this code into Gforth, the following output is
generated:

     include test.fs <RET> text-1text-3text-5text-6 ok

   • Messages ‘text-1’ and ‘text-3’ are displayed because ‘.(’ is an
     immediate word; it behaves in the same way whether it is used
     inside or outside a colon definition.
   • Message ‘text-5’ is displayed because of Gforth’s added
     interpretation semantics for ‘."’.
   • Message ‘text-6’ is displayed because ‘"text-6" type’ is
     interpreted.
   • Message ‘text-2’ is not displayed, because the text interpreter
     performs the compilation semantics for ‘."’ within the definition
     of ‘my-word’.
   • Message ‘text-4’ is not displayed, because ‘"text-4" type’ is
     compiled into ‘my-word’.


File: gforth.info,  Node: Displaying characters and strings,  Next: Terminal output,  Prev: Miscellaneous output,  Up: Other I/O

6.20.5 Displaying characters and strings
----------------------------------------

‘type’ ( c-addr u –  ) core “type”
   If U>0, display U characters from a string starting with the
character stored at C-ADDR.

‘xemit’ ( xc –  ) xchar “x-emit”
   Prints an xchar on the terminal.

‘emit’ ( c –  ) core “emit”
   Send the byte c to the current output; for ASCII characters, ‘emit’
is equivalent to ‘xemit’.

‘typewhite’ ( addr n –  ) gforth-0.2 “typewhite”
   Like type, but white space is printed instead of the characters.


File: gforth.info,  Node: Terminal output,  Next: Single-key input,  Prev: Displaying characters and strings,  Up: Other I/O

6.20.6 Terminal output
----------------------

If you are outputting to a terminal, you may want to control the
positioning of the cursor:

‘at-xy’ ( x y –  ) facility “at-x-y”
   Put the curser at position x y.  The top left-hand corner of the
display is at 0 0.

‘at-deltaxy’ ( dx dy –  ) gforth-0.7 “at-deltaxy”
   With the current position at x y, put the cursor at x+dx y+dy.

   In order to know where to position the cursor, it is often helpful to
know the size of the screen:

‘form’ ( – nlines ncols  ) gforth-0.2 “form”

   And sometimes you want to use:

‘page’ ( –  ) facility “page”
   Clear the screen

   Note that on non-terminals you should use ‘12 emit’, not ‘page’, to
get a form feed.

6.20.6.1 Color output
.....................

The following words are used to create (semantic) colorful output;
further output is produced in the color and style given by the word; the
actual color and style depends on the theme (see below).

‘default-color’ ( –  ) gforth-1.0 “default-color”
   use system-default color

‘error-color’ ( –  ) gforth-1.0 “error-color”
   error color: red

‘error-hl-inv’ ( –  ) gforth-1.0 “error-hl-inv”
   color mod for error highlight inverse

‘error-hl-ul’ ( –  ) gforth-1.0 “error-hl-ul”
   color mod for error highlight underline

‘warning-color’ ( –  ) gforth-1.0 “warning-color”
   color for warnings: blue/yellow on black terminals

‘info-color’ ( –  ) gforth-1.0 “info-color”
   color for info: green/cyan on black terminals

‘success-color’ ( –  ) gforth-1.0 “success-color”
   color for success: green

‘input-color’ ( –  ) gforth-1.0 “input-color”
   color for user-input: black/white (both bold)

‘status-color’ ( –  ) gforth-1.0 “status-color”
   color mod for error highlight inverse

6.20.6.2 Color themes
.....................

Depending on wether you prefer bright or dark background the foreground
colors-theme can be changed by:

‘light-mode’ ( –  ) gforth-1.0 “light-mode”
   color theme for white background

‘dark-mode’ ( –  ) gforth-1.0 “dark-mode”
   color theme for black background

‘uncolored-mode’ ( –  ) gforth-1.0 “uncolored-mode”
   This mode does not set colors, but uses the default ones.

‘magenta-input’ ( –  ) gforth-1.0 “magenta-input”
   make input color easily recognizable (useful in presentations)


File: gforth.info,  Node: Single-key input,  Next: Line input and conversion,  Prev: Terminal output,  Up: Other I/O

6.20.7 Single-key input
-----------------------

If you want to get a single printable character, you can use ‘key’; to
check whether a character is available for ‘key’, you can use ‘key?’.

‘key’ ( – char  ) core “key”
   Receive (but do not display) one character, CHAR.

‘key-ior’ ( – char|ior  ) gforth-1.0 “key-ior”
   Receive (but do not display) one character, CHAR, in case of an error
or interrupt, return the negative IOR instead.

‘key?’ ( – flag  ) facility “key-question”
   Determine whether a character is available.  If a character is
available, FLAG is true; the next call to ‘key’ will yield the
character.  Once ‘key?’ returns true, subsequent calls to ‘key?’ before
calling ‘key’ or ‘ekey’ will also return true.

‘xkey?’ ( – flag  ) xchar “x-key-query”

   If you want to process a mix of printable and non-printable
characters, you can do that with ‘ekey’ and friends.  ‘Ekey’ produces a
keyboard event that you have to convert into a character with
‘ekey>char’ or into a key identifier with ‘ekey>fkey’.

   Typical code for using EKEY looks like this:

     ekey ekey>xchar if ( xc )
       ... \ do something with the character
     else ekey>fkey if ( key-id )
       case
         k-up                                  of ... endof
         k-f1                                  of ... endof
         k-left k-shift-mask or k-ctrl-mask or of ... endof
         ...
       endcase
     else ( keyboard-event )
       drop \ just ignore an unknown keyboard event type
     then then

‘ekey’ ( – u  ) facility-ext “e-key”
   Receive a keyboard event U (encoding implementation-defined).

‘ekey>xchar’ ( u – u false | xc true  ) xchar-ext “e-key-to-x-char”
   Convert keyboard event U into xchar ‘xc’ if possible.

‘ekey>char’ ( u – u false | c true  ) facility-ext “e-key-to-char”
   Convert keyboard event U into character ‘c’ if possible.  Note that
non-ASCII characters produce ‘false’ from both ‘ekey>char’ and
‘ekey>fkey’.  Instead of ‘ekey>char’, use ‘ekey>xchar’ if available.

‘ekey>fkey’ ( u1 – u2 f  ) facility-ext “e-key-to-f-key”
   If u1 is a keyboard event in the special key set, convert keyboard
event U1 into key id U2 and return true; otherwise return U1 and false.

‘ekey?’ ( – flag  ) facility-ext “e-key-question”
   True if a keyboard event is available.

   The key identifiers for cursor keys are:

‘k-left’ ( – u  ) facility-ext “k-left”

‘k-right’ ( – u  ) facility-ext “k-right”

‘k-up’ ( – u  ) facility-ext “k-up”

‘k-down’ ( – u  ) facility-ext “k-down”

‘k-home’ ( – u  ) facility-ext “k-home”
   aka Pos1

‘k-end’ ( – u  ) facility-ext “k-end”

‘k-prior’ ( – u  ) facility-ext “k-prior”
   aka PgUp

‘k-next’ ( – u  ) facility-ext “k-next”
   aka PgDn

‘k-insert’ ( – u  ) facility-ext “k-insert”

‘k-delete’ ( – u  ) facility-ext “k-delete”
   the <DEL> key on my xterm, not backspace

   The key identifiers for function keys (aka keypad keys) are:

‘k-f1’ ( – u  ) facility-ext “k-f-1”

‘k-f2’ ( – u  ) facility-ext “k-f-2”

‘k-f3’ ( – u  ) facility-ext “k-f-3”

‘k-f4’ ( – u  ) facility-ext “k-f-4”

‘k-f5’ ( – u  ) facility-ext “k-f-5”

‘k-f6’ ( – u  ) facility-ext “k-f-6”

‘k-f7’ ( – u  ) facility-ext “k-f-7”

‘k-f8’ ( – u  ) facility-ext “k-f-8”

‘k-f9’ ( – u  ) facility-ext “k-f-9”

‘k-f10’ ( – u  ) facility-ext “k-f-10”

‘k-f11’ ( – u  ) facility-ext “k-f-11”

‘k-f12’ ( – u  ) facility-ext “k-f-12”

   Note that ‘k-f11’ and ‘k-f12’ are not as widely available.

   You can combine these key identifiers with masks for various shift
keys:

‘k-shift-mask’ ( – u  ) facility-ext “k-shift-mask”

‘k-ctrl-mask’ ( – u  ) facility-ext “k-ctrl-mask”

‘k-alt-mask’ ( – u  ) facility-ext “k-alt-mask”

   There are a number of keys that have ASCII values, and therefore are
unlikely to be reported as special keys, but the combination of these
keys with shift keys may be reported as a special key:

‘k-enter’ ( – u  ) gforth-1.0 “k-enter”

‘k-backspace’ ( – u  ) gforth-1.0 “k-backspace”

‘k-tab’ ( – u  ) gforth-1.0 “k-tab”

   Moreover, there the following key codes for keys and other events:

‘k-winch’ ( – u  ) gforth-1.0 “k-winch”
   A key code that may be generated when the user changes the window
size.

‘k-pause’ ( – u  ) gforth-1.0 “k-pause”

‘k-mute’ ( – u  ) gforth-1.0 “k-mute”

‘k-volup’ ( – u  ) gforth-1.0 “k-volup”

‘k-voldown’ ( – u  ) gforth-1.0 “k-voldown”

‘k-sel’ ( – u  ) gforth-1.0 “k-sel”
   keycode for Android selections

‘k-eof’ ( – u  ) gforth-1.0 “k-eof”

   Note that, even if a Forth system has ‘ekey>fkey’ and the key
identifier words, the keys are not necessarily available or it may not
necessarily be able to report all the keys and all the possible
combinations with shift masks.  Therefore, write your programs in such a
way that they are still useful even if the keys and key combinations
cannot be pressed or are not recognized.

   Examples: Older keyboards often do not have an F11 and F12 key.  If
you run Gforth in an xterm, the xterm catches a number of combinations
(e.g., <Shift-Up>), and never passes it to Gforth.  Finally, Gforth
currently does not recognize and report combinations with multiple shift
keys (so the <shift-ctrl-left> case in the example above would never be
entered).

   Gforth recognizes various keys available on ANSI terminals (in MS-DOS
you need the ANSI.SYS driver to get that behaviour); it works by
recognizing the escape sequences that ANSI terminals send when such a
key is pressed.  If you have a terminal that sends other escape
sequences, you will not get useful results on Gforth.  Other Forth
systems may work in a different way.

   Gforth also provides a few words for outputting names of function
keys:

‘fkey.’ ( u –  ) gforth-1.0 “fkey-dot”
   Print a string representation for the function key u.  U must be a
function key (possibly with modifier masks), otherwise there may be an
exception.

‘simple-fkey-string’ ( u1 – c-addr u  ) gforth-1.0 “simple-fkey-string”
   c-addr u is the string name of the function key u1.  Only works for
simple function keys without modifier masks.  Any u1 that does not
correspond to a simple function key currently produces an exception.


File: gforth.info,  Node: Line input and conversion,  Next: Pipes,  Prev: Single-key input,  Up: Other I/O

6.20.8 Line input and conversion
--------------------------------

For ways of storing character strings in memory see *note String
representations::.

   Words for inputting one line from the keyboard:

‘accept’ ( c-addr +n1 – +n2  ) core “accept”
   Get a string of up to N1 characters from the user input device and
store it at C-ADDR.  N2 is the length of the received string.  The user
indicates the end by pressing <RET>.  Gforth supports all the editing
functions available on the Forth command line (including history and
word completion) in ‘accept’.

‘edit-line’ ( c-addr n1 n2 – n3  ) gforth-0.6 “edit-line”
   edit the string with length N2 in the buffer C-ADDR N1, like
‘accept’.

   Conversion words:

‘s>number?’ ( addr u – d f  ) gforth-0.5 “s>number?”
   converts string addr u into d, flag indicates success

‘s>unumber?’ ( c-addr u – ud flag  ) gforth-0.5 “s>unumber?”
   converts string c-addr u into ud, flag indicates success

‘>number’ ( ud1 c-addr1 u1 – ud2 c-addr2 u2  ) core “to-number”
   Attempt to convert the character string C-ADDR1 U1 to an unsigned
number in the current number base.  The double UD1 accumulates the
result of the conversion to form UD2.  Conversion continues,
left-to-right, until the whole string is converted or a character that
is not convertable in the current number base is encountered (including
+ or -).  For each convertable character, UD1 is first multiplied by the
value in ‘BASE’ and then incremented by the value represented by the
character.  C-ADDR2 is the location of the first unconverted character
(past the end of the string if the whole string was converted).  U2 is
the number of unconverted characters in the string.  Overflow is not
detected.

‘>float’ ( c-addr u – f:... flag ) floating “to-float”
   Actual stack effect: ( c_addr u – r t | f ).  Attempt to convert the
character string c-addr u to internal floating-point representation.  If
the string represents a valid floating-point number, r is placed on the
floating-point stack and flag is true.  Otherwise, flag is false.  A
string of blanks is a special case and represents the floating-point
number 0.

‘>float1’ ( c-addr u c – f:... flag ) gforth-1.0 “to-float1”
   Actual stack effect: ( c_addr u c – r t | f ).  Attempt to convert
the character string c-addr u to internal floating-point representation,
with c being the decimal separator.  If the string represents a valid
floating-point number, r is placed on the floating-point stack and flag
is true.  Otherwise, flag is false.  A string of blanks is a special
case and represents the floating-point number 0.

   Obsolescent input and conversion words:

‘convert’ ( ud1 c-addr1 – ud2 c-addr2  ) core-ext-obsolescent “convert”
   Obsolescent: superseded by ‘>number’.

‘expect’ ( c-addr +n –  ) core-ext-obsolescent “expect”
   Receive a string of at most +n characters, and store it in memory
starting at c-addr.  The string is displayed.  Input terminates when the
<return> key is pressed or +n characters have been received.  The normal
Gforth line editing capabilites are available.  The length of the string
is stored in ‘span’; it does not include the <return> character.
OBSOLESCENT: superceeded by ‘accept’.

‘span’ ( – c-addr  ) core-ext-obsolescent “span”
   ‘Variable’ – c-addr is the address of a cell that stores the length
of the last string received by ‘expect’.  OBSOLESCENT.

