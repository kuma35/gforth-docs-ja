<!DOCTYPE html>
<html>
<!-- Created by GNU Texinfo 7.1, https://www.gnu.org/software/texinfo/ -->
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- このマニュアルは、 仮想マシン・インタープリタ・ジェネレーターである Vmgen (バージョン
0.7.9_20240418、April 18, 2024) 用です

Author: Anton Ertl Copyright © 2002,2003,2005,2007,2008,2019 Free
Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document under
the terms of the GNU Free Documentation License, Version 1.2 or any later
version published by the Free Software Foundation; with no Invariant
Sections, with the Front-Cover texts being "A GNU Manual," and with the
Back-Cover Texts as in (a) below.  A copy of the license is included in the
section entitled "GNU Free Documentation License."

(a) The FSF's Back-Cover Text is: "You have freedom to copy and modify this
GNU Manual, like GNU software.  Copies published by the Free Software
Foundation raise funds for GNU development." -->
<title>VM profiler (Vmgen (Gforth 0.7.9_20240418))</title>

<meta name="description" content="VM profiler (Vmgen (Gforth 0.7.9_20240418))">
<meta name="keywords" content="VM profiler (Vmgen (Gforth 0.7.9_20240418))">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="index.html" rel="start" title="Top">
<link href="Index.html" rel="index" title="Index">
<link href="index.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="Using-the-generated-code.html" rel="up" title="Using the generated code">
<link href="VM-disassembler.html" rel="prev" title="VM disassembler">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
div.example {margin-left: 3.2em}
span:hover a.copiable-link {visibility: visible}
-->
</style>


</head>

<body lang="en">
<div class="section-level-extent" id="VM-profiler">
<div class="nav-panel">
<p>
Previous: <a href="VM-disassembler.html" accesskey="p" rel="prev">VM disassembler</a>, Up: <a href="Using-the-generated-code.html" accesskey="u" rel="up">Using the generated code</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>
<hr>
<h3 class="section" id="VM-profiler-1"><span>8.6 VM profiler<a class="copiable-link" href="#VM-profiler-1"> &para;</a></span></h3>
<a class="index-entry-id" id="index-VM-profiler"></a>
<a class="index-entry-id" id="index-profiling-for-selecting-superinstructions"></a>
<a class="index-entry-id" id="index-superinstructions-and-profiling"></a>
<a class="index-entry-id" id="index-profile_002ec"></a>
<a class="index-entry-id" id="index-_002dprofile_002ei-output-file"></a>

<p>The VM profiler is designed for getting execution and occurence counts for
VM instruction sequences, and these counts can then be used for selecting
sequences as superinstructions.  The VM profiler is probably not useful as
profiling tool for the interpretive system.  I.e., the VM profiler is useful
for the developers, but not the users of the interpretive system.
</p>
<p>The output of the profiler is: for each basic block (executed at least
once), it produces the dynamic execution count of that basic block and all
its subsequences; e.g.,
</p>
<div class="example">
<pre class="example-preformatted">       9227465  lit storelocal 
       9227465  storelocal branch 
       9227465  lit storelocal branch 
</pre></div>

<p>I.e., a basic block consisting of &lsquo;<samp class="samp">lit storelocal branch</samp>&rsquo; is executed
9227465 times.
</p>
<a class="index-entry-id" id="index-stat_002eawk"></a>
<a class="index-entry-id" id="index-seq2rule_002eawk"></a>
<p>This output can be combined in various ways.  E.g., <samp class="file">vmgen-ex/stat.awk</samp>
adds up the occurences of a given sequence wrt dynamic execution, static
occurence, and per-program occurence.  E.g.,
</p>
<div class="example">
<pre class="example-preformatted">      2      16        36910041 loadlocal lit 
</pre></div>

<p>indicates that the sequence &lsquo;<samp class="samp">loadlocal lit</samp>&rsquo; occurs in 2 programs, in 16
places, and has been executed 36910041 times.  Now you can select
superinstructions in any way you like (note that compile time and space
typically limit the number of superinstructions to 100&ndash;1000).  After you
have done that, <samp class="file">vmgen/seq2rule.awk</samp> turns lines of the form above into
rules for inclusion in a Vmgen input file.  Note that this script does not
ensure that all prefixes are defined, so you have to do that in other ways.
So, an overall script for turning profiles into superinstructions can look
like this:
</p>
<div class="example">
<pre class="example-preformatted">awk -f stat.awk fib.prof test.prof|
awk '$3&gt;=10000'|                #select sequences
fgrep -v -f peephole-blacklist| #eliminate wrong instructions
awk -f seq2rule.awk|            #turn into superinstructions
sort -k 3 &gt;mini-super.vmg       #sort sequences
</pre></div>

<p>Here the dynamic count is used for selecting sequences (preliminary results
indicate that the static count gives better results, though); the third line
eliminates sequences containing instructions that must not occur in a
superinstruction, because they access a stack directly.  The dynamic count
selection ensures that all subsequences (including prefixes) of longer
sequences occur (because subsequences have at least the same count as the
longer sequences); the sort in the last line ensures that longer
superinstructions occur after their prefixes.
</p>
<p>But before using this, you have to have the profiler.  Vmgen supports its
creation by generating <samp class="file"><var class="var">file</var>-profile.i</samp>; you also need the
wrapper file <samp class="file">vmgen-ex/profile.c</samp> that you can use almost verbatim.
</p>
<a class="index-entry-id" id="index-SUPER_005fEND-in-profiling"></a>
<a class="index-entry-id" id="index-BB_005fBOUNDARY-in-profiling"></a>
<p>The profiler works by recording the targets of all VM control flow changes
(through <code class="code">SUPER_END</code> during execution, and through <code class="code">BB_BOUNDARY</code>
in the front end), and counting (through <code class="code">SUPER_END</code>) how often they
were targeted.  After the program run, the numbers are corrected such that
each VM basic block has the correct count (entering a block without
executing a branch does not increase the count, and the correction fixes
that), then the subsequences of all basic blocks are printed.  To get all
this, you just have to define <code class="code">SUPER_END</code> (and <code class="code">BB_BOUNDARY</code>)
appropriately, and call <code class="code">vm_print_profile(FILE *file)</code> when you want to
output the profile on <code class="code">file</code>.
</p>
<a class="index-entry-id" id="index-VM_005fIS_005fINST-in-profiling"></a>
<p>The <samp class="file"><var class="var">file</var>-profile.i</samp> is similar to the disassembler file, and it
uses variables and functions defined in <samp class="file">vmgen-ex/profile.c</samp>, plus
<code class="code">VM_IS_INST</code> already defined for the VM disassembler (see <a class="pxref" href="VM-disassembler.html">VM disassembler</a>).
</p>
</div>
<hr>
<div class="nav-panel">
<p>
Previous: <a href="VM-disassembler.html">VM disassembler</a>, Up: <a href="Using-the-generated-code.html">Using the generated code</a> &nbsp; [<a href="index.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="Index.html" title="Index" rel="index">Index</a>]</p>
</div>



</body>
</html>
